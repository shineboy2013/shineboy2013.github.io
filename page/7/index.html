<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 7 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/25/lee-981/">LeetCode 981 Time Based Key-Value Store</a></h1>
  

      
        <time datetime="2021-12-26T00:52:26.416Z">2021-12-25</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/time-based-key-value-store/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp.<br><br>Implement the <code>TimeMap</code> class:<br><br><em>   <code>TimeMap()</code> Initializes the object of the data structure.
</em>   <code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value</code> at the given time <code>timestamp</code>.<br><em>   <code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“TimeMap”, “set”, “get”, “get”, “set”, “get”, “get”]<br>[[], [“foo”, “bar”, 1], [“foo”, 1], [“foo”, 3], [“foo”, “bar2”, 4], [“foo”, 4], [“foo”, 5]]<br><strong>Output</strong><br>[null, null, “bar”, “bar”, null, “bar2”, “bar2”]<br><br><strong>Explanation</strong><br>TimeMap timeMap = new TimeMap();<br>timeMap.set(“foo”, “bar”, 1);  // store the key “foo” and value “bar” along with timestamp = 1.<br>timeMap.get(“foo”, 1);         // return “bar”<br>timeMap.get(“foo”, 3);         // return “bar”, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is “bar”.<br>timeMap.set(“foo”, “bar2”, 4); // store the key “foo” and value “bar2” along with timestamp = 4.<br>timeMap.get(“foo”, 4);         // return “bar2”<br>timeMap.get(“foo”, 5);         // return “bar2”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= key.length, value.length &lt;= 100</code><br><em>   <code>key</code> and <code>value</code> consist of lowercase English letters and digits.
</em>   <code>1 &lt;= timestamp &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code><br><em>   All the timestamps <code>timestamp</code> of <code>set</code> are strictly increasing.
</em>   At most <code>2 * 10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>set</code> and <code>get</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现带历史记录的HashMap。也就是同一个key记录所有赋过值的value</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Map to list的思路，list含两个，包括value和timestamp，用binary search搜索timestamp的下标，然后返回对应的value   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.key_to_val = collections.defaultdict(list)</span><br><span class="line">        self.key_to_timestamp = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key: str, value: str, timestamp: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.key_to_val[key].append(value)</span><br><span class="line">        self.key_to_timestamp[key].append(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: str, timestamp: int)</span> -&gt; str:</span></span><br><span class="line">        index = bisect.bisect(self.key_to_timestamp[key], timestamp) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key_to_val[key][index]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>get时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/25/lee-937/">LeetCode 937 Reorder Data in Log Files</a></h1>
  

      
        <time datetime="2021-12-25T10:03:16.769Z">2021-12-25</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/reorder-data-in-log-files/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of <code>logs</code>. Each log is a space-delimited string of words, where the first word is the <strong>identifier</strong>.<br><br>There are two types of logs:<br><br><em>   <strong>Letter-logs</strong>: All words (except the identifier) consist of lowercase English letters.
</em>   <strong>Digit-logs</strong>: All words (except the identifier) consist of digits.<br><br>Reorder these logs so that:<br><br>1.  The <strong>letter-logs</strong> come before all <strong>digit-logs</strong>.<br>2.  The <strong>letter-logs</strong> are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.<br>3.  The <strong>digit-logs</strong> maintain their relative ordering.<br><br>Return <em>the final order of the logs</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> logs = [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br><strong>Output:</strong> [“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]<br><strong>Explanation:</strong><br>The letter-log contents are all different, so their ordering is “art can”, “art zero”, “own kit dig”.<br>The digit-logs have a relative order of “dig1 8 1 5 1”, “dig2 3 6”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> logs = [“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]<br><strong>Output:</strong> [“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= logs.length &lt;= 100</code>
</em>   <code>3 &lt;= logs[i].length &lt;= 100</code><br><em>   All the tokens of <code>logs[i]</code> are separated by a <strong>single</strong> space.
</em>   <code>logs[i]</code> is guaranteed to have an identifier and at least one word after the identifier.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排序log file，以下顺序：字母log (内容，id), 数字log</p>
<h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>排序的multi key实现(0, content_str, li[0]) if is_alpha else (1, ). (1, )表示按数组顺序    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(x)</span>:</span></span><br><span class="line">		li = x.split(<span class="string">' '</span>)</span><br><span class="line">		content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">		is_alpha = <span class="number">1</span> <span class="keyword">if</span> content_str[<span class="number">0</span>].isalpha() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>, content_str, li[<span class="number">0</span>]) <span class="keyword">if</span> is_alpha <span class="keyword">else</span> (<span class="number">1</span>, )</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted(logs, key=get_key)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmlogn)</code>，空间复杂度<code>O(mn)</code>, n为log数量，m为每个log的最长长度。如mergesort中merge复杂度为nm, 每个key比较是O(m)复杂度  </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>我的解法。本质上和上法一致，较繁琐  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>字母log排序不能按content_str + ‘ ‘ + li[0], 而是(content_str, li[0])作多key排序  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles2</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">	letter_logs, digit_logs = [], []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(logs)):</span><br><span class="line">		<span class="keyword">if</span> logs[i][<span class="number">-1</span>].isdigit():</span><br><span class="line">			digit_logs.append(logs[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			li = logs[i].split(<span class="string">' '</span>)</span><br><span class="line">			content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">			letter_logs.append((content_str, li[<span class="number">0</span>], i))</span><br><span class="line">	letter_logs.sort()</span><br><span class="line">	res = [logs[pair[<span class="number">2</span>]] <span class="keyword">for</span> pair <span class="keyword">in</span> letter_logs]</span><br><span class="line">	res += digit_logs</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/25/lee-1268/">LeetCode 1268 Search Suggestions System</a></h1>
  

      
        <time datetime="2021-12-25T09:02:37.829Z">2021-12-25</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/search-suggestions-system/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.<br><br>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.<br><br>Return <em>a list of lists of the suggested products after each character of</em> <code>searchWord</code> <em>is typed</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> products = [“mobile”,”mouse”,”moneypot”,”monitor”,”mousepad”], searchWord = “mouse”<br><strong>Output:</strong> [<br>[“mobile”,”moneypot”,”monitor”],<br>[“mobile”,”moneypot”,”monitor”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”]<br>]<br><strong>Explanation:</strong> products sorted lexicographically = [“mobile”,”moneypot”,”monitor”,”mouse”,”mousepad”]<br>After typing m and mo all products match and we show user [“mobile”,”moneypot”,”monitor”]<br>After typing mou, mous and mouse the system suggests [“mouse”,”mousepad”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> products = [“havana”], searchWord = “havana”<br><strong>Output:</strong> [[“havana”],[“havana”],[“havana”],[“havana”],[“havana”],[“havana”]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> products = [“bags”,”baggage”,”banner”,”box”,”cloths”], searchWord = “bags”<br><strong>Output:</strong> [[“baggage”,”bags”,”banner”],[“baggage”,”bags”,”banner”],[“baggage”,”bags”],[“bags”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= products.length &lt;= 1000</code>
</em>   <code>1 &lt;= products[i].length &lt;= 3000</code><br><em>   `1 &lt;= sum(products[i].length) &lt;= 2 </em> 10<sup>4</sup><code>*   All the strings of</code>products<code>are **unique**.
*</code>products[i]<code>consists of lowercase English letters.
*</code>1 &lt;= searchWord.length &lt;= 1000<code>*</code>searchWord` consists of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现搜索结果为3个autocomplete的功能</p>
<h3 id="Prefix解题思路-推荐-："><a href="#Prefix解题思路-推荐-：" class="headerlink" title="Prefix解题思路(推荐)："></a><strong>Prefix解题思路(推荐)：</strong></h3><p>Prefix</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Trie，另一种思路是用prefix，此法采用prefix法，将所有单词按前缀加入到字典中     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products: List[str], searchWord: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">	products.sort()</span><br><span class="line">	prefix_dict = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> products:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">			prefix = word[:i + <span class="number">1</span>]</span><br><span class="line">			<span class="keyword">if</span> len(prefix_dict[prefix]) &lt; <span class="number">3</span>:</span><br><span class="line">				prefix_dict[prefix].append(word)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(searchWord)):</span><br><span class="line">		prefix = searchWord[:i + <span class="number">1</span>]</span><br><span class="line">		res.append(prefix_dict[prefix])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL1 + L2)</code>，空间复杂度<code>O(nL1)</code>, L1为单词列表中最长的长度，L2为搜索单词长度，n为单词个数  </p>
<hr>
<h3 id="Trie-DFS算法II解题思路："><a href="#Trie-DFS算法II解题思路：" class="headerlink" title="Trie + DFS算法II解题思路："></a><strong>Trie + DFS算法II解题思路：</strong></h3><p>建Trie，然后根据搜索的前缀定位到Trie节点，然后对此节点做DFS找到3个单词，因为DFS和字母顺序是一致的，所以DFS可行<br>具体参考Leetcode solution</p>
<hr>
<h3 id="Two-pointers算法III解题思路-推荐-："><a href="#Two-pointers算法III解题思路-推荐-：" class="headerlink" title="Two pointers算法III解题思路(推荐)："></a><strong>Two pointers算法III解题思路(推荐)：</strong></h3><p>先排序，用双指针相向搜索，根据搜索单词的每一个字母，不断收缩搜索范围，左指针和右指针之间即为满足条件的结果。每轮将左指针往后三个结果加到结果集<br>具体参考Leetcode discussion  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/24/lee-735/">LeetCode 735 Asteroid Collision</a></h1>
  

      
        <time datetime="2021-12-25T07:52:53.889Z">2021-12-24</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/asteroid-collision/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>We are given an array <code>asteroids</code> of integers representing asteroids in a row.<br><br>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.<br><br>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> asteroids = [5,10,-5]<br><strong>Output:</strong> [5,10]<br><strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> asteroids = [8,-8]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> The 8 and -8 collide exploding each other.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> asteroids = [10,2,-5]<br><strong>Output:</strong> [10]<br><strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= asteroids.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-1000 &lt;= asteroids[i] &lt;= 1000</code><br>*   <code>asteroids[i] != 0</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>星体向左向右同速运动，符号表示方向，数值表示星体大小。若相撞，同大小想消，否则较小的消失。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>保持原有顺序且相邻元素大小关系，考虑用Stack</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>两星体可以正负，所以有四种可能：同左，同右，向左向右，向右向左。<strong>只有最后一种向右向左才会相撞。</strong>所以出栈条件为栈顶为正，遍历元素为负。    </li>
<li>同大小要特别处理，记录到is_same_size变量中。入栈条件为<strong>出栈条件的非以及不是is_same_size</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">		is_same_size = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span> <span class="keyword">and</span> -asteroids[i] &gt;= stack[<span class="number">-1</span>]:</span><br><span class="line">			stack_top = stack.pop()</span><br><span class="line">			<span class="keyword">if</span> stack_top == -asteroids[i]:</span><br><span class="line">				is_same_size = <span class="keyword">True</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> (stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>) <span class="keyword">and</span> <span class="keyword">not</span> is_same_size:</span><br><span class="line">			stack.append(asteroids[i])</span><br><span class="line">	<span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<p>更简洁的写法，不要要掌握while, break, else语句，如果没有break，else永远执行，若break，else不执行。若不熟悉该语法，推荐用上法。  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision2</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> -asteroids[i] &lt; stack[<span class="number">-1</span>] <span class="keyword">or</span> stack.pop() == -asteroids[i]:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append(asteroids[i])</span><br><span class="line">	<span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/24/lee-314/">LeetCode 314 Binary Tree Vertical Order Traversal</a></h1>
  

      
        <time datetime="2021-12-25T04:10:20.140Z">2021-12-24</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em><strong>the vertical order traversal</strong> of its nodes’ values</em>. (i.e., from top to bottom, column by column).<br><br>If two nodes are in the same row and column, the order should be from <strong>left to right</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7]<br><strong>Output:</strong> [[4],[9],[3,0,1],[8],[7]]<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7,null,null,null,2,5]<br><strong>Output:</strong> [[4],[9,5],[3,0,1],[8,2],[7]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 100]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序打印二叉树  </p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p><strong>从root开始从0编号，左右节点分别为-1, 1</strong>，如此类推，就可以标记所有节点，从而将这些节点加入结果集。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>BFS引入(vertical_id, root)来做计算。由于结果列表如vertical_id = -1, 1可以从左或右加入，用dict来记录vertical到list更好合理   </li>
<li>由于vertical_id是连续的，所以不妨用min_col, max_col来记录dict的范围，保证从dict到结果集是按顺序加入。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line">	min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		vertical_id, node = queue.popleft()</span><br><span class="line">		min_col, max_col = min(min_col, vertical_id), max(max_col, vertical_id)</span><br><span class="line">		idx_to_list[vertical_id].append(node.val)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">		res.append(idx_to_list[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="BFS算法II解题思路："><a href="#BFS算法II解题思路：" class="headerlink" title="BFS算法II解题思路："></a><strong>BFS算法II解题思路：</strong></h3><p>先写了这个，优化后才得到算法I。区别在于keys需要排序  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder1_1</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		vertical_id, node = queue.popleft()</span><br><span class="line">		idx_to_list[vertical_id].append(node.val)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line">	sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">		res.append(idx_to_list[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="DFS算法III解题思路-不推荐-："><a href="#DFS算法III解题思路-不推荐-：" class="headerlink" title="DFS算法III解题思路(不推荐)："></a><strong>DFS算法III解题思路(不推荐)：</strong></h3><p>最开始的思路，很容易错，因为不符合题目的按层遍历的顺序。题目要求同一column的节点是从上到下，从左到右。DFS与此违反。    </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>要将同一个column节点从上到下从左到右排序，就要记录height和左到右的顺序(height_id, len(idx_to_list[vertical_id]) - 1, root.val)</li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder2</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	self.dfs(root, <span class="number">0</span>, <span class="number">0</span>, idx_to_list)</span><br><span class="line">	sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">		li = sorted(idx_to_list[i])</span><br><span class="line">		res.append([node[<span class="number">2</span>] <span class="keyword">for</span> node <span class="keyword">in</span> li])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, height_id, vertical_id, idx_to_list)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	idx_to_list[vertical_id].append((height_id, len(idx_to_list[vertical_id]) - <span class="number">1</span>, root.val))</span><br><span class="line">	self.dfs(root.left, height_id + <span class="number">1</span>, vertical_id - <span class="number">1</span>, idx_to_list)</span><br><span class="line">	self.dfs(root.right, height_id + <span class="number">1</span>, vertical_id + <span class="number">1</span>, idx_to_list)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/6/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/8/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/01/02/lee-048/">LeetCode 048 Rotate Image</a>
      </li>
    
      <li>
        <a href="/2022/01/01/lee-395/">LeetCode 395 Longest Substring with At Least K Repeating Characters</a>
      </li>
    
      <li>
        <a href="/2021/12/30/lee-101/">LeetCode 101 Symmetric Tree</a>
      </li>
    
      <li>
        <a href="/2021/12/30/lee-102/">LeetCode 102 Binary Tree Level Order Traversal</a>
      </li>
    
      <li>
        <a href="/2021/12/30/lee-103/">LeetCode 103 Binary Tree Zigzag Level Order Traversal</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Amazon/" style="font-size: 13.16px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.68px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.89px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 14.74px;">Binary Tree</a> <a href="/tags/Bloomberg/" style="font-size: 10.53px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.89px;">Breadth-first Search</a> <a href="/tags/Classic/" style="font-size: 19.47px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15.26px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.58px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.58px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 10.53px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 18.95px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 16.32px;">Facebook</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/Graph/" style="font-size: 11.05px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.11px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.37px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 13.68px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 14.21px;">Interviewer</a> <a href="/tags/Knowledge-Base/" style="font-size: 18.42px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 13.68px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 11.58px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 15.79px;">Math</a> <a href="/tags/Matrix/" style="font-size: 11.58px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.58px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.53px;">Merge Sort</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 17.89px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.53px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.53px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.53px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.58px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.53px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 18.42px;">Stack</a> <a href="/tags/String/" style="font-size: 16.84px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.05px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 12.63px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.05px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.74px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.53px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

