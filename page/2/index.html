<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 2 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-785-is-graph-bipartite/">LeetCode 785 Is Graph Bipartite?</a></h1>
  

      
        <time datetime="2022-02-07T06:49:11.703Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:<br><br><em>   There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).
</em>   There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).<br><em>   If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).
</em>   The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.<br><br>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.<br><br>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>graph.length == n</code>
</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= graph[u].length &lt; n</code>
</em>   <code>0 &lt;= graph[u][i] &lt;= n - 1</code><br><em>   <code>graph[u]</code> does not contain <code>u</code>.
</em>   All the values of <code>graph[u]</code> are <strong>unique</strong>.<br>*   If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>无向图中是否存在一个划分，将节点分为两集合，任何一条边都连接着两个集合，也就是不存在一条边在单一集合内。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</li>
<li>题意表示，图可能是有几个连通图，所以要从每个节点做BFS，除非节点已访问过， Line 4. node_to_color作为visited的功能</li>
<li>return True在两个函数中要写，否则返回None</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	node_to_color = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> node_to_color: <span class="comment"># disconnected nodes</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		node_to_color[i] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, i, node_to_color):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, n, node_to_color)</span>:</span></span><br><span class="line">	queue = collections.deque([n])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color <span class="keyword">and</span> node_to_color[neighbor] != <span class="number">1</span> - node_to_color[node]:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			node_to_color[neighbor] = <span class="number">1</span> - node_to_color[node]</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-770-basic-calculator-iv/">LeetCode 770. Basic Calculator IV</a></h1>
  

      
        <time datetime="2022-02-07T04:05:26.527Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/basic-calculator-iv/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code><br><br><em>   An expression alternates chunks and symbols, with a space separating each chunk and symbol.
</em>   A chunk is either an expression in parentheses, a variable, or a non-negative integer.<br><em>   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.<br><br>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.

</em>   For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.<br><br>The format of the output is as follows:<br><br><em>   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
    </em>   For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.<br><em>   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
    </em>   For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.<br><em>   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
</em>   An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.<br><em>   Terms (including constant terms) with coefficient <code>0</code> are not included.
    </em>   For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “e + 8 - a + 5”, evalvars = [“e”], evalints = [1]<br><strong>Output:</strong> [“-1<em>a”,”14”]<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “e - 8 + temperature - pressure”, evalvars = [“e”, “temperature”], evalints = [1, 12]<br><strong>Output:</strong> [“-1pressure”,”5”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> expression = “(e + 8) <em> (e - 8)”, evalvars = [], evalints = []<br><strong>Output:</strong> [“1</em>e<em>e”,”-64”]<br></em></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= expression.length &lt;= 250</code><br><em>   <code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, `’</em>‘<code>,</code>‘(‘<code>,</code>‘)’<code>,</code>‘ ‘<code>.
*</code>expression<code>does not contain any leading or trailing spaces.
*   All the tokens in</code>expression<code>are separated by a single space.
*</code>0 &lt;= evalvars.length &lt;= 100<code>*</code>1 &lt;= evalvars[i].length &lt;= 20<code>*</code>evalvars[i]<code>consists of lowercase English letters.
*</code>evalints.length == evalvars.length<code>*</code>-100 &lt;= evalints[i] &lt;= 100`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>表达式含有若干变量evalvars及其对应值evalints，且含加减乘和括号，求结果。若变量不在evalvars就简化表达式</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题<strong>不需要掌握</strong>，若考到就认命好了。之前的LeetCode 224 Basic Calculator含有括号和加法已经是Hard，此题不但有括号和加减乘，还有变量，难度不止提高一个数量级。不过不可以用eval函数的条件去掉了。所以就是考察eval。<br>如果不含变量，直接调用eval即可求解  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="keyword">return</span> eval(expression)</span><br></pre></td></tr></table></figure>
<p>含变量且变量有值，就调用字典将变量替代掉，这里考到了regex替代函数re.sub</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s.group()</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'\w+'</span>, f, expression)</span><br><span class="line">	res = eval(converted_expr)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>由于变量可能没有值，所以核心思路是用dict进行计算，如x + 2，用集合求和{(x,): 1} + {(): 2}得到{(‘x’,): 1, (): -2}，用dict来计算及保存结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>regex替代变量</li>
<li>将表达式用f包装，如(f(“x”) + f(“8”)) * (f(“x”) - f(“8”))</li>
<li>实现dict的加减乘</li>
<li>dict的计算结果转成题目所求</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span><span class="params">(Counter)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.update(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.subtract(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			product = MyCounter()</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">				<span class="keyword">for</span> y <span class="keyword">in</span> other:</span><br><span class="line">					xy = tuple(sorted(x + y))</span><br><span class="line">					product[xy] += self[x] * other[y]</span><br><span class="line">			<span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> MyCounter(&#123;(s, ): <span class="number">1</span>&#125;) <span class="keyword">if</span> s.isalpha() <span class="keyword">else</span> MyCounter(&#123;(): int(s)&#125;)</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'(\w+)'</span>, <span class="string">r'f("\1")'</span>, expression)</span><br><span class="line">	<span class="comment"># (f("x") + f("8")) * (f("x") - f("8"))</span></span><br><span class="line">	res = eval(converted_expr) <span class="comment">#</span></span><br><span class="line">	<span class="comment"># C(&#123;('x', 'x'): 1, ('x',): 0, (): -64&#125;)</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">'*'</span>.join((str(res[x]), ) + x)</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> sorted(res, key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line">			<span class="keyword">if</span> res[x]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/30/karat-002/">Karat 002 Longest Common Continuous Subarray</a></h1>
  

      
        <time datetime="2022-01-30T09:46:41.967Z">2022-01-30</time>
      
    </header>
    <div class="entry">
      
        <p>[<br>  [“3234.html”, “xys.html”, “7hsaa.html”], // user1<br>  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2<br>]</p>
<p>输出两个user的最长连续且相同的访问记录。</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续最长子数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 1143先求最长公共子字符串。</p>
<p>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p>
<p>不同之处在于： </p>
<ol>
<li>由于是连续，所以递归只有相同的情况，其他情况为0。 </li>
<li>答案不是最后一位，而是全局最值</li>
</ol>
<p>递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = 0</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归只有一种情况</li>
<li>答案需求全局</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				res = max(res, dp[i][j])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>回到原题，输入是列表而不是字符串，但原理一样。还有需要输出公共结果，而不是数字</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuousSubarray</span><span class="params">(self, history1, history2)</span>:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history1) + <span class="number">1</span>)]</span><br><span class="line">	max_len, res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> history1[i - <span class="number">1</span>] == history2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">					max_len = dp[i][j]</span><br><span class="line">					res = history1[i - dp[i][j]:i]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/30/leetcode-518-coin-change-2/">LeetCode 518 Coin Change 2</a></h1>
  

      
        <time datetime="2022-01-30T08:11:02.133Z">2022-01-30</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br><br>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.<br><br>You may assume that you have an infinite number of each kind of coin.<br><br>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> amount = 5, coins = [1,2,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> amount = 3, coins = [2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> amount = 10, coins = [10]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= coins.length &lt;= 300</code>
</em>   <code>1 &lt;= coins[i] &lt;= 5000</code><br><em>   All the values of <code>coins</code> are <strong>unique</strong>.
</em>   <code>0 &lt;= amount &lt;= 5000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求兑换硬币的种数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 322 Coin Change，那题求最小个数，此题求总数，也是用DP。<br>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = sum(dp[j]), i = j + coins[i]</span><br></pre></td></tr></table></figure></p>
<p>LeetCode 377 Combination Sum IV 题目基本一样，唯一区别是结果元素有序，属于排列<br>LeetCode 518 Coin Change 2 题目基本一样，唯一区别是结果元素无序，属于组合</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>递归5部曲</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>for循环顺序不能错，先coin再dp</strong>，否则会有重复计算，如dp[3] = 2 + 1和1 + 2. 字面上理解也是可以知道重复。但如果coin先的话，就只能用1的硬币，第二轮是只能用2的硬币，如此类推，显然不会重复，dp[3] = dp[2] + 1(只用硬币1), dp[1] + 2(只用硬币2) </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[j], i = j + coins[i]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)): <span class="comment"># [0, 0]</span></span><br><span class="line">			<span class="keyword">if</span> i + coin &lt;= amount:</span><br><span class="line">				dp[i + coin] += dp[i]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*amount)</code>，空间复杂度<code>O(amount)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/29/leetcode-259-3sum-smaller/">LeetCode 259 3Sum Smaller</a></h1>
  

      
        <time datetime="2022-01-30T07:18:03.625Z">2022-01-29</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <code>n</code> integers <code>nums</code> and an integer <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-2,0,1,3], target = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Because there are two triplets which sums are less than 2:<br>[-2,0,1]<br>[-2,0,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [0], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>0 &lt;= n &lt;= 3500</code><br><em>   <code>-100 &lt;= nums[i] &lt;= 100</code>
</em>   <code>-100 &lt;= target &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找三数和小于target的组合个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于三数和等于target，但当小于target时，直接求个数，类似于LeetCode 315 Count of Smaller Numbers After Self。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>res不是+1而是right - left</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">		left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; right:</span><br><span class="line">			<span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">				res += right - left <span class="comment"># remember</span></span><br><span class="line">				left += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				right -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/07/karat-003/">Karat 003 Nonogram</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/">LeetCode 1522 Diameter of N-Ary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-543-diameter-of-binary-tree/">LeetCode 543 Diameter of Binary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/">LeetCode 549 Binary Tree Longest Consecutive Sequence II</a>
      </li>
    
      <li>
        <a href="/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/">LeetCode 298 Binary Tree Longest Consecutive Sequence</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 13.91px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.48px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 16.52px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.48px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.43px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.43px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.39px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.87px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.7px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 14.78px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.3px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.3px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 10.43px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.57px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.13px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.74px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.61px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.17px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 16.52px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 13.48px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.04px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.3px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 11.3px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 16.52px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.22px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.61px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 17.83px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.65px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.3px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.87px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 10px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.09px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.87px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.43px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.87px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.3px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.43px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 16.96px;">Stack</a> <a href="/tags/String/" style="font-size: 18.26px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.3px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.09px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.3px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.35px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.43px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.43px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

