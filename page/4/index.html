<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 4 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/">LeetCode 549 Binary Tree Longest Consecutive Sequence II</a></h1>
  

      
        <time datetime="2022-02-07T07:51:56.353Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive path in the tree</em>.<br><br>A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.<br><br><em>   For example, <code>[1,2,3,4]</code> and <code>[4,3,2,1]</code> are both considered valid, but the path <code>[1,2,4,3]</code> is not valid.<br><br>On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The longest consecutive path is [1, 2] or [2, 1].<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest consecutive path is [1, 2, 3] or [3, 2, 1].<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the tree is in the range <code>[1, 3 * 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><em>   `-3 </em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求任意节点到另一个节点的最长连续数列的长度(由小到大)</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 298 Binary Tree Longest Consecutive Sequence，不过由于父亲到儿子可能递增或递减，所以DFS返回值也返回递增和递减的长度</p>
<p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p>
<p>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>DFS返回值也返回递增和递减的长度</li>
<li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># (increasing, decreasing) from root</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		inc = desc = <span class="number">1</span></span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		left = dfs(root.left)</span><br><span class="line">		right = dfs(root.right)</span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:</span><br><span class="line">			lpath += left[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right[<span class="number">0</span>]</span><br><span class="line">		inc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val - <span class="number">1</span> == root.left.val:</span><br><span class="line">			lpath += left[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val - <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right[<span class="number">1</span>]</span><br><span class="line">		desc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">		total = inc + desc - <span class="number">1</span></span><br><span class="line">		max_len = max(inc, desc, total, max_len)</span><br><span class="line">		<span class="keyword">return</span> inc, desc</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/">LeetCode 298 Binary Tree Longest Consecutive Sequence</a></h1>
  

      
        <time datetime="2022-02-07T07:22:19.605Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive sequence path</em>.<br><br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,null,3,2,null,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range `[1, 3 </em> 10<sup>4</sup>]<code>.
*</code>-3 <em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 </em> 10<sup>4</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求从父到子的最长连续数列的长度(由小到大)</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p>
<p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题意是从父到儿子的有小到大数列，而不是儿子到父亲</li>
<li>以root为起点的最长数列，若root不符合条件，不加入left或right的长度</li>
<li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有三种情况：自己，自己+左，自己+右</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		left = dfs(root.left)</span><br><span class="line">		right = dfs(root.right)</span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:  <span class="comment"># remember not ==</span></span><br><span class="line">			lpath += left</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right</span><br><span class="line">		res = max(lpath, rpath)</span><br><span class="line">		max_len = max(res, max_len)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-785-is-graph-bipartite/">LeetCode 785 Is Graph Bipartite?</a></h1>
  

      
        <time datetime="2022-02-07T06:49:11.703Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:<br><br><em>   There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).
</em>   There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).<br><em>   If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).
</em>   The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.<br><br>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.<br><br>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>graph.length == n</code>
</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= graph[u].length &lt; n</code>
</em>   <code>0 &lt;= graph[u][i] &lt;= n - 1</code><br><em>   <code>graph[u]</code> does not contain <code>u</code>.
</em>   All the values of <code>graph[u]</code> are <strong>unique</strong>.<br>*   If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>无向图中是否存在一个划分，将节点分为两集合，任何一条边都连接着两个集合，也就是不存在一条边在单一集合内。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</li>
<li>题意表示，图可能是有几个连通图，所以要从每个节点做BFS，除非节点已访问过， Line 4. node_to_color作为visited的功能</li>
<li>return True在两个函数中要写，否则返回None</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	node_to_color = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> node_to_color: <span class="comment"># disconnected nodes</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		node_to_color[i] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, i, node_to_color):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, n, node_to_color)</span>:</span></span><br><span class="line">	queue = collections.deque([n])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color <span class="keyword">and</span> node_to_color[neighbor] != <span class="number">1</span> - node_to_color[node]:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			node_to_color[neighbor] = <span class="number">1</span> - node_to_color[node]</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/06/leetcode-770-basic-calculator-iv/">LeetCode 770 Basic Calculator IV</a></h1>
  

      
        <time datetime="2022-02-07T04:05:26.527Z">2022-02-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/basic-calculator-iv/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code><br><br><em>   An expression alternates chunks and symbols, with a space separating each chunk and symbol.
</em>   A chunk is either an expression in parentheses, a variable, or a non-negative integer.<br><em>   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.<br><br>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.

</em>   For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.<br><br>The format of the output is as follows:<br><br><em>   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
    </em>   For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.<br><em>   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
    </em>   For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.<br><em>   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
</em>   An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.<br><em>   Terms (including constant terms) with coefficient <code>0</code> are not included.
    </em>   For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “e + 8 - a + 5”, evalvars = [“e”], evalints = [1]<br><strong>Output:</strong> [“-1<em>a”,”14”]<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “e - 8 + temperature - pressure”, evalvars = [“e”, “temperature”], evalints = [1, 12]<br><strong>Output:</strong> [“-1pressure”,”5”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> expression = “(e + 8) <em> (e - 8)”, evalvars = [], evalints = []<br><strong>Output:</strong> [“1</em>e<em>e”,”-64”]<br></em></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= expression.length &lt;= 250</code><br><em>   <code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, `’</em>‘<code>,</code>‘(‘<code>,</code>‘)’<code>,</code>‘ ‘<code>.
*</code>expression<code>does not contain any leading or trailing spaces.
*   All the tokens in</code>expression<code>are separated by a single space.
*</code>0 &lt;= evalvars.length &lt;= 100<code>*</code>1 &lt;= evalvars[i].length &lt;= 20<code>*</code>evalvars[i]<code>consists of lowercase English letters.
*</code>evalints.length == evalvars.length<code>*</code>-100 &lt;= evalints[i] &lt;= 100`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>表达式含有若干变量evalvars及其对应值evalints，且含加减乘和括号，求结果。若变量不在evalvars就简化表达式</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题<strong>不需要掌握</strong>，若考到就认命好了。之前的LeetCode 224 Basic Calculator含有括号和加法已经是Hard，此题不但有括号和加减乘，还有变量，难度不止提高一个数量级。不过不可以用eval函数的条件去掉了。所以就是考察eval。<br>如果不含变量，直接调用eval即可求解  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="keyword">return</span> eval(expression)</span><br></pre></td></tr></table></figure>
<p>含变量且变量有值，就调用字典将变量替代掉，这里考到了regex替代函数re.sub</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s.group()</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'\w+'</span>, f, expression)</span><br><span class="line">	res = eval(converted_expr)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>由于变量可能没有值，所以核心思路是用dict进行计算，如x + 2，用集合求和{(x,): 1} + {(): 2}得到{(‘x’,): 1, (): -2}，用dict来计算及保存结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>regex替代变量</li>
<li>将表达式用f包装，如(f(“x”) + f(“8”)) * (f(“x”) - f(“8”))</li>
<li>实现dict的加减乘</li>
<li>dict的计算结果转成题目所求</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span><span class="params">(Counter)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.update(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.subtract(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			product = MyCounter()</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">				<span class="keyword">for</span> y <span class="keyword">in</span> other:</span><br><span class="line">					xy = tuple(sorted(x + y))</span><br><span class="line">					product[xy] += self[x] * other[y]</span><br><span class="line">			<span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> MyCounter(&#123;(s, ): <span class="number">1</span>&#125;) <span class="keyword">if</span> s.isalpha() <span class="keyword">else</span> MyCounter(&#123;(): int(s)&#125;)</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'(\w+)'</span>, <span class="string">r'f("\1")'</span>, expression)</span><br><span class="line">	<span class="comment"># (f("x") + f("8")) * (f("x") - f("8"))</span></span><br><span class="line">	res = eval(converted_expr) <span class="comment">#</span></span><br><span class="line">	<span class="comment"># C(&#123;('x', 'x'): 1, ('x',): 0, (): -64&#125;)</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">'*'</span>.join((str(res[x]), ) + x)</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> sorted(res, key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line">			<span class="keyword">if</span> res[x]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/30/karat-002/">Karat 002 Longest Common Continuous Subarray</a></h1>
  

      
        <time datetime="2022-01-30T09:46:41.967Z">2022-01-30</time>
      
    </header>
    <div class="entry">
      
        <p>[<br>  [“3234.html”, “xys.html”, “7hsaa.html”], // user1<br>  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2<br>]</p>
<p>输出两个user的最长连续且相同的访问记录。</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续最长子数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 1143先求最长公共子字符串。</p>
<p>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p>
<p>不同之处在于： </p>
<ol>
<li>由于是连续，所以递归只有相同的情况，其他情况为0。 </li>
<li>答案不是最后一位，而是全局最值</li>
</ol>
<p>递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = 0</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归只有一种情况</li>
<li>答案需求全局</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				res = max(res, dp[i][j])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>回到原题，输入是列表而不是字符串，但原理一样。还有需要输出公共结果，而不是数字</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuousSubarray</span><span class="params">(self, history1, history2)</span>:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history1) + <span class="number">1</span>)]</span><br><span class="line">	max_len, res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> history1[i - <span class="number">1</span>] == history2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">					max_len = dp[i][j]</span><br><span class="line">					res = history1[i - dp[i][j]:i]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/5/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/13/leetcode-158-read-n-characters-given-read4/">LeetCode 157 Read N Characters Given Read4</a>
      </li>
    
      <li>
        <a href="/2022/02/13/leetcode-157-read-n-characters-given-read4/">LeetCode 157 Read N Characters Given Read4</a>
      </li>
    
      <li>
        <a href="/2022/02/12/karat-004/">Karat 004 Ads Conversion</a>
      </li>
    
      <li>
        <a href="/2022/02/12/leetcode-498-diagonal-traverse/">LeetCode 498 Diagonal Traverse</a>
      </li>
    
      <li>
        <a href="/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/">LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.17px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.75px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.08px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.75px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.42px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.42px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.92px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.83px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.75px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.25px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.25px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 11.25px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.58px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.17px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.67px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.92px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.08px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 14.17px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.33px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.25px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 12.5px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 17.08px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.42px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.5px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.33px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.83px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.25px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.83px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 12.08px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.25px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.83px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.42px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.83px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.42px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.5px;">Stack</a> <a href="/tags/String/" style="font-size: 18.75px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.25px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.67px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.25px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.58px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.42px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.42px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

