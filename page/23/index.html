<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 23 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/27/lee-909/">LeetCode 909 Snakes and Ladders</a></h1>
  

      
        <time datetime="2021-12-27T21:50:38.164Z">2021-12-27</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>&lt;div&gt;</p>
<p>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n&lt;sup&gt;2&lt;/sup&gt;</code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank" rel="noopener"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.</p>
<p>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:</p>
<ul>
<li>Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n&lt;sup&gt;2&lt;/sup&gt;)]</code>.
<ul>
<li>This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.</li>
</ul>
</li>
<li>If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.</li>
<li>The game ends when you reach the square <code>n&lt;sup&gt;2&lt;/sup&gt;</code>.</li>
</ul>
<p>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have a snake or ladder.</p>
<p>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent snake or ladder.</p>
<ul>
<li>For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.</li>
</ul>
<p>Return <em>the least number of moves required to reach the square</em> <code>n&lt;sup&gt;2&lt;/sup&gt;</code><em>. If it is not possible to reach the square, return</em> <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt=""></p>
<p>&lt;pre&gt;<strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
&lt;/pre&gt;</p>
<p><strong>Example 2:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> board = [[-1,-1],[-1,3]]
<strong>Output:</strong> 1
&lt;/pre&gt;</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == board.length == board[i].length</code></li>
<li><code>2 &lt;= n &lt;= 20</code></li>
<li><code>grid[i][j]</code> is either <code>-1</code> or in the range <code>[1, n&lt;sup&gt;2&lt;/sup&gt;]</code>.</li>
<li>The squares labeled <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have any ladders or snakes.</li>
</ul>
<p>&lt;/div&gt;</p>
<h3><strong>题目大意：</strong></h3>
<p>二维版上每格label从1到n^2, 从左到右或从右到左(梅花间竹)，从下到上。每次走1-6步，格上可能有梯子和蛇，梯子是快进，蛇是回退直接到达目标格。求从1到n^2所需要步数。始点和目标不含梯子和蛇。</p>
<h3><strong>BFS解题思路(推荐)：</strong></h3>
<p>求最值两个方法：DP和BFS。一开始考虑用DP，但状态很复杂，因为存在回退，这样回退后要重新计算回退之后的DP值。<br>
由于此题没有方向性而且似jump game，所以考虑用DP。</p>
<h3><strong>解题步骤：</strong></h3>
<p>N/A</p>
<h3><strong>注意事项：</strong></h3>
<ol>
<li>题意：对于梯子和蛇，它不能停留在梯子和蛇的起点，只能够停在终点，所以梯子和蛇的起点到1的距离为无穷大。其实可以留在起点，比如一个格同时是蛇的终点和梯子的起点。题意表明不能在同一步中两次用梯子或蛇。</li>
<li>根据上述题意，程序中对应是<strong>如碰到儿子中有梯子和蛇的起点，完全忽略它，立刻转换成终点，也就是不入列，不如visited，不计算距离，完全当其透明</strong>。开始犯的错误是将其入列，出列才计算梯子终点。此算法仍然可以满足上述题意，此时梯子的起点会被加入到visited和distance，queue中，因为它确实停在那里了。</li>
<li>visited在计算完梯子和蛇的终点后才处理，而不是进入for loop后</li>
<li>neighbor不能超过n，达不到目标返回-1</li>
<li>另一个难点在label转成坐标从而查找是否有梯子和蛇</li>
</ol>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited: <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			queue.append(next_step)</span><br><span class="line">			visited.add(next_step)</span><br><span class="line">			distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>
<p>另一种优化是只入最远的节点，类似于jump game。</p>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		max_non_jump = node</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">				queue.append(next_step)</span><br><span class="line">				visited.add(next_step)</span><br><span class="line">				distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				max_non_jump = next_step</span><br><span class="line">		<span class="keyword">if</span> max_non_jump <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		queue.append(max_non_jump)</span><br><span class="line">		visited.add(max_non_jump)</span><br><span class="line">		distance[max_non_jump] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;/6)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;/6)&lt;/code&gt;</p>
<hr>
<h3><strong>DP算法II解题思路(不推荐)：</strong></h3>
<p>非常容易错，且效率更低，需要回退重新计算dp值。 dp[i] + 1 &lt; dp[dest_label]保证不会在无限回退，i = dest_label - 1要在break前做，而不是更前，否二影响dp[dest_label]计算</p>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders_dp</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	N = len(board) * len(board) + <span class="number">1</span></span><br><span class="line">	dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="comment"># i is label id</span></span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">	<span class="comment"># for i in range(2, N):</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; N:</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> i + k &lt; N:</span><br><span class="line">				board_x, board_y = self.get_board_cell(len(board), i + k)</span><br><span class="line">				dest_label = board[board_x][board_y]</span><br><span class="line">				next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> i + k</span><br><span class="line">				<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">					<span class="keyword">if</span> dest_label &lt; i <span class="keyword">and</span> dp[i] + <span class="number">1</span> &lt; dp[dest_label]: <span class="comment"># remember </span></span><br><span class="line">						dp[dest_label] = min(dp[dest_label], dp[i] + <span class="number">1</span>)</span><br><span class="line">						i = dest_label - <span class="number">1</span> <span class="comment"># remember to assign at the end</span></span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">				dp[next_step] = min(dp[next_step], dp[i] + <span class="number">1</span>) <span class="comment"># remember + 1 inside min</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/27/lee-987/">LeetCode 987 Vertical Order Traversal of a Binary Tree</a></h1>
  

      
        <time datetime="2021-12-27T20:08:31.755Z">2021-12-27</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>&lt;div&gt;</p>
<p>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.</p>
<p>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.</p>
<p>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.</p>
<p>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt=""></p>
<p>&lt;pre&gt;<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[9],[3,15],[20],[7]]
<strong>Explanation:</strong>
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.&lt;/pre&gt;</p>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt=""></p>
<p>&lt;pre&gt;<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
1 is at the top, so it comes first.
5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
&lt;/pre&gt;</p>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt=""></p>
<p>&lt;pre&gt;<strong>Input:</strong> root = [1,2,3,4,6,5,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
&lt;/pre&gt;</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>&lt;/div&gt;</p>
<h3><strong>题目大意：</strong></h3>
<p>按列顺序打印二叉树，若列号同，同一行的节点按值排序</p>
<h3><strong>解题思路：</strong></h3>
<p>与<a href="https://shineboy2013.github.io/2021/12/24/lee-314/" target="_blank" rel="noopener">LeetCode 314 Binary Tree Vertical Order Traversal</a>类似，用BFS</p>
<h3><strong>解题步骤：</strong></h3>
<p>N/A</p>
<h3><strong>注意事项：</strong></h3>
<ol>
<li>一开始以为同一列的同一行的节点在queue是一个紧接一个出列。但同一行节点可能先出列col=3, col=4， col=3。而且同一列同一行的节点有多个，不止两个。所以<strong>将row_id也加入到queue节点中，row_id也加入到map中，最后遍历结果时，将同一row_id节点排序</strong></li>
</ol>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	col_to_node_list = collections.defaultdict(list)</span><br><span class="line">	min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	queue = collections.deque([(root, <span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node, row_id, col_id = queue.popleft()</span><br><span class="line">		col_to_node_list[col_id].append((node.val, row_id))</span><br><span class="line">		min_col, max_col = min(min_col, col_id), max(max_col, col_id)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((node.left, row_id + <span class="number">1</span>, col_id - <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((node.right, row_id + <span class="number">1</span>, col_id + <span class="number">1</span>))</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">		last_row_id, same_row, same_col = <span class="number">-1</span>, [], []</span><br><span class="line">		<span class="keyword">for</span> pair <span class="keyword">in</span> col_to_node_list[i]:</span><br><span class="line">			<span class="keyword">if</span> last_row_id == pair[<span class="number">1</span>]:</span><br><span class="line">				same_row.append(pair[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				same_col += sorted(same_row)</span><br><span class="line">				same_row = [pair[<span class="number">0</span>]]</span><br><span class="line">				last_row_id = pair[<span class="number">1</span>]</span><br><span class="line">		same_col += sorted(same_row)</span><br><span class="line">		res.append(same_col)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，稍大于O(n), 因为同一列同一行节点要排序</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/26/lee-453/">LeetCode 453 Minimum Moves to Equal Array Elements</a></h1>
  

      
        <time datetime="2021-12-27T07:26:35.925Z">2021-12-26</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>&lt;div&gt;</p>
<p>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.</p>
<p>In one move, you can increment <code>n - 1</code> elements of the array by <code>1</code>.</p>
<p><strong>Example 1:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Only three moves are needed (remember each move increments two elements):
[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
&lt;/pre&gt;</p>
<p><strong>Example 2:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 0
&lt;/pre&gt;</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li><code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>The answer is guaranteed to fit in a <strong>32-bit</strong> integer.</li>
</ul>
<p>&lt;/div&gt;</p>
<h3><strong>题目大意：</strong></h3>
<p>求最小移动步数使得数组所有数相等。每次移动是将n-1个元素加1</p>
<h3><strong>解题思路：</strong></h3>
<p>最小值考虑用DP。但比较难写递归式，以[1, 2, 3]为例，值为3，现在是[1, 2, 3, 6]，由于dp[3]的最终状态为[4, 4, 4], 而最终状态加上新元素为[4, 4, 4, 9], 由6变成9是因为dp[3] = 3，表示移动了3步，新元素6，移动的3步全部参与了，所以变成9<br>
由[4, 4, 4, 9], 4变9，需要5步，所以结果dp[4] = dp[3] + 5 = 8</p>
<p>公式为<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + (nums[i] + dp[i] - equal_num)  </span><br><span class="line">equal_num = nums[i] + dp[i]</span><br></pre></td></tr></table></figure></p>
<h3><strong>解题步骤：</strong></h3>
<p>N/A</p>
<h3><strong>注意事项：</strong></h3>
<ol>
<li>数组要排序</li>
<li>equal_num初始值为nums[0]</li>
</ol>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	dp, equal_num = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		new_val = n + dp</span><br><span class="line">		dp = dp + (n + dp - equal_num) <span class="comment"># 2</span></span><br><span class="line">		equal_num = new_val <span class="comment"># 3</span></span><br><span class="line">	<span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/26/lee-926/">LeetCode 926 Flip String to Monotone Increasing</a></h1>
  

      
        <time datetime="2021-12-27T06:17:44.346Z">2021-12-26</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>&lt;div&gt;</p>
<p>A binary string is monotone increasing if it consists of some number of <code>0</code>'s (possibly none), followed by some number of <code>1</code>'s (also possibly none).</p>
<p>You are given a binary string <code>s</code>. You can flip <code>s[i]</code> changing it from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.</p>
<p>Return <em>the minimum number of flips to make</em> <code>s</code> <em>monotone increasing</em>.</p>
<p><strong>Example 1:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;00110&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We flip the last digit to get 00111.
&lt;/pre&gt;</p>
<p><strong>Example 2:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;010110&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We flip to get 011111, or alternatively 000111.
&lt;/pre&gt;</p>
<p><strong>Example 3:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;00011000&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We flip to get 00000000.
&lt;/pre&gt;</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li><code>s[i]</code> is either <code>'0'</code> or <code>'1'</code>.</li>
</ul>
<p>&lt;/div&gt;</p>
<h3><strong>题目大意：</strong></h3>
<p>01字符串中Flip其中一些将它变成00111,0和1的个数是任意。</p>
<h3><strong>DP解题思路(推荐)：</strong></h3>
<p>求最小值考虑用BFS或者DP。BFS的复杂度可能比较大，DP定义为以s[i]为结尾的最小flip数，但由于不知道具体排列(末状态)是什么或者结尾是什么，所以比较难从子问题推导出来。<br>
不妨用两个dp来计算，<br>
dp为以0为结尾的最小flip数<br>
dp2为以1为结尾的最小flip数<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = dp     if s[i] = &apos;0&apos;</span><br><span class="line">   = dp + 1 if s[i] = &apos;1&apos;</span><br><span class="line">   </span><br><span class="line">dp2 = min(dp2 + 1, dp + 1)     if s[i] = &apos;0&apos;</span><br><span class="line">    = min(dp2, dp)             if s[i] = &apos;1&apos;</span><br></pre></td></tr></table></figure></p>
<h3><strong>解题步骤：</strong></h3>
<p>N/A</p>
<h3><strong>注意事项：</strong></h3>
<ol>
<li>用Python的dp和dp2同时由前状态赋值，这样避免用临时变量</li>
</ol>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	dp, dp2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">			dp, dp2 = dp, min(dp, dp2) + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			dp, dp2 = dp + <span class="number">1</span>, min(dp2, dp)</span><br><span class="line">	<span class="keyword">return</span> min(dp, dp2)</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>
<hr>
<h3><strong>presum算法II解题思路：</strong></h3>
<p>统计1的个数，若是0同时统计从0 flip到1的个数，取两者较小为新flip数。较难理解，不推荐</p>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	ones, flips = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> c == <span class="string">'1'</span>:</span><br><span class="line">			ones += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			flips += <span class="number">1</span></span><br><span class="line">		flips = min(ones, flips)</span><br><span class="line">	<span class="keyword">return</span> flips</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/26/lee-828/">LeetCode 828 Count Unique Characters of All Substrings of a Given String</a></h1>
  

      
        <time datetime="2021-12-27T03:47:53.235Z">2021-12-26</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>&lt;div&gt;</p>
<p>Let's define a function <code>countUniqueChars(s)</code> that returns the number of unique characters on <code>s</code>.</p>
<ul>
<li>For example if <code>s = &quot;LEETCODE&quot;</code> then <code>&quot;L&quot;</code>, <code>&quot;T&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;O&quot;</code>, <code>&quot;D&quot;</code> are the unique characters since they appear only once in <code>s</code>, therefore <code>countUniqueChars(s) = 5</code>.</li>
</ul>
<p>Given a string <code>s</code>, return the sum of <code>countUniqueChars(t)</code> where <code>t</code> is a substring of s.</p>
<p>Notice that some substrings can be repeated so in this case you have to count the repeated ones too.</p>
<p><strong>Example 1:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;ABC&quot;
<strong>Output:</strong> 10
<strong>Explanation:</strong> All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.
Evey substring is composed with only unique letters.
Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10
&lt;/pre&gt;</p>
<p><strong>Example 2:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;ABA&quot;
<strong>Output:</strong> 8
<strong>Explanation:</strong> The same as example 1, except <code>countUniqueChars</code>(&quot;ABA&quot;) = 1.
&lt;/pre&gt;</p>
<p><strong>Example 3:</strong></p>
<p>&lt;pre&gt;<strong>Input:</strong> s = &quot;LEETCODE&quot;
<strong>Output:</strong> 92
&lt;/pre&gt;</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10</code>&lt;sup&gt;5&lt;/sup&gt;</li>
<li><code>s</code> consists of uppercase English letters only.</li>
</ul>
<p>&lt;/div&gt;</p>
<h3><strong>题目大意：</strong></h3>
<p>求所有子串的唯一字符的个数的总和</p>
<h3><strong>解题思路：</strong></h3>
<p>暴力法是所有子串O(n^2)，统计唯一字符个数O(n), 复杂度为O(n^3). 尝试优化统计那一步，用presum map来详见可以O(1)求得，但内存过大，仍然TLE。<br>
求个个数且是字符串题，考虑用DP。此题还有点似Leetcode 003 Longest Substring Without Repeating Characters。</p>
<p>写几个找规律且从简单开始，也就是没有重复<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A: 1</span><br><span class="line">AB: 1                + 2 + 1 = 4, 1是dp[1], 2是以B结尾的2个子串有两个B，最后一个1表示AB串中有一个A  </span><br><span class="line">       B</span><br><span class="line">      AB        </span><br><span class="line">ABC： 4           + 3 + 2 + 1 = 10， 4是dp[2], 2是以C结尾的3个子串有三个C，2个B，1个A. Delta = 6  </span><br><span class="line">        C</span><br><span class="line">       BC</span><br><span class="line">      ABC  </span><br><span class="line">ABCB:10      + 2 + 3 + 0 + 1 = 16, 同理是上一个DP结果和从后往前每个字母在新子串中的唯一数。由于出现重复，B从4个变成2个，前一个B变成0个，其他加法项是不变的。Delta = 6 + 4 - 2 x 2 = 6 公式为Delta = Delta + 当前长度 - (i - 上一个重复元素下标) x 2    </span><br><span class="line">         B</span><br><span class="line">        CB</span><br><span class="line">       BCB</span><br><span class="line">      ABCB  </span><br><span class="line">ABCBA:16 + 4 + 2 + 3 + 0 + 0 = 25 = 16 + delta 验证公式delta = 6 + 5 - 1 x 2 = 9    </span><br><span class="line">          A </span><br><span class="line">         BA</span><br><span class="line">        CBA</span><br><span class="line">       BCBA</span><br><span class="line">      ABCBA </span><br><span class="line">ABCBAC:25 + 3 + 4 + 2 + 0 + 0 + 0 = 34 = 25 + delta 验证公式delta = 9 + 6 - (6 - 3) x 2 = 9    </span><br><span class="line">           C </span><br><span class="line">          AC </span><br><span class="line">         BAC</span><br><span class="line">        CBAC</span><br><span class="line">       BCBAC</span><br><span class="line">      ABCBAC </span><br><span class="line">ABCBACA:34 + 2 + 3 + 0 + 2 + 0 + 0 + 0 = 41 = 34 + delta 验证公式delta = 9 + 7 - (7 - 2) x 2 = 6不匹配，新A本来是7个变成2个，而次新A上一轮有4个最多减4个并不能减5个，所以x 2是不对的。      </span><br><span class="line">            A </span><br><span class="line">           CA </span><br><span class="line">          ACA </span><br><span class="line">         BACA</span><br><span class="line">        CBACA</span><br><span class="line">       BCBACA</span><br><span class="line">      ABCBACA</span><br></pre></td></tr></table></figure></p>
<p>公式为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Delta = Delta + 当前长度 - (i - 上一个重复元素下标) - 上个重复元素对应的加法项delta[j]</span><br><span class="line">Res += Delta</span><br></pre></td></tr></table></figure></p>
<h3><strong>解题步骤：</strong></h3>
<p>delta_sum为上一轮的增加的唯一元素个数<br>
delta[i]为下标为i的元素的唯一个数的增量</p>
<h3><strong>注意事项：</strong></h3>
<ol>
<li>公式中减去重复个数不能乘以2，因为上一个重复元素的增量可能不够减</li>
</ol>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	res, delta_sum, delta, char_to_index = <span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>] * len(s), collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		cur_len = i + <span class="number">1</span></span><br><span class="line">		delta[i] = cur_len</span><br><span class="line">		<span class="keyword">if</span> s[i] <span class="keyword">in</span> char_to_index:</span><br><span class="line">			delta[i] -= char_to_index[s[i]] + <span class="number">1</span></span><br><span class="line">			delta_sum += delta[i] - delta[char_to_index[s[i]]]</span><br><span class="line">			delta[char_to_index[s[i]]] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			delta_sum += delta[i]</span><br><span class="line">		res += delta_sum</span><br><span class="line">		char_to_index[s[i]] = i</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code></p>
<hr>
<h3><strong>两个Map算法II解题思路(推荐)：</strong></h3>
<p>公式中上个重复元素对应的加法项也就是上个重复元素与上上个重复元素的距离，所以引入另一个map来记录，避免用delta[i]，算法更加简单。</p>
<h3><strong>Python代码：</strong></h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	last_last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	res, delta = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		delta += i - last_char_to_index[c] - (last_char_to_index[c] - last_last_char_to_index[c])</span><br><span class="line">		last_last_char_to_index[c] = last_char_to_index[c]</span><br><span class="line">		last_char_to_index[c] = i</span><br><span class="line">		res += delta</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3><strong>算法分析：</strong></h3>
<p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/22/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/24/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/01/29/leetcode-259-3sum-smaller/">LeetCode 259 3Sum Smaller</a>
      </li>
    
      <li>
        <a href="/2022/01/29/leetcode-628-maximum-product-of-three-numbers/">LeetCode 628 Maximum Product of Three Numbers</a>
      </li>
    
      <li>
        <a href="/2022/01/29/leetcode-1143-longest-common-subsequence/">LeetCode 1143 Longest Common Subsequence</a>
      </li>
    
      <li>
        <a href="/2022/01/27/leetcode-399-evaluate-division/">LeetCode 399 Evaluate Division</a>
      </li>
    
      <li>
        <a href="/2022/01/27/leetcode-384-shuffle-an-array/">LeetCode 384 Shuffle an Array</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 13.91px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.48px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 16.96px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.48px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.43px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.43px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.83px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.43px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 19.13px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 14.78px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.3px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.3px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 10.43px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.57px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.13px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.74px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.17px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.17px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 16.96px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 13.48px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.04px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.3px;">Iterator</a> <a href="/tags/Knowledge-Base/" style="font-size: 16.96px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.65px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.61px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.26px;">Math</a> <a href="/tags/Matrix/" style="font-size: 16.09px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.3px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.87px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 10px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.52px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.87px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.43px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.87px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.3px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.43px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.39px;">Stack</a> <a href="/tags/String/" style="font-size: 18.7px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.3px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 15.22px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.3px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.35px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.43px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.43px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

