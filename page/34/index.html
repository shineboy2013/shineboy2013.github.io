<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 34 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/06/lee-863/">LeetCode 863 All Nodes Distance K in Binary Tree</a></h1>
  

      
        <time datetime="2021-12-06T19:49:23.856Z">2021-12-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, the value of a target node <code>target</code>, and an integer <code>k</code>, return <em>an array of the values of all nodes that have a distance</em> <code>k</code> <em>from the target node.</em><br><br>You can return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2<br><strong>Output:</strong> [7,4,1]<br>Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 1, k = 3<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 500]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 500</code><br><em>   All the values <code>Node.val</code> are <strong>unique</strong>.
</em>   <code>target</code> is the value of one of the nodes in the tree.<br>*   <code>0 &lt;= k &lt;= 1000</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>有三种情况，都容易忽略： 1. 儿子节点 2. 所有父节点路劲上 3. 兄弟节点路径上。而第三种情况要搜另一边的儿子节点（左右不确定）要用visited记录，而且不一定是父亲的兄弟节点，可能爷爷的非父亲的儿子节点。<br>既然不是单向搜索，不妨转换为图，然后用计算距离BFS模板，只要用map来记录某节点的父亲节点或者增加一个域。BFS中for neighbor in [node.left, node, right, node.parent]  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>root的parent是None，所以从root去赋值parent，而不是从parent root给儿子赋parent  </li>
<li>Line 13 node.left, node.right, node.parent都可能为None，所以Line14要加not neighbor      </li>
<li>BFS从target开始而不是root</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root: TreeNode, target: TreeNode, k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	self.dfs(root, <span class="keyword">None</span>)</span><br><span class="line">	queue, visited, distance_to_tgt,  = collections.deque([target]), set([target]), collections.defaultdict(int)</span><br><span class="line">	distance_to_tgt[target], res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> distance_to_tgt[node] == k:</span><br><span class="line">			res.append(node.val)</span><br><span class="line">		<span class="keyword">if</span> distance_to_tgt[node] &gt; k:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> [node.left, node.right, node.parent]:</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> neighbor <span class="keyword">or</span> neighbor <span class="keyword">in</span> visited:  <span class="comment"># remember not neighbor</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance_to_tgt[neighbor] = distance_to_tgt[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, parent)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	root.parent = parent</span><br><span class="line">	<span class="string">'''if root.left:</span></span><br><span class="line"><span class="string">		root.left.parent = root</span></span><br><span class="line"><span class="string">	if root.right:</span></span><br><span class="line"><span class="string">		root.right.parent = root'''</span></span><br><span class="line">	self.dfs(root.left, root)  <span class="comment"># remember to pass parent</span></span><br><span class="line">	self.dfs(root.right, root)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/06/lee-295/">LeetCode 295 Find Median from Data Stream</a></h1>
  

      
        <time datetime="2021-12-06T17:48:27.935Z">2021-12-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.<br><br><em>   For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.
</em>   For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.<br><br>Implement the MedianFinder class:<br><br><em>   <code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.
</em>   <code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.<br><em>   <code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> of the actual answer will be accepted.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br><strong>Output</strong><br>[null, null, null, 1.5, null, 2.0]<br><br><strong>Explanation</strong><br>MedianFinder medianFinder = new MedianFinder();<br>medianFinder.addNum(1);    // arr = [1]<br>medianFinder.addNum(2);    // arr = [1, 2]<br>medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)<br>medianFinder.addNum(3);    // arr[1, 2, 3]<br>medianFinder.findMedian(); // return 2.0<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= num &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   There will be at least one element in the data structure before calling <code>findMedian</code>.
</em>   At most <code>5 * 10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.<br><br><strong>Follow up:</strong><br><br><em>   If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?
</em>   If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求动态中位数</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>用max_heap, min_heap, 保证min_heap个数永远等于max_heap或多一个。插入元素先进max_heap, 再heappop将堆顶元素加入min_heap, 若此时比max_heap多2个，就再heappop加入到max_heap. </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>中位数有1-2个  </li>
<li>Python中的max_heap用负数实现，<strong>入堆出堆都要取反</strong>        </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        heapq.heappush(self.max_heap, -num)</span><br><span class="line">        max_value = -heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, max_value)</span><br><span class="line">        <span class="keyword">if</span> len(self.min_heap) - len(self.max_heap) &gt;= <span class="number">2</span>:</span><br><span class="line">            min_value = heapq.heappop(self.min_heap)</span><br><span class="line">            heapq.heappush(self.max_heap, -min_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">            <span class="keyword">return</span> (-self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.min_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/06/lee-227/">LeetCode 227 Basic Calculator II</a></h1>
  

      
        <time datetime="2021-12-06T08:35:57.253Z">2021-12-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.<br><br>The integer division should truncate toward zero.<br><br>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>.<br><br><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “3+2<em>2”<br><strong>Output:</strong> 7<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ 3/2 “<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ 3+5 / 2 “<br><strong>Output:</strong> 5<br></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= s.length &lt;= 3 * 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>s</code> consists of integers and operators `(‘+’, ‘-‘, ‘</em>‘, ‘/‘)<code>separated by some number of spaces.
*</code>s<code>represents **a valid expression**.
*   All the integers in the expression are non-negative integers in the range</code>[0, 2<sup>31</sup> - 1]`.<br><em>   The answer is <strong>guaranteed</strong> to fit in a <em>*32-bit integer</em></em>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除，但无括号。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>逆波兰式的实现用Stack。Stack只存数，而且<strong>只存加号操作符</strong>的数，也就是说，<br>如果是减，就将-num入栈，<br>如果是乘除，立刻计算stack[-1]乘除num的结果再压入栈，因为乘除是最高优先级可以直接计算，而加减不可以。<br>所以用<strong>一个stack</strong>  </p>
<p>代码中含三种情况：空格，运算符，数字</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>此题没有括号，不能用模板，要借用op来记录前一个操作符  </p>
<ol>
<li>op记录前一个运算符，char为运算符或当前字符。计算时候根据op，因为char(+)只是第二个操作数(1-2+)的终结字符，此时表明操作数stack[-1], num以及操作符op均已完成，可以计算         </li>
<li>最容易错的是向下取整Line 18, 题目返回要求整数。所以<strong>要除法后取整int(prev / num)</strong></li>
<li>s末尾加入加号，方便parse最后一个num  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	s += <span class="string">'+'</span></span><br><span class="line">	res, num, stack, op = <span class="number">0</span>, <span class="number">0</span>, [], <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">			stack.append(-num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">			stack.append(num) <span class="comment"># [4+2*1]</span></span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(prev * num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(int(prev / num))  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">			op = char</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		n = stack.pop()</span><br><span class="line">		res += n</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/06/lee-301/">LeetCode 301 Remove Invalid Parentheses</a></h1>
  

      
        <time datetime="2021-12-06T08:01:52.622Z">2021-12-06</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.<br><br>Return <em>all the possible results</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “()())()”<br><strong>Output:</strong> [“(())()”,”()()()”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “(a)())()”<br><strong>Output:</strong> [“(a())()”,”(a)()()”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “)(“<br><strong>Output:</strong> [“”]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 25</code>
</em>   <code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.<br>*   There will be at most <code>20</code> parentheses in <code>s</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最小去掉不合法括号数之后的所有结果</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最值问题考虑用DP和BFS，DP难以拆分子问题。所以考虑用BFS + 括号是否合法  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于()())() -&gt; (())()，所以去掉的括号不一定都不合法，所以<strong>BFS要尝试删除每一个括号</strong>。若节点合法，加入结果且记录最小删除数，因为要求同一距离下的所有结果，所以<strong>用这个最小数来剪枝</strong>。</li>
<li>输入含小写字母，所以<strong>无论是判断括号是否合法还是生成儿子节点都要跳过</strong></li>
<li>模板中含if neighbor in visited，不能忘记写</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">	queue = collections.deque([s])</span><br><span class="line">	visited = set([s])</span><br><span class="line">	res, min_dis = [], float(<span class="string">'inf'</span>)</span><br><span class="line">	distance = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> self.is_valid(node):</span><br><span class="line">			res.append(node)</span><br><span class="line">			min_dis = min(min_dis, distance[node])</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> distance[node] &gt; min_dis:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)):</span><br><span class="line">			<span class="keyword">if</span> node[i] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			child = node[:i] + node[i + <span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> child <span class="keyword">in</span> visited: <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(child)</span><br><span class="line">			visited.add(child)</span><br><span class="line">			distance[child] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, s)</span>:</span> <span class="comment"># remember not to use get_invalid_index ()())() -&gt; (())()</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span> <span class="keyword">and</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span>:</span><br><span class="line">			stack.pop()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/05/lee-516/">LeetCode 516 Longest Palindromic Subsequence</a></h1>
  

      
        <time datetime="2021-12-06T07:27:35.791Z">2021-12-05</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, find <em>the longest palindromic <strong>subsequence</strong>‘s length in</em> <code>s</code>.<br><br>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bbbab”<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> One possible longest palindromic subsequence is “bbbb”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “cbbd”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> One possible longest palindromic subsequence is “bb”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 1000</code>
</em>   <code>s</code> consists only of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串中最长回文序列</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始看到子序列如LIS就想用DP，dp[i]表示以s[i]为结尾的最长回文子序列。但不容易推导公式，难点是没有限制左边界<br>所以应该扩展到二维dp[i][j]表示[i, j]之间的最长回文子序列。公式就简单多了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] + 2,             s[i] == s[j]</span><br><span class="line">         = max(dp[i+1][j], dp[i][j-1]),  s[i] != s[j]</span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>难点是想到用二维DP(区间型DP)。用区间型递归模板，注意dp[i + 1][j]并不是i - 1</li>
<li>初始值为dp[i][i] = 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		dp[i][i] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - k):</span><br><span class="line">			j = i + k</span><br><span class="line">			<span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">				dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*n)</code>，空间复杂度<code>O(n*n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/33/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/35/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/01/20/leetcode-721/">LeetCode</a>
      </li>
    
      <li>
        <a href="/2022/01/20/leetcode-287-find-the-duplicate-number/">LeetCode 287 Find the Duplicate Number</a>
      </li>
    
      <li>
        <a href="/2022/01/20/leetcode-286-walls-and-gates/">LeetCode 286 Walls and Gates</a>
      </li>
    
      <li>
        <a href="/2022/01/20/leetcode-283-move-zeroes/">LeetCode 283 Move Zeroes</a>
      </li>
    
      <li>
        <a href="/2022/01/19/leetcode-282-expression-add-operators/">LeetCode 282 Expression Add Operators</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 13.68px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.68px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.37px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.68px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.53px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.53px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.37px;">Breadth-first Search</a> <a href="/tags/Classic/" style="font-size: 18.95px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15.26px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.58px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.58px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 10.53px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.47px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 18.42px;">Facebook</a> <a href="/tags/Google/" style="font-size: 10.53px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.11px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.63px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 16.84px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 13.68px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.16px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.58px;">Iterator</a> <a href="/tags/Knowledge-Base/" style="font-size: 17.37px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.79px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.63px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 17.89px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.26px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.58px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.53px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 10px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.32px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 11.05px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.53px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 11.05px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.58px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.53px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.89px;">Stack</a> <a href="/tags/String/" style="font-size: 18.42px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.58px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 14.74px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.58px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.21px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.53px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.53px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

