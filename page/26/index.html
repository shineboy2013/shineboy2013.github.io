<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 26 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/28/lee-037/">LeetCode 037 Sudoku Solver</a></h1>
  

      
        <time datetime="2021-12-28T21:54:39.986Z">2021-12-28</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div>Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy <strong>all of the following rules</strong>: 1. Each of the digits <code>1-9</code> must occur exactly once in each row. 2. Each of the digits <code>1-9</code> must occur exactly once in each column. 3. Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid. The <code>&#39;.&#39;</code> character indicates empty cells. <strong>Example 1:</strong> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br><strong>Output:</strong> [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br><strong>Explanation:</strong> The input board is shown above and the only valid solution is shown below:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""><br></pre><br><br><strong>Constraints:</strong> <em> <code>board.length == 9</code> </em> <code>board[i].length == 9</code> <em> <code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>. </em> It is <strong>guaranteed</strong> that the input board has only one solution.</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>日本游戏。需要保证每行每列每个9个方块的数是1-9里唯一。</p>
<h3 id="Global-dict解题思路-推荐-："><a href="#Global-dict解题思路-推荐-：" class="headerlink" title="Global dict解题思路(推荐)："></a><strong>Global dict解题思路(推荐)：</strong></h3><p>DFS。利用DFS模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用三种全局性dict(row, col, box)来记录所有已填的数，方便dfs时候迅速判断是否合法。这是比算法II优胜的地方。Python中不存在list of set只能用list of dict： [collections.defaultdict(int) for _ in range(len(board))]  </li>
<li><strong>初始化要将棋局上所有已有的数加入到dict中</strong>。一开始是dfs时候才加，但这样填的数不知道后面的格是否已经存在。题意保证有解，所以这些数不需验证重复。    </li>
<li>for循环是1-9是数字但棋盘是字符，所以要<strong>字符和数字转化</strong>，选择统一转成数字，不转的话dict会实效。  </li>
<li>box_dict的id转换： i // 3 * 3 + j // 3 </li>
<li>终止条件为start_x == len(board) - 1 and start_y == len(board[0])   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	row_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))] <span class="comment"># remember</span></span><br><span class="line">	col_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">	box_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">				self.add_to_dict(board, i, j, row_dict, col_dict, box_dict) <span class="comment"># rememeber</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(board, <span class="number">0</span>, <span class="number">0</span>, row_dict, col_dict, box_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		start_x += <span class="number">1</span></span><br><span class="line">		start_y = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict) <span class="comment"># guarantee solution</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(board, k, start_x, start_y, row_dict, col_dict, box_dict):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		board[start_x][start_y] = str(k)</span><br><span class="line">		self.add_to_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line">		<span class="keyword">if</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		self.remove_from_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line">		board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	row_dict[i][int(board[i][j])] = <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">	col_dict[j][int(board[i][j])] = <span class="number">1</span></span><br><span class="line">	box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][int(board[i][j])] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_from_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	row_dict[i].pop(int(board[i][j]))</span><br><span class="line">	col_dict[j].pop(int(board[i][j]))</span><br><span class="line">	box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>].pop(int(board[i][j]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, k, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> k <span class="keyword">in</span> row_dict[i] <span class="keyword">or</span> k <span class="keyword">in</span> col_dict[j] <span class="keyword">or</span> k <span class="keyword">in</span> box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>]: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(9<sup>n*n</sup>)</code>，空间复杂度<code>O(n)</code>，n为边长  </p>
<hr>
<h3 id="常量空间算法II解题思路："><a href="#常量空间算法II解题思路：" class="headerlink" title="常量空间算法II解题思路："></a><strong>常量空间算法II解题思路：</strong></h3><p>我一开始的方法，每填一位就验证。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku2</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs2(board, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, board, start_x, start_y)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		start_x += <span class="number">1</span></span><br><span class="line">		start_y = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>) <span class="comment"># guarantee solution</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		if self.is_sudoku(board, start_x, start_y):</span></span><br><span class="line"><span class="string">			return self.dfs(board, start_x, start_y + 1)</span></span><br><span class="line"><span class="string">		else:</span></span><br><span class="line"><span class="string">			return False</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">		board[start_x][start_y] = str(k)</span><br><span class="line">		<span class="keyword">if</span> self.is_sudoku2(board, start_x, start_y) <span class="keyword">and</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sudoku2</span><span class="params">(self, board, x, y)</span>:</span></span><br><span class="line">	<span class="comment"># row, # col, # square</span></span><br><span class="line">	<span class="keyword">if</span> self.is_valid(board, x, <span class="number">0</span>, x, len(board[<span class="number">0</span>]) - <span class="number">1</span>) <span class="keyword">and</span> self.is_valid(board, <span class="number">0</span>, y, len(board) - <span class="number">1</span>, y) <span class="keyword">and</span> \</span><br><span class="line">			self.is_valid(board, x // <span class="number">3</span> * <span class="number">3</span>, y // <span class="number">3</span> * <span class="number">3</span>, x // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>, y // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, start_x, start_y, end_x, end_y)</span>:</span></span><br><span class="line">	num_set = set()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start_x, end_x + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(start_y, end_y + <span class="number">1</span>):</span><br><span class="line">			val = board[i][j]</span><br><span class="line">			<span class="keyword">if</span> val == <span class="string">'.'</span>:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> int(val) <span class="keyword">in</span> num_set:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			num_set.add(int(val))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(81<sup>n*n</sup>)</code>，空间复杂度<code>O(1)</code>，n为边长  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/28/lee-871/">LeetCode 871 Minimum Number of Refueling Stops</a></h1>
  

      
        <time datetime="2021-12-28T10:25:39.285Z">2021-12-28</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.<br><br>There are gas stations along the way. The gas stations are represented as an array <code>stations</code> where <code>stations[i] = [position&lt;sub&gt;i&lt;/sub&gt;, fuel&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> gas station is <code>position&lt;sub&gt;i&lt;/sub&gt;</code> miles east of the starting position and has <code>fuel&lt;sub&gt;i&lt;/sub&gt;</code> liters of gas.<br><br>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.<br><br>Return <em>the minimum number of refueling stops the car must make in order to reach its destination</em>. If it cannot reach the destination, return <code>-1</code>.<br><br>Note that if the car reaches a gas station with <code>0</code> fuel left, the car can still refuel there. If the car reaches the destination with <code>0</code> fuel left, it is still considered to have arrived.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 1, startFuel = 1, stations = []<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> We can reach the target without refueling.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 1, stations = [[10,100]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We can not reach the target (or even the first gas station).<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We start with 10 liters of fuel.<br>We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.<br>Then, we drive from position 10 to position 60 (expending 50 liters of fuel),<br>and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.<br>We made 2 refueling stops along the way, so we return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target, startFuel &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>0 &lt;= stations.length &lt;= 500</code><br><em>   <code>0 &lt;= position&lt;sub&gt;i&lt;/sub&gt; &lt;= position&lt;sub&gt;i+1&lt;/sub&gt; &lt; target</code>
</em>   <code>1 &lt;= fuel&lt;sub&gt;i&lt;/sub&gt; &lt; 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>其最小加油次数使得能到达目标  </p>
<h3 id="Heap解题思路-推荐-："><a href="#Heap解题思路-推荐-：" class="headerlink" title="Heap解题思路(推荐)："></a><strong>Heap解题思路(推荐)：</strong></h3><p>由于是重叠区间题且贪婪法加找最大油加油站，考虑用heap。求最小值，所以用最大堆。heap存的油数。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>每到一个加油站，先将油预存到heap中。startFuel为到达某个站后的剩余油数，若startFuel为负，从heap中取油，且累计加油次数。  </li>
<li>用heap模板，遍历数组也就是加油站。  </li>
<li>若加完油后，仍为负数，返回-1。</li>
<li>因为要计算target是否能达到，所以不妨<strong>将target加入到stations</strong>中，这样startFuel的计算可以包括target     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	heap, res, prev_pos = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	stations.append([target, <span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> pos, fuel <span class="keyword">in</span> stations:</span><br><span class="line">		startFuel -= pos - prev_pos</span><br><span class="line">		<span class="keyword">while</span> heap <span class="keyword">and</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line">			startFuel += -heapq.heappop(heap)</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		heapq.heappush(heap, -fuel)</span><br><span class="line">		prev_pos = pos</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code> </p>
<hr>
<h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>一开始考虑用jump game，但此题可以在同一层加多次油。比如start fuel有100 mi，而加油站有3个，所以同一层可以加3次油。所以层数和加油次数不是一个概念。<br>既然是最值考虑另一种方法DP。这题有两个难点:<br>第一个难点是DP式： dp不采用题目的最小加油次数，考虑jump game的分析，转化成dp[i]为停i个站加油能达到的最远距离。或者这样思考，若定义走到第n个站需要最小加油次数，这个n颗粒度不够细，可以换成miles，不如将下标和数值互换。<br>第二个难点是递归式。首先知道假设dp[2]能到达的范围内有一个加油站，加油后dp[3] = dp[2] + 该油站的油数。递归式为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span><br></pre></td></tr></table></figure>
<p>有个前提条件是dp[2]必须能达到当前的加油站。比如要更新dp[3]从任意两个加油站dp[2] + 加油站[i]可能获得。还可能是从dp[2] + 加油站[i+1]获得，如此类推，要试完stations[i..n]。<br><strong>dp值从后往前更新</strong>，因为当前加油站在后方。   </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp定义和递归式     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [startFuel] + [<span class="number">0</span>] * len(stations)</span><br><span class="line">	<span class="keyword">for</span> i, (pos, fuel) <span class="keyword">in</span> enumerate(stations):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">if</span> dp[j] &gt;= pos:</span><br><span class="line">				dp[j + <span class="number">1</span>] = max(dp[j + <span class="number">1</span>], dp[j] + fuel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, miles <span class="keyword">in</span> enumerate(dp):</span><br><span class="line">		<span class="keyword">if</span> miles &gt;= target:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/27/lee-909/">LeetCode 909 Snakes and Ladders</a></h1>
  

      
        <time datetime="2021-12-27T21:50:38.164Z">2021-12-27</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n&lt;sup&gt;2&lt;/sup&gt;</code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank" rel="noopener"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.<br><br>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:<br><br><em>   Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n&lt;sup&gt;2&lt;/sup&gt;)]</code>.
    </em>   This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.<br><em>   If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.
</em>   The game ends when you reach the square <code>n&lt;sup&gt;2&lt;/sup&gt;</code>.<br><br>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have a snake or ladder.<br><br>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent snake or ladder.<br><br><em>   For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.<br><br>Return <em>the least number of moves required to reach the square</em> <code>n&lt;sup&gt;2&lt;/sup&gt;</code><em>. If it is not possible to reach the square, return</em> <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt=""><br><br><pre><strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>In the beginning, you start at square 1 (at row 5, column 0).<br>You decide to move to square 2 and must take the ladder to square 15.<br>You then decide to move to square 17 and must take the snake to square 13.<br>You then decide to move to square 14 and must take the ladder to square 35.<br>You then decide to move to square 36, ending the game.<br>This is the lowest possible number of moves to reach the last square, so return 4.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> board = [[-1,-1],[-1,3]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>n == board.length == board[i].length</code><br><em>   <code>2 &lt;= n &lt;= 20</code>
</em>   <code>grid[i][j]</code> is either <code>-1</code> or in the range <code>[1, n&lt;sup&gt;2&lt;/sup&gt;]</code>.<br>*   The squares labeled <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have any ladders or snakes.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二维版上每格label从1到n^2, 从左到右或从右到左(梅花间竹)，从下到上。每次走1-6步，格上可能有梯子和蛇，梯子是快进，蛇是回退直接到达目标格。求从1到n^2所需要步数。始点和目标不含梯子和蛇。</p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>求最值两个方法：DP和BFS。一开始考虑用DP，但状态很复杂，因为存在回退，这样回退后要重新计算回退之后的DP值。<br>由于此题没有方向性而且似jump game，所以考虑用DP。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题意：对于梯子和蛇，它不能停留在梯子和蛇的起点，只能够停在终点，所以梯子和蛇的起点到1的距离为无穷大。其实可以留在起点，比如一个格同时是蛇的终点和梯子的起点。题意表明不能在同一步中两次用梯子或蛇。   </li>
<li>根据上述题意，程序中对应是<strong>如碰到儿子中有梯子和蛇的起点，完全忽略它，立刻转换成终点，也就是不入列，不入visited，不计算距离，完全当其透明</strong>。开始犯的错误是将其入列，出列才计算梯子终点。此算法仍然可以满足上述题意，此时梯子的起点会被加入到visited和distance，queue中，因为它确实停在那里了。  </li>
<li>visited在计算完梯子和蛇的终点后才处理，而不是进入for loop后  </li>
<li>neighbor不能超过n，达不到目标返回-1  </li>
<li>另一个难点在label转成坐标从而查找是否有梯子和蛇</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited: <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			queue.append(next_step)</span><br><span class="line">			visited.add(next_step)</span><br><span class="line">			distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
<p>另一种优化是只入最远的节点和蛇梯子的终点，类似于jump两种，类似于jump game。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		max_non_jump = node</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">				queue.append(next_step)</span><br><span class="line">				visited.add(next_step)</span><br><span class="line">				distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				max_non_jump = next_step</span><br><span class="line">		<span class="keyword">if</span> max_non_jump <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		queue.append(max_non_jump)</span><br><span class="line">		visited.add(max_non_jump)</span><br><span class="line">		distance[max_non_jump] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>/6)</code>，空间复杂度<code>O(n<sup>2</sup>/6)</code>  </p>
<hr>
<h3 id="DP算法II解题思路-不推荐-："><a href="#DP算法II解题思路-不推荐-：" class="headerlink" title="DP算法II解题思路(不推荐)："></a><strong>DP算法II解题思路(不推荐)：</strong></h3><p>非常容易错，且效率更低，需要回退重新计算dp值。 dp[i] + 1 &lt; dp[dest_label]保证不会在无限回退，i = dest_label - 1要在break前做，而不是更前，否二影响dp[dest_label]计算</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders_dp</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	N = len(board) * len(board) + <span class="number">1</span></span><br><span class="line">	dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="comment"># i is label id</span></span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">	<span class="comment"># for i in range(2, N):</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; N:</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> i + k &lt; N:</span><br><span class="line">				board_x, board_y = self.get_board_cell(len(board), i + k)</span><br><span class="line">				dest_label = board[board_x][board_y]</span><br><span class="line">				next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> i + k</span><br><span class="line">				<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">					<span class="keyword">if</span> dest_label &lt; i <span class="keyword">and</span> dp[i] + <span class="number">1</span> &lt; dp[dest_label]: <span class="comment"># remember </span></span><br><span class="line">						dp[dest_label] = min(dp[dest_label], dp[i] + <span class="number">1</span>)</span><br><span class="line">						i = dest_label - <span class="number">1</span> <span class="comment"># remember to assign at the end</span></span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">				dp[next_step] = min(dp[next_step], dp[i] + <span class="number">1</span>) <span class="comment"># remember + 1 inside min</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/27/lee-987/">LeetCode 987 Vertical Order Traversal of a Binary Tree</a></h1>
  

      
        <time datetime="2021-12-27T20:08:31.755Z">2021-12-27</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.<br><br>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.<br><br>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.<br><br>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br><strong>Explanation:</strong><br>Column -1: Only node 9 is in this column.<br>Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.<br>Column 1: Only node 20 is in this column.<br>Column 2: Only node 7 is in this column.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5,6,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>Column -2: Only node 4 is in this column.<br>Column -1: Only node 2 is in this column.<br>Column 0: Nodes 1, 5, and 6 are in this column.<br>          1 is at the top, so it comes first.<br>          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.<br>Column 1: Only node 3 is in this column.<br>Column 2: Only node 7 is in this column.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,6,5,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>This case is the exact same as example 2, but with nodes 5 and 6 swapped.<br>Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 1000]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序打印二叉树，若列号同，同一行的节点按值排序 </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>与<a href="https://shineboy2013.github.io/2021/12/24/lee-314/" target="_blank" rel="noopener">LeetCode 314 Binary Tree Vertical Order Traversal</a>类似，用BFS</p>
<p>LeetCode 314 Binary Tree Vertical Order Traversal 同一列，从上到下，从左到右排序<br>LeetCode 987 Vertical Order Traversal of a Binary Tree 同一列，从上到下，同一行值从小到大排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>与LeetCode 314实现的区别</p>
<ol>
<li>一开始以为同一列的同一行的节点在queue是一个紧接一个出列。但同一行节点可能先出列col=3, col=4， col=3。而且同一列同一行的节点有多个，不止两个。所以<strong>将row_id也加入到queue节点和map中</strong>  </li>
<li>遍历结果时，map中的value排序**, value是先row_id再node.val，所以直接可以排序，最后直接取出第二维度</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	col_to_node_list = collections.defaultdict(list)</span><br><span class="line">	min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	queue = collections.deque([(root, <span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node, row_id, col_id = queue.popleft()</span><br><span class="line">		col_to_node_list[col_id].append((row_id, node.val))</span><br><span class="line">		min_col, max_col = min(min_col, col_id), max(max_col, col_id)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((node.left, row_id + <span class="number">1</span>, col_id - <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((node.right, row_id + <span class="number">1</span>, col_id + <span class="number">1</span>))</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">		col_to_node_list[i].sort()</span><br><span class="line">		res.append([_[<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> col_to_node_list[i]])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，稍大于O(n), 因为同一列同一行节点要排序    </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2021/12/26/lee-453/">LeetCode 453 Minimum Moves to Equal Array Elements</a></h1>
  

      
        <time datetime="2021-12-27T07:26:35.925Z">2021-12-26</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.<br><br>In one move, you can increment <code>n - 1</code> elements of the array by <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Only three moves are needed (remember each move increments two elements):<br>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,1]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   The answer is guaranteed to fit in a <strong>32-bit</strong> integer.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最小移动步数使得数组所有数相等。每次移动是将n-1个元素加1</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最小值考虑用DP。但比较难写递归式，以[1, 2, 3]为例，值为3，现在是[1, 2, 3, 6]，由于dp[3]的最终状态为[4, 4, 4], 而最终状态加上新元素为[4, 4, 4, 9], 由6变成9是因为dp[3] = 3，表示移动了3步，新元素6，移动的3步全部参与了，所以变成9<br>由[4, 4, 4, 9], 4变9，需要5步，所以结果dp[4] = dp[3] + 5 = 8  </p>
<p>公式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + (nums[i] + dp[i] - equal_num)  </span><br><span class="line">equal_num = nums[i] + dp[i]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组要排序  </li>
<li>equal_num初始值为nums[0]    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	dp, equal_num = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		dp, equal_num = dp + (n + dp - equal_num), n + dp <span class="comment"># 2</span></span><br><span class="line">	<span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/25/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/27/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/">LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</a>
      </li>
    
      <li>
        <a href="/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/">LeetCode 1761 Minimum Degree of a Connected Trio in a Graph</a>
      </li>
    
      <li>
        <a href="/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/">LeetCode 979 Distribute Coins in Binary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/">LeetCode 1448 Count Good Nodes in Binary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/">LeetCode 1304 Find N Unique Integers Sum up to Zero</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.17px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.75px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.08px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.75px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.42px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.42px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.92px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.83px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.75px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.25px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.25px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 11.25px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.58px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.17px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.67px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.92px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.08px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 14.17px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.33px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.25px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 11.25px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 17.08px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.42px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.5px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.33px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.83px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.25px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.83px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 12.08px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.25px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.83px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.42px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.83px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.42px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.5px;">Stack</a> <a href="/tags/String/" style="font-size: 18.75px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.25px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.67px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.25px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.58px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.42px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.42px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

