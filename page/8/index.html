<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 8 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/20/leetcode-721-accounts-mergesolution/">LeetCode 721 Accounts Merge</a></h1>
  

      
        <time datetime="2022-01-21T03:34:29.553Z">2022-01-20</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> accounts = [[“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],[“John”,”johnsmith@mail.com”,”john00@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Output:</strong> [[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Explanation:</strong><br>The first and second John’s are the same person as they have the common email “johnsmith@mail.com”.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’],<br>[‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> accounts = [[“Gabe”,”Gabe0@m.co”,”Gabe3@m.co”,”Gabe1@m.co”],[“Kevin”,”Kevin3@m.co”,”Kevin5@m.co”,”Kevin0@m.co”],[“Ethan”,”Ethan5@m.co”,”Ethan4@m.co”,”Ethan0@m.co”],[“Hanzo”,”Hanzo3@m.co”,”Hanzo1@m.co”,”Hanzo0@m.co”],[“Fern”,”Fern5@m.co”,”Fern1@m.co”,”Fern0@m.co”]]<br><strong>Output:</strong> [[“Ethan”,”Ethan0@m.co”,”Ethan4@m.co”,”Ethan5@m.co”],[“Gabe”,”Gabe0@m.co”,”Gabe1@m.co”,”Gabe3@m.co”],[“Hanzo”,”Hanzo0@m.co”,”Hanzo1@m.co”,”Hanzo3@m.co”],[“Kevin”,”Kevin0@m.co”,”Kevin3@m.co”,”Kevin5@m.co”],[“Fern”,”Fern0@m.co”,”Fern1@m.co”,”Fern5@m.co”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= accounts.length &lt;= 1000</code>
</em>   <code>2 &lt;= accounts[i].length &lt;= 10</code><br><em>   <code>1 &lt;= accounts[i][j] &lt;= 30</code>
</em>   <code>accounts[i][0]</code> consists of English letters.<br>*   <code>accounts[i][j] (for j &gt; 0)</code> is a valid email.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li>
<li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li>
<li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		li[:] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	name_dict = collections.defaultdict(str)</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">			graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">			graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">			graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">	res, visited = [], set()</span><br><span class="line">	<span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">		sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line">		<span class="keyword">if</span> sub_res:</span><br><span class="line">			res.append(sub_res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	res, name = [], <span class="string">''</span></span><br><span class="line">	queue = collections.deque([start])</span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">			name = name_dict[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	res.sort()</span><br><span class="line">	res.insert(<span class="number">0</span>, name)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p>
<hr>
<h3 id="UnionFind算法II解题思路-不推荐-："><a href="#UnionFind算法II解题思路-不推荐-：" class="headerlink" title="UnionFind算法II解题思路(不推荐)："></a><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li>
<li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li>
<li>处理名字</li>
<li>有重复邮件</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/20/leetcode-287-find-the-duplicate-number/">LeetCode 287 Find the Duplicate Number</a></h1>
  

      
        <time datetime="2022-01-20T10:10:33.912Z">2022-01-20</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br><br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br><br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,4,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,1,3,4,2]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>nums.length == n + 1</code><br><em>   <code>1 &lt;= nums[i] &lt;= n</code>
</em>   All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.<br><br><strong>Follow up:</strong><br><br><em>   How can we prove that at least one duplicate number must exist in <code>nums</code>?
</em>   Can you solve the problem in linear runtime complexity?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数值二分法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li>
<li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line">		<span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/20/leetcode-286-walls-and-gates/">LeetCode 286 Walls and Gates</a></h1>
  

      
        <time datetime="2022-01-20T09:36:10.895Z">2022-01-20</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values.<br><br><em>   <code>-1</code> A wall or an obstacle.
</em>   <code>0</code> A gate.<br><em>   <code>INF</code> Infinity means an empty room. We use the value <code>2&lt;sup&gt;31&lt;/sup&gt; - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.<br><br>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt=""><br><br><pre><strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br><strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> rooms = [[-1]]<br><strong>Output:</strong> [[-1]]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == rooms.length</code><br><em>   <code>n == rooms[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 250</code><br>*   <code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有房间到门的最短距离</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>属于多始点BFS类型</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>门的距离不更新，所以出列后要判断该点是否为门，不是用距离来判断</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OFFSET = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        gates = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rooms)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(rooms[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    gates.append((i, j, <span class="number">0</span>))</span><br><span class="line">        queue = collections.deque(gates)</span><br><span class="line">        visited = set(gates)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, distance = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> rooms[x][y] != <span class="number">0</span>: <span class="comment"># not distance != 0</span></span><br><span class="line">                rooms[x][y] = distance</span><br><span class="line">            <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">                _x, _y = x + _dx, y + _dy</span><br><span class="line">                <span class="keyword">if</span> _x &lt; <span class="number">0</span> <span class="keyword">or</span> _x &gt;= len(rooms) <span class="keyword">or</span> _y &lt; <span class="number">0</span> <span class="keyword">or</span> _y &gt;= len(rooms[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        rooms[_x][_y] == <span class="number">-1</span> <span class="keyword">or</span> (_x, _y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((_x, _y, distance + <span class="number">1</span>))</span><br><span class="line">                visited.add((_x, _y))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(mn)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/20/leetcode-283-move-zeroes/">LeetCode 283 Move Zeroes</a></h1>
  

      
        <time datetime="2022-01-20T08:58:11.187Z">2022-01-20</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.<br><br><strong>Note</strong> that you must do this in-place without making a copy of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,12]<br><strong>Output:</strong> [1,3,12,0,0]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you minimize the total number of operations done?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将数组的0全部移到数组末</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。Quicksort的partition的应用</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	non_zero_idx = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">			nums[i], nums[non_zero_idx] = nums[non_zero_idx], nums[i]</span><br><span class="line">			non_zero_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/19/leetcode-282-expression-add-operators/">LeetCode 282 Expression Add Operators</a></h1>
  

      
        <time datetime="2022-01-20T07:00:41.425Z">2022-01-19</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/expression-add-operators" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators</em> <code>&#39;+&#39;</code><em>,</em> <code>&#39;-&#39;</code><em>, and/or</em> <code>&#39;*&#39;</code> <em>between the digits of</em> <code>num</code> <em>so that the resultant expression evaluates to the</em> <code>target</code> <em>value</em>.<br><br>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = “123”, target = 6<br><strong>Output:</strong> [“1<em>2</em>3”,”1+2+3”]<br><strong>Explanation:</strong> Both “1<em>2</em>3” and “1+2+3” evaluate to 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = “232”, target = 8<br><strong>Output:</strong> [“2<em>3+2”,”2+3</em>2”]<br><strong>Explanation:</strong> Both “2<em>3+2” and “2+3</em>2” evaluate to 8.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = “3456237490”, target = 9191<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no expressions that can be created from “3456237490” to evaluate to 9191.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num.length &lt;= 10</code>
</em>   <code>num</code> consists of only digits.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= target &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一串数字加入加减乘能得到target的所有可能性</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有可能用DFS。属于分割型DFS，在数位之间加符号，数位可以是1个到多个。<br>一轮递归分割出符号 + 数字<br>另一种选择是数字 + 符号，但需要额外变量sign，因为不能立刻计算到结果。也不符合正常逻辑。所以选择前者。</p>
<p>由于运算都是二元，也就是用上述分割法，第一个数要特别处理。所以DFS中要特别处理第一个数。这样可以开始写加减。引入prev_res作为DFS参数，这样只要prev_res 加减 该轮数字即可得到该轮结果。用DFS模板5个标准参数外加prev_res：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_res, path, res):</span><br></pre></td></tr></table></figure></p>
<p>这样只处理加减的DFS比较容易实现  </p>
<p>最大难点在于乘法，参考LeetCode 227 Basic Calculator II，加减和乘除属于两层计算需要分别处理，所以引入<strong>新参数prev_multi_res，用于保存乘法结果，而刚才的命名为prev_add_res保存加减乘的全部结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_add_res, prev_multi_res, path, res):</span><br></pre></td></tr></table></figure></p>
<p>举例2+3*4，按照原来的逻辑会计算到2+3=5，但此时如果遇到乘号，就要重新计算加法结果，先减去乘法结果，退回到2，再计算3*4=12这是乘法结果，再加回2得到新加法结果。进一步理解prev_multi_res，如果该轮是加减法，仍要将该轮的数作为prev_multi_res传到下轮DFS，因为如果下一轮是乘法，它就是第一个乘法的数。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>先实现加减法</li>
<li>再实现乘法</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>分割型DFS，选择每轮递归分割符号 + 数字。由于运算都是二元，<strong>特别处理第一个数</strong></li>
<li>引入参数prev_add_res, prev_multi_res. <strong>prev_multi_res若是加减，用(+/-)cur_num, 否则用乘法结果prev_multi_res * cur_num</strong>。注意若是减法cur_num用负号</li>
<li>分割时数字不能有前缀0</li>
<li>prev_res不用恢复状态因为是标量</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span><span class="params">(self, num: str, target: int)</span> -&gt; List[str]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(num, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, st, target, prev_add_res, prev_multi_res, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(num):</span><br><span class="line">		<span class="keyword">if</span> target == prev_add_res:</span><br><span class="line">			res.append(path)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(num)):</span><br><span class="line">		<span class="keyword">if</span> i &gt; st <span class="keyword">and</span> num[st] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		cur_num = int(num[st:i + <span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> path: <span class="comment"># remember</span></span><br><span class="line">		    <span class="comment"># first number, same as + case</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, str(cur_num), res)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, path + <span class="string">'+'</span> + str(cur_num), res) <span class="comment"># use cur_num rather than cur</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res - cur_num, -cur_num, path + <span class="string">'-'</span> + str(cur_num), res) <span class="comment"># -cur_num rather than cur_num</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, (prev_add_res - prev_multi_res) + prev_multi_res * cur_num, prev_multi_res * cur_num, path + <span class="string">'*'</span> + str(cur_num), res) <span class="comment"># prev_multi_res * cur_num not cur_num</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(4<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>, 因为每个字符之间都有不加操作符，加3个操作符，所以是4，有n-1个间隔  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/7/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/9/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/">LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</a>
      </li>
    
      <li>
        <a href="/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/">LeetCode 1761 Minimum Degree of a Connected Trio in a Graph</a>
      </li>
    
      <li>
        <a href="/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/">LeetCode 979 Distribute Coins in Binary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/">LeetCode 1448 Count Good Nodes in Binary Tree</a>
      </li>
    
      <li>
        <a href="/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/">LeetCode 1304 Find N Unique Integers Sum up to Zero</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.17px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.75px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.08px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.75px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.42px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.42px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.92px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.83px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.75px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.25px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.25px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 11.25px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.58px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.17px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.67px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.92px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.08px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 14.17px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.33px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.25px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 11.25px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 17.08px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.42px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.5px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.33px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.83px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.25px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.83px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 12.08px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.25px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.83px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.42px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.83px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.42px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.5px;">Stack</a> <a href="/tags/String/" style="font-size: 18.75px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.25px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.67px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.25px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.58px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.42px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.42px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

