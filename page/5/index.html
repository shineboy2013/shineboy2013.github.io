<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Page 5 › KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/">LeetCode 315 Count of Smaller Numbers After Self</a></h1>
  

      
        <time datetime="2022-01-24T03:09:12.360Z">2022-01-23</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [5,2,6,1]<br><strong>Output:</strong> [2,1,1,0]<br><strong>Explanation:</strong><br>To the right of 5 there are <strong>2</strong> smaller elements (2 and 1).<br>To the right of 2 there is only <strong>1</strong> smaller element (1).<br>To the right of 6 there is <strong>1</strong> smaller element (1).<br>To the right of 1 there is <strong>0</strong> smaller element.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-1]<br><strong>Output:</strong> [0,0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组中，统计每一位比自己小的数。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑用递减栈。但不可行, 因为这是统计题，而不是求比自己大的一个数LeetCode 503 Next Greater Element II。类似于merge sort，考虑统计逆序数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于mergesort会改变数组顺序，所以统计数组count也要对应的数也会变，所以将原数组变成(数值, 下标)对，count就可以统计原数组</li>
<li>计算逆序对时候，放在nums[i][0] &lt;= nums[j][0]中，核心在count[nums[i][1]] += j - mid - 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	count = [<span class="number">0</span>] * len(nums)</span><br><span class="line">	num_with_idx = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">	self.merge_sort(num_with_idx, <span class="number">0</span>, len(nums) - <span class="number">1</span>, count)</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums, start, end, count)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">	self.merge_sort(nums, start, mid, count)</span><br><span class="line">	self.merge_sort(nums, mid + <span class="number">1</span>, end, count)</span><br><span class="line">	self.merge(nums, start, mid, end, count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, start, mid, end, count)</span>:</span></span><br><span class="line">	i, j = start, mid + <span class="number">1</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">		<span class="keyword">if</span> nums[i][<span class="number">0</span>] &lt;= nums[j][<span class="number">0</span>]:</span><br><span class="line">			res.append(nums[i])</span><br><span class="line">			count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(nums[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">		res.append(nums[i])</span><br><span class="line">		count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= end:</span><br><span class="line">		res.append(nums[j])</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/23/leetcode-348-design-tic-tac-toe/">LeetCode 348 Design Tic-Tac-Toe</a></h1>
  

      
        <time datetime="2022-01-24T00:15:36.677Z">2022-01-23</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/design-tic-tac-toe/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Assume the following rules are for the tic-tac-toe game on an <code>n x n</code> board between two players:<br><br>1.  A move is guaranteed to be valid and is placed on an empty block.<br>2.  Once a winning condition is reached, no more moves are allowed.<br>3.  A player who succeeds in placing <code>n</code> of their marks in a horizontal, vertical, or diagonal row wins the game.<br><br>Implement the <code>TicTacToe</code> class:<br><br><em>   <code>TicTacToe(int n)</code> Initializes the object the size of the board <code>n</code>.
</em>   <code>int move(int row, int col, int player)</code> Indicates that the player with id <code>player</code> plays at the cell <code>(row, col)</code> of the board. The move is guaranteed to be a valid move.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“TicTacToe”, “move”, “move”, “move”, “move”, “move”, “move”, “move”]<br>[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]<br><strong>Output</strong><br>[null, 0, 0, 0, 0, 0, 0, 1]<br><br><strong>Explanation</strong><br>TicTacToe ticTacToe = new TicTacToe(3);<br>Assume that player 1 is “X” and player 2 is “O” in the board.<br>ticTacToe.move(0, 0, 1); // return 0 (no one wins)<br>|X| | |<br>| | | |    // Player 1 makes a move at (0, 0).<br>| | | |<br><br>ticTacToe.move(0, 2, 2); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 2 makes a move at (0, 2).<br>| | | |<br><br>ticTacToe.move(2, 2, 1); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 1 makes a move at (2, 2).<br>| | |X|<br><br>ticTacToe.move(1, 1, 2); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 2 makes a move at (1, 1).<br>| | |X|<br><br>ticTacToe.move(2, 0, 1); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 1 makes a move at (2, 0).<br>|X| |X|<br><br>ticTacToe.move(1, 0, 2); // return 0 (no one wins)<br>|X| |O|<br>|O|O| |    // Player 2 makes a move at (1, 0).<br>|X| |X|<br><br>ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)<br>|X| |O|<br>|O|O| |    // Player 1 makes a move at (2, 1).<br>|X|X|X|<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 100</code>
</em>   player is <code>1</code> or <code>2</code>.<br><em>   <code>0 &lt;= row, col &lt; n</code>
</em>   <code>(row, col)</code> are <strong>unique</strong> for each different call to <code>move</code>.<br><em>   At most <code>n&lt;sup&gt;2&lt;/sup&gt;</code> calls will be made to <code>move</code>.<br><br><em>*Follow-up:</em></em> Could you do better than <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> per <code>move()</code> operation?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计井字过三关</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>游戏题。最重要是是数据结构，类似于LeetCode 051 N-Queens和LeetCode 037 Sudoku Solver用matrix记录每行，每列，对角线和反对角线的和。这样验证时候只需要O(1). </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>对角线和反对角线只有一条，所以要先判断move的这个点是否在对角线上。</li>
<li>由于用-1来代表某一个player，所以判断和时候，用abs</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.board_len = n</span><br><span class="line">        self.row = [<span class="number">0</span>] * n</span><br><span class="line">        self.col = [<span class="number">0</span>] * n</span><br><span class="line">        self.diag = <span class="number">0</span></span><br><span class="line">        self.anti_diag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, row: int, col: int, player: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> player == <span class="number">2</span>:</span><br><span class="line">            player = <span class="number">-1</span></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="keyword">if</span> row == col: <span class="comment"># remember</span></span><br><span class="line">            self.diag += player</span><br><span class="line">        <span class="keyword">if</span> row == self.board_len - <span class="number">1</span> - col:</span><br><span class="line">            self.anti_diag += player</span><br><span class="line">        does_win = abs(self.row[row]) == self.board_len <span class="keyword">or</span> abs(self.col[col]) == self.board_len <span class="keyword">or</span> \</span><br><span class="line">                abs(self.diag) == self.board_len <span class="keyword">or</span> abs(self.anti_diag) == self.board_len <span class="comment"># remember abs</span></span><br><span class="line">        <span class="keyword">if</span> does_win:</span><br><span class="line">            <span class="keyword">if</span> player == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> player</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>move时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/">LeetCode 317 Shortest Distance from All Buildings</a></h1>
  

      
        <time datetime="2022-01-23T23:33:23.203Z">2022-01-23</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> grid <code>grid</code> of values <code>0</code>, <code>1</code>, or <code>2</code>, where:<br><br><em>   each <code>0</code> marks <strong>an empty land</strong> that you can pass by freely,
</em>   each <code>1</code> marks <strong>a building</strong> that you cannot pass through, and<br><em>   each <code>2</code> marks <strong>an obstacle</strong> that you cannot pass through.<br><br>You want to build a house on an empty land that reaches all buildings in the <strong>shortest total travel</strong> distance. You can only move up, down, left, and right.<br><br>Return <em>the <strong>shortest travel distance</strong> for such a house</em>. If it is not possible to build such a house according to the above rules, return <code>-1</code>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).<br>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.<br>So return 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,0]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> grid = [[1]]<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == grid.length</code><br><em>   <code>n == grid[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 50</code><br><em>   <code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.
</em>   There will be <strong>at least one</strong> building in the <code>grid</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找到所有大厦最短距离的点，这个点不能是大厦也不能是障碍</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始觉得类似于LeetCode 296 Best Meeting Point，但由于有障碍，所以不能用贪婪法。最值考虑用BFS。属于对所有节点BFS。类似于LeetCode 200 Number of Islands，<br>从每一栋大厦开始做BFS，计算每个点到此大厦距离。然后对累计到这个点的总距离矩阵dis中。最后求距离矩阵的最小值。 </p>
<p>此题难点在于-1的情况，也就是一个点不能到达其中一个building或者是这个building不能到达的点。所以要再用一个矩阵house_count来记录每一个点能到达的大厦数。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>-1的情况，用一个矩阵house_count来记录每一个点能到达的大厦数。  </li>
<li>用常数记录矩阵长和宽，不用x &gt;= len(grid) or y &gt;= len(grid[0]), 否则会TLE</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dis = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	house_count = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	total_houses = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">				self.bfs(grid, i, j, dis, house_count)</span><br><span class="line">				total_houses += <span class="number">1</span></span><br><span class="line">	min_dis = float(<span class="string">'inf'</span>) <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dis)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(dis[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> dis[i][j] &gt; <span class="number">0</span> <span class="keyword">and</span> house_count[i][j] == total_houses:</span><br><span class="line">				min_dis = min(min_dis, dis[i][j])</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> min_dis == float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_dis <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, start_x, start_y, dis, house_count)</span>:</span></span><br><span class="line">	h = len(grid)</span><br><span class="line">	w = len(grid[<span class="number">0</span>]) <span class="comment"># remember otherwise TLE</span></span><br><span class="line">	queue = collections.deque([(start_x, start_y, <span class="number">0</span>)])</span><br><span class="line">	visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = node[<span class="number">0</span>] + _dx, node[<span class="number">1</span>] + _dy</span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= h <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= w <span class="keyword">or</span> grid[x][y] != <span class="number">0</span> <span class="keyword">or</span> visited[x][y]:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((x, y, node[<span class="number">2</span>] + <span class="number">1</span>))</span><br><span class="line">			visited[x][y] = <span class="keyword">True</span></span><br><span class="line">			dis[x][y] += node[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">			house_count[x][y] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm * nm)</code>，空间复杂度<code>O(nm)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/21/leetcode-304-range-sum-query-2d-immutable/">LeetCode 304 Range Sum Query 2D - Immutable</a></h1>
  

      
        <time datetime="2022-01-21T10:03:16.136Z">2022-01-21</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:<br><br><em>   Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br>Implement the NumMatrix class:

</em>   <code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.<br><em>   <code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt=""><br><br><pre><strong>Input</strong><br>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<br><strong>Output</strong><br>[null, 8, 11, 12]<br><br><strong>Explanation</strong><br>NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == matrix.length</code><br><em>   <code>n == matrix[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= row1 &lt;= row2 &lt; m</code><br><em>   <code>0 &lt;= col1 &lt;= col2 &lt; n</code>
</em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>sumRegion</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子矩阵和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>计算presum公式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j] - dp[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>计算子矩阵公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp有左上边界，计算子矩阵注意dp和输入差1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp[<span class="number">0</span>])):</span><br><span class="line">                self.dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + self.dp[i - <span class="number">1</span>][j] + self.dp[i][j - <span class="number">1</span>] - self.dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(nm)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/01/20/leetcode-721-accounts-mergesolution/">LeetCode 721 Accounts Merge</a></h1>
  

      
        <time datetime="2022-01-21T03:34:29.553Z">2022-01-20</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> accounts = [[“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],[“John”,”johnsmith@mail.com”,”john00@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Output:</strong> [[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Explanation:</strong><br>The first and second John’s are the same person as they have the common email “johnsmith@mail.com”.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’],<br>[‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> accounts = [[“Gabe”,”Gabe0@m.co”,”Gabe3@m.co”,”Gabe1@m.co”],[“Kevin”,”Kevin3@m.co”,”Kevin5@m.co”,”Kevin0@m.co”],[“Ethan”,”Ethan5@m.co”,”Ethan4@m.co”,”Ethan0@m.co”],[“Hanzo”,”Hanzo3@m.co”,”Hanzo1@m.co”,”Hanzo0@m.co”],[“Fern”,”Fern5@m.co”,”Fern1@m.co”,”Fern0@m.co”]]<br><strong>Output:</strong> [[“Ethan”,”Ethan0@m.co”,”Ethan4@m.co”,”Ethan5@m.co”],[“Gabe”,”Gabe0@m.co”,”Gabe1@m.co”,”Gabe3@m.co”],[“Hanzo”,”Hanzo0@m.co”,”Hanzo1@m.co”,”Hanzo3@m.co”],[“Kevin”,”Kevin0@m.co”,”Kevin3@m.co”,”Kevin5@m.co”],[“Fern”,”Fern0@m.co”,”Fern1@m.co”,”Fern5@m.co”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= accounts.length &lt;= 1000</code>
</em>   <code>2 &lt;= accounts[i].length &lt;= 10</code><br><em>   <code>1 &lt;= accounts[i][j] &lt;= 30</code>
</em>   <code>accounts[i][0]</code> consists of English letters.<br>*   <code>accounts[i][j] (for j &gt; 0)</code> is a valid email.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li>
<li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li>
<li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		li[:] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	name_dict = collections.defaultdict(str)</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">			graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">			graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">			graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">	res, visited = [], set()</span><br><span class="line">	<span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">		sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line">		<span class="keyword">if</span> sub_res:</span><br><span class="line">			res.append(sub_res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	res, name = [], <span class="string">''</span></span><br><span class="line">	queue = collections.deque([start])</span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">			name = name_dict[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	res.sort()</span><br><span class="line">	res.insert(<span class="number">0</span>, name)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p>
<hr>
<h3 id="UnionFind算法II解题思路-不推荐-："><a href="#UnionFind算法II解题思路-不推荐-：" class="headerlink" title="UnionFind算法II解题思路(不推荐)："></a><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li>
<li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li>
<li>处理名字</li>
<li>有重复邮件</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/4/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/6/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/">LeetCode 549 Binary Tree Longest Consecutive Sequence II</a>
      </li>
    
      <li>
        <a href="/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/">LeetCode 298 Binary Tree Longest Consecutive Sequence</a>
      </li>
    
      <li>
        <a href="/2022/02/06/leetcode-785-is-graph-bipartite/">LeetCode 785 Is Graph Bipartite?</a>
      </li>
    
      <li>
        <a href="/2022/02/06/leetcode-770-basic-calculator-iv/">LeetCode 770. Basic Calculator IV</a>
      </li>
    
      <li>
        <a href="/2022/01/30/karat-002/">Karat 002 Longest Common Continuous Subarray</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.09px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 13.64px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 16.82px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.64px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.45px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.45px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.73px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.91px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 19.09px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.36px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.36px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 10.45px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.55px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.09px;">Facebook</a> <a href="/tags/Google/" style="font-size: 11.82px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.73px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 12.27px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 16.82px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 13.64px;">Heap</a> <a href="/tags/Interviewer/" style="font-size: 13.18px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.36px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 10.91px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 16.82px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.45px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.73px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.18px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.91px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.36px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.91px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 10px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 16.36px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.91px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.45px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 10.91px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.36px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.45px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.27px;">Stack</a> <a href="/tags/String/" style="font-size: 18.64px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.36px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 15.91px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.36px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.55px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.45px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.45px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

