<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Binary Search</title>
    <url>/2020/04/21/binary-search/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol>
<li>循环条件start + 1 &lt; end。 当跳出循环时，start和end的关系只能是相等或相邻。<br>相等是若数组只有一个元素，没有进入循环时出现。当进入过循环，一定是相邻。</li>
<li>跳出循环后比较start和end的关系从而判断答案。  </li>
</ol>
<p>这可以满足二分法找first position或者last position, peak element的题目。<br>first position中若等于target，end = mid，因为要在左半部分找，相反last<br>position在右半部分找，所以start = mid。</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>有序数组找目标</li>
<li>没给定目标情况下，找峰值， 缺失数(元素间关系)</li>
<li>没给定目标情况下，求第k小的数，如求根号（数值关系）</li>
</ol>
<h2 id="找目标"><a href="#找目标" class="headerlink" title="找目标"></a>找目标</h2><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>判断数组是否为空。    </li>
<li>如果只有唯一的target的话，target==nums[mid]可以并入任何一种。end和target的顺序也没关系。其他注意循环后要根据题目条件(如小于或者大于或者等于tgt)，<br>再比较一次start和end上的元素，详见下表  </li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">if target = nums[mid]</th>
<th style="text-align:left">循环之后</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>binary_search</td>
<td style="text-align:left">任意</td>
<td style="text-align:left">任意</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td>last_position</td>
<td style="text-align:left">向右start = mid</td>
<td style="text-align:left">先end且是否等于tgt</td>
<td style="text-align:left">贪婪法，找最后一个target，所以尽量靠后，先end</td>
</tr>
<tr>
<td>first_position</td>
<td style="text-align:left">向左end = mid</td>
<td style="text-align:left">先start是否等于tgt</td>
<td style="text-align:left">贪婪法，找第一个target，所以尽量靠前，先start</td>
</tr>
<tr>
<td>smaller(_or_equal)_position</td>
<td style="text-align:left">向左end = mid</td>
<td style="text-align:left">先end是否小于tgt</td>
<td style="text-align:left">贪婪法，找最后一个小于target的数，所以尽量靠近target，先end</td>
</tr>
<tr>
<td>greater(_or_equal)_position</td>
<td style="text-align:left">向右start = mid</td>
<td style="text-align:left">先start是否大于tgt</td>
<td style="text-align:left">贪婪法，找第一个大于target的数，所以尽量靠近target，先start</td>
</tr>
</tbody>
</table>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">elif</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:  <span class="comment"># Depends on the target on the right side or left side. For fist pos, use end = mid</span></span><br><span class="line">			start = mid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">elif</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">elif</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Python代码：-3"><a href="#Python代码：-3" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><p>如果是smaller_or_equal_position，Line 13和15取等号<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smaller_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> nums[end] &lt; target:  <span class="comment"># nums[end] &lt;= target for smaller_or_equal_position</span></span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">if</span> nums[start] &lt; target:  <span class="comment"># nums[start] &lt; target for smaller_or_equal_position</span></span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Python代码：-4"><a href="#Python代码：-4" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><p>如果是greater_or_equal_position，Line 13和15取等号<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greater_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">if</span> nums[start] &gt; target:  <span class="comment"># nums[start] &gt;= target for greater_or_equal_position</span></span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">if</span> nums[end] &gt; target:  <span class="comment"># nums[end] &gt;= target for greater_or_equal_position</span></span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="找峰值"><a href="#找峰值" class="headerlink" title="找峰值"></a>找峰值</h2><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>判断mid+1的元素不越界  </li>
<li>最后返回start和end之中较大者    </li>
</ol>
<h3 id="Python代码：-5"><a href="#Python代码：-5" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_peak</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mid + <span class="number">1</span> &lt;= end <span class="keyword">and</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">return</span> start <span class="keyword">if</span> nums[start] &gt; nums[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>
<h2 id="找第k小的数"><a href="#找第k小的数" class="headerlink" title="找第k小的数"></a>找第k小的数</h2><h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数值比较，所以mid是除2获得不是//2。start，end，mid都是数值而不是索引    </li>
<li>k是从0开始，count==k的时候，k在mid的右边，如数组1-10, k=3, mid=3.5, count=3，k是前4个数，所以在mid右边。nums[i] &lt;= mid这个等号有没有也没关系，因为mid是小数，不会相等的。   </li>
<li>最后start，end区间内是一个整数正是所求，所以返回end向下取整</li>
</ol>
<h3 id="Python代码：-6"><a href="#Python代码：-6" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_select</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line">		<span class="keyword">if</span> k &lt; count:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> k &gt; count:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start =  mid</span><br><span class="line">	<span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure>
<p>若nums有序，<strong>count的统计可以用bisect(nums, mid)完成</strong>，记得不需要用+1，而且空数组也无问题<br>上面line 8可以改成<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = bisect.bisect(matrix[i], mid)</span><br></pre></td></tr></table></figure></p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlog(|hi-lo|/delta))</code>，如果数据比较平均也就是差值相当的情况下(比如1,2,3)，复杂度为O(nlogn). 空间复杂度<code>O(1)</code>。<br>若不需要搜索全数组，前面的n会变成logn  </p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">			start = mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">		<span class="comment">// Depends on the target on the right side or left side. For fist pos, use end = mid</span></span><br><span class="line">			start = mid; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			end = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(nums[end] == target)</span><br><span class="line">		<span class="keyword">return</span> end;</span><br><span class="line">	<span class="keyword">if</span>(nums[start] == target)</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS</title>
    <url>/2017/12/03/bfs/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>图用邻接表为输入，思路用Queue实现, 还要一个机制记录节点访问过没有，可以用HashSet，同时它作为结果存储BFS访问结果。<br><strong>BFS多用于找最短路径</strong><br><strong>DFS多用于快速发现底部节点和具体路劲问题（如路径和或打印路径）。</strong></p>
<p>BFS优缺点：<br>同一层的所有节点都会加入队列，所以耗用大量空间<br>仅能非递归实现<br>相比DFS较快，空间换时间<br>适合广度大的图<br>找环的话需要用拓扑排序</p>
<p>DFS优缺点：<br>无论是系统栈还是用户栈保存的节点数都只是树的深度，所以空间耗用小<br>有递归和非递归实现<br>由于有大量栈操作（特别是递归实现时候的系统调用），执行速度较BFS慢<br>适合深度大的图<br>找环的话比较容易实现</p>
<p><strong>如果BFS和DFS都可以用，建议用BFS</strong>，因为工业应用中，BFS不用有限的栈空间，可以利用到所有内存。<br><strong>BFS题目问自己是否需要按层遍历，是否需要visited</strong></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>坐标型BFS，注意输入为(i, j)时候，x = node[0] + _dx[0], <strong>用x不要用输入的i</strong>  </li>
<li>deque([(start[0], start[1])]), set([(startx, starty)])</li>
<li>board[x][y] == ‘+’ 注意矩阵的其他不能遍历的元素，如L200中的0</li>
</ol>
<p>其他:</p>
<ol>
<li>只要把节点放入队列立即标记其为访问，不要在出列的时候才标记。否则同一个节点会入列多次。<br>比如下图, 入列顺序为1,2,3,4,4。4入列了两次。</li>
<li>矩阵的遍历用方向List: OFFSETS = [(1, 0), (-1, 0), (0, 1), (0, -1)]</li>
</ol>
<h2 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h2><p>只有是对所有节点BFS题型才需要将visited作为参数传入  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start)</span> -&gt; List[int]:</span></span><br><span class="line">	queue, res = deque([start]), []</span><br><span class="line">	visited = set([start])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>树模板只要把visited去掉，neighbor改成left和right  </p>
<h2 id="计算最短距离的图遍历-最常考的模板"><a href="#计算最短距离的图遍历-最常考的模板" class="headerlink" title="计算最短距离的图遍历(最常考的模板)"></a>计算最短距离的图遍历(最常考的模板)</h2><ul>
<li>只要加line 4和14</li>
<li>visited在函数内定义  </li>
<li>遇到target就返回最短距离，若离开循环返回-1，<strong>问清楚是否存在路径不存在的情况</strong></li>
<li>求距离公式不需要用min，因为这个遍历保证了最短距离了。    </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_layer</span><span class="params">(self, graph, start)</span> -&gt; List[int]:</span></span><br><span class="line">	queue = deque([start])</span><br><span class="line">	visited = set([start])</span><br><span class="line">	distance = &#123;start: <span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == target:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance[neighbor] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="按层遍历"><a href="#按层遍历" class="headerlink" title="按层遍历"></a>按层遍历</h2><p>核心是加这一行for _ in range(len(queue))<br>具体还要加line 5, 6和14, 15. 二叉树不需要visited。能用distance dict就尽量不用此法，因为多了一个循环。  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>关键行： 多这一行for循环 </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_layer2</span><span class="params">(self, graph, visited, start)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	queue, res, layer = deque([start]), [], <span class="number">0</span></span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">				<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">				visited.add(neighbor)</span><br><span class="line">		layer += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * visited: 记录已访问节点，避免重复访问</span></span><br><span class="line"><span class="comment"> * start: BFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(start);</span><br><span class="line">	visited.add(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.poll();</span><br><span class="line">		LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited.contains(child))&#123;</span><br><span class="line">				q.offer(child);</span><br><span class="line">				visited.add(child);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误算法："><a href="#错误算法：" class="headerlink" title="错误算法："></a><strong>错误算法：</strong></h3><p>问题是加入到queue里面的child没有去重，这样容易queue爆炸式增长。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.poll();</span><br><span class="line">		visited.add(node);</span><br><span class="line">		LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited.contains(child))</span><br><span class="line">				q.offer(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按层次遍历："><a href="#按层次遍历：" class="headerlink" title="按层次遍历："></a><strong>按层次遍历：</strong></h3><p>第一个思路是三重循环，先queue，然后该层所有节点，最后该层每一个节点的儿子。关键在于size = q.size();</p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer3</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">	q.offer(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> size = q.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">// loop this layer</span></span><br><span class="line">			<span class="keyword">int</span> node = q.poll();</span><br><span class="line">			System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ layer);</span><br><span class="line">			LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;<span class="comment">// loop its children</span></span><br><span class="line">				q.add(child);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		layer++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码三重循环看似可读性不够好，所有可以用hashMap来记录每个点的距离从而减少第二重循环。<br>nodeToHeight.put(start, 1);<br>nodeToHeight.put(child, nodeToHeight.get(node) + 1);  </p>
<h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer4</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(start);</span><br><span class="line">	Map&lt;Integer, Integer&gt; nodeToHeight = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	nodeToHeight.put(start, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> node = q.poll();</span><br><span class="line">		System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ nodeToHeight.get(node));</span><br><span class="line">		LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;<span class="comment">// loop its children</span></span><br><span class="line">			q.add(child);</span><br><span class="line">			nodeToHeight.put(child, nodeToHeight.get(node) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/bfs.png" alt=""></p>
<ol>
<li>q.isEmpty() &amp;&amp; !q2.isEmpty()</li>
</ol>
<p>第三思路是用两个队列来实现：用第一个队列存储该层的节点，第二个队列存储第一个队列中节点的儿子节点，<br>也就是下一次的节点。此思路比较容易实现。</p>
<h3 id="Java代码：-3"><a href="#Java代码：-3" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 假设不循环</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * start: BFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	Queue&lt;Integer&gt; q2=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">	q.offer(start);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.poll();</span><br><span class="line">		System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ layer);</span><br><span class="line">		LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">			q2.offer(child);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(q.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">			q = q2;</span><br><span class="line">			q2 = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">			layer++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四思路是只用一个队列来实现：层与层之间用结束符间隔，每遇到结束符，表示该层访问结束，下一层的节点也准备好<br>（不会再有新的节点加入到这一层），此时再往队列加入新的结束符。此思路对数据有一定限制，实现起来注意事项较多。</p>
<h3 id="Java代码：-4"><a href="#Java代码：-4" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer2</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">	q.offer(start);</span><br><span class="line">	q.offer(-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> node = q.poll();</span><br><span class="line">		<span class="keyword">if</span>(node == -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//确保有非结束符节点</span></span><br><span class="line">			<span class="keyword">if</span>(q.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				q.offer(-<span class="number">1</span>);</span><br><span class="line">				layer++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ layer);</span><br><span class="line">		LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">			q.offer(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>BST的非递归中序，前序，后序遍历</title>
    <url>/2020/04/26/bst-iterative/</url>
    <content><![CDATA[<h3 id="中序遍历算法思路："><a href="#中序遍历算法思路：" class="headerlink" title="中序遍历算法思路："></a><strong>中序遍历算法思路：</strong></h3><p><img src="/images/bst-iterative.png" alt=""><br>如图所示，总体思路是左节点按层次遍历，而区别在于何时加入到结果集。 </p>
<ol>
<li>首先初始化将root的所有左儿子加入到stack。</li>
<li>开始循环，取出节点，判断其右儿子不为空，因为左儿子已经访问过。  </li>
<li>若右子树不为空，跟初始化一样，将右子树的所有左儿子加入到栈中。  </li>
<li>用到两个指针node和n，分别指向出栈节点和遍历所有左儿子节点。  </li>
</ol>
<p>若前序遍历，只要把打印语句从出栈时打印移到入栈时打印即可。见L144</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>BST的关于Iterator的题目<a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">Leetcode 173</a></li>
<li>不需要遍历所有节点而需要遍历某些节点的题目如求某target最接近N个节点。<a href="https://shineboy2013.github.io/2020/04/26/lee-272/" target="_blank" rel="noopener">Leetcode 272</a></li>
</ol>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">Leetcode 094 Binary Tree Inorder Traversal</a>  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterative_inorder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res, stack = [], []</span><br><span class="line">	it = root</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		stack.append(it)</span><br><span class="line">		it = it.left</span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		node = stack.pop()</span><br><span class="line">		res.append(node.val)</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			n = node.right</span><br><span class="line">			<span class="keyword">while</span> n:</span><br><span class="line">				stack.append(n)</span><br><span class="line">				n = n.left</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">Leetcode 144 Binary Tree Preorder Traversal</a><br>只要将出栈节点加入结果换到入栈前加即可，也就是将Line 11换到取Line 7和Line 15   </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterative_preorder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res, stack = [], []</span><br><span class="line">	it = root</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		stack.append(it)</span><br><span class="line">		res.append(it.val)</span><br><span class="line">		it = it.left</span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		node = stack.pop()</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			n = node.right</span><br><span class="line">			<span class="keyword">while</span> n:</span><br><span class="line">				stack.append(n)</span><br><span class="line">				res.append(n.val)</span><br><span class="line">				n = n.left</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">Leetcode 145 Binary Tree Postorder Traversal</a><br>跟中序比，需要用一个记数器来记录出现在栈顶的次数，若为2次就加入到结果集，并且不能继续迭代到右节点，因为第一次时候已做了。<br>由于tuple不可改，所以即使次数为1，也要出栈，更新次数后重新入栈。代码区别在Line 10 - 17.   </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>记得要continue。 </li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterative_postorder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res, stack = [], []</span><br><span class="line">	it = root</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		stack.append((it, <span class="number">0</span>))  <span class="comment"># count for it in the stack top</span></span><br><span class="line">		it = it.left</span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		pair = stack.pop()</span><br><span class="line">		node = pair[<span class="number">0</span>]</span><br><span class="line">		occurrence = pair[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> occurrence == <span class="number">2</span>:</span><br><span class="line">			res.append(node.val)</span><br><span class="line">			<span class="keyword">continue</span>  <span class="comment"># don't iterate on right node again</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append((node, occurrence))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			n = node.right</span><br><span class="line">			<span class="keyword">while</span> n:</span><br><span class="line">				stack.append((n, <span class="number">0</span>))</span><br><span class="line">				n = n.left</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">iterativeInorder</span><span class="params">(BinaryNode p)</span> </span>&#123;  </span><br><span class="line">	Stack&lt;BinaryNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryNode&gt;();  </span><br><span class="line">	BinaryNode head = p;</span><br><span class="line">	<span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">		stack.push(head);</span><br><span class="line">		head = head.left;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	BinaryNode node = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">		node = stack.pop();</span><br><span class="line">		System.out.print(node.data);</span><br><span class="line">		<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			BinaryNode n = node.right; </span><br><span class="line">			<span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">				stack.push(n);</span><br><span class="line">				n = n.left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>，最差为<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2020/05/03/combination/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 078的题目。这里作为知识点归纳。  </p>
<ol>
<li>递归中i=st开始。  </li>
<li>回溯： path递归后去恢复状态。  </li>
<li>dfs中传入i+1。  </li>
<li>结果要复制new ArrayList&lt;&gt;(path)  </li>
<li>一般来说，终止条件才加入结果，但由于子集任何path修改都是子集，所有立即加入。  </li>
</ol>
<p>和全排列的区别：  </p>
<ol>
<li>由于排列可以乱序如[1,2,3]结果是[1,3,2]也就是一个结果需要多次从左向右完全扫描，所以i=0开始且维护visited数组<br>组合的结果是按照数组顺序的，所以只要从左到右扫描一次即可，所以用i=st。  </li>
<li>结果方面，排列结果是满长度，而组合不是。所以在加入到res位置上，组合用st来判断是否结束且加入到path就立刻进入最后<br>结果，而排列是在终结条件上加入。  </li>
</ol>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>找所有可能性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> [[]]</span><br><span class="line">	path, result = [], []</span><br><span class="line">	self.dfs(nums, <span class="number">0</span>, path, result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, result)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(nums):</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		result.append(list(path))</span><br><span class="line">		self.dfs(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); <span class="comment">//empty set</span></span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	dfs(nums, <span class="number">0</span>, path, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> st, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st == nums.length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = st; i &lt; nums.length; i++) &#123;</span><br><span class="line">		path.add(nums[i]);</span><br><span class="line">		res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">		dfs(nums, i + <span class="number">1</span>, path, res);</span><br><span class="line">		path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>2</em><sup>n</sup>)</code> ，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Design Chime</title>
    <url>/2018/05/01/design-chime/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Design a chatting application like Chime  </p>
<h3 id="了解用户需求："><a href="#了解用户需求：" class="headerlink" title="了解用户需求："></a><strong>了解用户需求：</strong></h3><p>通过不断和面试官沟通，了解用户角度的需求。把这些需求逐一列举在白板上。面试者一开始会刻意只说出1-2点。面试者通过联系实际，不够构想<br>一些需求，若得到确认就要写入。</p>
<ol>
<li>用户可以单对单相互聊天(one-on-one chat)</li>
<li>用户可以群聊(group chat)</li>
<li>用户可登陆</li>
<li>用户可以添加好友(sending)，接受好友(accepting)，拒绝添加(rejecting). 好友相互添加(mutual)，不支持两人分别添加。</li>
<li>用户更新状态为offline, available, busy, don’t disturb，还有个性化签名</li>
</ol>
<p>面试者通过重新排序user life cycle更有助于理解和记忆</p>
<ol>
<li>用户可登陆</li>
<li>用户可以添加好友(sending)，接受好友(accepting)，拒绝添加(rejecting)</li>
<li>用户可以单对单相互聊天(one-on-one chat)</li>
<li>用户可以群聊(group chat)</li>
<li>用户更新状态为offline, available, busy, don’t disturb，还有个性化签名</li>
</ol>
<p>本面试不支持以下use cases<br>音频会议，视频会议，文件传输</p>
<h3 id="Block-Component-diagram："><a href="#Block-Component-diagram：" class="headerlink" title="Block/Component diagram："></a><strong>Block/Component diagram：</strong></h3><p>最简单的设计就是一系列的clients，一系列的servers，还有存储系统。<br><img src="/images/chime.png" alt=""><br>存储系统可以选择SQL或者No SQL。No SQL就会更加scalable.这里可以讨论它们之间的pros和cons。<br>传输协议(client-server)可用Java中的Socket和ServerSocket对象，它们建立一个TCP连接，用IO Stream传输。<br>服务器端用多个服务器避免single point of failure。server端的memory会存一些用户状态等数据（当然它也会被持久化），这表示它需要<br>    replicate一些数据减少不同机器之间的lookup时间。</p>
<p>这些大概讨论一下即可，本design主要针对OOD。</p>
<h3 id="Class-diagram："><a href="#Class-diagram：" class="headerlink" title="Class diagram："></a><strong>Class diagram：</strong></h3><p>从User开始写fields和key methods，因为需求就是针对用户，比较直观。当参数含有多个属性时，就应该考虑产生一个新的class，如Message，<br>因为Message不只内容String还有发送时间甚至styling等。 还有注意每个类是否存在状态(如UserStatus)，如果有，就要考虑用enum。</p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   String fullName;</span><br><span class="line">   String alias;</span><br><span class="line">   List&lt;User&gt; friends;</span><br><span class="line">   List&lt;GroupChat&gt; gChats;</span><br><span class="line">   List&lt;PrivateChat&gt; pChats;</span><br><span class="line">   UserStatus s;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sign</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signout</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">acceptFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rejectFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setUserStatus</span><span class="params">(UserStatus s)</span></span>;</span><br><span class="line">   <span class="function">PrivateChat <span class="title">createConversation</span><span class="params">(User b)</span></span>;</span><br><span class="line">   <span class="function">GroupChat <span class="title">createConversation</span><span class="params">(List&lt;User&gt; c)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(PrivateChat s, String msg)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(GroupChat s, String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">Conversation:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   List&lt;User&gt; users;</span><br><span class="line">   List&lt;Message&gt; messages;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">   </span><br><span class="line">PrivateChat extends Conversation:</span><br><span class="line">   PrivateChat(User user, User user2);</span><br><span class="line"></span><br><span class="line">GroupChat extends Conversation:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User u)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">removeUser</span><span class="params">(User u)</span></span>;</span><br><span class="line">   </span><br><span class="line">Message:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   Date timestamp;</span><br><span class="line">   User user;<span class="comment">//I would like to know who sent this msg</span></span><br><span class="line">   String content;</span><br><span class="line"></span><br><span class="line">FriendRequest:</span><br><span class="line">   User from;</span><br><span class="line">   User to;</span><br><span class="line">   Date timestamp;</span><br><span class="line">   RequestStatus Status;</span><br><span class="line"></span><br><span class="line">UserStatus:</span><br><span class="line">   String message;</span><br><span class="line">   UserStatusType type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RequestStatus:</span><br><span class="line">   ACCEPTED, REJECTED, PENDING</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> UserStatusType:</span><br><span class="line">   offline, available, busy, DONT_disturb</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个类最为复杂，主要是维护用户关系和用户状态以及对应的数据库读写。这里有几个隐形需求。。可以根据alias搜索用户，  </span></span><br><span class="line"><span class="comment">//如果用户offline，即使是好友也不能发信息。它是singleton。</span></span><br><span class="line">UserManager:</span><br><span class="line">   HashMap&lt;String, User&gt; usersByAlias;</span><br><span class="line">   <span class="comment">//User类需要含有UserManager，查看要发送信息的对象是否在线，若不在线，不能发出信息。</span></span><br><span class="line">   HashMap&lt;Integer, User&gt; onlineUsers;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (instance==<span class="keyword">null</span>) instance = <span class="keyword">new</span> UserManager();</span><br><span class="line">	   <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//用observer模式，User调用UserManager这个接口来更新onlineUsers</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signInUser</span><span class="params">(String alias)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signOutUser</span><span class="params">(String alias)</span></span>;</span><br><span class="line">   <span class="comment">//User to的acceptFriend会调用这个函数来更新User a和User b的friend list同时更新FriendRequest的状态。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">approveRequest</span><span class="params">(FriendRequest f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体实现可以选择approveRequest或者某用户发信息怎么令group chat的其他用户收到该信息sendMessage(GroupChat s, String msg)。</p>
<p>void sendMessage(GroupChat s, String msg){<br>    List<user> users = s.getUsers();<br>}</user></p>
<h3 id="扩展问题："><a href="#扩展问题：" class="headerlink" title="扩展问题："></a><strong>扩展问题：</strong></h3><ol>
<li>怎么知道某用户真的在线</li>
<li>怎么处理内存和数据冲突的信息</li>
<li>怎么让server scale</li>
<li>怎么防止DDOS攻击</li>
</ol>
]]></content>
      <tags>
        <tag>Design</tag>
        <tag>Object Oriented Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Design Distributed ID Generator</title>
    <url>/2018/06/17/design-distributed-id/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>生成唯一ID如用户ID，订单ID。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>基本思路是将所有网站映射到一个整数。<br>三大核心需求：</p>
<ol>
<li>全局唯一(unique)</li>
<li>按照时间粗略有序(sortable by time)。按时间查询是普遍的请求，如得到最新的1000个用户。</li>
<li>尽可能短。省空间，查询要更有效率。</li>
</ol>
<h3 id="UUID："><a href="#UUID：" class="headerlink" title="UUID："></a><strong>UUID：</strong></h3><p>UUID是一类算法的统称，具体有不同的实现。UUID的有点是每台机器可以独立产生ID，理论上保证<br>不会重复，所以天然是分布式的，缺点是生成的ID太长，不仅占用内存，而且索引查询效率低。<br>4个字节表示的Unix timestamp,<br>3个字节表示的机器的ID<br>2个字节表示的进程ID<br>3个字节表示的计数器</p>
<h3 id="多机器分别自增："><a href="#多机器分别自增：" class="headerlink" title="多机器分别自增："></a><strong>多机器分别自增：</strong></h3><p>假设用8台MySQL服务器协同工作，第一台MySQL初始值是1，每次自增8，第二台MySQL初始值是2，<br>每次自增8，依次类推。前面用一个 round-robin load balancer 挡着，每来一个请求，由<br>round-robin balancer 随机地将请求发给8台MySQL中的任意一个，然后返回一个ID。<br>load balance可以确保请求平均分配到不同的机器，所以粗略有序，缺点是加机器要re-hash这些Id<br>且顺序不够稳定。</p>
<h3 id="Twitter-Snowflake："><a href="#Twitter-Snowflake：" class="headerlink" title="Twitter Snowflake："></a><strong>Twitter Snowflake：</strong></h3><p>原理与UUID基本一样。也是时间戳+机器id+自增序号。时间戳保证有序。<br><img src="/images/design-distributed-id.png" alt="">  </p>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS</title>
    <url>/2017/12/24/dfs/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>图用邻接表为输入，思路递归实现, 还要一个机制记录节点访问过没有，可以用HashSet，同时它作为结果存储BFS访问结果。<br><strong>BFS多用于找最短路径</strong><br><strong>DFS多用于快速发现底部节点和具体路劲问题（如路径和或打印路径）。</strong></p>
<p>BFS优缺点：<br>同一层的所有节点都会加入队列，所以耗用大量空间<br>仅能非递归实现<br>相比DFS较快，空间换时间<br>适合广度大的图</p>
<p>DFS优缺点：<br>无论是系统栈还是用户栈保存的节点数都只是树的深度，所以空间耗用小<br>有递归和非递归实现<br>由于有大量栈操作（特别是递归实现时候的系统调用），执行速度较BFS慢<br>适合深度大的图</p>
<p>如果BFS和DFS都可以用，建议用BFS，因为工业应用中，BFS不用有限的栈空间，可以利用到所有内存。  </p>
<h2 id="图DFS"><a href="#图DFS" class="headerlink" title="图DFS"></a>图DFS</h2><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol>
<li>不合法情况（已访问、越界、trivial情况等）返回。</li>
<li>标记为已访问。</li>
<li>递归访问相邻节点。</li>
<li>DFS路径尽量记录在数组中而非ArrayList中，路径(图)再DFS后要恢复为原状态L332。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, start, visited, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	visited.add(start)</span><br><span class="line">	res.append(start)</span><br><span class="line">	<span class="keyword">for</span> node <span class="keyword">in</span> graph[start]:</span><br><span class="line">		self.dfs(graph, visited, node, res)</span><br></pre></td></tr></table></figure>
<h2 id="字符型DFS"><a href="#字符型DFS" class="headerlink" title="字符型DFS"></a>字符型DFS</h2><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>输入值为空的情况或空节点 </li>
<li>求得解以后复制path到result中</li>
<li>终止条件记得return</li>
<li>每次递归完恢复输入图或中间结果path的状态，<strong>递归式用i + 1</strong></li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, input, start, endIndex, path, result)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> start == endIndex: </span><br><span class="line">        result.append(list(path))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &lt;func&gt;(input[start]): </span><br><span class="line">        self.dfs(input, i + <span class="number">1</span>, endIndex , path + input[i], result)</span><br></pre></td></tr></table></figure>
<h2 id="填位法"><a href="#填位法" class="headerlink" title="填位法"></a>填位法</h2><p>类似于排列(visited)，组合模板(带start)，组合模板是的下一轮递归用i + 1, 但这里由于是填位，一位一位加入，所以是start + 1</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, start, path, res, col_set)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start == n: <span class="comment"># remember not len(path)</span></span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(start, i, col_set):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(i) </span><br><span class="line">		col_set.add(i)</span><br><span class="line">		self.dfs(n, start + <span class="number">1</span>, path, res, col_set)</span><br><span class="line">		col_set.remove(i)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h2 id="Catalan法-双边递归"><a href="#Catalan法-双边递归" class="headerlink" title="Catalan法(双边递归)"></a>Catalan法(双边递归)</h2><p>DFS中几乎是最难的类型。考得很少。主要思想是左右儿子递归结果叉乘，再将所有结果返回。所以返回值一定是list</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>返回结果是解的集合，所以<strong>终止条件返回也需要是一个list</strong></li>
<li>循环中除掉自己，递归左部分和右半部分，叉乘它们的结果</li>
<li>与记忆性搜索的模板类似，有时需要和它一起用，见LeetCode 241 Different Ways to Add Parentheses</li>
</ol>
<h3 id="Python代码：-3"><a href="#Python代码：-3" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, input)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> &lt;终止条件&gt;:</span><br><span class="line">		<span class="keyword">return</span> [] <span class="comment"># remember to use list</span></span><br><span class="line">	res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input)):</span><br><span class="line">        left_res = self.dfs(input[:i])</span><br><span class="line">        right_res = self.dfs(input[i + <span class="number">1</span>:])</span><br><span class="line">        res += [&lt;calculate results&gt; <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code>  </p>
<h3 id="应用题型："><a href="#应用题型：" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2022/01/18/leetcode-095-unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode 095 Unique Binary Search Trees II</a><br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-241-different-ways-to-add-parentheses/" target="_blank" rel="noopener">LeetCode 241 Different Ways to Add Parentheses</a> </p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * visited: 记录已访问节点，避免重复访问</span></span><br><span class="line"><span class="comment"> * start: DFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(visited.contains(start))&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	visited.add(start);</span><br><span class="line">	System.out.print(start+<span class="string">","</span>);</span><br><span class="line">	<span class="keyword">for</span>(Integer child : graph.get(start))&#123;</span><br><span class="line">		dfs(graph, visited, child);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，h为树的高度，空间复杂度<code>O(h)</code>，如果用系统栈，可理解其为O(1)。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Design Tiny URL</title>
    <url>/2018/04/30/design-tiny-url/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>长URL变成短URL方便传输和阅读，特别是很多社交网站对字数有限制如Twitter。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol>
<li>沟通清楚需要，用户数（都会很大）</li>
<li>数据量估计。如火车售票系统，估计西雅图总人口，高峰乘坐人数。</li>
<li>先完成一个功能。如buy ticket。画图，每个部件high level细节包括数据库的schema和组件间的API接口。</li>
<li>自觉加上优化，如cache，master-slave数据库,LB等等。不要等面试官提醒</li>
<li>完成一个功能后，再画图扩展到其他功能。 </li>
</ol>
<h3 id="短网址长度："><a href="#短网址长度：" class="headerlink" title="短网址长度："></a><strong>短网址长度：</strong></h3><p>短网址若只含数字，也就是十进制整数还是不够短。可以考虑加入大小写字母，总共有26x2+10=62，也就是一个62进制数。<br>网站总数是45亿个，62^7就远远大于45亿，7位就够。<br>若long表示的64位整数，log62(2^64-1)=11，大约是对应11位。  </p>
<table>
<thead>
<tr>
<th>网站</th>
<th style="text-align:left">十进制</th>
<th style="text-align:left">62进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>amazon.com</td>
<td style="text-align:left">0854</td>
<td style="text-align:left">a5G</td>
</tr>
</tbody>
</table>
<h3 id="存储方法："><a href="#存储方法：" class="headerlink" title="存储方法："></a><strong>存储方法：</strong></h3><p>写操作：长网址到短网址<br>读操作：短网址到长网址<br>读操作远远大于写操作，所以key（或primary key）选在短网址， value在长网址。<br>每个新的长网址，对应一个短网址还是多个？考虑一下几点：</p>
<ol>
<li>若对应一个短网址，必须再产生一个unique key在长网址上来决定该长网址对应的短网址是否存在。大大降低写操作速度。  </li>
<li>长网址虽然一样，但可以带不同的header, user agent，从而知道进入该长网址的入口（其他网站），短网址商的盈利来源。<br>所以长网址对应多个短网址，Google Maps就采取这个设计。    </li>
</ol>
<table>
<thead>
<tr>
<th>网站</th>
<th style="text-align:left">十进制</th>
<th style="text-align:left">62进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>amazon.com</td>
<td style="text-align:left">0854</td>
<td style="text-align:left">a5G</td>
</tr>
<tr>
<td>amazon.com</td>
<td style="text-align:left">17922</td>
<td style="text-align:left">bYd</td>
</tr>
</tbody>
</table>
<p>数据库选择可以是关系型数据库SQL Server，或者KV数据库如Redis，dynamoDB。可以详细讨论关系型数据库与No SQL的区别。<br>此题目用No sql比较好，因为从分布性考虑和是否需要复杂的Join操作来考虑，No sql有明显优势。</p>
<h3 id="计算短网址："><a href="#计算短网址：" class="headerlink" title="计算短网址："></a><strong>计算短网址：</strong></h3><p>另一个核心问题就是如何计算短网址，具体而言是怎么从URL转化为一个十进制整数。有几个方案：  </p>
<ol>
<li>最简单的是维护一个最大值，每个新的请求，对此值加1。缺点是分布式系统中，维护单一最大值（所有机器中）大大降低性能。</li>
<li>取URL的hash值得到64位整数再取前7位，但会有冲突。</li>
<li><a href="https://shineboy2013.github.io/2018/06/17/design-distributed-id/" target="_blank" rel="noopener">参考分布式发号器</a>  </li>
</ol>
<p>十进制到62进制用短除法来做，<br><img src="/images/design-tiny-url.png" alt=""><br>796%62=52， (796-52)/62=12.<br>12%62=12, (12-12)/62=0.<br>结果为(12)(52) = cP</p>
<h3 id="DDOS："><a href="#DDOS：" class="headerlink" title="DDOS："></a><strong>DDOS：</strong></h3><p>这是一个细节考虑，若黑客大量发请求，耗尽所有ID怎么办？</p>
<ol>
<li>限制IP单日请求总数，超过直接拒绝。</li>
<li>限制长网址的单一性。限制IP还不够，因为用proxy provider服务可以绕过这个限制。用Redis来cache长网址到短网址的一日数据，<br>然后LRU淘汰旧的数据。这样如果此URL的请求超过一定数量，比如100次，就返回最新的短网址。<br>长网址-&gt;次数+短URL</li>
</ol>
<h3 id="301还是302："><a href="#301还是302：" class="headerlink" title="301还是302："></a><strong>301还是302：</strong></h3><p>301是永久重定向，302是临时重定向。如果用了301， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计<br>到短地址被点击的次数了，也无法收集用户的Cookie, User Agent等信息。这是短网址商的盈利来源。  </p>
<h3 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a><strong>Ref：</strong></h3><p><a href="https://soulmachine.gitbooks.io/system-design/content/cn/tinyurl.html" target="_blank" rel="noopener">https://soulmachine.gitbooks.io/system-design/content/cn/tinyurl.html</a><br><a href="https://segmentfault.com/a/1190000006140476" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006140476</a>  </p>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Heap</title>
    <url>/2021/11/14/heap/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最小堆可以维持堆顶元素为最小值。    </p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>求数组第k个大的数  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapreplace, heappush</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_heap</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &lt; k:</span><br><span class="line">			heappush(res, nums[i])</span><br><span class="line">		<span class="keyword">elif</span> nums[i] &gt; res[<span class="number">0</span>]:</span><br><span class="line">			heapreplace(res, nums[i])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>max heap的话，入堆的数转负数，<strong>跟堆顶比较的大于号不变</strong>，出堆后转为整数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heap</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &lt; k:</span><br><span class="line">			heappush(res, -nums[i])</span><br><span class="line">		<span class="keyword">elif</span> -nums[i] &gt; -res[<span class="number">0</span>]:</span><br><span class="line">			heapreplace(res, -nums[i])</span><br><span class="line">	res = [-n <span class="keyword">for</span> n <span class="keyword">in</span> res]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="BFS-Heap"><a href="#BFS-Heap" class="headerlink" title="BFS + Heap"></a><strong>BFS + Heap</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, nums, start, k)</span> -&gt; List[int]:</span></span><br><span class="line">	heap, res = ([start])), []</span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		node = heapq.heappop(heap)</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">if</span> len(res) == k:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			heap.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/2021/11/27/dp/</url>
    <content><![CDATA[<ul>
<li>典型递归式</li>
<li>单序列或匹配型DP模板</li>
<li>数值到个数DP模板(最常考) </li>
<li>区间型DP模板</li>
<li>压缩空间</li>
<li>打印路径</li>
</ul>
<h2 id="典型递归式："><a href="#典型递归式：" class="headerlink" title="典型递归式："></a>典型递归式：</h2><p>单序列型(与一个或多个前状态有关)<br>硬币个数(数值型)： dp[i] = min(dp[i], dp[i - j] + 1)<br>偷房子： dp[i] = max(dp[i-1], dp[i-2] + nums[i - 1])<br>LIS： dp[i] = max(dp[i], dp[j] + 1)  1 &lt;= j &lt; i<br>Work break： dp[i] |= dp[j] and s[j:i] in word_set, 0 &lt;= j &lt; i    </p>
<p>坐标型DP(与上、左等两个前状态有关)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n][m] = max&#123;1, min(dp[n+1][m], dp[n][m+1]) - dungeon[n][m]&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配型(与上、左、左上等三个前状态有关)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正则： dp[i][j] = dp[i-1][j-1] &amp;&amp; (p[j-1] == . || s[i-1] == p[j-1])</span><br><span class="line">OR ((dp[i-1][j] &amp;&amp; (s[i-1] == p[j-2] || p[j-2] == .)) || dp[i][j-2]) &amp;&amp; p[j-1] == *</span><br></pre></td></tr></table></figure></p>
<p>区间型(与该区间内以k为划分的两个子区间有关)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[i][m] + nums[i]×nums[m]×nums[j] + dp[m][j]&#125;, i &lt; m &lt; j</span><br></pre></td></tr></table></figure></p>
<p>多状态型DP(DP有多个终止状态)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp = dp     if s[i] = &apos;0&apos;</span><br><span class="line">   = dp + 1 if s[i] = &apos;1&apos;</span><br><span class="line">   </span><br><span class="line">dp2 = min(dp2 + 1, dp + 1)     if s[i] = &apos;0&apos;</span><br><span class="line">    = min(dp2, dp)             if s[i] = &apos;1&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>9zhang按照DP四部曲  </p>
<ol>
<li>[初始化]dp数组</li>
<li>[实现]  </li>
<li>[答案]  </li>
<li>[优化]是否可以用滚动内存优化空间</li>
</ol>
<h2 id="单序列或匹配型DP模板"><a href="#单序列或匹配型DP模板" class="headerlink" title="单序列或匹配型DP模板"></a>单序列或匹配型DP模板</h2><h3 id="实现注意事项-5点-："><a href="#实现注意事项-5点-：" class="headerlink" title="实现注意事项(5点)："></a><strong>实现注意事项(5点)：</strong></h3><ol>
<li>[多1][初始化]初始化矩阵，dp是原长度加1。因为令边界计算方便. 遍历从多少开始，<strong>取决于前状态多少个，若递归式含dp[i-1],从1开始，如果dp[i-2]就从2开始</strong>.数值型DP，如硬币个数DP长度是数值amount，不是数组长度。Python用dp = [[0 for _ in range(M)] for _ in range(N)], <strong>M为col数，再row数</strong></li>
<li>[特殊初始值]是第一步的完善，若一维初始化dp<a href="少数情况下初始化dp[1]如L198">0</a>，若为矩阵，初始化dp[0][0]以及上和左边界。求个数dp[0] = 1, 求最值, dp[0] = 0因为递归式含+1</li>
<li>[多1]<strong>跳过初始值，i从1循环到len(dp)而不是len(s)</strong>, 因为用了dp[0]占位。若不用占位法，就要用if语句判断第一位的边界。大部分递归式含i-1项，所以<strong>绝大部分从1开始，从什么开始取决于递归式，这也受第二步的影响</strong></li>
<li>[少1]用到原数组s时候是s[i - 1]而不是s[i], 因为用了dp[0]占位。实现时候<strong>递归式和条件要合法，保证边界内</strong>，如dp[i - t] =&gt; i - t &gt;=0和s[i - 1 - dp[i - 1] - 1]，见最长括号数</li>
<li>[答案]不一定是dp[-1]，如果以某位结束的答案而不是累积结果，<strong>一般就用max_len</strong> </li>
</ol>
<p>累积DP递归公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n] = max(dp[n - 1], f)</span><br></pre></td></tr></table></figure></p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(self, s)</span>:</span></span><br><span class="line">	dp = [<span class="keyword">False</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
<h3 id="应用题型："><a href="#应用题型：" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2020/05/09/lee-139/" target="_blank" rel="noopener">LeetCode 139 Word Break</a><br><a href="https://shineboy2013.github.io/2020/05/10/lee-044/" target="_blank" rel="noopener">LeetCode 044 Wildcard Matching</a><br><a href="https://shineboy2013.github.io/2020/05/10/lee-010/" target="_blank" rel="noopener">LeetCode 010 Regular Expression Matching</a>  </p>
<h2 id="数值到个数DP模板-最常考"><a href="#数值到个数DP模板-最常考" class="headerlink" title="数值到个数DP模板(最常考)"></a>数值到个数DP模板(最常考)</h2><p>求个数DP是比较简单的DP，但也是比较常考的。一般DP是前n个，这里是用<strong>数值</strong>，这点还是有点难的。  </p>
<p>递归公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n + num[i]] = dp[n], n = [1, tgt], i = [0, len(nums) - 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp[i + nums[j]] += dp[i] 而不是dp[i] + 1 </li>
<li>dp[0] = 1表示数值为0，可以不用任何数就能获得，所以是1种     </li>
<li>i从0开始，因为此题递归式用相加i + nums[j]，而不是相减 </li>
<li>nums先排序，否则如[3, 1, 2, 4]，返回dp[1] = 0, 但应该是dp[1] = 1  </li>
<li><strong>上述4点注意事项只有1和2。</strong>数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">	nums.sort() <span class="comment"># remember</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">			<span class="keyword">if</span> i + nums[j] &gt; target:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			dp[i + nums[j]] += dp[i] <span class="comment"># remember no +1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="应用题型：-1"><a href="#应用题型：-1" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2021/12/29/lee-377/" target="_blank" rel="noopener">LeetCode 377 Combination Sum IV</a>  </p>
<hr>
<h3 id="一个变体是求最小个数"><a href="#一个变体是求最小个数" class="headerlink" title="一个变体是求最小个数"></a>一个变体是求最小个数</h3><p>递归公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n + coins[i]] = min&#123;dp[n + coins[i]], dp[n] + 1&#125;, n = [1, tgt], i = [0, len(nums) - 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="不同之处："><a href="#不同之处：" class="headerlink" title="不同之处："></a><strong>不同之处：</strong></h3><ol>
<li>递归式是dp[i] + 1 </li>
<li>dp初始值为最大值，而且dp[0] = 0</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">	coins.sort()</span><br><span class="line">	dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">			<span class="keyword">if</span> i + coins[j] &gt; amount:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			dp[i + coins[j]] = min(dp[i + coins[j]], dp[i] + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] &lt; float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="应用题型：-2"><a href="#应用题型：-2" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2021/12/06/lee-322/" target="_blank" rel="noopener">LeetCode 322 Coin Change</a><br><a href="https://shineboy2013.github.io/2021/12/28/lee-871/" target="_blank" rel="noopener">LeetCode 871 Minimum Number of Refueling Stops</a>  </p>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*target)</code>，空间复杂度<code>O(n)</code>。</p>
<h2 id="区间型DP模板"><a href="#区间型DP模板" class="headerlink" title="区间型DP模板"></a>区间型DP模板</h2><p>k循环从1还是从2开始取决于递归式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	<span class="comment"># init dp array</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - k):</span><br><span class="line">			j = i + k</span><br><span class="line">			<span class="comment"># dp formula</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="应用题型：-3"><a href="#应用题型：-3" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2021/12/05/lee-516/" target="_blank" rel="noopener">LeetCode 516 Longest Palindromic Subsequence</a><br><a href="https://shineboy2013.github.io/2017/12/28/lee-312/" target="_blank" rel="noopener">LeetCode 312 Burst Balloons</a></p>
<h2 id="压缩空间"><a href="#压缩空间" class="headerlink" title="压缩空间"></a>压缩空间</h2><p>若递归式和上一行有关，绝大部分属于此情况，就可以用两行，原数量列来处理</p>
<h3 id="与标准模板不同之处："><a href="#与标准模板不同之处：" class="headerlink" title="与标准模板不同之处："></a><strong>与标准模板不同之处：</strong></h3><ol>
<li>行个数为2</li>
<li>i仍然是遍历到所有行，所以不能用len(dp),而是len(text1) + 1. </li>
<li>dp行不用i，而是i % 2</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(text1) + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i % <span class="number">2</span>][j] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				res = max(res, dp[i % <span class="number">2</span>][j])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="应用题型：-4"><a href="#应用题型：-4" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2022/01/30/karat-002/" target="_blank" rel="noopener">Karat 002 Longest Common Continuous Subarray</a><br><a href="https://shineboy2013.github.io/2022/01/05/lee-063/" target="_blank" rel="noopener">LeetCode 063 Unique Paths II</a></p>
<h2 id="打印路径"><a href="#打印路径" class="headerlink" title="打印路径"></a>打印路径</h2><p>三种类型：  </p>
<ol>
<li>LCA: <a href="https://shineboy2013.github.io/2022/01/30/karat-002/" target="_blank" rel="noopener">Karat 002 Longest Common Continuous Subarray</a>  res = history1[i - dp[i][j]:i]  </li>
<li>LIS:<br><a href="https://shineboy2013.github.io/2021/12/01/lee-300/" target="_blank" rel="noopener">LeetCode 300 Longest Increasing Subsequence</a><br><a href="https://shineboy2013.github.io/2020/05/10/lee-368/" target="_blank" rel="noopener">LeetCode 368 Largest Divisible Subset</a></li>
<li>LCS: <a href="https://shineboy2013.github.io/2022/01/29/leetcode-1143-longest-common-subsequence/" target="_blank" rel="noopener">LeetCode 1143 Longest Common Subsequence</a></li>
</ol>
<p>LIS过程： </p>
<ol>
<li>path跟dp数组一样大，记录回溯跳转j -&gt; i路径path[i - 1] = j - 1</li>
<li>记录回溯开始点if res == dp[i]: biggest_pos = i - 1</li>
<li>循环长度为res, 从biggest_pos开始</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(self, nums, path[:biggest_pos + <span class="number">1</span>], dp_value = res)</span>:</span></span><br><span class="line">	pos, res = len(path) - <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(dp_value):</span><br><span class="line">		res.append(nums[pos])</span><br><span class="line">		pos = path[pos]</span><br><span class="line">	<span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>LCS:  </p>
<ol>
<li>path和dp一样，不用特别数组</li>
<li>从右下到左上，若上或左值一样，向此方向移动，直到左和上少一，此时res -= 1</li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">longest, res = dp[<span class="number">-1</span>][<span class="number">-1</span>], <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> m &gt;= <span class="number">0</span> <span class="keyword">and</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">if</span> dp[m - <span class="number">1</span>][n] == longest:</span><br><span class="line">		m -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">elif</span> dp[m][n - <span class="number">1</span>] == longest:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		res += text1[m - <span class="number">1</span>]</span><br><span class="line">		longest -= <span class="number">1</span></span><br><span class="line">		m -= <span class="number">1</span></span><br><span class="line">		n -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator</title>
    <url>/2022/01/03/iterator/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>hasNext, next都涉及计算下一个元素，大部分题目是先计算再返回。只有BST是先返回再计算，因为BST的下一个节点取决于要返回的节点，若返回了，就无法知道下一个节点。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>hasNext中，while循环找到下一个符合条件的元素</li>
<li>next中取值后<strong>指针要后移</strong>。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">	self.stack = []</span><br><span class="line">	&lt;add to stack&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> self.hasNext():</span><br><span class="line">		<span class="keyword">return</span> self.stack.pop()</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">while</span> &lt;until find the next element&gt;:</span><br><span class="line">	   &lt;calculate&gt;</span><br><span class="line">	<span class="keyword">return</span> &lt;next element&gt;</span><br></pre></td></tr></table></figure>
<h3 id="应用题型："><a href="#应用题型：" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2022/01/03/lee-251/" target="_blank" rel="noopener">LeetCode 251 Flatten 2D Vector</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-281/" target="_blank" rel="noopener">LeetCode 281 Zigzag Iterator</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-341/" target="_blank" rel="noopener">LeetCode 341 Flatten Nested List Iterator</a><br><a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(N + V)/N</code>或<code>O(1)</code>，N为所有数，V为复合结构数 </p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Karat 003 Nonogram</title>
    <url>/2022/02/07/karat-003/</url>
    <content><![CDATA[<p>A nonogram is a logic puzzle, similar to a crossword, in which the player is given<br>a blank grid and has to color it according to some instructions. Specifically,<br>each cell can be either black or white, which we will represent as 0 for black and<br>1 for white.<br>+————+<br>| 1 1 1 1 |<br>| 0 1 1 1 |<br>| 0 1 0 0 |<br>| 1 1 0 1 |<br>| 0 0 1 1 |<br>+————+<br>For each row and column, the instructions give the lengths of contiguous runs of<br>black (0) cells. For example, the instructions for one row of [ 2, 1 ] indicate<br>that there must be a run of two black cells, followed later by another run of one<br>black cell, and the rest of the row filled with white cells.<br>These are valid solutions: [ 1, 0, 0, 1, 0 ] and [ 0, 0, 1, 1, 0 ] and also [ 0,<br>0, 1, 0, 1 ]<br>This is not valid: [ 1, 0, 1, 0, 0 ] since the runs are not in the correct order.<br>This is not valid: [ 1, 0, 0, 0, 1 ] since the two runs of 0s are not separated by<br>1s.<br>Your job is to write a function to validate a possible solution against a set of<br>instructions. Given a 2D matrix representing a player’s solution; and instructions<br>for each row along with additional instructions for each column; return True or<br>False according to whether both sets of instructions match.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Nonogram日本游戏，0表示黑子，[2, 1]表示黑子的连续数目，如棋盘状态[ 1, 0, 0, 1, 0 ]，表示连续黑子数为[2, 1]<br>[ 1, 0, 0, 0, 1 ]连续黑子数为[3]. 验证棋盘的每一行和每一列是否满足rows和cols所指定的连续黑子数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归只有一种情况</li>
<li>答案需求全局</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_nonogram</span><span class="params">(self, matrix, rows, cols)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">		<span class="keyword">if</span> self.get_consecutive_zeros(matrix[i]) != rows[i]:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">		col_vals = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">			col_vals.append(matrix[i][j])</span><br><span class="line">		<span class="keyword">if</span> self.get_consecutive_zeros(col_vals) != cols[j]:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 1, 0, 0, 1, 0 ] -&gt; [2, 1], # of 0s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_consecutive_zeros</span><span class="params">(self, matrix_row)</span>:</span></span><br><span class="line">	count, res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> matrix_row:</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">				res.append(count)</span><br><span class="line">			count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">		res.append(count)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
      </tags>
  </entry>
  <entry>
    <title>Karat 002 Longest Common Continuous Subarray</title>
    <url>/2022/01/30/karat-002/</url>
    <content><![CDATA[<p>[<br>  [“3234.html”, “xys.html”, “7hsaa.html”], // user1<br>  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2<br>]</p>
<p>输出两个user的最长连续且相同的访问记录。</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续最长子数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 1143先求最长公共子字符串。</p>
<p>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p>
<p>不同之处在于： </p>
<ol>
<li>由于是连续，所以递归只有相同的情况，其他情况为0。 </li>
<li>答案不是最后一位，而是全局最值</li>
</ol>
<p>递归式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = 0</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归只有一种情况</li>
<li>答案需求全局</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				res = max(res, dp[i][j])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>优化空间：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(text1) + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i % <span class="number">2</span>][j] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				res = max(res, dp[i % <span class="number">2</span>][j])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>回到原题，输入是列表而不是字符串，但原理一样。还有需要输出公共结果，而不是数字</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuousSubarray</span><span class="params">(self, history1, history2)</span>:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history1) + <span class="number">1</span>)]</span><br><span class="line">	max_len, res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> history1[i - <span class="number">1</span>] == history2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">					max_len = dp[i][j]</span><br><span class="line">					res = history1[i - dp[i][j]:i]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
      </tags>
  </entry>
  <entry>
    <title>Karat 004 Ads Conversion</title>
    <url>/2022/02/12/karat-004/</url>
    <content><![CDATA[<p>A list of user ids + IPs, a list of user ids who have made purchases, a list of advertisement<br>clicks with user IPs.<br>Each user id has at most 1 IP.</p>
<p>Output: for each ad, output the number of clicks and the number of purchases.</p>
<pre>
completed_purchase_user_ids = ["123"]

ad_clicks = [
    #"IP_Address,Time,Ad_Text",
    "127.0.0.1,2011-01-03 09:21:22,black pen"]

all_user_ips = [
    #"User_ID,IP_Address",
        "123,127.0.0.1"]
</pre>

<p>输出:<br>black pen, 1 click, 1 purchase</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定购买记录，click记录，ip地址。求每个产品点击数和购买次数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题比较直观，点击数直接可以从click记录中获得，购买次数就是将三个表格join一起获得</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ad_clicks_purchases</span><span class="params">(self, completed_purchase_user_ids, ad_clicks, all_user_ips)</span>:</span></span><br><span class="line">	<span class="comment"># get clicks</span></span><br><span class="line">	product_to_clicks = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> ad_click <span class="keyword">in</span> ad_clicks:</span><br><span class="line">		parts = ad_click.split(<span class="string">','</span>)</span><br><span class="line">		product_to_clicks[parts[<span class="number">2</span>]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># get purchases</span></span><br><span class="line">	userid_to_ip = collections.defaultdict(str)</span><br><span class="line">	<span class="keyword">for</span> all_user_ip <span class="keyword">in</span> all_user_ips:</span><br><span class="line">		parts = all_user_ip.split(<span class="string">','</span>)</span><br><span class="line">		userid_to_ip[parts[<span class="number">0</span>]] = parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	ip_to_product = collections.defaultdict(str)</span><br><span class="line">	<span class="keyword">for</span> ad_click <span class="keyword">in</span> ad_clicks:</span><br><span class="line">		parts = ad_click.split(<span class="string">','</span>)</span><br><span class="line">		ip_to_product[parts[<span class="number">0</span>]] = parts[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">	product_to_purchase = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> user_id <span class="keyword">in</span> completed_purchase_user_ids:</span><br><span class="line">		ip = userid_to_ip[user_id]</span><br><span class="line">		product = ip_to_product[ip]</span><br><span class="line">		product_to_purchase[product] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> product, click <span class="keyword">in</span> product_to_clicks.items():</span><br><span class="line">		res.append((product, click, product_to_purchase[product]))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m + p)</code>，空间复杂度<code>O(n + m + p)</code>, n, m, p分别每个表的大小  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
      </tags>
  </entry>
  <entry>
    <title>Python知识点</title>
    <url>/2021/06/07/kb-Python/</url>
    <content><![CDATA[<p><strong>常用知识点</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">函数名</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">输入参数</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td style="text-align:left">range</td>
<td style="text-align:left">和len结合使用相当于取某范围List下标,第三个参数为步长</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><strong>for i in range(len(nums))</strong>前闭后开,用逗号</td>
</tr>
<tr>
<td>for</td>
<td style="text-align:left">in</td>
<td style="text-align:left">枚举列表的每个数</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">for n in nums</td>
</tr>
<tr>
<td>for</td>
<td style="text-align:left">range</td>
<td style="text-align:left">逆序遍历</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">for i in range(len(nums) - 1, -1, -1)前闭后开, 或用<strong>reversed(range(len(nums)))</strong></td>
</tr>
<tr>
<td>for</td>
<td style="text-align:left">enumerate</td>
<td style="text-align:left">枚举List的下标和数值，与range不同的是它不能指定范围和步长</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">for i, n in enumerate(nums)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">max/min</td>
<td style="text-align:left">取最大值</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">max_len = max(2, 3) 或min(1, 2, 3)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">pow</td>
<td style="text-align:left">求幂值</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">val = pow(2, 3)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">int</td>
<td style="text-align:left">str转int或将float变成int</td>
<td style="text-align:left">String</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">val = int(‘123’), val = int(2.6) -&gt; 2</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">math.ceil/floor</td>
<td style="text-align:left">求向上或下取整</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">import math, val = math.ceil(5/2), math.floor(5/2)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">float(‘inf’)</td>
<td style="text-align:left">无穷大值</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">val = <strong>float(‘inf’)</strong> or float(‘-inf’)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">min</td>
<td style="text-align:left"><strong>求数组中的正数的最小值</strong></td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">min(n for n in nums if n &gt; 0)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">len</td>
<td style="text-align:left"><strong>求数组中的正数的个数</strong></td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">len([n for n in nums if n &gt; 0])</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">sum</td>
<td style="text-align:left">求数组和</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">sum(nums)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">abs</td>
<td style="text-align:left">求绝对值</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">abs(-1)</td>
</tr>
<tr>
<td>Math</td>
<td style="text-align:left">//与int</td>
<td style="text-align:left">求整数值</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">//是比它小的整数如-2.8就是-3，只在负数是有区别。写程序用的更多是<strong>int(num / a)</strong>结果是-2，这和Java一致</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">str</td>
<td style="text-align:left">任意类型变成字符串</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">String</td>
<td style="text-align:left">str(2)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">replace</td>
<td style="text-align:left">替换</td>
<td style="text-align:left">String</td>
<td style="text-align:left">String</td>
<td style="text-align:left">‘abc’.replace(‘c’, ‘d’)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">format</td>
<td style="text-align:left">格式化字符串</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">String</td>
<td style="text-align:left">‘{} of {}’.format(a, b)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">得到某一个字符</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Char</td>
<td style="text-align:left">s[2]</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">得到子串(前闭后开)</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">string</td>
<td style="text-align:left">s = ‘abc’, s[:2] -&gt; ‘ab’, s[2:] -&gt; ‘c’</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">len</td>
<td style="text-align:left">得到字符串长度</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">int</td>
<td style="text-align:left">num = len(s)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">[::-1]</td>
<td style="text-align:left">反转字符串</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">String</td>
<td style="text-align:left">new_str = s[::-1]</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">[:-1]</td>
<td style="text-align:left">(DFS中)去掉最后一个字符</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">String</td>
<td style="text-align:left">path = path[:-1]</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">两个字符串叉乘</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">List</td>
<td style="text-align:left">a_list = [s + c for s in s1 for c in s2]</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">比较两个字符串</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">‘111’ &gt; ‘21’ -&gt; False, ‘21’ == ‘21’ -&gt; True</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left"><strong>find</strong></td>
<td style="text-align:left">查找返回下标</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">‘word’.find(‘w’) 若找不到返回-1</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">upper</td>
<td style="text-align:left">变成全部大写</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">‘word’.upper()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">lower</td>
<td style="text-align:left">变成全部大写</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">‘WORD’.lower()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">startswith</td>
<td style="text-align:left">是否以某个字母开头</td>
<td style="text-align:left">str</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">‘word’.startswith(‘w’)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">endswith</td>
<td style="text-align:left">是否以某个字母结尾</td>
<td style="text-align:left">str</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">‘word’.endswith(‘d’)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">strip, lstrip, rstrip</td>
<td style="text-align:left">去掉空格</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">str</td>
<td style="text-align:left">‘word ‘.strip(), ‘word ‘.lstrip(), ‘word ‘.rstrip()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">split</td>
<td style="text-align:left">用分隔符变成List</td>
<td style="text-align:left">str</td>
<td style="text-align:left">List</td>
<td style="text-align:left">‘a,b’.split(‘,’)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">+</td>
<td style="text-align:left">一个个字符加到字符串末</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">res += ‘g’  </td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">in</td>
<td style="text-align:left">查看某个字符是否属于一个字符集合里</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">if char in ‘([{‘ 可以避免用list</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">isalpha</td>
<td style="text-align:left">是否字母</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">‘ab’.isalpha()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">isdigit</td>
<td style="text-align:left">是否数字</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">‘23’.isdigit()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">ascii_lowercase</td>
<td style="text-align:left">a-z的所有字母</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">import string, string.ascii_lowercase</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">ord</td>
<td style="text-align:left">一个字母的ASCII</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">ord(‘A’) = 65</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">计算字符串的数值，变量，函数运算结果，返回数字</td>
<td style="text-align:left">str</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">eval(‘5+ 6’) = 11, num = 1, eval(num + 1) = 2, eval(‘f(2)’)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">ljust</td>
<td style="text-align:left">靠左右边补空格</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">line.ljust(maxWidth), line.ljust(maxWidth, ‘#’)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">初始化列表</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li = []，这是空列表，不能通过索引取值  </td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">初始化固定大小的列表</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li = [0] * 10, [None] * 10 -&gt; 创建一个list, * 是复制只能用于标量，若矢量是复制ref如[[]] * 10, 要用<strong>[[] for _ in range(10)]</strong></td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">len</td>
<td style="text-align:left">大小</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">int</td>
<td style="text-align:left">num = len(li)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">append</td>
<td style="text-align:left">尾部加入</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.append(‘apple’)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">insert</td>
<td style="text-align:left">头部加入</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.insert(0, ‘apple’)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">pop</td>
<td style="text-align:left">头部/某位置删除</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.pop(0), li.pop(2)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">按值删除</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.remove(3)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">+</td>
<td style="text-align:left">两个list合并</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">list1 + list2</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">extend</td>
<td style="text-align:left">两个list合并到第一个</td>
<td style="text-align:left">Any</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.extend([‘apple’, ‘banana’])</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">join</td>
<td style="text-align:left">加入分隔符</td>
<td style="text-align:left">List</td>
<td style="text-align:left">String</td>
<td style="text-align:left">‘,’.join(li), <strong>将字符列表变成字符串’’.join(char_list)</strong>  </td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">sort</td>
<td style="text-align:left">原地排序，如果List的元素是tuple，按第一个元素排序</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">li.sort(), 如果不改变原数组用list(li)先复制</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">sort</td>
<td style="text-align:left">按字符串长度降序排列</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">words.sort(key=len, reverse=True), intervals.sort(key=lambda x: x[0]), 按两个key来排序li.sort(key=lambda x: (x[0], x[1]))先顺序再逆序li.sort(key=lambda x: (x[0], -x[1]))  </td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">sorted</td>
<td style="text-align:left">非原地排序</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">nums[idx+1:] = sorted(nums[idx+1:])  </td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">list</td>
<td style="text-align:left">复制list</td>
<td style="text-align:left">List</td>
<td style="text-align:left">List</td>
<td style="text-align:left">new_list = list(old_list)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">list</td>
<td style="text-align:left">扩展一倍一样的list</td>
<td style="text-align:left">List</td>
<td style="text-align:left">List</td>
<td style="text-align:left">new_list = nums * 2</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">反转list</td>
<td style="text-align:left">List</td>
<td style="text-align:left">List</td>
<td style="text-align:left">new_list = li[::-1]跟反转string一样，<strong>反转子列表nums[idx+1:] = nums[len(nums)-1:idx:-1]</strong></td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[-1]</td>
<td style="text-align:left">返回list中最后一个元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">int</td>
<td style="text-align:left"><strong>li[-1]</strong>，而不是dp[len(li)-1]广泛用于DP题</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left"><strong>index</strong></td>
<td style="text-align:left">list中找某个元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">int</td>
<td style="text-align:left">li.index(2), 找不到的话抛出异常，先要检查if 9 in li2 else -1. 字符串用find</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">count</td>
<td style="text-align:left">list中计算某个元素值的个数</td>
<td style="text-align:left">T</td>
<td style="text-align:left">int</td>
<td style="text-align:left">li.count(‘a’)</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[:]</td>
<td style="text-align:left">批量替换成list中某些元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">nums[start:end + 1] = res</td>
</tr>
<tr>
<td>List</td>
<td style="text-align:left">[::-1]</td>
<td style="text-align:left">reverse sublist</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">nums[:k] = nums[:k][::-1]先取sublist再倒转</td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:left">deque</td>
<td style="text-align:left">初始化队列</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">from collections import deque, queue = deque(), queue = <strong>deque([node])</strong></td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:left">append</td>
<td style="text-align:left">入列</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">queue.append(node)</td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:left">popleft</td>
<td style="text-align:left">出列</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">T</td>
<td style="text-align:left">s = <strong>queue.popleft()</strong> </td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:left">appendleft</td>
<td style="text-align:left">队首入列</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">T</td>
<td style="text-align:left">s = queue.appendleft()较少用</td>
</tr>
<tr>
<td>deque</td>
<td style="text-align:left">[0]</td>
<td style="text-align:left">看列首元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">queue = [], s = queue[0] </td>
</tr>
<tr>
<td>List(Heap)</td>
<td style="text-align:left">heapify</td>
<td style="text-align:left">对list最小堆排序</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">from heapq import heapify, pq = [2, 3], heapify(pq) 若最大堆，则将所有值取负加入堆</td>
</tr>
<tr>
<td>List(Heap)</td>
<td style="text-align:left">heappush</td>
<td style="text-align:left">入堆</td>
<td style="text-align:left">List, T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">from heapq import heappush, heappush(pq, 4) </td>
</tr>
<tr>
<td>List(Heap)</td>
<td style="text-align:left">heappop</td>
<td style="text-align:left">出堆</td>
<td style="text-align:left">List</td>
<td style="text-align:left">T</td>
<td style="text-align:left">from heapq import heappop, heappop(pq)</td>
</tr>
<tr>
<td>List(Heap)</td>
<td style="text-align:left">heapreplace</td>
<td style="text-align:left">置换堆</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">heapq.heapreplace(pq, 4)= heappush(pq, 4) + heappop(pq)</td>
</tr>
<tr>
<td>List(Heap)</td>
<td style="text-align:left">[0]</td>
<td style="text-align:left">看堆顶元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">pq[0]  </td>
</tr>
<tr>
<td>List(Stack)</td>
<td style="text-align:left">append</td>
<td style="text-align:left">入栈</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">stack = [], stack.append(node)</td>
</tr>
<tr>
<td>List(Stack)</td>
<td style="text-align:left">pop</td>
<td style="text-align:left">出栈</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">stack = [], s = stack.pop() </td>
</tr>
<tr>
<td>List(Stack)</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">看栈顶元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">stack = [], s = stack[-1] </td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">{}</td>
<td style="text-align:left">初始化字典</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">di = {}, di = {1: ‘a’, 2: ‘b’}</td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">{}</td>
<td style="text-align:left">初始化字典带初始key</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">di = collections.defaultdict(int), <strong>defaultdict(list)</strong>避免第一次赋值时需要写if语句，一定用。只有用下标di[2]才会产生key和value,其他2 in di, di.keys()都不会产生key. collections.defaultdict(lambda: [0, 0])用于value是pair, 默认返回1： collections.defaultdict(lambda: 1)       </td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">获得字典的值</td>
<td style="text-align:left">T</td>
<td style="text-align:left">T</td>
<td style="text-align:left">di[key]</td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">插入到字典</td>
<td style="text-align:left">T</td>
<td style="text-align:left">T</td>
<td style="text-align:left">di[key] = 2</td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">items</td>
<td style="text-align:left">Dict的所有pairs</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">K,V</td>
<td style="text-align:left">for k, v in <strong>di.items()</strong></td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">items</td>
<td style="text-align:left">Dict的所有keys</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">List</td>
<td style="text-align:left">for k in di.keys(), 类型不是List，若要，则list(di.keys())</td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">in</td>
<td style="text-align:left">是否含有某个key</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">if key in di</td>
</tr>
<tr>
<td>Dictionary</td>
<td style="text-align:left">pop</td>
<td style="text-align:left">删除某个key</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">di.pop(key)</td>
</tr>
<tr>
<td>Set</td>
<td style="text-align:left">{}</td>
<td style="text-align:left">产生一个Set</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Set</td>
<td style="text-align:left">b = set(), b = <strong>set([‘a’, ‘b’])</strong></td>
</tr>
<tr>
<td>Set</td>
<td style="text-align:left">add</td>
<td style="text-align:left">set增加一个元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">b.add(‘c’)</td>
</tr>
<tr>
<td>Set</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">set删除一个元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">b.remove(‘c’)</td>
</tr>
<tr>
<td>Set</td>
<td style="text-align:left">set</td>
<td style="text-align:left">List转换成Set或反之</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">s = set(l), l = list(s)</td>
</tr>
<tr>
<td>bisect</td>
<td style="text-align:left">bisect</td>
<td style="text-align:left">二分法查找下标插入位置</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">跟greater_position一样, from bisect import bisect, bisect([], 3) -&gt; 0, bisect([2], 3) -&gt; 1, bisect([3], 3) -&gt; 1, bisect([4], 3) -&gt; 0。还可以用于<strong>统计小于等于target的个数</strong>，如bisect([0, 1], 1) -&gt; 2</td>
</tr>
<tr>
<td>bisect</td>
<td style="text-align:left">bisect_left</td>
<td style="text-align:left">二分法查找下标插入位置</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">似于greater_or_equal_position但若equal时，取第一个，但greater_or_equal_position是取最后一个. <strong>用于LIS</strong></td>
</tr>
<tr>
<td>bisect</td>
<td style="text-align:left">insort</td>
<td style="text-align:left">二分法查找下标插入位置且插入</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">似于greater_position，插入复杂度为O(n)</td>
</tr>
<tr>
<td>bisect</td>
<td style="text-align:left">bisect</td>
<td style="text-align:left">二分法查找二维数组</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">bisect.bisect([[0, 1], [0, 2], [1, 2], [1, 3]], [1]) -&gt; [1, 2]下标，若找[1, 2] -&gt; [1, 3]下标</td>
</tr>
<tr>
<td>Lambda</td>
<td style="text-align:left">func/expr…for…in</td>
<td style="text-align:left">整型数组变字符串数组</td>
<td style="text-align:left">List</td>
<td style="text-align:left">List</td>
<td style="text-align:left">[str(x) for x in list]</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">return</td>
<td style="text-align:left">返回tuple值</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">return a, b 不要括号</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">isinstance</td>
<td style="text-align:left">判断输入是什么类型</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">bool</td>
<td style="text-align:left">isinstance(stack[2], list)</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">Counter</td>
<td style="text-align:left">计算List和字符串频率</td>
<td style="text-align:left">List</td>
<td style="text-align:left">dict</td>
<td style="text-align:left">from collections import Counter, di = Counter(nums), di = Counter(‘apple’), graph = Counter({c: [] for word in words for c in word})</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">[]</td>
<td style="text-align:left">初始化NxM矩阵为0</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">a = <del>[[1] * M] * N</del>不能复制矢量。[[0 for _ in range(M)] for _ in range(N)] <strong>先col再row</strong></td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">randint</td>
<td style="text-align:left">求[start, end]之间随机值</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">Num</td>
<td style="text-align:left">import random, random.randint(0, 1) -&gt; 0/1</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">map, max</td>
<td style="text-align:left">求矩阵最大值</td>
<td style="text-align:left">[][]</td>
<td style="text-align:left">T</td>
<td style="text-align:left">max(map(max, matrix))</td>
</tr>
<tr>
<td>Others</td>
<td style="text-align:left">or</td>
<td style="text-align:left">若0返回1</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">a or 1 -&gt; a if a != 0, 1 if a == 0</td>
</tr>
<tr>
<td>OrderedDict</td>
<td style="text-align:left">OrderedDict</td>
<td style="text-align:left">类似于LinkedHashMap，dict的key的插入顺序排序</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">di = collections.OrderedDict(), di[‘a’] = 2</td>
</tr>
<tr>
<td>re</td>
<td style="text-align:left">search</td>
<td style="text-align:left">search只match一次</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">re.search(r’(\+&#124;\-)?\d+’, ‘-23.1e2’).group() -&gt; -23</td>
</tr>
<tr>
<td>re</td>
<td style="text-align:left">sub</td>
<td style="text-align:left">全部用regex替代类似Java中的replaceAll</td>
<td style="text-align:left">str</td>
<td style="text-align:left">str</td>
<td style="text-align:left">re.sub(r’\s+’, ‘’, ‘a 6 7’) -&gt; a67</td>
</tr>
<tr>
<td>Exception</td>
<td style="text-align:left">Exception</td>
<td style="text-align:left">抛出异常</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">raise Exception(‘abc’)</td>
</tr>
</tbody>
</table>
<p>总结：<br>除了deque, Stack, List的实现都是List<br>插入append, insert<br>删除pop, popleft(deque)  </p>
<p>初始化列表：<br>创建一个list： li = [0] * 10, [False] * 10 而不是[False * 10], [0 * 10]这是乘法<br>创建一个list of list不用乘号： [[0 for _ in range(M)] for _ in range(N)], [[] for _ in range(10)]</p>
<p>if left_val可能为整数或None，要写成<strong>if left_val is not None</strong>，否则若left_val = 0, 会False<br>i += 1没有i++<br>if 0 &lt; i &lt; len(nums) 不像Java一样，Python可以连续比较范围<br>所有int都是long<br>22//5 = 4<br>22/5 = 4.4 </p>
<p>def myFunc(e):<br>  return e[‘year’]<br>cars.sort(reverse=True, key=myFunc)  </p>
<p>由于Python的数字类型都是Numeric（自动识别为Integer, Float, Complex Numbers）,所以自动变成小数，不像Java是int<br><a href="https://www.geeksforgeeks.org/python-data-types/" target="_blank" rel="noopener">数据类型</a></p>
<p>True/False<br>and/or/not<br>pass什么都不做 if a: pass</p>
<p>&amp;, ^异或, ~取反(~3), |, &lt;&lt;, &gt;&gt;</p>
<p>lo = hi = 0<br>swap: a, b = b, a<br>elif<br>return -res if is_negative else res<br>if root / if not root<br><strong>if not nums</strong> 包含(None以及len(nums) == 0<br>Node(0)没有new<br>zip是将两个list的元素同步合成tuple，以短的为终结点。例如[i + j for i, j in zip(li, li2)] -&gt; [5, 7], li = [1, 2], li2 = [4, 5, 6]<br>函数中更改输入list如f(list) -&gt; list = [‘’]，不会改变原list，必须更改任意元素： list[:] = [‘’]<br>匿名函数和重载： ListNode.__lt__ = lambda x, y: (x.val &lt; y.val)<br>Python中自定义obj可以任意定义属性，所以若要给某属性赋值如node.value，一定要match类定义里边的，不是node.val = 5。  </p>
<p>补集：<br>list(set(li) - set(li2))<br>[n for n in self.all if n not in set(li)]<br>并集：<br>list(set(li) | set(li2))<br>list(set(li + li2))<br>交集：<br>list(set(li) &amp; set(li2))<br>[n for n in li if n in set(li2)]</p>
<p>10的6次方，不能用10^6，这是异或，用1e6或pow(10, 6)<br>self.maxDepth  </p>
<p>用_i来表示内部使用，dict_表示与关键字不重复</p>
<p>三个引号就是多行comment，#是一行comment<br>换行用 \ </p>
<p><a href="https://www.runoob.com/python3/python3-basic-syntax.html" target="_blank" rel="noopener">Python基础</a><br><a href="https://visualgit.readthedocs.io/en/latest/pages/naming_convention.html" target="_blank" rel="noopener">Python命名规则</a><br><a href="https://zhuanlan.zhihu.com/p/36173202" target="_blank" rel="noopener">Python下划线</a></p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>算法知识点目录</title>
    <url>/2021/11/13/kb-alg/</url>
    <content><![CDATA[<h3 id="数组题"><a href="#数组题" class="headerlink" title="数组题"></a><strong>数组题</strong></h3><p><a href="https://shineboy2013.github.io/2018/03/13/lee-001/" target="_blank" rel="noopener">LeetCode 001 Two Sum</a><br><a href="https://shineboy2013.github.io/2021/11/14/lee-2073/" target="_blank" rel="noopener">LeetCode 2073 Time Needed to Buy Tickets</a>  </p>
<h3 id="整数题"><a href="#整数题" class="headerlink" title="整数题"></a><strong>整数题</strong></h3><p><a href="https://shineboy2013.github.io/2021/10/21/lee-007/" target="_blank" rel="noopener">LeetCode 007 Reverse Integer</a>  </p>
<h3 id="整洁题"><a href="#整洁题" class="headerlink" title="整洁题"></a><strong>整洁题</strong></h3><p><a href="https://shineboy2013.github.io/2018/04/30/lee-273/" target="_blank" rel="noopener">LeetCode 273 Integer to English Words</a><br><a href="https://shineboy2013.github.io/2018/02/22/lee-054/" target="_blank" rel="noopener">LeetCode 054 Spiral Matrix</a><br><a href="https://shineboy2013.github.io/2022/01/02/lee-048/" target="_blank" rel="noopener">LeetCode 048 Rotate Image</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-166/" target="_blank" rel="noopener">LeetCode 166 Fraction to Recurring Decimal</a><br><a href="https://shineboy2013.github.io/2022/01/04/lee-008/" target="_blank" rel="noopener">LeetCode 008 String to Integer (atoi)</a> 合法整数<br><a href="https://shineboy2013.github.io/2022/01/13/lee-065/" target="_blank" rel="noopener">LeetCode 065 Valid Number</a> 合法小数指数  </p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><p><a href="https://shineboy2013.github.io/2021/07/27/lee-003/" target="_blank" rel="noopener">LeetCode 003 Longest Substring Without Repeating Characters</a>  </p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h3><p>注意事项： [4步]</p>
<ul>
<li>fake_node</li>
<li>while it or it.next</li>
<li>删除节点.next = None</li>
<li>it = it.next    </li>
</ul>
<p>快慢指针找循环，找中点(注意中位数有1-2个, 用fast是否为None来判断)<br><a href="https://shineboy2013.github.io/2022/01/16/leetcode-142-linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode 142 Linked List Cycle II</a><br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-234-palindrome-linked-list/" target="_blank" rel="noopener">LeetCode 234 Palindrome Linked List</a><br>反转LL及其模板<br><a href="https://shineboy2013.github.io/2022/01/17/leetcode-206-reverse-linked-list/" target="_blank" rel="noopener">LeetCode 206 Reverse Linked List</a><br><a href="https://shineboy2013.github.io/2022/01/15/lee-092/" target="_blank" rel="noopener">LeetCode 092 Reverse Linked List II</a><br>其他：<br><a href="https://shineboy2013.github.io/2021/12/22/lee-021/" target="_blank" rel="noopener">LeetCode 021 Merge Two Sorted Lists</a><br><a href="https://shineboy2013.github.io/2021/12/12/lee-002/" target="_blank" rel="noopener">LeetCode 002 Add Two Numbers</a><br><a href="https://shineboy2013.github.io/2021/07/27/lee-138/" target="_blank" rel="noopener">LeetCode 138 Copy List with Random Pointer</a><br><a href="https://shineboy2013.github.io/2021/12/02/lee-023/" target="_blank" rel="noopener">LeetCode 023 Merge k Sorted Lists</a>    </p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><strong>Stack</strong></h3><p>递减栈<br>适用条件： 数组元素之间大小关系(包括相等)且顺序不能变，可以动态处理(一个个处理)<br><a href="https://shineboy2013.github.io/2021/10/30/stack/" target="_blank" rel="noopener">Stack</a><br><a href="https://shineboy2013.github.io/2018/01/28/lee-503/" target="_blank" rel="noopener">LeetCode 503 Next Greater Element II</a><br><a href="https://shineboy2013.github.io/2018/07/12/lee-042/" target="_blank" rel="noopener">LeetCode 042 Trapping Rain Water</a><br><a href="https://shineboy2013.github.io/2017/12/31/lee-316/" target="_blank" rel="noopener">LeetCode 316 Remove Duplicate Letters</a><br><a href="https://shineboy2013.github.io/2021/12/24/lee-1209/" target="_blank" rel="noopener">LeetCode 1209 Remove All Adjacent Duplicates in String II</a><br><a href="https://shineboy2013.github.io/2021/12/06/lee-239/" target="_blank" rel="noopener">LeetCode 239 Sliding Window Maximum</a>  </p>
<h3 id="BST的非递归遍历"><a href="#BST的非递归遍历" class="headerlink" title="BST的非递归遍历"></a><strong>BST的非递归遍历</strong></h3><p><a href="https://shineboy2013.github.io/2020/04/26/bst-iterative/" target="_blank" rel="noopener">BST的非递归中序，前序，后序遍历</a><br><a href="https://shineboy2013.github.io/2020/04/26/lee-272/" target="_blank" rel="noopener">LeetCode 272 Closest Binary Search Tree Value II</a><br>Iterator题目基本是List转Stack<br><a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a>  </p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a><strong>Heap</strong></h3><p><a href="https://shineboy2013.github.io/2021/11/14/heap/" target="_blank" rel="noopener">Heap</a><br><a href="https://shineboy2013.github.io/2017/12/31/lee-347/" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a><br><a href="https://shineboy2013.github.io/2018/01/29/lee-253/" target="_blank" rel="noopener">LeetCode 253 Meeting Rooms II</a> endTime的Heap (最常见)<br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-218-the-skyline-problem/" target="_blank" rel="noopener">LeetCode 218 The Skyline Problem</a> 高度的Heap<br>Heap + BFS<br><a href="https://shineboy2013.github.io/2021/11/30/lee-264/" target="_blank" rel="noopener">LeetCode 264 Ugly Number II</a><br><a href="https://shineboy2013.github.io/2021/12/04/lee-373/" target="_blank" rel="noopener">LeetCode 373 Find K Pairs with Smallest Sums</a><br><a href="https://shineboy2013.github.io/2021/11/14/lee-378/" target="_blank" rel="noopener">LeetCode 378 Kth Smallest Element in a Sorted Matrix</a>    </p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>题目大多都是HashMap + LL 或 HashMap + List<br><a href="https://shineboy2013.github.io/2021/11/30/lee-1429/" target="_blank" rel="noopener">LeetCode 1429 First Unique Number</a><br><a href="https://shineboy2013.github.io/2021/11/30/lee-380/" target="_blank" rel="noopener">LeetCode 380 Insert Delete GetRandom O(1)</a><br><a href="https://shineboy2013.github.io/2020/05/04/lee-146/" target="_blank" rel="noopener">LeetCode 146 LRU Cache</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-460/" target="_blank" rel="noopener">LeetCode 460 LFU Cache</a><br><a href="https://shineboy2013.github.io/2021/11/29/trie/" target="_blank" rel="noopener">Trie</a><br><a href="https://shineboy2013.github.io/2021/12/16/lee-588/" target="_blank" rel="noopener">LeetCode 588 Design In-Memory File System</a><br><a href="https://shineboy2013.github.io/2022/01/17/leetcode-211-design-add-and-search-words-data-structure/" target="_blank" rel="noopener">LeetCode 211 Design Add and Search Words Data Structure</a> search含TrieNode参数 + DFS<br><a href="https://shineboy2013.github.io/2021/12/03/lee-212/" target="_blank" rel="noopener">LeetCode 212 Word Search II</a> search含TrieNode参数<br><a href="https://shineboy2013.github.io/2022/01/03/iterator/" target="_blank" rel="noopener">Iterator</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-251/" target="_blank" rel="noopener">LeetCode 251 Flatten 2D Vector</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-281/" target="_blank" rel="noopener">LeetCode 281 Zigzag Iterator</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-341/" target="_blank" rel="noopener">LeetCode 341 Flatten Nested List Iterator</a><br><a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a><br>数组二分法:<br><a href="https://shineboy2013.github.io/2021/12/25/lee-981/" target="_blank" rel="noopener">LeetCode 981 Time Based Key-Value Store</a><br><a href="https://shineboy2013.github.io/2021/11/20/lee-2080/" target="_blank" rel="noopener">LeetCode 2080 Range Frequency Queries</a><br>其他：<br><a href="https://shineboy2013.github.io/2018/06/14/lee-155/" target="_blank" rel="noopener">LeetCode 155 Min Stack</a>  </p>
<h3 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a><strong>Two pointers</strong></h3><p>同向双指针： 应用条件需要<strong>连续</strong>一段达到target，然后连续一段达不到target，梅花间竹<br><a href="https://shineboy2013.github.io/2021/12/05/two-pointers/" target="_blank" rel="noopener">Two pointers</a><br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-243-shortest-word-distance/" target="_blank" rel="noopener">LeetCode 243 Shortest Word Distance</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-209/" target="_blank" rel="noopener">LeetCode 209 Minimum Size Subarray Sum</a><br><a href="https://shineboy2013.github.io/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/" target="_blank" rel="noopener">LeetCode 438 Find All Anagrams in a String</a><br><a href="https://shineboy2013.github.io/2022/01/15/lee-076/" target="_blank" rel="noopener">LeetCode 076 Minimum Window Substring</a><br><a href="https://shineboy2013.github.io/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">LeetCode 340 Longest Substring with At Most K Distinct Characters</a> 最长类型<br><a href="https://shineboy2013.github.io/2022/01/01/lee-395/" target="_blank" rel="noopener">LeetCode 395 Longest Substring with At Least K Repeating Characters</a> 最长类型<br>相向双指针<br>Hash(value -&gt; index, value -&gt; count)适用条件： 数组元素之间的关系，相加相减等于target，复杂度为O(n)<br><a href="https://shineboy2013.github.io/2021/12/26/lee-1010/" target="_blank" rel="noopener">LeetCode 1010 Pairs of Songs With Total Durations Divisible by 60</a> value -&gt; count变体<br>Two points适用条件： 数组元素之间的关系，相加相减等于target，<strong>元素相等或有序</strong>，复杂度为O(n)<br>回文题首先考虑用相向双指针<br><a href="https://shineboy2013.github.io/2022/01/16/lee-125-valid-palindrome/" target="_blank" rel="noopener">LeetCode 125 Valid Palindrome</a><br><a href="https://shineboy2013.github.io/2021/12/16/lee-680/" target="_blank" rel="noopener">LeetCode 680 Valid Palindrome II</a>  </p>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a><strong>Sorting</strong></h3><p><a href="https://shineboy2013.github.io/2020/04/26/quick-sort/" target="_blank" rel="noopener">Quick sort</a><br>Partition的应用, O(1)空间且注意循环外处理最后一部分：<br><a href="https://shineboy2013.github.io/2022/01/20/leetcode-283-move-zeroes/" target="_blank" rel="noopener">LeetCode 283 Move Zeroes</a><br><a href="https://shineboy2013.github.io/2021/12/20/lee-443/" target="_blank" rel="noopener">LeetCode 443 String Compression</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-075/" target="_blank" rel="noopener">LeetCode 075 Sort Colors</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-696/" target="_blank" rel="noopener">LeetCode 696 Count Binary Substrings</a><br><a href="https://shineboy2013.github.io/2021/12/16/lee-041/" target="_blank" rel="noopener">LeetCode 041 First Missing Positive</a><br><a href="https://shineboy2013.github.io/2020/04/26/quick-sort/" target="_blank" rel="noopener">Quick select</a><br><a href="https://shineboy2013.github.io/2021/11/15/merge-sort/" target="_blank" rel="noopener">Merge sort</a><br><a href="https://shineboy2013.github.io/2021/12/25/lee-244/" target="_blank" rel="noopener">LeetCode 244 Shortest Word Distance II</a><br><a href="https://shineboy2013.github.io/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode 315 Count of Smaller Numbers After Self</a><br><a href="https://shineboy2013.github.io/2018/04/30/lee-493/" target="_blank" rel="noopener">LeetCode 493 Reverse Pairs</a><br>Bucket sort<br><a href="https://shineboy2013.github.io/2017/12/31/lee-347/" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a><br><a href="https://shineboy2013.github.io/2021/11/20/lee-2080/" target="_blank" rel="noopener">LeetCode 2080 Range Frequency Queries</a>  </p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a><strong>Binary Search</strong></h3><p><a href="https://shineboy2013.github.io/2020/04/21/binary-search/" target="_blank" rel="noopener">Binary Search</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-278/" target="_blank" rel="noopener">LeetCode 278 First Bad Version</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-153/" target="_blank" rel="noopener">LeetCode 153 Find Minimum in Rotated Sorted Array</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-033/" target="_blank" rel="noopener">LeetCode 033 Search in Rotated Sorted Array</a><br><a href="https://shineboy2013.github.io/2019/02/26/lee-540/" target="_blank" rel="noopener">LeetCode 540 Single Element in a Sorted Array</a><br><a href="https://shineboy2013.github.io/2021/11/13/lee-275/" target="_blank" rel="noopener">LeetCode 275 H-Index II</a><br><a href="https://shineboy2013.github.io/2020/04/21/binary-search/" target="_blank" rel="noopener">Binary Select</a><br>适用条件：试某个数接近于最优解，全部试一遍就是*logn的复杂度<br><a href="https://shineboy2013.github.io/2021/11/14/lee-378/" target="_blank" rel="noopener">LeetCode 378 Kth Smallest Element in a Sorted Matrix</a><br><a href="https://shineboy2013.github.io/2018/01/31/lee-004/" target="_blank" rel="noopener">LeetCode 004 Median of Two Sorted Arrays</a>  </p>
<h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a><strong>Tree</strong></h3><p>检查方法： None, 一个节点，两个节点(只有左或右)，三个节点<br>nonlocal方法，不用定义全局变量见<a href="https://shineboy2013.github.io/2022/02/07/leetcode-543-diameter-of-binary-tree/" target="_blank" rel="noopener">LeetCode 543 Diameter of Binary Tree</a><br><a href="https://shineboy2013.github.io/2021/07/27/lee-104/" target="_blank" rel="noopener">LeetCode 104 Maximum Depth of Binary Tree</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-230/" target="_blank" rel="noopener">LeetCode 230 Kth Smallest Element in a BST</a><br><a href="https://shineboy2013.github.io/2021/12/29/lee-114/" target="_blank" rel="noopener">LeetCode 114 Flatten Binary Tree to Linked List</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-105/" target="_blank" rel="noopener">LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal</a><br><a href="https://shineboy2013.github.io/2021/12/24/lee-314/" target="_blank" rel="noopener">LeetCode 314 Binary Tree Vertical Order Traversal</a><br>方法：用Map记录子节点到父节点关系等价于形成双向Tree<br><a href="https://shineboy2013.github.io/2021/12/28/lee-1650/" target="_blank" rel="noopener">LeetCode 1650 Lowest Common Ancestor of a Binary Tree III</a><br><a href="https://shineboy2013.github.io/2021/12/04/lee-236/" target="_blank" rel="noopener">LeetCode 236 Lowest Common Ancestor of a Binary Tree</a><br><a href="https://shineboy2013.github.io/2021/12/06/lee-863/" target="_blank" rel="noopener">LeetCode 863 All Nodes Distance K in Binary Tree</a>  </p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a><strong>BFS</strong></h3><p>适用条件： 可行性，最大和最小值且每个点不能重复访问<br>注意事项： [3步]建图没有边的节点也要加到邻接表, 输入参数不等于迭代参数, 返回-1,<br><a href="https://shineboy2013.github.io/2017/12/03/bfs/" target="_blank" rel="noopener">图BFS</a><br><a href="https://shineboy2013.github.io/2017/12/23/lee-200/" target="_blank" rel="noopener">LeetCode 200 Number of Islands</a> 连通集问题, 对所有节点BFS<br><a href="https://shineboy2013.github.io/2021/11/27/lee-1048/" target="_blank" rel="noopener">LeetCode 1048 Longest String Chain</a> 多源最长路劲，对所有节点BFS<br><a href="https://shineboy2013.github.io/2020/04/20/lee-1197/" target="_blank" rel="noopener">LeetCode 1197 Minimum Knight Moves</a><br><a href="https://shineboy2013.github.io/2020/04/19/lee-133/" target="_blank" rel="noopener">LeetCode 133 Clone Graph</a><br><a href="https://shineboy2013.github.io/2020/04/20/lee-297/" target="_blank" rel="noopener">LeetCode 297 Serialize and Deserialize Binary Tree</a><br><a href="https://shineboy2013.github.io/2020/04/20/lee-127/" target="_blank" rel="noopener">LeetCode 127 Word Ladder</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-1654/" target="_blank" rel="noopener">LeetCode 301 Remove Invalid Parenthesess</a><br><a href="https://shineboy2013.github.io/2021/12/15/lee-055/" target="_blank" rel="noopener">LeetCode 055 Jump Game</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-1654/" target="_blank" rel="noopener">LeetCode 1654 Minimum Jumps to Reach Home</a><br><a href="https://shineboy2013.github.io/2022/01/20/leetcode-286-walls-and-gates/" target="_blank" rel="noopener">LeetCode 286 Walls and Gates</a> 多始点一次BFS<br><a href="https://shineboy2013.github.io/2021/12/05/lee-490/" target="_blank" rel="noopener">LeetCode 490 The Maze</a> 一组节点作为一层的BFS<br><a href="https://shineboy2013.github.io/2021/12/19/lee-815/" target="_blank" rel="noopener">LeetCode 815 Bus Routes</a> 一组节点作为一层的BFS<br>[LeetCode 1293 Shortest Path in a Grid with Obstacles Elimination] 多状态BFS<br><a href="https://shineboy2013.github.io/2017/12/03/topological/" target="_blank" rel="noopener">拓扑排序</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-210/" target="_blank" rel="noopener">LeetCode 210 Course Schedule II</a><br><a href="https://shineboy2013.github.io/2017/12/04/lee-310/" target="_blank" rel="noopener">LeetCode 310 Minimum Height Trees</a><br><a href="https://shineboy2013.github.io/2021/11/29/lee-269/" target="_blank" rel="noopener">LeetCode 269 Alien Dictionary</a>    </p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a><strong>DFS</strong></h3><p>适用条件： 种数(优先用DP，次选用DFS)，可行性<br><a href="https://shineboy2013.github.io/2017/12/24/dfs/" target="_blank" rel="noopener">图DFS/填位法</a><br><a href="https://shineboy2013.github.io/2020/05/03/permutation/" target="_blank" rel="noopener">排列</a><br><a href="https://shineboy2013.github.io/2021/12/26/lee-526/" target="_blank" rel="noopener">LeetCode 526 Beautiful Arrangement</a><br><a href="https://shineboy2013.github.io/2020/05/03/combination/" target="_blank" rel="noopener">组合</a><br><a href="https://shineboy2013.github.io/2021/12/29/lee-039/" target="_blank" rel="noopener">LeetCode 039 Combination Sum</a><br><a href="https://shineboy2013.github.io/2021/12/29/lee-077/" target="_blank" rel="noopener">LeetCode 077 Combinations</a><br><a href="https://shineboy2013.github.io/2021/12/29/lee-216/" target="_blank" rel="noopener">LeetCode 216 Combination Sum III</a><br><a href="https://shineboy2013.github.io/2021/10/21/lee-017/" target="_blank" rel="noopener">LeetCode 017 Letter Combinations of a Phone Number</a>  填位法<br><a href="https://shineboy2013.github.io/2021/12/05/lee-051/" target="_blank" rel="noopener">LeetCode 051 N-Queens</a> 填位法<br><a href="https://shineboy2013.github.io/2021/12/28/lee-037/" target="_blank" rel="noopener">LeetCode 037 Sudoku Solver</a> 填位法, 单边DFS + 循环DFS<br><a href="https://shineboy2013.github.io/2022/01/16/lee-093/" target="_blank" rel="noopener">LeetCode 093 Restore IP Addresses</a> 分割型，结果分组型DFS<br><a href="https://shineboy2013.github.io/2021/12/04/lee-291/" target="_blank" rel="noopener">LeetCode 291 Word Pattern II</a> 分割型, 单边DFS + 循环DFS<br><a href="https://shineboy2013.github.io/2021/12/03/lee-079/" target="_blank" rel="noopener">LeetCode 079 Word Search</a> 图DFS + 分割型<br><a href="https://shineboy2013.github.io/2020/05/03/lee-126/" target="_blank" rel="noopener">LeetCode 126 Word Ladder II</a> 图DFS<br><a href="https://shineboy2013.github.io/2020/05/09/memoization/" target="_blank" rel="noopener">记忆性搜索</a><br><a href="https://shineboy2013.github.io/2020/05/09/lee-140/" target="_blank" rel="noopener">LeetCode 140 Word Break II</a> 分割型<br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-095-unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode 095 Unique Binary Search Trees II</a> Catalan型DFS<br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-241-different-ways-to-add-parentheses/" target="_blank" rel="noopener">LeetCode 241 Different Ways to Add Parentheses</a> Catalan型DFS     </p>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a><strong>DP</strong></h3><p>适用条件： 最值，种数，可行性。输入数据有序,暴力法非多项式<br>注意事项： [5步]多1, 初始化, 多1, 少1, 答案<br><a href="https://shineboy2013.github.io/2021/11/27/dp/" target="_blank" rel="noopener">DP</a><br><a href="https://shineboy2013.github.io/2021/12/29/lee-070/" target="_blank" rel="noopener">LeetCode 070 Climbing Stairs</a> 单序列型<br><a href="https://shineboy2013.github.io/2022/01/16/lee-091/" target="_blank" rel="noopener">LeetCode 091 Decode Ways</a> 单序列型<br><a href="https://shineboy2013.github.io/2021/12/05/lee-198/" target="_blank" rel="noopener">LeetCode 198 House Robber</a> 单序列型<br><a href="https://shineboy2013.github.io/2021/12/29/lee-377/" target="_blank" rel="noopener">LeetCode 377 Combination Sum IV</a> <strong>数值到个数DP</strong><br><a href="https://shineboy2013.github.io/2021/12/06/lee-322/" target="_blank" rel="noopener">LeetCode 322 Coin Change</a> 数值到个数DP<br><a href="https://shineboy2013.github.io/2022/01/30/leetcode-518-coin-change-2/" target="_blank" rel="noopener">LeetCode 518 Coin Change 2</a> 数值到个数DP(元素无序)<br><a href="https://shineboy2013.github.io/2022/01/05/lee-063/" target="_blank" rel="noopener">LeetCode 063 Unique Paths II</a> 坐标型DP<br><a href="https://shineboy2013.github.io/2022/01/05/lee-064/" target="_blank" rel="noopener">LeetCode 064 Minimum Path Sum</a> 坐标型DP<br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-221-maximal-square/" target="_blank" rel="noopener">LeetCode 221 Maximal Square</a> 坐标型DP<br><a href="https://shineboy2013.github.io/2021/12/22/lee-174/" target="_blank" rel="noopener">LeetCode 174 Dungeon Game</a> 坐标型DP<br><a href="https://shineboy2013.github.io/2021/12/23/lee-718/" target="_blank" rel="noopener">LeetCode 718 Maximum Length of Repeated Subarray</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2021/12/01/lee-300/" target="_blank" rel="noopener">LeetCode 300 LIS</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2020/05/09/lee-139/" target="_blank" rel="noopener">LeetCode 139 Word Break</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2022/01/15/lee-072/" target="_blank" rel="noopener">LeetCode 072 Edit Distance</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2020/05/10/lee-044/" target="_blank" rel="noopener">LeetCode 044 Wildcard Matching</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2020/05/10/lee-010/" target="_blank" rel="noopener">LeetCode 010 Regular Expression Matching</a> 匹配型DP<br><a href="https://shineboy2013.github.io/2021/12/05/lee-516/" target="_blank" rel="noopener">LeetCode 516 Longest Palindromic Subsequence</a>  区间型DP<br><a href="https://shineboy2013.github.io/2017/12/28/lee-312/" target="_blank" rel="noopener">LeetCode 312 Burst Balloons</a> 区间型DP<br><a href="https://shineboy2013.github.io/2022/01/30/karat-002/" target="_blank" rel="noopener">Karat 002 Longest Common Continuous Subarray</a> 打印路径<br><a href="https://shineboy2013.github.io/2021/12/01/lee-300/" target="_blank" rel="noopener">LeetCode 300 Longest Increasing Subsequence</a> 打印路径<br><a href="https://shineboy2013.github.io/2020/05/10/lee-368/" target="_blank" rel="noopener">LeetCode 368 Largest Divisible Subset</a> 打印路径<br><a href="https://shineboy2013.github.io/2022/01/29/leetcode-1143-longest-common-subsequence/" target="_blank" rel="noopener">LeetCode 1143 Longest Common Subsequence</a> 打印路径<br>多状态DP需要同时赋值<br><a href="https://shineboy2013.github.io/2022/01/17/leetcode-152-maximum-product-subarray/" target="_blank" rel="noopener">LeetCode 152 Maximum Product Subarray</a> 多状态DP<br><a href="https://shineboy2013.github.io/2021/12/26/lee-926/" target="_blank" rel="noopener">LeetCode 926 Flip String to Monotone Increasing</a> 多状态DP<br><a href="https://shineboy2013.github.io/2022/01/19/leetcode-256-paint-house/" target="_blank" rel="noopener">LeetCode 256 Paint House</a> 多状态DP<br>多状态DP-fg双函数(g为累计DP) - 和前状态不能相邻<br><a href="https://shineboy2013.github.io/2022/01/24/leetcode-337-house-robber-iii/" target="_blank" rel="noopener">LeetCode 337 House Robber III</a> 多状态DP-fg双函数<br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a> 多状态DP-fg双函数     </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p>动态计算连接数，其他均用BFS<br><a href="https://shineboy2013.github.io/2017/12/24/union-find/" target="_blank" rel="noopener">Union Find</a><br><a href="https://shineboy2013.github.io/2022/01/20/leetcode-721-accounts-mergesolution/" target="_blank" rel="noopener">LeetCode 721 Accounts Merge</a><br>[双向BFS]<a href="https://shineboy2013.github.io/2020/04/20/lee-127/" target="_blank" rel="noopener">LeetCode 127 Word Ladder</a><br>[线段树]<a href="https://shineboy2013.github.io/2021/12/05/lee-729/" target="_blank" rel="noopener">LeetCode 729 My Calendar I</a>  </p>
<h2 id="最大的k个-最大的前k个数-无序数值数组"><a href="#最大的k个-最大的前k个数-无序数值数组" class="headerlink" title="最大的k个/最大的前k个数(无序数值数组)"></a>最大的k个/最大的前k个数(无序数值数组)</h2><p><a href="https://shineboy2013.github.io/2017/12/31/lee-347/" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a><br>优先考虑Heap，因为Heap支持<strong>动态</strong>和静态数据。适用范围最广，动态包括Data stream，不将整个数组读入从而优化复杂度<br><a href="https://shineboy2013.github.io/2021/12/06/lee-295/" target="_blank" rel="noopener">LeetCode 295 Find Median from Data Stream</a><br><a href="https://shineboy2013.github.io/2021/11/14/lee-378/" target="_blank" rel="noopener">LeetCode 378 Kth Smallest Element in a Sorted Matrix</a><br>Binary select，数值法计算个数，不能用于动态，实现较复杂<br><a href="https://shineboy2013.github.io/2018/01/31/lee-004/" target="_blank" rel="noopener">LeetCode 004 Median of Two Sorted Arrays</a><br>Quick select, binary select的特殊版，只能用于一维数组   </p>
<h2 id="数组区间内动态最大值最小值或保留数组顺序-数值数组"><a href="#数组区间内动态最大值最小值或保留数组顺序-数值数组" class="headerlink" title="数组区间内动态最大值最小值或保留数组顺序(数值数组)"></a>数组区间内动态最大值最小值或保留数组顺序(数值数组)</h2><p>由于保留顺序，首选stack<br><a href="https://shineboy2013.github.io/2021/12/12/lee-2104/" target="_blank" rel="noopener">LeetCode 2104 Sum of Subarray Ranges</a>  </p>
<h2 id="二维坐标最短距离"><a href="#二维坐标最短距离" class="headerlink" title="二维坐标最短距离"></a>二维坐标最短距离</h2><p>BFS首选，然后DP。若状态转移是无序用BFS，否则DP(可从上到下，从左到右)<br>BFS<br><a href="https://shineboy2013.github.io/2020/04/20/lee-1197/" target="_blank" rel="noopener">LeetCode 1197 Minimum Knight Moves</a><br><a href="https://shineboy2013.github.io/2021/12/27/lee-909/" target="_blank" rel="noopener">LeetCode 909 Snakes and Ladders</a><br>DP<br><a href="https://shineboy2013.github.io/2021/12/22/lee-174/" target="_blank" rel="noopener">LeetCode 174 Dungeon Game</a> 坐标型DP   </p>
<h2 id="累计思想"><a href="#累计思想" class="headerlink" title="累计思想"></a>累计思想</h2><p>将相连的批量计算提高效率或者满足累计条件<br><a href="https://shineboy2013.github.io/2021/12/08/lee-032/" target="_blank" rel="noopener">LeetCode 032 Longest Valid Parentheses</a>  统计左括号个数保证其一直为非负数<br><a href="https://shineboy2013.github.io/2021/12/09/lee-134/" target="_blank" rel="noopener">LeetCode 134 Gas Station</a>  保证gas一直为非负数<br>数组的presum<br><strong>加入presum[0] = 0</strong><br><a href="https://shineboy2013.github.io/2021/12/05/lee-696/" target="_blank" rel="noopener">LeetCode 696 Count Binary Substrings</a><br><a href="https://shineboy2013.github.io/2021/12/13/lee-560/" target="_blank" rel="noopener">LeetCode 560 Subarray Sum Equals K</a><br><a href="https://shineboy2013.github.io/2021/12/28/lee-238/" target="_blank" rel="noopener">LeetCode 238 Product of Array Except Self</a><br>子矩阵的presum<br>同数组，presum矩阵大小为长度 + 1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br><span class="line"></span><br><span class="line">presum[i][j] = row_sum + (presum[i - 1][j] if i &gt; 0 else 0)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://shineboy2013.github.io/2022/01/21/leetcode-304-range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode 304 Range Sum Query 2D - Immutable</a><br><a href="https://shineboy2013.github.io/2022/01/04/lee-427/" target="_blank" rel="noopener">LeetCode 427 Construct Quad Tree</a>  </p>
<h2 id="括号题或者字符串运算题"><a href="#括号题或者字符串运算题" class="headerlink" title="括号题或者字符串运算题"></a>括号题或者字符串运算题</h2><p><a href="https://shineboy2013.github.io/2021/12/07/parenthesis/" target="_blank" rel="noopener">括号题或者字符串运算题</a>优先用Stack<br><a href="https://shineboy2013.github.io/2021/12/06/lee-020/" target="_blank" rel="noopener">LeetCode 020 Valid Parentheses</a><br><a href="https://shineboy2013.github.io/2021/12/08/lee-032/" target="_blank" rel="noopener">LeetCode 032 Longest Valid Parentheses</a><br><a href="https://shineboy2013.github.io/2021/12/07/lee-1249/" target="_blank" rel="noopener">LeetCode 1249 Minimum Remove to Make Valid Parentheses</a> 括号下标<br><a href="https://shineboy2013.github.io/2021/12/08/lee-678/" target="_blank" rel="noopener">LeetCode 678 Valid Parenthesis String</a><br><a href="https://shineboy2013.github.io/2021/12/11/lee-022/" target="_blank" rel="noopener">LeetCode 022 Generate Parentheses</a><br><a href="https://shineboy2013.github.io/2021/12/26/lee-071/" target="_blank" rel="noopener">LeetCode 071 Simplify Path</a><br>字符串运算题<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a><br><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a><br><a href="https://shineboy2013.github.io/2021/12/13/lee-394/" target="_blank" rel="noopener">LeetCode 394 Decode String</a>  </p>
<h2 id="游戏题"><a href="#游戏题" class="headerlink" title="游戏题"></a>游戏题</h2><p>数据结构设计 + 模拟<br>[LeetCode 348 Design Tic-Tac-Toe] 设计游戏<br><a href="https://shineboy2013.github.io/2021/12/05/lee-051/" target="_blank" rel="noopener">LeetCode 051 N-Queens</a> 求游戏所有解<br><a href="https://shineboy2013.github.io/2021/12/28/lee-037/" target="_blank" rel="noopener">LeetCode 037 Sudoku Solver</a> 求游戏是否有解  </p>
<h2 id="区间重合题"><a href="#区间重合题" class="headerlink" title="区间重合题"></a>区间重合题</h2><p>条件区间重合且<strong>区间始点有序</strong>。用端点排序法(更常用)或Heap(处理重合情况下的计算)<br><a href="https://shineboy2013.github.io/2018/01/29/lee-253/" target="_blank" rel="noopener">LeetCode 253 Meeting Rooms II</a><br><a href="https://shineboy2013.github.io/2018/01/28/lee-056/" target="_blank" rel="noopener">LeetCode 056 Merge Intervals</a><br><a href="https://shineboy2013.github.io/2021/12/26/lee-759/" target="_blank" rel="noopener">LeetCode 759 Employee Free Time</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-1235/" target="_blank" rel="noopener">LeetCode 1235 Maximum Profit in Job Scheduling</a><br><a href="https://shineboy2013.github.io/2021/12/28/lee-871/" target="_blank" rel="noopener">LeetCode 871 Minimum Number of Refueling Stops</a><br><a href="https://shineboy2013.github.io/2022/01/18/leetcode-218-the-skyline-problem/" target="_blank" rel="noopener">LeetCode 218 The Skyline Problem</a> 端点排序法 + Heap  </p>
<h2 id="所有子串和子数组"><a href="#所有子串和子数组" class="headerlink" title="所有子串和子数组"></a>所有子串和子数组</h2><p>用presum, stack, DP<br><a href="https://shineboy2013.github.io/2021/12/13/lee-560/" target="_blank" rel="noopener">LeetCode 560 Subarray Sum Equals K</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-696/" target="_blank" rel="noopener">LeetCode 696 Count Binary Substrings</a><br><a href="https://shineboy2013.github.io/2021/12/12/lee-907/" target="_blank" rel="noopener">LeetCode 907 Sum of Subarray Minimums</a><br><a href="https://shineboy2013.github.io/2021/12/12/lee-2104/" target="_blank" rel="noopener">LeetCode 2104 Sum of Subarray Ranges</a><br><a href="https://shineboy2013.github.io/2021/12/26/lee-828/" target="_blank" rel="noopener">Leetcode 828 Count Unique Characters of All Substrings of a Given String</a>    </p>
<h2 id="26字母存储法"><a href="#26字母存储法" class="headerlink" title="26字母存储法"></a>26字母存储法</h2><p>条件，若题目含所有字母，且求最值，需要存储每个字母对应的结果<br><a href="https://shineboy2013.github.io/2022/01/01/lee-395/" target="_blank" rel="noopener">LeetCode 395 Longest Substring with At Least K Repeating Characters</a><br><a href="https://shineboy2013.github.io/2021/12/05/lee-1857/" target="_blank" rel="noopener">LeetCode 1857 Largest Color Value in a Directed Graph</a>  </p>
<h2 id="水王法"><a href="#水王法" class="headerlink" title="水王法"></a>水王法</h2><p>candidate取首元素，遍历每一个元素，若candidate不符合条件就换成当前元素为candidate<br><a href="https://shineboy2013.github.io/2022/01/17/leetcode-169-majority-element/" target="_blank" rel="noopener">LeetCode 169 Majority Element</a><br><a href="https://shineboy2013.github.io/2022/01/19/leetcode-277-find-the-celebrity/" target="_blank" rel="noopener">LeetCode 277 Find the Celebrity</a><br><a href="https://shineboy2013.github.io/2021/12/09/lee-134/" target="_blank" rel="noopener">LeetCode 134 Gas Station</a>    </p>
<h2 id="Word相关题目"><a href="#Word相关题目" class="headerlink" title="Word相关题目"></a>Word相关题目</h2><p>DFS: word pattern, word search<br>BFS: word ladder<br>DP: word break  </p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点</title>
    <url>/2017/11/02/kb/</url>
    <content><![CDATA[<p><strong>常用知识点</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">函数名</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">输入参数</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td style="text-align:left">split</td>
<td style="text-align:left">根据输入参数分拆成字符串数组</td>
<td style="text-align:left">String</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">String[] tokens = s.split(“ “);</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">trim</td>
<td style="text-align:left">将前后空格去掉</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">String</td>
<td style="text-align:left">s = s.trim()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">toCharArray</td>
<td style="text-align:left">将字符串变成字符数组</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">char</td>
<td style="text-align:left">char[] a = s.toCharArray()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">charAt</td>
<td style="text-align:left">取某字符</td>
<td style="text-align:left">int</td>
<td style="text-align:left">char</td>
<td style="text-align:left">num1.charAt(i)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">length</td>
<td style="text-align:left">取某字符长度</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int</td>
<td style="text-align:left">num1.length()</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">equals</td>
<td style="text-align:left">判断相等</td>
<td style="text-align:left">String</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">“”.equals(str)</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">substring</td>
<td style="text-align:left">取某字符[beginIdx, endIdx)子串</td>
<td style="text-align:left">int, int</td>
<td style="text-align:left">String</td>
<td style="text-align:left">“smiles”.substring(1,5)-&gt;”mile”</td>
</tr>
<tr>
<td>Integer</td>
<td style="text-align:left">parseInt</td>
<td style="text-align:left">字符串变整型</td>
<td style="text-align:left">String</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer.parseInt(“2”); Integer.parseInt(“100”, 2) -&gt; 4，任意进制数转为10进制。</td>
</tr>
<tr>
<td>Integer</td>
<td style="text-align:left">Integer.MIN_VALUE</td>
<td style="text-align:left">整型最小值</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer.MIN_VALUE</td>
</tr>
<tr>
<td>Integer</td>
<td style="text-align:left">Integer.toString</td>
<td style="text-align:left">整型-&gt;String</td>
<td style="text-align:left">int</td>
<td style="text-align:left">String</td>
<td style="text-align:left">Integer.toString(root.val)</td>
</tr>
<tr>
<td>StringBuilder</td>
<td style="text-align:left">append</td>
<td style="text-align:left">将新字符（串）加入到末尾</td>
<td style="text-align:left">String或char</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">sb.append(“abc”)</td>
</tr>
<tr>
<td>StringBuilder</td>
<td style="text-align:left">new StringBuilder()</td>
<td style="text-align:left">新建这个类当然也将目前字符串清空</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">sb=new StringBuilder()</td>
</tr>
<tr>
<td>StringBuilder</td>
<td style="text-align:left">reverse</td>
<td style="text-align:left">反转</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">StringBuilder</td>
<td style="text-align:left">sb.reverse()</td>
</tr>
<tr>
<td>StringBuilder</td>
<td style="text-align:left">toString</td>
<td style="text-align:left">StringBuilder变成字符串</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">String</td>
<td style="text-align:left">sb.reverse().toString()</td>
</tr>
<tr>
<td>StringBuilder</td>
<td style="text-align:left">deleteCharAt</td>
<td style="text-align:left">StringBuilder删除某字符</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">int</td>
<td style="text-align:left">sb.deleteCharAt(sb.length() - 1);</td>
</tr>
<tr>
<td>Arrays</td>
<td style="text-align:left">length</td>
<td style="text-align:left">数组长度</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">int</td>
<td style="text-align:left">ary.length</td>
</tr>
<tr>
<td>Arrays</td>
<td style="text-align:left">sort</td>
<td style="text-align:left">对数组正(逆)排序</td>
<td style="text-align:left">T[]</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Arrays.sort(nums1); Arrays.sort(nums1,Collections.reverseOrder());  Arrays.sort(nums1,new Comparator<int[]>(){});</int[]></td>
</tr>
<tr>
<td>Arrays</td>
<td style="text-align:left">asList</td>
<td style="text-align:left">包装类型数组转化成List</td>
<td style="text-align:left">T[]</td>
<td style="text-align:left">List</td>
<td style="text-align:left">Arrays.asList(ary), ary为Integer数组或者常量  List: Arrays.asList(“a”, “b”);</td>
</tr>
<tr>
<td>Arrays</td>
<td style="text-align:left">stream</td>
<td style="text-align:left">基本类型数组转化成List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><strong>List<integer> re = Arrays.stream(ints).boxed()   .collect(Collectors.toList())</integer></strong></td>
</tr>
<tr>
<td>Arrays</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><strong>去重</strong></td>
<td style="text-align:left">int[]</td>
<td style="text-align:left">int[]</td>
<td style="text-align:left">Set<integer> set = new HashSet&lt;&gt;(list);set-&gt;int[]</integer></td>
</tr>
<tr>
<td>Collections</td>
<td style="text-align:left">sort</td>
<td style="text-align:left">对List排序</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Collections.sort(list); Collections.sort(l, Collections.reverseOrder());</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">new ArrayList&lt;&gt;()</td>
<td style="text-align:left">新建List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">List</td>
<td style="text-align:left">List<integer> l = new ArrayList&lt;&gt;()</integer></td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">stream</td>
<td style="text-align:left">List转为基本类型数组</td>
<td style="text-align:left">List</td>
<td style="text-align:left">int[]</td>
<td style="text-align:left"><strong>int[] re = l.stream().mapToInt(i-&gt;i).toArray()</strong></td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">stream</td>
<td style="text-align:left">List转为Object类型数组</td>
<td style="text-align:left">List</td>
<td style="text-align:left">Integer[]</td>
<td style="text-align:left">Integer[] re = l.toArray(new Integer[0]);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">add</td>
<td style="text-align:left">把一个元素加入到List l中</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">l.add(“pen”);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">addAll</td>
<td style="text-align:left">把一个List的所有元素加入到另一个中</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">l2.addAll(l);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">get</td>
<td style="text-align:left">返回给定的下标对应的元素</td>
<td style="text-align:left">List</td>
<td style="text-align:left">T</td>
<td style="text-align:left">l.get(2);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">把给定下标的元素从List l中删除</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">l.remove(2);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">把第一个出现的元素从List l中删除</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">l.remove(“pen”);</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">size</td>
<td style="text-align:left">大小</td>
<td style="text-align:left">List</td>
<td style="text-align:left">int</td>
<td style="text-align:left">l.size();</td>
</tr>
<tr>
<td>ArrayList</td>
<td style="text-align:left">reverse</td>
<td style="text-align:left">反转</td>
<td style="text-align:left">List</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Collections.reverse(l);</td>
</tr>
<tr>
<td>LinkedList</td>
<td style="text-align:left">add</td>
<td style="text-align:left">加到末尾</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/a</td>
<td style="text-align:left">ll.add(2);</td>
</tr>
<tr>
<td>LinkedList</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">头部删除</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">ll.remove();</td>
</tr>
<tr>
<td>LinkedList</td>
<td style="text-align:left">addFirst</td>
<td style="text-align:left">加到头部</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">ll.addFirst(2);</td>
</tr>
<tr>
<td>LinkedList</td>
<td style="text-align:left">removeLast</td>
<td style="text-align:left">末尾删除</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">ll.removeLast();</td>
</tr>
<tr>
<td>Queue</td>
<td style="text-align:left">new LinkedList<integer>()</integer></td>
<td style="text-align:left">新建/复制队列</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Queue</td>
<td style="text-align:left">Queue<integer> q = new LinkedList&lt;&gt;(q2)</integer></td>
</tr>
<tr>
<td>Queue</td>
<td style="text-align:left">offer</td>
<td style="text-align:left">不抛异常的加入尾元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">q.offer(5)</td>
</tr>
<tr>
<td>Queue</td>
<td style="text-align:left">poll</td>
<td style="text-align:left">不抛异常的取出头元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">Integer i = q.poll()</td>
</tr>
<tr>
<td>Queue</td>
<td style="text-align:left">peek</td>
<td style="text-align:left">不抛异常的看看头元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">Integer i = q.peek()</td>
</tr>
<tr>
<td>Stack</td>
<td style="text-align:left">new Stack</td>
<td style="text-align:left">新建栈</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Stack</td>
<td style="text-align:left">Stack<integer> s = new Stack&lt;&gt;()</integer></td>
</tr>
<tr>
<td>Stack</td>
<td style="text-align:left">peek</td>
<td style="text-align:left">获取栈顶元素但不出栈</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">Integer i = s.peek()</td>
</tr>
<tr>
<td>Stack</td>
<td style="text-align:left">pop</td>
<td style="text-align:left">获取栈顶元素且出栈</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">T</td>
<td style="text-align:left">Integer i = s.pop()</td>
</tr>
<tr>
<td>Stack</td>
<td style="text-align:left">push</td>
<td style="text-align:left">加入</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">s.push(5)</td>
</tr>
<tr>
<td>Stack</td>
<td style="text-align:left">isEmpty</td>
<td style="text-align:left">是否为空</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">s.isEmpty()</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:left">new HashMap</td>
<td style="text-align:left">新建哈希表</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Map</td>
<td style="text-align:left">Map<character, integer=""> m = new HashMap&lt;&gt;()</character,></td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:left">get</td>
<td style="text-align:left">获取</td>
<td style="text-align:left">T</td>
<td style="text-align:left">T</td>
<td style="text-align:left">m.get(‘a’)</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:left">put</td>
<td style="text-align:left">加入</td>
<td style="text-align:left">T,T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">m.put(‘a’,5)</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:left">containsKey</td>
<td style="text-align:left">是否含有某个key</td>
<td style="text-align:left">T</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">m.containsKey(‘a’)</td>
</tr>
<tr>
<td>HashMap</td>
<td style="text-align:left">get,put</td>
<td style="text-align:left">更新key对应的value</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">m.put(‘a’,m.get(‘a’)+1)</td>
</tr>
<tr>
<td>Map</td>
<td style="text-align:left">Map.of</td>
<td style="text-align:left">Map常量</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Map</td>
<td style="text-align:left">Map.of(2, “abc”, 3, “def”);</td>
</tr>
<tr>
<td>Iterator</td>
<td style="text-align:left">Iterator</td>
<td style="text-align:left">entrySet</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Iterator it = map.entrySet().iterator();</td>
</tr>
<tr>
<td>Iterator</td>
<td style="text-align:left">Iterator</td>
<td style="text-align:left">keySet</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Iterator it = map.keySet().iterator();</td>
</tr>
<tr>
<td>Iterator</td>
<td style="text-align:left">hasNext</td>
<td style="text-align:left">有无下一个元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">while(it.hasNext())</td>
</tr>
<tr>
<td>Iterator</td>
<td style="text-align:left">next</td>
<td style="text-align:left">下一个元素</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Map.Entry pair = (Map.Entry)it.next()</td>
</tr>
<tr>
<td>Map.Entry</td>
<td style="text-align:left">getValue, getKey</td>
<td style="text-align:left">得到key, Value</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">pair.getValue(), pair.getKey()</td>
</tr>
<tr>
<td>HashSet</td>
<td style="text-align:left">new HashSet</td>
<td style="text-align:left">新建哈希集</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">Set</td>
<td style="text-align:left">Set<character> m = new HashSet&lt;&gt;()</character></td>
</tr>
<tr>
<td>HashSet</td>
<td style="text-align:left">add</td>
<td style="text-align:left">加入</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">m.add(‘a’)</td>
</tr>
<tr>
<td>HashSet</td>
<td style="text-align:left">remove</td>
<td style="text-align:left">删除</td>
<td style="text-align:left">T</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">m.remove(‘a’)</td>
</tr>
<tr>
<td>HashSet</td>
<td style="text-align:left">contains</td>
<td style="text-align:left">是否含有某个元素</td>
<td style="text-align:left">T</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">m.contains(‘a’)</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td style="text-align:left">offer,poll,peek</td>
<td style="text-align:left">与Queue相同</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td style="text-align:left">Comparator</td>
<td style="text-align:left">k大小的heap</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">见下</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(k,</span><br><span class="line">				<span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">						<span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>
<p>Arrays的二分法： 若找不到，返回比tgt大的数的下标数组长度的负值-1。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] lis = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(lis, <span class="number">0</span>, len, tgt);</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	index = -index - <span class="number">1</span>;</span><br><span class="line">	lis[index] = tgt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	lis[index] = tgt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 001 Two Sum</title>
    <url>/2018/03/13/lee-001/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode 001 Two Sum</a></strong></p>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong>  </p>
<pre>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字。可以假设题目有唯一解。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol>
<li>最简单的思路是暴力法，两重循环试遍所有组合。</li>
<li>先排序，再用两指针法，若指针指向的数和小于target则左指针右移，反之亦然。注意，为了保持原数组的下标，要预先保留下标及值对到Node中。</li>
<li>遍历数组，同时查看target-该数是否在HashMap中，否则加入到HashMap中。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">			<span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">				<span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">	temp = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">	temp.sort()</span><br><span class="line">	i, j = <span class="number">0</span>, len(temp) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; j:</span><br><span class="line">		<span class="keyword">if</span> temp[i][<span class="number">0</span>] + temp[j][<span class="number">0</span>] &lt; target:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">elif</span> temp[i][<span class="number">0</span>] + temp[j][<span class="number">0</span>] &gt; target:</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> [temp[i][<span class="number">1</span>], temp[j][<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">	nums_dict = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">		<span class="keyword">if</span> target - n <span class="keyword">in</span> nums_dict:</span><br><span class="line">             <span class="keyword">return</span> [nums_dict[target - n], i]</span><br><span class="line">		nums_dict[n] = i</span><br></pre></td></tr></table></figure>
<p>第二种方法，Python的tuple相当于Java的自定义Node，但节省了很多代码。每种方法都大概节省了2/3的代码。  </p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum0(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	<span class="keyword">int</span>[] re = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">				re[<span class="number">0</span>] = i;</span><br><span class="line">				re[<span class="number">1</span>] = j;</span><br><span class="line">				<span class="keyword">return</span> re;</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	Node[] ary = <span class="keyword">new</span> Node[nums.length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		ary[i] = <span class="keyword">new</span> Node(i, nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Arrays.sort(ary, <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">int</span>[] re = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> start=<span class="number">0</span>, end=nums.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ary[start].value+ary[end].value==target)&#123;</span><br><span class="line">			re[<span class="number">0</span>] = ary[start].index;</span><br><span class="line">			re[<span class="number">1</span>] = ary[end].index;</span><br><span class="line">			<span class="keyword">return</span> re;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ary[start].value+ary[end].value&lt;target)</span><br><span class="line">			start++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			end--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	Node(<span class="keyword">int</span> i, <span class="keyword">int</span> v)&#123;</span><br><span class="line">		<span class="keyword">this</span>.index = i;</span><br><span class="line">		<span class="keyword">this</span>.value = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	HashMap&lt;Integer,Integer&gt; h  = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[] re = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		Integer index = h.get(target-nums[i]);</span><br><span class="line">		<span class="keyword">if</span>(index!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			re[<span class="number">0</span>]=index;</span><br><span class="line">			re[<span class="number">1</span>]=i;</span><br><span class="line">			<span class="keyword">return</span> re;</span><br><span class="line">		&#125;</span><br><span class="line">		h.put(nums[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><ol>
<li>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(1)</code>。</li>
<li>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>。</li>
<li>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</li>
</ol>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Interviewer</tag>
        <tag>Python KB</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 002 Add Two Numbers</title>
    <url>/2021/12/12/lee-002/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/add-two-numbers" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p><br><br><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><br><br><p>&nbsp;</p><br><p><strong>Example 1:</strong></p><br><img alt="" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" style="width: 483px; height: 342px;"><br><pre><strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]<br><strong>Output:</strong> [7,0,8]<br><strong>Explanation:</strong> 342 + 465 = 807.<br></pre><br><br><p><strong>Example 2:</strong></p><br><br><pre><strong>Input:</strong> l1 = [0], l2 = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><p><strong>Example 3:</strong></p><br><br><pre><strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br><strong>Output:</strong> [8,9,9,9,0,0,0,1]<br></pre><br><br><p>&nbsp;</p><br><p><strong>Constraints:</strong></p><br><br><ul><br>    <li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><br>    <li><code>0 &lt;= Node.val &lt;= 9</code></li><br>    <li>It is guaranteed that the list represents a number that does not have leading zeros.</li><br></ul><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数位链表(从最低位到最高位)相加</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于merge sort  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>其中一个可能较长，所以主循环出来后还要继续循环较长的链表，类似于merge sort</li>
<li>所有链表遍历完后，carry可能还会是1，要加一个if语句特别处理     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">	fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">	carry = <span class="number">0</span></span><br><span class="line">	it, it2, it_res = l1, l2, fake_head</span><br><span class="line">	<span class="keyword">while</span> it <span class="keyword">or</span> it2:</span><br><span class="line">		value = carry</span><br><span class="line">		<span class="keyword">if</span> it:</span><br><span class="line">			value += it.val</span><br><span class="line">			it = it.next</span><br><span class="line">		<span class="keyword">if</span> it2:</span><br><span class="line">			value += it2.val</span><br><span class="line">			it2 = it2.next</span><br><span class="line">		carry = <span class="number">1</span> <span class="keyword">if</span> value &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">		value %= <span class="number">10</span></span><br><span class="line">		it_res.next = ListNode(value)</span><br><span class="line">		it_res = it_res.next</span><br><span class="line">	<span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">		it_res.next = ListNode(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 003 Longest Substring Without Repeating Characters</title>
    <url>/2021/07/27/lee-003/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode 003 Longest Substring Without Repeating Characters</a></strong></p>
<p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** s = "abcabcbb"
**Output:** 3
**Explanation:** The answer is "abc", with the length of 3.
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** s = "bbbbb"
**Output:** 1
**Explanation:** The answer is "b", with the length of 1.
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** s = "pwwkew"
**Output:** 3
**Explanation:** The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:** s = ""
**Output:** 0
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最长不重复子串。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>HashMap和滑动窗口法，利用HashMap来记录这个窗口中所有字符的下标，该窗口中所有字符都不重复。<br>start_idx表示窗口的左界，而i是右界。左界=上次一次出现该字符的下标和目前左界的较大值，<br>因为Map中的某些字符可能已经不在窗口中，我没有把它从窗口中去掉，而是用start_idx来限制。  </p>
<p>要计算长度就要先计算start_idx，步骤：  </p>
<ol>
<li>计算start_idx  </li>
<li>计算长度  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>start_idx和前值比较，且只有当字符在map中才更新start_idx    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	start_idx, max_len = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	char_map = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] <span class="keyword">in</span> char_map:</span><br><span class="line">			start_idx = max(start_idx, char_map[s[i]] + <span class="number">1</span>)</span><br><span class="line">		max_len = max(max_len, i - start_idx + <span class="number">1</span>)</span><br><span class="line">		char_map[s[i]] = i</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Python KB</tag>
        <tag>String</tag>
        <tag>Sliding window</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 005 Longest Palindromic Substring</title>
    <url>/2021/12/19/lee-005/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “babad”<br><strong>Output:</strong> “bab”<br><strong>Explanation:</strong> “aba” is also a valid answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “cbbd”<br><strong>Output:</strong> “bb”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 1000</code>
</em>   <code>s</code> consist of only digits and English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长回文</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>遍历每个字符，以该字符为中心，往前后比较是否回文，求最长回文  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>回文字符串的中心位可以为1个或2个      </li>
<li>此题求最长回文字符串，而不是其长度  </li>
<li>避免死循环，记得i -= 1, j += 1  </li>
<li>Line 63 <strong>若不相等，要break，或者return[i + 1:j]和下面return一样</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		tmp = self.longestPalindromeFromCenter(s, i, i)</span><br><span class="line">		<span class="keyword">if</span> len(tmp) &gt; len(res):</span><br><span class="line">			res = tmp</span><br><span class="line">		<span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s):</span><br><span class="line">			tmp = self.longestPalindromeFromCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> len(tmp) &gt; len(res):</span><br><span class="line">				res = tmp</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeFromCenter</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">	<span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(s) - <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		left -= <span class="number">1</span></span><br><span class="line">		right += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 006 ZigZag Conversion</title>
    <url>/2018/01/30/lee-006/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/zigzag-conversion" target="_blank" rel="noopener">LeetCode 006 ZigZag Conversion</a></strong></p>
<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre>P   A   H   N
A P L S I I G
Y   I   R
</pre>

<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre>string convert(string text, int nRows);</pre>

<p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>&quot;PAHNAPLSIIGYIR&quot;</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定字符串按如上的“Z”字锯齿形进行按行重排。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是一个周期性的字符串。周期是竖+折（不含首节点）。<br><img src="/images/L006.png" alt=""><br>首节点和竖的最后一点在每周期只会出现一次，其他点会出现两次。<br>T=2&times;numRows-2(因为不含竖节点最后一点+折线上的最后一点属于另一个周期)。nT是有几个周期，即使不完成的周期也算一个。<br>按行遍历（实质是周期上的每个点），再按周期遍历，非顶点有两个需加入到结果中：j&times;T+i,(j+1)&times;T-i。由于周期可能不完成，只要写一个API检查边界且加入字符即可。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>一个字符的字符串。此时T=0.直接返回原字符串。</p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert2</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	<span class="keyword">int</span> T = numRows*<span class="number">2</span>-<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">int</span> nT = (<span class="keyword">int</span>)Math.ceil((s.length()+<span class="number">0.0</span>)/T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nT;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span> || i==numRows-<span class="number">1</span>)</span><br><span class="line">				sb.append(addChar(s, j*T+i));</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				sb.append(addChar(s, j*T+i));</span><br><span class="line">				sb.append(addChar(s, (j+<span class="number">1</span>)*T-i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addChar</span><span class="params">(String s, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	String a = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;s.length())</span><br><span class="line">		<span class="keyword">return</span> s.substring(index, index+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 004 Median of Two Sorted Arrays</title>
    <url>/2018/01/31/lee-004/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">LeetCode 004 Median of Two Sorted Arrays</a></strong></p>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong>Example 1:</strong>  </p>
<pre>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</pre>

<p><strong>Example 2:</strong>  </p>
<pre>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两个有序数组中的中位数。</p>
<h3 id="数值二分法解题思路-推荐-："><a href="#数值二分法解题思路-推荐-：" class="headerlink" title="数值二分法解题思路(推荐)："></a><strong>数值二分法解题思路(推荐)：</strong></h3><p>由于是求中位数或第k小的数，根据题型分类用Heap或binary select。Heap的话，由于是有序，所以优势不大，复杂度为O[(m+n)log2].<br>考虑用binary select，思路比较直接，就是将两个数组看成一个，统计个数的时候由于有序，分别在两数组用二分法统计。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>中位数有1-2两个。用单一元素数组的例子来确定+1还是-1，Line 6  </li>
<li>统计最大最小值，注意空数组  </li>
<li>统计count用bisect不需要+1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">	m, n = len(nums1), len(nums2)</span><br><span class="line">	<span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> self.find_kth_smallest(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> (self.find_kth_smallest(nums1, nums2, (m + n) // <span class="number">2</span>) + self.find_kth_smallest(nums1, nums2, (m + n) // <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">	min_val, min_val2 = nums1[<span class="number">0</span>] <span class="keyword">if</span> nums1 <span class="keyword">else</span> float(<span class="string">'inf'</span>), nums2[<span class="number">0</span>] <span class="keyword">if</span> nums2 <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">	max_val, max_val2 = nums1[<span class="number">-1</span>] <span class="keyword">if</span> nums1 <span class="keyword">else</span> float(<span class="string">'-inf'</span>), nums2[<span class="number">-1</span>] <span class="keyword">if</span> nums2 <span class="keyword">else</span> float(<span class="string">'-inf'</span>)</span><br><span class="line">	start, end, epsilon = min(min_val, min_val2), max(max_val, max_val2), <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = self.count(nums1, nums2, mid)</span><br><span class="line">		<span class="keyword">if</span> k &lt; count:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> k &gt; count:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">return</span> math.floor(end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, nums1, nums2, mid)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> bisect.bisect(nums1, mid) + bisect.bisect(nums2, mid)  <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlog(|hi-lo|/delta))</code>，由于数据大小范围是10^6, 而前面的n是基于全数组扫描，这里用二分法，n变成log(m)+log(n)<br>时间复杂度为<code>O(logm + logn)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="Merge-sort算法II解题思路："><a href="#Merge-sort算法II解题思路：" class="headerlink" title="Merge sort算法II解题思路："></a><strong>Merge sort算法II解题思路：</strong></h3><p>既然是有序，考虑用merge sort中的merge步骤<br>merge sort里面的数组是无序，但这里是有序，所以merge这个步骤可以改进，不是一个个数比较，可以分别取第k/2进行比较，原理是一样的，但效率更高。<br>若num1[k/2] &lt; num2[k/2]相当于nums1[i] &lt;= nums2[j]，此时表示num1[0..k/2]都满足小于等于第k个数的结果数组中。i移位，不是移一位，而是移k/4.<br>这样得到方法三。方法三解释比较难懂，用mergesort模拟较易懂。<br>一般是对数组二分，<strong>此法采用对k二分</strong>  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若i或j用完，返回另一个数组的元素，下标是j+k或i+k，k此时是剩余的k  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays2</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">	m, n = len(nums1), len(nums2)</span><br><span class="line">	<span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> self.find_kth_smallest2(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> (self.find_kth_smallest2(nums1, nums2, (m + n) // <span class="number">2</span>) + self.find_kth_smallest2(nums1, nums2, (m + n) // <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest2</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">	i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(nums1) <span class="keyword">and</span> j &lt; len(nums2) <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i == len(nums1):  <span class="comment"># remember dont use (not nums1)</span></span><br><span class="line">		<span class="keyword">return</span> nums2[j + k]  <span class="comment"># remember use j+k rather than k</span></span><br><span class="line">	<span class="keyword">if</span> j == len(nums2):</span><br><span class="line">		<span class="keyword">return</span> nums1[i + k]</span><br><span class="line">	<span class="keyword">return</span> min(nums1[i], nums2[j])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(m + n)</code>，空间复杂度<code>O(1)</code>。</p>
<hr>
<h3 id="二分法算法III解题思路："><a href="#二分法算法III解题思路：" class="headerlink" title="二分法算法III解题思路："></a><strong>二分法算法III解题思路：</strong></h3><p>将上面的方法换成递归，if判断语句换成递归终止条件，+1变成+k/2，注意判断越界<br>说起来轻松，但非常容易错，不推荐  </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>中位数有1-2两个。</li>
<li>off by 1的问题。递归子函数要用(k+1)//2而不是k//2因为若k=1时候，k//2就不能移动一位。</li>
<li>若nums中i + k // 2越界，不碰nums，右移j，因为nums不能右移那么多, 所以num1赋最大值不是最小值  </li>
<li>终止条件i &gt;= len(nums1)取大于号，跟上面不同，因为可能越界  </li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays3</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">	m, n = len(nums1), len(nums2)</span><br><span class="line">	<span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> self.find_kth_smallest3(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (m + n) // <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		aa = self.find_kth_smallest3(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (m + n) // <span class="number">2</span>)</span><br><span class="line">		bb = self.find_kth_smallest3(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (m + n) // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> (self.find_kth_smallest3(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (m + n) // <span class="number">2</span>)</span><br><span class="line">				+ self.find_kth_smallest3(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, (m + n) // <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest3</span><span class="params">(self, nums1, nums2, i, j, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= len(nums1):  <span class="comment"># remember to use &gt;= rather than ==</span></span><br><span class="line">            <span class="keyword">return</span> nums2[j + k]</span><br><span class="line">        <span class="keyword">if</span> j == len(nums2):</span><br><span class="line">            <span class="keyword">return</span> nums1[i + k]</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[i], nums2[j])</span><br><span class="line">        num1 = nums1[i + k // <span class="number">2</span>] <span class="keyword">if</span> i + k // <span class="number">2</span> &lt; len(nums1) <span class="keyword">else</span> float(<span class="string">'inf'</span>)  <span class="comment"># remember sys.maxsize not minus</span></span><br><span class="line">        num2 = nums2[j + k // <span class="number">2</span>] <span class="keyword">if</span> j + k // <span class="number">2</span> &lt; len(nums2) <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> num1 &lt;= num2:  <span class="comment"># remember the steps are same by moving i and k, k + 1</span></span><br><span class="line">            <span class="keyword">return</span> self.find_kth_smallest3(nums1, nums2, i + (k + <span class="number">1</span>) // <span class="number">2</span>, j, k - (k + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find_kth_smallest3(nums1, nums2, i, j + (k + <span class="number">1</span>) // <span class="number">2</span>, k - (k + <span class="number">1</span>) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p>Java实现  </p>
<p>题目要求log(m+n)复杂度，也就提示要对数组总长做二分法。因为要同时处理两个数组所以考虑用递归版二分法。因奇偶中位数有1-2个，<br>所以加强命题为求两有序数组的第k个数(k&gt;=1)。<br>对k的值进行二分k/2，先尝试num1数组的第k/2个数和num2数组的第k/2个数。若它们相等，表示它们即为第k个数。也就是比如求第4个数，<br>分别在两数组中取前两个，平均分配名额。此题类似于求前k大的数(算法文档4.1.13)用统计个数的方法来判断走左还是右。若它们不等，不妨假设<br>aKey&lt;bKey，这样表示第k个数一定不会是aKey，因为即使比bKey小的数均小于aKey的话（有k/2-1个），总共有k/2-1+k/2-1=k-2个数小于<br>aKey，也就是aKey为第k-1个数，不可能为第k个数，它只可能出现是bKey或者在num1中比aKey大的数。既然aKey不是解，比aKey小的数<br>更不可能是解。所以，可以抛掉num1[0, k/2]这部分，转而求num1[k/2+1,nums.length-1]以及nums2的第k-k/2个数，抛掉部分会影响结果<br>吗？答案是否定的。比如<br>1 2 3 4<br>0 6 7 8<br>k=4，比较2和6,2&lt;6抛掉1 2，转求[3,4],[0,6,7,8]的第2个数，答案仍为3，不影响结果，因为前k/2个数即使有些在nums2也不会影响<br>最后结果，求的是第k个。<br>1 2 3 4<br>0 6 7 8<br>第k=4数可能出现在num1[k/2+1,nums.length-1]=3或num2=6（下面例子），所以保留部分是正确的。<br>主要思路是<strong>每次递归抛掉k/2个数，数组规模减少k/2，k变成k-k/2</strong>, API为left, left2表示新数组的左边界(因为永远抛左边部分)以及k。<br>递归终止条件为</p>
<ol>
<li>left越界，这时此数组的数刚好用完或此数组为空(不会越界太多，否则aKey无穷大会递归到num2)。归结为求另一数组[left..]的第k个数.  </li>
<li>k为1时候，是基本情况，表示求两数组的第1个数，只要返回左端的最小值即可。  </li>
</ol>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>中位数有1-2两个。</li>
<li>off by 1的问题。若API中的k定义为第k个数k&gt;=1，若总长len=5，中位数为第len/2+1=3个数。所以在递归函数中，数组下标用到k时<br>都要-1。抛掉[left, left+k/2-1],递归[left+k/2..]。</li>
<li>若nums中left+k/2-1越界，不碰nums，右移left2，因为nums不能右移那么多。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = num1.length+num2.length;</span><br><span class="line">	<span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>)+findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2, <span class="keyword">int</span> left, <span class="keyword">int</span> left2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;=num1.length)</span><br><span class="line">		<span class="keyword">return</span> num2[left2+k-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(left2&gt;=num2.length)</span><br><span class="line">		<span class="keyword">return</span> num1[left+k-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> Math.min(num1[left], num2[left2]);;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> aKey = left+k/<span class="number">2</span>-<span class="number">1</span>&lt;num1.length?num1[left+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">int</span> bKey = left2+k/<span class="number">2</span>-<span class="number">1</span>&lt;num2.length?num2[left2+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">if</span>(aKey&lt;bKey)</span><br><span class="line">		<span class="keyword">return</span> findKth(num1,num2,left+k/<span class="number">2</span>,left2,k-k/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> findKth(num1,num2,left,left2+k/<span class="number">2</span>, k-k/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>假设两数组总长度为N，k为中位数即N/2，每次抛掉k/2也就是子问题规模为N-k/2=N-N/4=3N/4. f(N)=f(3N/4)+1.<br>利用master理论b=4/3, a=1, f(n)=1代入时间复杂度为<code>O(log(m+n))</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 007 Reverse Integer</title>
    <url>/2021/10/21/lee-007/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode 007 Reverse Integer</a></strong></p>
<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>, then return <code>0</code>.</p>
<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** x = 123
**Output:** 321
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** x = -123
**Output:** -321
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** x = 120
**Output:** 21
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:** x = 0
**Output:** 0
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= x &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>反转整数中的数字。</p>
<h3 id="数学法解题思路："><a href="#数学法解题思路：" class="headerlink" title="数学法解题思路："></a><strong>数学法解题思路：</strong></h3><p>用数学方法每位取余，余数左移。另一种方法是转成字符串然后用字符串反转的方法。  </p>
<p>与Java的区别：  </p>
<ol>
<li>不需要定义long，因为Python3所有int默认都是long  </li>
<li>反转str一行完成，非常简洁  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>负值  </li>
<li>溢出    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">	res, is_negative = <span class="number">0</span>, <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">		is_negative = <span class="keyword">True</span></span><br><span class="line">		x = -x</span><br><span class="line">	<span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">		digit = x % <span class="number">10</span></span><br><span class="line">		res = res * <span class="number">10</span> + digit</span><br><span class="line">		x //= <span class="number">10</span></span><br><span class="line">	<span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> is_negative:</span><br><span class="line">		res = -res</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="字符串法解题思路："><a href="#字符串法解题思路：" class="headerlink" title="字符串法解题思路："></a><strong>字符串法解题思路：</strong></h3><p>转为字符串，然后反转。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">	res, is_negative = <span class="number">0</span>, <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">		is_negative = <span class="keyword">True</span></span><br><span class="line">		x = -x</span><br><span class="line">	res = int(str(x)[::<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> -res <span class="keyword">if</span> is_negative <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><ol>
<li>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。  </li>
<li>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</li>
</ol>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 008 String to Integer (atoi)</title>
    <url>/2022/01/04/lee-008/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).<br><br>The algorithm for <code>myAtoi(string s)</code> is as follows:<br><br>1.  Read in and ignore any leading whitespace.<br>2.  Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.<br>3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.<br>4.  Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).<br>5.  If the integer is out of the 32-bit signed integer range <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2&lt;sup&gt;31&lt;/sup&gt;</code> should be clamped to <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>, and integers greater than <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code> should be clamped to <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br>6.  Return the integer as the final result.<br><br><strong>Note:</strong><br><br><em>   Only the space character <code>&#39; &#39;</code> is considered a whitespace character.
</em>   <strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “42”<br><strong>Output:</strong> 42<br><strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.<br>Step 1: “42” (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: “42” (no characters read because there is neither a ‘-‘ nor ‘+’)<br>         ^<br>Step 3: “<u>42</u>“ (“42” is read in)<br>           ^<br>The parsed integer is 42.<br>Since 42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 42.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “   -42”<br><strong>Output:</strong> -42<br><strong>Explanation:</strong><br>Step 1: “-42” (leading whitespace is read and ignored)<br>            ^<br>Step 2: “   <u>-</u>42” (‘-‘ is read, so the result should be negative)<br>             ^<br>Step 3: “   -<u>42</u>“ (“42” is read in)<br>               ^<br>The parsed integer is -42.<br>Since -42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is -42.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “4193 with words”<br><strong>Output:</strong> 4193<br><strong>Explanation:</strong><br>Step 1: “4193 with words” (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: “4193 with words” (no characters read because there is neither a ‘-‘ nor ‘+’)<br>         ^<br>Step 3: “<u>4193</u> with words” (“4193” is read in; reading stops because the next character is a non-digit)<br>             ^<br>The parsed integer is 4193.<br>Since 4193 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 4193.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= s.length &lt;= 200</code>
</em>   <code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串转整数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>关键是第一位是否符号的判断，之后是ord函数的运用</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>空字符或全空格返回0</li>
<li>[key]<strong>若有符号只能第一位是符号</strong>，连续是符号不合法返回0，如-+12, <strong>将符号处理放在循环外</strong></li>
<li>除符号外，若第一位为非数字，不合法，返回0</li>
<li>循环内，若出现非数字，跳出循环</li>
<li>计算符号，然后检查数字范围</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	s = s.strip()</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	sign = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">		sign = <span class="number">-1</span></span><br><span class="line">		s = s[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">		s = s[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> s[<span class="number">0</span>].isdigit():</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char.isdigit():</span><br><span class="line">			res = res * <span class="number">10</span> + ord(char) - ord(<span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	res *= sign</span><br><span class="line">	<span class="keyword">if</span> res &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">		<span class="keyword">return</span> -pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">	<span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 010 Regular Expression Matching</title>
    <url>/2020/05/10/lee-010/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode 010 Regular Expression Matching</a></strong></p>
<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<pre>'.' Matches any single character.
'*' Matches zero or more of the preceding element.
</pre>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre>**Input:**
s = "aa"
p = "a"
**Output:** false
**Explanation:** "a" does not match the entire string "aa".
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:**
s = "aa"
p = "a*"
**Output:** true
**Explanation:** '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:**
s = "ab"
p = ".*"
**Output:** true
**Explanation:** ".*" means "zero or more (*) of any character (.)".
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:**
s = "aab"
p = "c*a*b"
**Output:** true
**Explanation:** c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
</pre>

<p><strong>Example 5:</strong></p>
<pre>**Input:**
s = "mississippi"
p = "mis*is*p*."
**Output:** false
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>这道求正则表达式匹配的题和那道Leetocde 044 Wildcard Matching很类似，不同点在于*的意义不同，在之前那道题中，<br>*表示可以代替任意个数的不同字符，而这道题中的*表示之前一个字符（同样字符）可以有0-N个匹配。此题更难一些。    </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。两字符串匹配题基本就是DP而且知道子问题答案可以推导下一个。    </p>
<ol>
<li>定义dp[i][j]为字符串s[i-1]和p[j-1]是否能匹配。  </li>
<li>递归式为dp[i][j] = dp[i-1][j-1] &amp;&amp; (p[j-1] == <strong>.</strong> || s[i-1] == p[j-1])<br>OR ((dp[i-1][j] &amp;&amp; <strong>(s[i-1] == p[j-2] || p[j-2] == .)</strong>) || dp[i][<strong>j-2</strong>]) &amp;&amp; p[j-1] == *<br>第一种情况为非*，通配一样字符或.<br>第二种情况为*，如果通配<strong>（有条件：与p的前一个字符相等或p为.）</strong>就是只移动s，dp[i-1][j]。若不通配就只移动p<strong>及其前一个字符</strong>。  </li>
<li>方向为从左到右，从上到下。初始值为dp[0][0] = true。以及若s为空，p为多个*时候，dp[0][j]=true。</li>
</ol>
<p>与Wildcard Matching不同之处用黑体标注了：  </p>
<ol>
<li>用.代替?  </li>
<li>*情况，不匹配p移动两位而不是一位。  </li>
<li>*情况，匹配带条件而不是无条件。  </li>
<li>初始化用dp[0][j-2]而不是j-1。  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归式含*不匹配情况dp[i][j-2]。  </li>
<li>初始化s为空，p为多个*。此情况其实与递归式符合，因为i=1开始，所以i=0的时候，dp[i-1][j]为负值省去，<br>只取dp[i][j-2]。</li>
<li>循环中j按理应该从2开始，因为递归式含p[j-2], 这样要初始化第1列(第0列已经初始化为False)。由于题目条件保证星号前一定有其他字符，所以<strong>p的第0位不能是星号，所以j可以从1开始</strong>   </li>
<li>Python中任何矩阵初始化都只能用两重for循环而不能用乘号</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">	dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range((len(p) + <span class="number">1</span>))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> p[j - <span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>)) <span class="keyword">or</span> (dp[i][j - <span class="number">2</span>])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line">		<span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>) <span class="comment">// remember s="", p="a*"</span></span><br><span class="line">			dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">				dp[i][j] = (dp[i][j-<span class="number">2</span>] || ((s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) </span><br><span class="line">				|| p.charAt(j-<span class="number">2</span>) == <span class="string">'.'</span>) &amp;&amp; dp[i-<span class="number">1</span>][j]));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) </span><br><span class="line">				|| p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[dp.length -<span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*m)</code>，空间复杂度为<code>O(n*m)</code>。</p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 009 Palindrome Number</title>
    <url>/2021/12/22/lee-009/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>x</code>, return <code>true</code> if <code>x</code> is palindrome integer.<br><br>An integer is a <strong>palindrome</strong> when it reads the same backward as forward.<br><br><em>   For example, <code>121</code> is a palindrome while <code>123</code> is not.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 121<br><strong>Output:</strong> true<br><strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = -121<br><strong>Output:</strong> false<br><strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 10<br><strong>Output:</strong> false<br><strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= x &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you solve it without converting the integer to a string?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断是否回文数字</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">return</span> str(x) == str(x)[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>Follow-up 不能用str，就求它的reversed数</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>x是用于计算过程，所以不断变化，最后一行不能用它来与reversed的结果比较  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome2</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	rev, original = <span class="number">0</span>, x</span><br><span class="line">	<span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">		rev = rev * <span class="number">10</span> + x % <span class="number">10</span> <span class="comment"># 121</span></span><br><span class="line">		x = x // <span class="number">10</span> <span class="comment"># 1</span></span><br><span class="line">	<span class="keyword">return</span> rev == original</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 011 Container With Most Water</title>
    <url>/2021/12/20/lee-011/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.<br><br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br><br>Return <em>the maximum amount of water a container can store</em>.<br><br><strong>Notice</strong> that you may not slant the container.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""><br><br><pre><strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49<br><strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> height = [1,1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == height.length</code>
</em>   <code>2 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= height[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两板之间的最大水量</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>贪婪法，求面积，然后移动矮的那条边</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>贪婪法，求面积，然后移动矮的那条边    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	i, j = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; j:</span><br><span class="line">		res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class="line">		<span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 012 Integer to Roman</title>
    <url>/2021/12/23/lee-012/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.<br><br><pre><strong>Symbol</strong>       <strong>Value</strong><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</pre><br><br>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:<br><br><em>   <code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. 
</em>   <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.<br><em>   <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.<br><br>Given an integer, convert it to a roman numeral.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = 3<br><strong>Output:</strong> “III”<br><strong>Explanation:</strong> 3 is represented as 3 ones.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = 58<br><strong>Output:</strong> “LVIII”<br><strong>Explanation:</strong> L = 50, V = 5, III = 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = 1994<br><strong>Output:</strong> “MCMXCIV”<br><strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= num &lt;= 3999</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>阿拉伯数字转罗马数字</p>
<h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>本质上和算法二一样，但优化了代码。map的内容是一样的但变成list保证顺序，然后从大到小遍历这个map，商对应的symbol放入结果，余数进入下一轮  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>map的内容是一样的但变成list保证顺序，然后从大到小遍历这个map，商对应的symbol放入结果，余数进入下一轮   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">	INT_TO_ROMAN = [(<span class="number">1000</span>, <span class="string">'M'</span>), (<span class="number">900</span>, <span class="string">'CM'</span>), (<span class="number">500</span>, <span class="string">'D'</span>), (<span class="number">400</span>, <span class="string">'CD'</span>), (<span class="number">100</span>, <span class="string">'C'</span>),</span><br><span class="line">					(<span class="number">90</span>, <span class="string">'XC'</span>), (<span class="number">50</span>, <span class="string">'L'</span>), (<span class="number">40</span>, <span class="string">'XL'</span>), (<span class="number">10</span>, <span class="string">'X'</span>), (<span class="number">9</span>, <span class="string">'IX'</span>), (<span class="number">5</span>, <span class="string">'V'</span>),</span><br><span class="line">					(<span class="number">4</span>, <span class="string">'IV'</span>), (<span class="number">1</span>, <span class="string">'I'</span>)]</span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> n, symbol <span class="keyword">in</span> INT_TO_ROMAN:</span><br><span class="line">		count, num = num // n, num % n</span><br><span class="line">		res += symbol * count</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code></p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用int to english的递归方法，将固定值放入到Map中  </li>
<li>分界点为[4, 5, 9 10], [40, 50, 90, 100]进行递归     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman2</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">	INT_TO_ROMAN = &#123;</span><br><span class="line">		<span class="number">0</span>: <span class="string">''</span>,</span><br><span class="line">		<span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">		<span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">		<span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">		<span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">		<span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">		<span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">		<span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">		<span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">		<span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">		<span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">		<span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">		<span class="number">1000</span>: <span class="string">'M'</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> num <span class="keyword">in</span> INT_TO_ROMAN:</span><br><span class="line">		<span class="keyword">return</span> INT_TO_ROMAN[num]</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'I'</span> * num</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">9</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">5</span>) + self.intToRoman(num - <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">40</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'X'</span> * (num // <span class="number">10</span>) + self.intToRoman(num % <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">50</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">40</span>) + self.intToRoman(num - <span class="number">40</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">90</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">50</span>) + self.intToRoman(num - <span class="number">50</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">100</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">90</span>) + self.intToRoman(num % <span class="number">90</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">400</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'C'</span> * (num // <span class="number">100</span>) + self.intToRoman(num % <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">500</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">400</span>) + self.intToRoman(num - <span class="number">400</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">900</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">500</span>) + self.intToRoman(num - <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">elif</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">		<span class="keyword">return</span> self.intToRoman(<span class="number">900</span>) + self.intToRoman(num % <span class="number">900</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'M'</span> * (num // <span class="number">1000</span>) + self.intToRoman(num % <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 013 Roman to Integer</title>
    <url>/2021/12/21/lee-013/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.<br><br><pre><strong>Symbol</strong>       <strong>Value</strong><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</pre><br><br>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:<br><br><em>   <code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. 
</em>   <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.<br><em>   <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.<br><br>Given a roman numeral, convert it to an integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “III”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> III = 3.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “LVIII”<br><strong>Output:</strong> 58<br><strong>Explanation:</strong> L = 50, V= 5, III = 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “MCMXCIV”<br><strong>Output:</strong> 1994<br><strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length &lt;= 15</code><br><em>   <code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.
</em>   It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>罗马数组转阿拉伯数字</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按照规则累加。有一个特别规则是需要做减法如IV。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先加再减的方法。  </li>
<li>SYMBOL_TO_VAL的值可以哟用于判断先后顺序。     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	SYMBOL_TO_VAL = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">	res, num, prev = <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> symbol <span class="keyword">in</span> s:</span><br><span class="line">		num = SYMBOL_TO_VAL[symbol]</span><br><span class="line">		<span class="keyword">if</span> prev <span class="keyword">and</span> SYMBOL_TO_VAL[prev] &lt; SYMBOL_TO_VAL[symbol]:</span><br><span class="line">			res -= SYMBOL_TO_VAL[prev] * <span class="number">2</span></span><br><span class="line">		res += num</span><br><span class="line">		prev = symbol</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 014 Longest Common Prefix</title>
    <url>/2021/12/13/lee-014/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Write a function to find the longest common prefix string amongst an array of strings.<br><br>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“flower”,”flow”,”flight”]<br><strong>Output:</strong> “fl”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“dog”,”racecar”,”car”]<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> There is no common prefix among the input strings.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 200</code>
</em>   <code>0 &lt;= strs[i].length &lt;= 200</code><br>*   <code>strs[i]</code> consists of only lower-case English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串列表的最长前缀</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>求最小值len初始值用最大值而不是0  </li>
<li>char = strs[0][i]而不是char = strs[i]   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">	min_len, res = sys.maxsize, <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">		min_len = min(min_len, len(s))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_len):</span><br><span class="line">		char = strs[<span class="number">0</span>][i]</span><br><span class="line">		same_char = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">			<span class="keyword">if</span> char != strs[j][i]:</span><br><span class="line">				same_char = <span class="keyword">False</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> same_char:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		res += char</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 015 3Sum</title>
    <url>/2021/12/05/lee-015/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.<br><br>Notice that the solution set must not contain duplicate triplets.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-1,0,1,2,-1,-4]<br><strong>Output:</strong> [[-1,-1,2],[-1,0,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= nums.length &lt;= 3000</code>
</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>


<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先排序        </li>
<li>结果要去重，用i, j, k指针比较前一个元素，若相等指针移动跳过，k是比较后一个元素  </li>
<li>注意指针移动，等于target两指针都要移动，若与前一元素相等，相应指针移一位，要避免死循环  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		sub_res = self.two_sum(nums, i + <span class="number">1</span>, -nums[i])</span><br><span class="line">		<span class="keyword">for</span> li <span class="keyword">in</span> sub_res:</span><br><span class="line">			res.append([nums[i]] + li)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(self, nums, start, target)</span>:</span></span><br><span class="line">	j, k, res = start, len(nums) - <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">while</span> j &lt; k:</span><br><span class="line">		<span class="keyword">if</span> (j &gt; start <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">or</span> nums[j] + nums[k] &lt; target:</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		<span class="keyword">elif</span> (k &lt; len(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[k] == nums[k + <span class="number">1</span>]) <span class="keyword">or</span> nums[j] + nums[k] &gt; target:</span><br><span class="line">			k -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">elif</span> nums[j] + nums[k] == target:</span><br><span class="line">			res.append([nums[j], nums[k]])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">			k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; re = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> re;</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		twoPointers(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>, -nums[i], re);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoPointers</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; re)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> leftOri = left, rightOri = right;</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">if</span>(left &gt; leftOri &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) &#123;</span><br><span class="line">			left++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(right &lt; rightOri &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">			right--;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums[left] + nums[right] == target) </span><br><span class="line">			re.add(Arrays.asList(-target, nums[left++], nums[right--]));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)</span><br><span class="line">			left++;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			right--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^2)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 016 3Sum Closest</title>
    <url>/2022/01/04/lee-016/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.<br><br>Return <em>the sum of the three integers</em>.<br><br>You may assume that each input would have exactly one solution.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-1,2,1,-4], target = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,0,0], target = 1<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>3 &lt;= nums.length &lt;= 1000</code>
</em>   <code>-1000 &lt;= nums[i] &lt;= 1000</code><br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>三数和最接近target</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>此题不需去重，若等于target可直接返回 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	res = float(<span class="string">'inf'</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; right:</span><br><span class="line">			temp = nums[i] + nums[left] + nums[right]</span><br><span class="line">			<span class="keyword">if</span> abs(temp - target) &lt; abs(res - target):</span><br><span class="line">				res = temp</span><br><span class="line">			<span class="keyword">if</span> temp &lt; target:</span><br><span class="line">				left += <span class="number">1</span></span><br><span class="line">			<span class="keyword">elif</span> temp &gt; target:</span><br><span class="line">				right -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">return</span> target</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 017 Letter Combinations of a Phone Number</title>
    <url>/2021/10/21/lee-017/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">LeetCode 017 Letter Combinations of a Phone Number</a></strong></p>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** digits = "23"
**Output:** ["ad","ae","af","bd","be","bf","cd","ce","cf"]
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** digits = ""
**Output:** []
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** digits = "2"
**Output:** ["a","b","c"]
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>在拨号键盘上按下了几个键，问能打出来的字符串的所有组合是多少。。</p>
<h3 id="递归法解题思路："><a href="#递归法解题思路：" class="headerlink" title="递归法解题思路："></a><strong>递归法解题思路：</strong></h3><p>DFS的典型题目。  </p>
<p>与Java的区别：  </p>
<ol>
<li>直接用Str作为临时结果，不需要用char array，因为str可以含有array的性质  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>输入值为空的情况  </li>
<li>终止条件记得return</li>
<li>用常量  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIGIT2CHAR = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">    <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">    <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">    <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">    <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">    <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">    <span class="string">'9'</span>: <span class="string">'wxyz'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.dfs(digits, <span class="number">0</span>, <span class="string">''</span>, result, DIGIT2CHAR)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, start, path, result, DIGIT2CHAR)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(digits):</span><br><span class="line">            result.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> DIGIT2CHAR[digits[start]]:</span><br><span class="line">            self.dfs(digits, start + <span class="number">1</span>, path + letter, result, DIGIT2CHAR)</span><br></pre></td></tr></table></figure>
<h3 id="迭代法解题思路："><a href="#迭代法解题思路：" class="headerlink" title="迭代法解题思路："></a><strong>迭代法解题思路：</strong></h3><p>第二种方法，用迭代法，三种循环，输入数字串的每个数字，每个数字对应的字符加到当前的结果字符串列表中。 </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>要[‘’]而不是[]否则循环不会进行</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">''</span>:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	result = [<span class="string">''</span>]</span><br><span class="line">	<span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">		result = [s + c <span class="keyword">for</span> s <span class="keyword">in</span> result <span class="keyword">for</span> c <span class="keyword">in</span> DIGIT2CHAR[d]]</span><br><span class="line">	<span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>这是NP问题。时间复杂度为<code>O(<em>4</em><sup>n</sup>)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Python KB</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 018 4Sum</title>
    <url>/2021/12/26/lee-018/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:<br><br><em>   <code>0 &lt;= a, b, c, d &lt; n</code>
</em>   <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.<br><em>   <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code><br><br>You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0<br><strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,2,2,2,2], target = 8<br><strong>Output:</strong> [[2,2,2,2]]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= nums.length &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求四数和等于target。这些数值结果排序后不能重复。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于<a href="https://shineboy2013.github.io/2021/12/05/lee-015/" target="_blank" rel="noopener">3sum</a>，但需要更加一般化。用递归。<strong>不能用求所有笛卡尔积版的Two sum，会TLE</strong>。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>k_sum接口含k_sum(nums, target, k), 基础case为two_sum, 遍历nums每个元素，若重复跳过，将(子数组，target-nums[i], k-1)递归，返回结果拼接  </li>
<li>two_sum也是遇到重复元素跳过，若等于target，要<strong>左右指针均移动</strong>     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	<span class="keyword">return</span> self.k_sum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_sum</span><span class="params">(self, nums, target, k)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> self.two_sum(nums, target)</span><br><span class="line">	<span class="comment"># assume 3 sum</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		sub_res = self.k_sum(nums[i + <span class="number">1</span>:], target - nums[i], k - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> li <span class="keyword">in</span> sub_res:</span><br><span class="line">			res.append([nums[i]] + li)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">	i, j, res = <span class="number">0</span>, len(nums) - <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">while</span> i &lt; j:</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">or</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">elif</span> (j + <span class="number">1</span> &lt; len(nums) <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]) <span class="keyword">or</span> nums[i] + nums[j] &gt; target:</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append([nums[i], nums[j]]) <span class="comment"># remember to use list rather than tuple</span></span><br><span class="line">			i += <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 019 Remove Nth Node From End of List</title>
    <url>/2018/03/17/lee-019/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">LeetCode 019 Remove Nth Node From End of List</a></strong></p>
<p>Given a linked list, remove the <em>n</em><sup>th</sup> node from the end of list and return its head.</p>
<p>For example,</p>
<pre>   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.
</pre>

<p><strong>Note:</strong><br>Given <em>n</em> will always be valid.<br>Try to do this in one pass.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>删除一个单链表末尾开始算起的第n个结点，然后返回该单链表。 例如：<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5 其中n=2；<br>输出： 1-&gt;2-&gt;3-&gt;5;<br>n一定合法，只能遍历一次链表。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。两指针法。距离为N的两指针，当前指针到末尾，后指针即是要删除的节点。头部插入fake节点，类似于mergeIntervals L56末尾插入一个空节点避免特别化处理。</p>
<ol>
<li>快指针从fake节点开始先走n步</li>
<li>慢指针开始一起和快指针同步走，直到快指针到最后一个（next为空）</li>
<li>此时慢指针是要删除指针的上一个，删除操作是可以的。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>因为头指针也可能被删除，如只有一个节点的链表，n=1。删除操作在待删除节点的上一个节点上操作，所以引入假头节点prehead。 </p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">	prehead.next = head;</span><br><span class="line">	</span><br><span class="line">	ListNode slow = prehead, fast = prehead;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		fast = fast.next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">		fast = fast.next;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">	&#125;</span><br><span class="line">	deleteNode(slow);</span><br><span class="line">	<span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode p)</span></span>&#123;</span><br><span class="line">	p.next = p.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。   </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
        <tag>Classic</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 020 Valid Parentheses</title>
    <url>/2021/12/06/lee-020/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.<br><br>An input string is valid if:<br><br>1.  Open brackets must be closed by the same type of brackets.<br>2.  Open brackets must be closed in the correct order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “()”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “()[]{}”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “(]”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> s = “([)]”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong> s = “{[]}”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求给定字符串是否合法括号配对。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>括号题优先考虑用Stack  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空), ‘{]’ (不匹配)    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PARENTHESES_DICT = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'([&#123;'</span>:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                left = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> PARENTHESES_DICT[left] != char:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 021 Merge Two Sorted Lists</title>
    <url>/2021/12/22/lee-021/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.<br><br>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.<br><br>Return <em>the head of the merged linked list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""><br><br><pre><strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]<br><strong>Output:</strong> [1,1,2,3,4,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> list1 = [], list2 = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> list1 = [], list2 = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in both lists is in the range <code>[0, 50]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><em>   Both <code>list1</code> and <code>list2</code> are sorted in <em>*non-decreasing</em></em> order.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>合并两个LL</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Fake Node的引入    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, list1: ListNode, list2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">	it, it2, it_res = list1, list2, fake_head</span><br><span class="line">	<span class="keyword">while</span> it <span class="keyword">and</span> it2:</span><br><span class="line">		<span class="keyword">if</span> it.val &lt;= it2.val:</span><br><span class="line">			it_res.next = it</span><br><span class="line">			it = it.next</span><br><span class="line">			it_res = it_res.next</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			it_res.next = it2</span><br><span class="line">			it2 = it2.next</span><br><span class="line">			it_res = it_res.next</span><br><span class="line">	<span class="keyword">if</span> it:</span><br><span class="line">		it_res.next = it</span><br><span class="line">	<span class="keyword">if</span> it2:</span><br><span class="line">		it_res.next = it2</span><br><span class="line">	<span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 022 Generate Parentheses</title>
    <url>/2021/12/11/lee-022/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [“()”]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 8</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>产生n对括号的所有可能</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS填位法，运用括号定律1： 左括号数 &gt;= 右括号数，也就是左括号剩余数 &lt; 右括号剩余数    </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>复杂度的计算     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(n, n, <span class="string">''</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, left_paren_left, right_paren_left, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> left_paren_left == <span class="number">0</span> <span class="keyword">and</span> right_paren_left == <span class="number">0</span>:</span><br><span class="line">		res.append(path)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> left_paren_left &gt; <span class="number">0</span>:</span><br><span class="line">		path += <span class="string">'('</span></span><br><span class="line">		self.dfs(left_paren_left - <span class="number">1</span>, right_paren_left, path, res)</span><br><span class="line">		path = path[:<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> right_paren_left &gt; <span class="number">0</span> <span class="keyword">and</span> left_paren_left &lt; right_paren_left:</span><br><span class="line">		path += <span class="string">')'</span></span><br><span class="line">		self.dfs(left_paren_left, right_paren_left - <span class="number">1</span>, path, res)</span><br><span class="line">		path = path[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>n个括号，有2n位，时间复杂度为Catalan数<code>O[C(n,2n)/n+1]</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 023 Merge k Sorted Lists</title>
    <url>/2021/12/02/lee-023/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.<br><br><em>Merge all the linked-lists into one sorted linked-list and return it.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]<br><strong>Output:</strong> [1,1,2,3,4,4,5,6]<br><strong>Explanation:</strong> The linked-lists are:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>merging them into one sorted list:<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> lists = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> lists = [[]]<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>k == lists.length</code>
</em>   <code>0 &lt;= k &lt;= 10^4</code><br><em>   <code>0 &lt;= lists[i].length &lt;= 500</code>
</em>   <code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code><br><em>   <code>lists[i]</code> is sorted in <strong>ascending order</strong>.
</em>   The sum of <code>lists[i].length</code> won’t exceed <code>10^4</code>.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>heap不能比较ListNode大小，要实现<strong>lt</strong>函数或者将(node.val, node)对加入到heap中(此法Leetcode有编译错误但PyCharm可过)  </li>
<li>出堆后node的next赋None不需要，因为每个节点next都会重复赋值，而最后一个节点本来也没有next</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> x, y: x.val &lt; y.val</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[Optional[ListNode]])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        heap = []</span><br><span class="line">        fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> head <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                heappush(heap, head)</span><br><span class="line">        it = fake_head</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            node = heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                heappush(heap, node.next)</span><br><span class="line">            <span class="comment"># node.next = None</span></span><br><span class="line">            it.next = node</span><br><span class="line">            it = it.next</span><br><span class="line">        <span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(k)</code>.</p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>Devide and Conquer  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>k.next = None因为删除节点，所以赋None，这句不加也行，但作为良好习惯建议加，且不能在i = i.next前加，否则i会变空。      </li>
<li>查lists是否为空</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists2</span><span class="params">(self, lists: List[List[<span class="string">'ListNode'</span>]])</span> -&gt; 'ListNode':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">return</span> self.merge_sort(lists, <span class="number">0</span>, len(lists) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, lists, start, end)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span> lists[start]</span><br><span class="line">	mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">	li = self.merge_sort(lists, start, mid)</span><br><span class="line">	li2 = self.merge_sort(lists, mid + <span class="number">1</span>, end)</span><br><span class="line">	<span class="keyword">return</span> self.merge_two_lists(li, li2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_lists</span><span class="params">(self, li, li2)</span>:</span></span><br><span class="line">	i, j, res = li, li2, ListNode(<span class="number">0</span>)</span><br><span class="line">	k = res</span><br><span class="line">	<span class="keyword">while</span> i <span class="keyword">and</span> j:</span><br><span class="line">		<span class="keyword">if</span> i.val &lt; j.val:</span><br><span class="line">			k.next = i</span><br><span class="line">			i = i.next</span><br><span class="line">			k = k.next</span><br><span class="line">			k.next = <span class="keyword">None</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			k.next = j</span><br><span class="line">			j = j.next</span><br><span class="line">			k = k.next</span><br><span class="line">			k.next = <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">if</span> i:</span><br><span class="line">		k.next = i</span><br><span class="line">	<span class="keyword">if</span> j:</span><br><span class="line">		k.next = j</span><br><span class="line">	<span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>不管多少次递归，每次递归的一层总的节点数为n，而对k做二分，所以递归数为logk, 时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>.</p>
<hr>
<h3 id="算法III解题思路："><a href="#算法III解题思路：" class="headerlink" title="算法III解题思路："></a><strong>算法III解题思路：</strong></h3><p>算法二的迭代法  </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>输入大小的奇偶处理      </li>
<li>返回值是lists[0]而不是lists</li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists3</span><span class="params">(self, lists: List[List[<span class="string">'ListNode'</span>]])</span> -&gt; 'ListNode':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">while</span> len(lists) &gt; <span class="number">1</span>:</span><br><span class="line">		tmp = []</span><br><span class="line">		<span class="keyword">if</span> len(lists) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">			lists.append([])</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lists), <span class="number">2</span>):</span><br><span class="line">			tmp.append(self.merge_two_lists(lists[i], lists[i + <span class="number">1</span>]))</span><br><span class="line">		lists = tmp</span><br><span class="line">	<span class="keyword">return</span> lists[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>同算法二.</p>
]]></content>
      <tags>
        <tag>Linked List</tag>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
        <tag>Merge Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 032 Longest Valid Parentheses</title>
    <url>/2021/12/08/lee-032/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “(()”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The longest valid parentheses substring is “()”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “)()())”<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The longest valid parentheses substring is “()()”.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “”<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `0 &lt;= s.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>s[i]<code>is</code>‘(‘<code>, or</code>‘)’`.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长括号对数。</p>
<h3 id="Stack算法思路-推荐-："><a href="#Stack算法思路-推荐-：" class="headerlink" title="Stack算法思路(推荐)："></a><strong>Stack算法思路(推荐)：</strong></h3><p>括号题优先考虑用Stack。由于只有单种括号，只需考虑两种不合法情况。<br>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空)<br>难点： 1. <strong>用下标存于stack</strong>，方便计算长度。不合法的保留栈中，这样不合法之间的距离-1就是合法的长度 </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Stack存了左右括号，不只存左括号，所以Line 7要验证栈顶为左括号  </li>
<li>循环后头尾加-1和s长度，方便头尾计算    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">if</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span>:  <span class="comment"># remember</span></span><br><span class="line">				stack.pop()</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				stack.append(i)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># ())(()) # ())</span></span><br><span class="line">	stack.insert(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">	stack.append(len(s))</span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">		index = stack.pop()</span><br><span class="line">		max_len = max(max_len, index - stack[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>答案用max_len    </li>
<li>条件s[i - 1 - dp[i - 1] - 1]和递归式dp[i - dp[i - 1] - 2]不能越界      </li>
<li>递归式要加dp[i - dp[i - 1] - 2]，dp[..]”(“dp..[]”)” 就是第一个递归式，容易忽略     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max -&gt; dp[i-2] + 2 if s[i-2:i] == ()</span></span><br><span class="line"><span class="comment">#             -&gt; dp[i-1] + 2 + dp[i-1-dp[i-1]-2] if s[i-1-dp[i-1]-1]== ( and s[i-1] == )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">	max_len = <span class="number">0</span>  <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">		dp[i] = max(dp[i], dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="keyword">if</span> s[i - <span class="number">2</span>:i] == <span class="string">'()'</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">		prev_dp = <span class="number">0</span>  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">			prev_dp = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line">		<span class="comment"># remember i - 1 - dp[i - 1] - 1 &gt;= 0</span></span><br><span class="line">		dp[i] = max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">2</span> + prev_dp <span class="keyword">if</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">')'</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">		max_len = max(max_len, dp[i])</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="统计算法III解题思路："><a href="#统计算法III解题思路：" class="headerlink" title="统计算法III解题思路："></a><strong>统计算法III解题思路：</strong></h3><p>括号题另一个常用思路是用统计左右括号数。维护四个变量left, right, res, max_len<br>当左括号小于右括号数（第一个规律）：重设全部变量<br>当左括号等于右括号数（第二个规律）：满足两个条件，可以计算res。重设left，right，准备计算下一轮res。不重设res，因为可以连续如()()  </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>上述情况只覆盖了()),不能覆盖((), 因为左括号数在每一位永远都不会等于右括号数。所以旋转180度再做一次。    </li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses3</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	max_len = self.get_max_len(s)</span><br><span class="line">	res = []</span><br><span class="line">	PARENTHESES_DICT = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">')'</span>: <span class="string">'('</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		res.append(PARENTHESES_DICT[char])</span><br><span class="line">	max_len = max(max_len, self.get_max_len(res[::<span class="number">-1</span>]))</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_len</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	max_len = res = left = right = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">			right += <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> left &lt; right:</span><br><span class="line">				left = <span class="number">0</span></span><br><span class="line">				right = <span class="number">0</span></span><br><span class="line">				res = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> left == right:  <span class="comment"># (())), ()()</span></span><br><span class="line">				res += left * <span class="number">2</span></span><br><span class="line">				max_len = max(max_len, res)</span><br><span class="line">				left = <span class="number">0</span></span><br><span class="line">				right = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 031 Next Permutation</title>
    <url>/2021/12/13/lee-031/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.<br><br>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).<br><br>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a></strong> and use only constant extra memory.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> [1,3,2]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1]<br><strong>Output:</strong> [1,2,3]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,5]<br><strong>Output:</strong> [1,5,1]<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 100</code>
</em>   <code>0 &lt;= nums[i] &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>下一个全排列数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>找到从后往前升序的第一个非升序数，如135864的5     </li>
<li>找到从后往前比步骤1中大的数，调换，如6，变成136854</li>
<li>后边部分按升序排列或者做reverse(更高效)</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Python语法问题： reverse子列表，跟倒序遍历数组一样，要指明前后边界，前面边界值更大    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 135864 -&gt; 136854 -&gt; 136458</span></span><br><span class="line"><span class="comment"># 1355864 -&gt; 1356458</span></span><br><span class="line"><span class="comment"># 99</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	to_be_swapped_index, greater_index = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]: <span class="comment"># 5 &lt; 8</span></span><br><span class="line">			to_be_swapped_index = i <span class="comment"># 2</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">if</span> to_be_swapped_index == <span class="number">-1</span>:</span><br><span class="line">		nums.sort()</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, to_be_swapped_index, <span class="number">-1</span>): <span class="comment">#</span></span><br><span class="line">		<span class="keyword">if</span> nums[to_be_swapped_index] &lt; nums[i]: <span class="comment"># 5 &lt; 6</span></span><br><span class="line">			greater_index = i <span class="comment"># 4</span></span><br><span class="line">			<span class="keyword">break</span> <span class="comment"># 136854</span></span><br><span class="line">	nums[to_be_swapped_index], nums[greater_index] = nums[greater_index], nums[to_be_swapped_index]</span><br><span class="line">	<span class="comment"># nums[to_be_swapped_index + 1:] = sorted(nums[to_be_swapped_index + 1:]) # 136458</span></span><br><span class="line">	nums[to_be_swapped_index + <span class="number">1</span>:] = nums[:to_be_swapped_index:<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 033 Search in Rotated Sorted Array</title>
    <url>/2021/12/05/lee-033/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).<br><br>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.<br><br>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.<br><br>You must write an algorithm with <code>O(log n)</code> runtime complexity.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3<br><strong>Output:</strong> -1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [1], target = 0<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 5000</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   All values of <code>nums</code> are <strong>unique</strong>.
</em>   <code>nums</code> is an ascending array that is possibly rotated.<br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>有序数组旋转了几位，求target的下标  </p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>四种情况： 左半有序且target在这个有序区间内，左边有序的所有其他情况，右半有序且target在这个有序区间，右半有序的所有其他情况    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[start] &lt; nums[mid] <span class="keyword">and</span> nums[start] &lt;= target &lt;= nums[mid]:  <span class="comment"># remember</span></span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> nums[start] &lt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">elif</span> nums[mid] &lt; nums[end] <span class="keyword">and</span> nums[mid] &lt;= target &lt;= nums[end]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">if</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid] &gt; nums[start]) &#123; <span class="comment">// the left segment is increasing</span></span><br><span class="line">			<span class="comment">// pay attention to equal </span></span><br><span class="line">			<span class="keyword">if</span>(nums[start] &lt;= target &amp;&amp; target &lt;= nums[mid]) <span class="comment">//the [start, mid] is increasing</span></span><br><span class="line">				end = mid;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				start = mid;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) <span class="comment">// the [mid, end] is increasing</span></span><br><span class="line">				start = mid;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				end = mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(nums[start] == target)</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	<span class="keyword">if</span>(nums[end] == target)</span><br><span class="line">		<span class="keyword">return</span> end;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 034 Find First and Last Position of Element in Sorted Array</title>
    <url>/2022/01/03/lee-034/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.<br><br>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.<br><br>You must write an algorithm with <code>O(log n)</code> runtime complexity.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8<br><strong>Output:</strong> [3,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6<br><strong>Output:</strong> [-1,-1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [], target = 0<br><strong>Output:</strong> [-1,-1]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   <code>nums</code> is a non-decreasing array.
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求有序数列中元素等于target的第一个和最后一个下标</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组为空的情况要返回-1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">	first = self.first_position(nums, target)</span><br><span class="line">	last = self.last_position(nums, target)</span><br><span class="line">	<span class="keyword">return</span> [first, last]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">if</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">if</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start+ (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> nums[start] == target:</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">if</span> nums[end] == target:</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 036 Valid Sudoku</title>
    <url>/2022/01/03/lee-036/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Write a program to solve a Sudoku puzzle by filling the empty cells.<br><br>A sudoku solution must satisfy <strong>all of the following rules</strong>:<br><br>1.  Each of the digits <code>1-9</code> must occur exactly once in each row.<br>2.  Each of the digits <code>1-9</code> must occur exactly once in each column.<br>3.  Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.<br><br>The <code>&#39;.&#39;</code> character indicates empty cells.<br><br><strong>Example 1:</strong><br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br><strong>Output:</strong> [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br><strong>Explanation:</strong> The input board is shown above and the only valid solution is shown below:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""><br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>board.length == 9</code>
</em>   <code>board[i].length == 9</code><br><em>   <code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.
</em>   It is <strong>guaranteed</strong> that the input board has only one solution.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断Sudoku是否合法</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 037，用3个global的dict</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>此题和L37有点不同，可以当版上的数是一个个填上的，所以无需初始化将数直接加入到dict中。而是每一位判断是否合法再加入。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">	row_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">	col_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">	box_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(i, j, board[i][j], row_dict, col_dict, box_dict):</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			row_dict[i][board[i][j]] = <span class="number">1</span></span><br><span class="line">			col_dict[j][board[i][j]] = <span class="number">1</span></span><br><span class="line">			box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][board[i][j]] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, i, j, val, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> val <span class="keyword">in</span> row_dict[i] <span class="keyword">or</span> val <span class="keyword">in</span> col_dict[j] <span class="keyword">or</span> val <span class="keyword">in</span> box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>]:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 037 Sudoku Solver</title>
    <url>/2021/12/28/lee-037/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div>Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy <strong>all of the following rules</strong>: 1. Each of the digits <code>1-9</code> must occur exactly once in each row. 2. Each of the digits <code>1-9</code> must occur exactly once in each column. 3. Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid. The <code>&#39;.&#39;</code> character indicates empty cells. <strong>Example 1:</strong> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br><strong>Output:</strong> [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br><strong>Explanation:</strong> The input board is shown above and the only valid solution is shown below:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""><br></pre><br><br><strong>Constraints:</strong> <em> <code>board.length == 9</code> </em> <code>board[i].length == 9</code> <em> <code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>. </em> It is <strong>guaranteed</strong> that the input board has only one solution.</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>日本游戏。需要保证每行每列每个9个方块的数是1-9里唯一。</p>
<h3 id="Global-dict解题思路-推荐-："><a href="#Global-dict解题思路-推荐-：" class="headerlink" title="Global dict解题思路(推荐)："></a><strong>Global dict解题思路(推荐)：</strong></h3><p>DFS。利用DFS模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用三种全局性dict(row, col, box)来记录所有已填的数，方便dfs时候迅速判断是否合法。这是比算法II优胜的地方。Python中不存在list of set只能用list of dict： [collections.defaultdict(int) for _ in range(len(board))]  </li>
<li><strong>初始化要将棋局上所有已有的数加入到dict中</strong>。一开始是dfs时候才加，但这样填的数不知道后面的格是否已经存在。题意保证有解，所以这些数不需验证重复。    </li>
<li>for循环是1-9是数字但棋盘是字符，所以要<strong>字符和数字转化</strong>，选择统一转成数字，不转的话dict会实效。  </li>
<li>box_dict的id转换： i // 3 * 3 + j // 3 </li>
<li>终止条件为start_x == len(board) - 1 and start_y == len(board[0])   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	row_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))] <span class="comment"># remember</span></span><br><span class="line">	col_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">	box_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">				self.add_to_dict(board, i, j, row_dict, col_dict, box_dict) <span class="comment"># rememeber</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(board, <span class="number">0</span>, <span class="number">0</span>, row_dict, col_dict, box_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		start_x += <span class="number">1</span></span><br><span class="line">		start_y = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict) <span class="comment"># guarantee solution</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(board, k, start_x, start_y, row_dict, col_dict, box_dict):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		board[start_x][start_y] = str(k)</span><br><span class="line">		self.add_to_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line">		<span class="keyword">if</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		self.remove_from_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line">		board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	row_dict[i][int(board[i][j])] = <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">	col_dict[j][int(board[i][j])] = <span class="number">1</span></span><br><span class="line">	box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][int(board[i][j])] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_from_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	row_dict[i].pop(int(board[i][j]))</span><br><span class="line">	col_dict[j].pop(int(board[i][j]))</span><br><span class="line">	box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>].pop(int(board[i][j]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, k, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> k <span class="keyword">in</span> row_dict[i] <span class="keyword">or</span> k <span class="keyword">in</span> col_dict[j] <span class="keyword">or</span> k <span class="keyword">in</span> box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>]: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(9<sup>n*n</sup>)</code>，空间复杂度<code>O(n)</code>，n为边长  </p>
<hr>
<h3 id="常量空间算法II解题思路："><a href="#常量空间算法II解题思路：" class="headerlink" title="常量空间算法II解题思路："></a><strong>常量空间算法II解题思路：</strong></h3><p>我一开始的方法，每填一位就验证。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku2</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs2(board, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, board, start_x, start_y)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">		start_x += <span class="number">1</span></span><br><span class="line">		start_y = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>) <span class="comment"># guarantee solution</span></span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		if self.is_sudoku(board, start_x, start_y):</span></span><br><span class="line"><span class="string">			return self.dfs(board, start_x, start_y + 1)</span></span><br><span class="line"><span class="string">		else:</span></span><br><span class="line"><span class="string">			return False</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">		board[start_x][start_y] = str(k)</span><br><span class="line">		<span class="keyword">if</span> self.is_sudoku2(board, start_x, start_y) <span class="keyword">and</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sudoku2</span><span class="params">(self, board, x, y)</span>:</span></span><br><span class="line">	<span class="comment"># row, # col, # square</span></span><br><span class="line">	<span class="keyword">if</span> self.is_valid(board, x, <span class="number">0</span>, x, len(board[<span class="number">0</span>]) - <span class="number">1</span>) <span class="keyword">and</span> self.is_valid(board, <span class="number">0</span>, y, len(board) - <span class="number">1</span>, y) <span class="keyword">and</span> \</span><br><span class="line">			self.is_valid(board, x // <span class="number">3</span> * <span class="number">3</span>, y // <span class="number">3</span> * <span class="number">3</span>, x // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>, y // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, start_x, start_y, end_x, end_y)</span>:</span></span><br><span class="line">	num_set = set()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start_x, end_x + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(start_y, end_y + <span class="number">1</span>):</span><br><span class="line">			val = board[i][j]</span><br><span class="line">			<span class="keyword">if</span> val == <span class="string">'.'</span>:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> int(val) <span class="keyword">in</span> num_set:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			num_set.add(int(val))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(81<sup>n*n</sup>)</code>，空间复杂度<code>O(1)</code>，n为边长  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
        <tag>Matrix</tag>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 039 Combination Sum</title>
    <url>/2021/12/29/lee-039/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.<br><br>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.<br><br>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> candidates = [2,3,6,7], target = 7<br><strong>Output:</strong> [[2,2,3],[7]]<br><strong>Explanation:</strong><br>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 = 7.<br>These are the only two combinations.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> candidates = [2,3,5], target = 8<br><strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> candidates = [2], target = 1<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= candidates.length &lt;= 30</code>
</em>   <code>1 &lt;= candidates[i] &lt;= 200</code><br><em>   All elements of <code>candidates</code> are <strong>distinct</strong>.
</em>   <code>1 &lt;= target &lt;= 500</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求组合和等于目标。元素可以复用</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用标准组合模板dfs(self, candidates, start, target, path, res)，元素可以复用，所以下一轮递归从i开始</li>
<li>Python中path.pop()没有参数   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	candidates.sort()</span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(candidates, <span class="number">0</span>, target, [], res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, start, target, path, res)</span>:</span> <span class="comment"># [1, 2], 0, 0, [1, 1], [1, 1]</span></span><br><span class="line">	<span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)): <span class="comment"># [2]</span></span><br><span class="line">		path.append(candidates[i]) <span class="comment"># [1,1]</span></span><br><span class="line">		self.dfs(candidates, i, target - candidates[i], path, res)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 040 Combination Sum II</title>
    <url>/2021/12/29/lee-040/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.<br><br>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.<br><br><strong>Note:</strong> The solution set must not contain duplicate combinations.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8<br><strong>Output:</strong><br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> candidates = [2,5,2,1,2], target = 5<br><strong>Output:</strong><br>[<br>[1,2,2],<br>[5]<br>]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= candidates.length &lt;= 100</code>
</em>   <code>1 &lt;= candidates[i] &lt;= 50</code><br>*   <code>1 &lt;= target &lt;= 30</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求组合和等于目标。元素不可复用且结果去重</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>类似于Leetcode 39，有两点不同。要去重，<strong>i &gt; start</strong>并不是i &gt; 0, 且比较前一个元素  </li>
<li>因为元素不可重复，下一轮递归i + 1    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	candidates.sort()</span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(candidates, <span class="number">0</span>, target, [], res)</span><br><span class="line">	<span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, start, target, path, res)</span>:</span> <span class="comment"># [1, 2], 0, 0, [1, 1], [1, 1]</span></span><br><span class="line">	<span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)): <span class="comment"># [2]</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i - <span class="number">1</span>] == candidates[i]:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(candidates[i]) <span class="comment"># [1,1]</span></span><br><span class="line">		self.dfs(candidates, i + <span class="number">1</span>, target - candidates[i], path, res)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 041 First Missing Positive</title>
    <url>/2021/12/16/lee-041/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.<br><br>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,0]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,4,-1,1]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [7,8,9,11,12]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 5 </em> 10<sup>5</sup><code>*</code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找第一个缺失的正整数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于quick sort里面的partition，满足某些条件才移动指针  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>第一个正确元素为1，所以预期数组为[1, 2, 3…]，从1开始并不是从0开始。  </li>
<li>交换元素的条件：需要交换nums[i] != i + 1, 可以交换[1 &lt;= nums[i] &lt;= len(nums)], 不会死循环(nums[nums[i] - 1] != nums[i])    </li>
<li>若满足条件，无限交换，直到不满足条件。不满足条件才移动遍历指针i</li>
<li>交换两元素涉及内嵌数组，所以不能用comment上的。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">		<span class="keyword">if</span> nums[i] != i + <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">			<span class="comment"># nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]</span></span><br><span class="line">			self.swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">	j = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= len(nums):</span><br><span class="line">		<span class="keyword">if</span> j != nums[j - <span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">	nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 043 Multiply Strings</title>
    <url>/2022/01/03/lee-043/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.<br><br><strong>Note:</strong> You must not use any built-in BigInteger library or convert the inputs to integer directly.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num1 = “2”, num2 = “3”<br><strong>Output:</strong> “6”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num1 = “123”, num2 = “456”<br><strong>Output:</strong> “56088”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num1.length, num2.length &lt;= 200</code>
</em>   <code>num1</code> and <code>num2</code> consist of digits only.<br>*   Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number <code>0</code> itself.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串乘法结果</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>模拟小学乘法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>模拟小学乘法，开一个大小为len(num1) + len(num2)的整数数组，内外循环计算每位结果。这位可能是大于20的数，如20, 30..。计算前先反转输入，得到最后结果后也反转。</li>
<li>结果要消除前缀0，但注意<strong>0乘以0的情况会返回空</strong>，所以要特别处理。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">	digits = [<span class="number">0</span>] * (len(num1) + len(num2))</span><br><span class="line">	num1, num2 = num1[::<span class="number">-1</span>], num2[::<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">			digits[i + j] += int(num1[i]) * int(num2[j])</span><br><span class="line">	carry, res = <span class="number">0</span>, <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)):</span><br><span class="line">		n = digits[i] + carry</span><br><span class="line">		carry = n // <span class="number">10</span></span><br><span class="line">		res += str(n % <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'0'</span> <span class="keyword">if</span> res[::<span class="number">-1</span>].lstrip(<span class="string">'0'</span>) == <span class="string">''</span> <span class="keyword">else</span> res[::<span class="number">-1</span>].lstrip(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 042 Trapping Rain Water</title>
    <url>/2018/07/12/lee-042/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="noopener">LeetCode 042 Trapping Rain Water</a></strong></p>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt=""><br><small>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</small></p>
<p><strong>Example:</strong></p>
<pre>**Input:** [0,1,0,2,1,0,1,3,2,1,2,1]
**Output:** 6</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给出 n 个非负整数，代表一张X轴上每个区域宽度为 1 的海拔图, 计算这个海拔图最多能接住多少（面积）雨水。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>画图解题。<br>比较直观的方法是找低谷，只有低谷才可以藏水。用一个递减栈来存所有呈递减趋势的下标，而当上升时就计算藏水量。<br><img src="/images/L042-3.png" alt=""><br>从图可以看出，栈中有最高的，3,2,1，最矮的已经出栈了。蓝色的bar准备入栈。计算水量是水平计算的。具体而言，<br>右边界是确定的，左边界以及高度都是由此bar相邻的在栈中的bar确定的。如1的水量由bar2的高度和位置确定。<br>同理bar2的水量由bar3确定。实质上，是求出栈的元素之间的水量，既然是之间，最后一个出栈就要特殊处理，需要准入栈<br>元素来确定。特殊之处是计算栈中最后一个将要被新bar踢出栈的bar3时，并没有相邻的bar作参考，<br>导致它需要用新bar作为参考，所以它不能在while中处理，需要特别处理，主要因为它是最后一个，属于edge case。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>遍历数组</li>
<li>若比上一个高度递增，出栈直至栈中下标对应高度大于当前高度（保持递减栈）。每次出栈，用上一轮的高度作为底部计算高度差<br>乘以下标距离即为横向藏水增量，更新底部进入下一次出栈。  </li>
<li>出栈完成后，根据新bar计算最后一个bar的水量，用当前高度计算藏水增量。</li>
<li>加入下标到栈中</li>
</ol>
<p>公式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">水量 = 准入栈下标与相邻栈(栈顶)的下标i - stack[-1] - 1 乘以 (相邻栈高度 - 刚出栈高度)</span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>[公式]水量 = 准入栈下标与<strong>相邻栈(栈顶)</strong>的下标i - stack[-1] - 1 乘以 (<strong>相邻栈</strong>高度 - 刚出栈高度)<br>水量的宽度并不是用刚出栈的下标，因为如上图，2-3之间可能实际上不相邻（有些高度已出栈），若用当前栈的下标会忽略了2-3之间的水量。 </li>
<li>最后一个出栈的宽度计算要还有相邻栈(栈顶)i - stack[-1] - 1才计算也就是栈不为空if stack。</li>
<li>最后一个出栈的高度公式要改成相邻栈高度 -&gt; 准入栈高度。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">	stack = []</span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">		j = <span class="number">-1</span></span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[<span class="number">-1</span>]]:</span><br><span class="line">			j = stack.pop()</span><br><span class="line">			<span class="keyword">if</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[<span class="number">-1</span>]]:</span><br><span class="line">				sum += (height[stack[<span class="number">-1</span>]] - height[j]) * (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="comment"># stack[-1] is the neighboring index</span></span><br><span class="line">		<span class="keyword">if</span> stack <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">			sum += (height[i] - height[j]) * (i - stack[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">		stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
<hr>
<h3 id="算法II解题思路-推荐-："><a href="#算法II解题思路-推荐-：" class="headerlink" title="算法II解题思路(推荐)："></a><strong>算法II解题思路(推荐)：</strong></h3><p>算法I主要从面考虑，现在我们从点来考虑。下标4的水量取决于向左最大值（下标0）和向右最大值（下标12）中的较小值。<br>问题转化为求每个点的向左向右最大值。数组从左到右扫描，把当前最大值存入leftHeight中，这是向左最大值。<br><img src="/images/L042-2.png" alt=""><br>同理，数组从又到左扫描，得到向右最大值。对每个点取向左向右最大值的较小者，从而计算水量。此法实现起来简单很多。  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">	max_height = max(height)</span><br><span class="line">	max_index = height.index(max_height)</span><br><span class="line">	sum, left_max, right_max = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(max_index):</span><br><span class="line">		sum += max(<span class="number">0</span>, left_max - height[i])</span><br><span class="line">		left_max = max(left_max, height[i])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(height) - <span class="number">1</span>, max_index, <span class="number">-1</span>):</span><br><span class="line">		sum += max(<span class="number">0</span>, right_max - height[i])</span><br><span class="line">		right_max = max(right_max, height[i])</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
        <tag>Two Pointers</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 044 Wildcard Matching</title>
    <url>/2020/05/10/lee-044/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">LeetCode 044 Wildcard Matching</a></strong></p>
<div><br><br>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.<br><br><pre>‘?’ Matches any single character.<br>‘<em>‘ Matches any sequence of characters (including the empty sequence).<br></em></pre><br><br>The matching should cover the <strong>entire</strong> input string (not partial).<br><br><strong>Note:</strong>

   <code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.<br><em>   <code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>&lt;font face=&quot;monospace&quot;&gt;?&lt;/font&gt;</code> or `</em>`.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ matches any sequence.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong><br>s = “cb”<br>p = “?a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong><br>s = “adceb”<br>p = “<em>a</em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong><br>s = “acdcb”<br>p = “a<em>c?b”<br><em>*Output:</em></em> false<br></pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通配符外卡匹配问题，有特殊字符”*“和”?”，其中”?” 能代替任何字符，”*“能代替任何字符串。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。两字符串匹配题基本就是DP而且知道子问题答案可以推导下一个。    </p>
<ol>
<li>定义dp[i][j]为字符串s[i-1]和p[j-1]是否能匹配。  </li>
<li>递归式为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] &amp;&amp; (p[j-1] == ? || s[i-1] == p[j-1])  if p[j-1] != \* </span><br><span class="line">           dp[i-1][j] || dp[i][j-1]                           if p[j-1] == \*</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第一种情况为非*，通配一样字符或?<br>第二种情况为*，如果通配就是只移动s，dp[i-1][j]。若不通配（通配完）就只移动p。  </p>
<ol>
<li>方向为从左到右，从上到下。初始值为dp[0][0] = true。以及若s为空，p为多个*时候，dp[0][j]=true。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归式含*不匹配情况dp[i][j-1]，容易忽略。  </li>
<li>初始化s为空，p为多个*。根据递归式来写，i=0时，递归式只剩下dp[i][j-1]。将i = 0带入到内外循环代码实现即可(先写内外循环)</li>
<li>模板问题： dp初始化先col再row； i循环到len(dp)而不是len(s); 用到p时候是p[i - 1]而不是p[i]</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">	dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(p) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)] <span class="comment"># remember p then s</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">		<span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">			dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)): <span class="comment"># remember len(dp) not len(s)</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> p[j - <span class="number">1</span>] != <span class="string">'*'</span>: <span class="comment"># remember j-1 not j</span></span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'?'</span>)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归式含*不匹配情况dp[i][j-1]，我写的时候忽略了。  </li>
<li>初始化s为空，p为多个*。此情况其实与递归式符合，因为i=1开始，所以i=0的时候，dp[i-1][j]为负值省去，<br>只取dp[i][j-1]。  </li>
<li>一开始写的corner case并入到递归式处理。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if(s.isEmpty() &amp;&amp; p.isEmpty())</span></span><br><span class="line">		<span class="comment">//return true;</span></span><br><span class="line">	<span class="comment">//if(!s.isEmpty() &amp;&amp; p.isEmpty())</span></span><br><span class="line">		<span class="comment">//return false;</span></span><br><span class="line">	<span class="comment">//if(s.isEmpty() &amp;&amp; !p.isEmpty() &amp;&amp; isAllStars(p))</span></span><br><span class="line">		<span class="comment">//return true;</span></span><br><span class="line">	<span class="comment">//if(s.isEmpty() &amp;&amp; !p.isEmpty())</span></span><br><span class="line">		<span class="comment">//return false;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line">		<span class="comment">// remember empty s can match any prefix *** character in p making sure dp[0][j] = true</span></span><br><span class="line">		<span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">			dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line">			dp[i][j] = (dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; (p.charAt(j-<span class="number">1</span>) == <span class="string">'?'</span> || s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>)))</span><br><span class="line">			<span class="comment">// miss dp[i][j-1] means no match on *</span></span><br><span class="line">			|| ((dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">1</span>]) &amp;&amp; p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>); </span><br><span class="line">	<span class="keyword">return</span> dp[dp.length -<span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*m)</code>，空间复杂度为<code>O(n*m)</code>。</p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 048 Rotate Image</title>
    <url>/2022/01/02/lee-048/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).<br><br>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]<br><strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == matrix.length == matrix[i].length</code>
</em>   <code>1 &lt;= n &lt;= 20</code><br>*   <code>-1000 &lt;= matrix[i][j] &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>顺时针循环矩阵90度</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先上下对称，再沿正对角线(左上到右下)对称。正对角线实现比较容易</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先上下对称，再沿正对角线(左上到右下)对称。正对角线实现比较容易</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix) // <span class="number">2</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">			matrix[i][j], matrix[len(matrix) - <span class="number">1</span> - i][j] = matrix[len(matrix) - <span class="number">1</span> - i][j], matrix[i][j]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(matrix[<span class="number">0</span>])):</span><br><span class="line">			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 045 Jump Game II</title>
    <url>/2021/12/15/lee-045/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.<br><br>Each element in the array represents your maximum jump length at that position.<br><br>Your goal is to reach the last index in the minimum number of jumps.<br><br>You can assume that you can always reach the last index.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,0,1,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>0 &lt;= nums[i] &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>end, next_end分别表示该层和下一层的边界，end从0开始，表示第0个数是第一层，遍历每个数，从0开始。   </li>
<li>这个<strong>边界是inclusive的</strong>，所以当i==end时候，不应该res加1，是下一轮循环才是下一层的开始。有两种实现，我的实现是第一种，标准答案是遍历到最后一个数的前一个，因为最后一个数已经是目标，所以不需要计算next_end，更不需要层数+1。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	update_end = <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> update_end:</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">			update_end = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">if</span> i &lt;= end:</span><br><span class="line">			next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line">		<span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">			end = next_end <span class="comment"># 8</span></span><br><span class="line">			update_end = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> i &lt;= end:</span><br><span class="line">			next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line">		<span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">			end = next_end <span class="comment"># 8</span></span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 049 Group Anagrams</title>
    <url>/2021/12/11/lee-049/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“eat”,”tea”,”tan”,”ate”,”nat”,”bat”]<br><strong>Output:</strong> [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“”]<br><strong>Output:</strong> [[“”]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> strs = [“a”]<br><strong>Output:</strong> [[“a”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>0 &lt;= strs[i].length &lt;= 100</code><br>*   <code>strs[i]</code> consists of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>对同字母不同序单词分组  </p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A   </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>list(id_to_words.values())要转成list     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">	id_to_words = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">		id_to_words[self.get_id(word)].append(word)</span><br><span class="line">	<span class="keyword">return</span> list(id_to_words.values())  <span class="comment"># remember to convert it to list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_id</span><span class="params">(self, word)</span>:</span></span><br><span class="line">	char_to_freq = collections.Counter(word)</span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">		<span class="keyword">if</span> c <span class="keyword">in</span> char_to_freq:</span><br><span class="line">			res += c + str(char_to_freq[c])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(n+m)</code>. n是单词个数，m是单词长度  </p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 050 Pow(x, n)</title>
    <url>/2021/12/21/lee-050/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x&lt;sup&gt;n&lt;/sup&gt;</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = 10<br><strong>Output:</strong> 1024.00000<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 2.10000, n = 3<br><strong>Output:</strong> 9.26100<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = -2<br><strong>Output:</strong> 0.25000<br><strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-100.0 &lt; x &lt; 100.0</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= n &lt;= 2&lt;sup&gt;31&lt;/sup&gt;-1</code><br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= x&lt;sup&gt;n&lt;/sup&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求幂</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>保存dfs(x, n/2)的临时结果，避免重复计算   </li>
<li>n可以是0，负数 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">	<span class="keyword">if</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs(x, n)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> self.dfs(<span class="number">1</span> / x, -n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		tmp = self.dfs(x, n / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> tmp * tmp</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		tmp = self.dfs(x, (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> tmp * tmp * x</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Facebook</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 051 N-Queens</title>
    <url>/2021/12/05/lee-051/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p><br><br><p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p><br><br><p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>‘Q’</code> and <code>‘.’</code> both indicate a queen and an empty space, respectively.</p><br><br><p>&nbsp;</p><br><p><strong>Example 1:</strong></p><br><img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;"><br><pre><strong>Input:</strong> n = 4<br><strong>Output:</strong> [[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br><strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above<br></pre><br><br><p><strong>Example 2:</strong></p><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [[“Q”]]<br></pre><br><br><p>&nbsp;</p><br><p><strong>Constraints:</strong></p><br><br><ul><br>    <li><code>1 &lt;= n &lt;= 9</code></li><br></ul><br></div>


<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>八皇后问题，求所有解</p>
<h3 id="Global-dict算法思路-推荐-："><a href="#Global-dict算法思路-推荐-：" class="headerlink" title="Global dict算法思路(推荐)："></a><strong>Global dict算法思路(推荐)：</strong></h3><p>DFS填位法模板  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用3个set，col_set, 对角线，反对角线set来提高效率。   </li>
<li>path用append的方法加入，这样终止条件用n来比较，不能用len(path)  </li>
<li>打印函数中，one_result在每轮后reset；字符串不能改其中一个，只能用子串+Q+子串： (‘.’ <em> path[i]) + ‘Q’ + (‘.’ </em> (n - path[i] - 1)) </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">	res, path = [], []</span><br><span class="line">	self.dfs(n, <span class="number">0</span>, path, res, set(), set(), set())</span><br><span class="line">	result = self.convert(res)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, start, path, res, col_set, diag_set, anti_diag_set)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start == n: <span class="comment"># remember not len(path)</span></span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment"># 4</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(start, i, col_set, diag_set, anti_diag_set):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(i)  <span class="comment"># [0, 2]</span></span><br><span class="line">		col_set.add(i)</span><br><span class="line">		diag_set.add(start - i)</span><br><span class="line">		anti_diag_set.add(start + i)</span><br><span class="line">		self.dfs(n, start + <span class="number">1</span>, path, res, col_set, diag_set, anti_diag_set)</span><br><span class="line">		anti_diag_set.remove(start + i)</span><br><span class="line">		diag_set.remove(start - i)</span><br><span class="line">		col_set.remove(i)</span><br><span class="line">		path.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, i, val, col_set, diag_set, anti_diag_set)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> val <span class="keyword">in</span> col_set <span class="keyword">or</span> i - val <span class="keyword">in</span> diag_set <span class="keyword">or</span> i + val <span class="keyword">in</span> anti_diag_set:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(n^2)</code></p>
<hr>
<h3 id="常数空间算法II解题思路-推荐-："><a href="#常数空间算法II解题思路-推荐-：" class="headerlink" title="常数空间算法II解题思路(推荐)："></a><strong>常数空间算法II解题思路(推荐)：</strong></h3><p>较直观的方法，但复杂度稍差  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens2</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">	res, path = [], []</span><br><span class="line">	self.dfs2(n, <span class="number">0</span>, path, res)</span><br><span class="line">	result = self.convert(res)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, n, start, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start == n: <span class="comment"># remember not len(path)</span></span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment"># 4</span></span><br><span class="line">		path.append(i) <span class="comment"># [0, 2]</span></span><br><span class="line">		<span class="keyword">if</span> self.is_valid2(path):</span><br><span class="line">			self.dfs2(n, start + <span class="number">1</span>, path, res)</span><br><span class="line">		path.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid2</span><span class="params">(self, path)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(path) != len(set(path)):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(path)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(path)):</span><br><span class="line">			<span class="comment">#if i == j:</span></span><br><span class="line">			 <span class="comment">#   continue</span></span><br><span class="line">			<span class="keyword">if</span> abs(i - j) == abs(path[i] - path[j]):</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, res)</span>:</span></span><br><span class="line">	result, one_result = [], []</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(len(res)):</span><br><span class="line">		one_result = [] <span class="comment"># remember</span></span><br><span class="line">		path = res[k]</span><br><span class="line">		n = len(path)</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">			s = (<span class="string">'.'</span> * path[i]) + <span class="string">'Q'</span> + (<span class="string">'.'</span> * (n - path[i] - <span class="number">1</span>))  <span class="comment"># remember not s[path[i]] = 'Q'</span></span><br><span class="line">			one_result.append(s)</span><br><span class="line">		result.append(one_result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	solveR(n, col, <span class="number">0</span>, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5/2/2020</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveR</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] col, <span class="keyword">int</span> st, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st == n) &#123;</span><br><span class="line">		print(col, res);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		col[st] = i;</span><br><span class="line">		<span class="keyword">if</span>(isValid(col, st))</span><br><span class="line">			solveR(n, col, st + <span class="number">1</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] col, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(col[i] == col[k])</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Math.abs(k - i) == Math.abs(col[k] - col[i])) <span class="comment">//use abs</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(n^2)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 053 Maximum Subarray</title>
    <url>/2021/12/11/lee-053/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.<br><br>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> [4,-1,2,1] has the largest sum = 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [5,4,-1,7,8]<br><strong>Output:</strong> 23<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最大子数组和</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>dp[i] = max(dp[i-1] + nums[i], nums[i])    </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>引入全局最大的res，因为递归式是以末位为结尾的最大和   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max(dp[i-1] + nums[i], nums[i])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	sum, res = -sys.maxsize, -sys.maxsize</span><br><span class="line">	<span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">		<span class="keyword">if</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">			sum += num</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			sum = num</span><br><span class="line">		res = max(sum, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 054 Spiral Matrix</title>
    <url>/2018/02/22/lee-054/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/spiral-matrix" target="_blank" rel="noopener">LeetCode 054 Spiral Matrix</a></strong></p>
<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<pre>[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</pre>

<p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个mxn的矩阵（m行 n列），以螺旋状返回矩阵中的所有元素。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>打印方法主要是以下两种：第一种四边对称打印，实现起来边际情况很多，不推荐。因为要不断向内遍历，所以对称打印不合适。第二种方法是每条边比上一条少一个，<br>用四个指针，top, bottom, left, right来记录四个边界，每打印完一条边该边界向内扩展。注意有些回路不是完整比如[1,2]或上面例子中5就不是完整回路，此情况，<br>注意判断top和bottom以及left和right关系即可。四指针法可以进一步升级到两指针法甚至一个指针法，其实都是大同小异。<br><img src="/images/L054.png" alt=""></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意不是所有矩阵都有完整回路。所以后两个for循环要加if语句  </li>
<li>右边和左边，遍历矩阵用matrix[i][right]，而不是matrix[right][i]</li>
<li>Python中从后往前遍历要注意始点-1，range(right, left - 1, -1):</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res = []</span><br><span class="line">	top, bottom, left, right = <span class="number">0</span>, len(matrix) - <span class="number">1</span>, <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> top &lt;= bottom <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">			res.append(matrix[top][i])</span><br><span class="line">		top += <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(top, bottom + <span class="number">1</span>):</span><br><span class="line">			res.append(matrix[i][right])  <span class="comment"># remember [i[[right] not [right][i]</span></span><br><span class="line">		right -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> top &lt;= bottom:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(right, left - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">				res.append(matrix[bottom][i])</span><br><span class="line">			bottom -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> left &lt;= right:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(bottom, top - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">				res.append(matrix[i][left])</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiral2</span><span class="params">(<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rowTop = <span class="number">0</span>, rowBottom = a.length-<span class="number">1</span>, colLeft = <span class="number">0</span>, colRight = a[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(rowTop&lt;=rowBottom &amp;&amp; colLeft&lt;=colRight)&#123;</span><br><span class="line">		<span class="comment">//topRow</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=colLeft;i&lt;=colRight;i++)</span><br><span class="line">			System.out.print(a[rowTop][i]+<span class="string">" "</span>);</span><br><span class="line">		rowTop++;</span><br><span class="line">		<span class="comment">//rightCol</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=rowTop;i&lt;=rowBottom;i++)</span><br><span class="line">			System.out.print(a[i][colRight]+<span class="string">" "</span>);</span><br><span class="line">		colRight--;</span><br><span class="line">		<span class="keyword">if</span>(rowTop&lt;=rowBottom)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=colRight;i&gt;=colLeft;i--)</span><br><span class="line">				System.out.print(a[rowBottom][i]+<span class="string">" "</span>);</span><br><span class="line">			rowBottom--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(colLeft&lt;=colRight)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=rowBottom;i&gt;=rowTop;i--)</span><br><span class="line">				System.out.print(a[i][colLeft]+<span class="string">" "</span>);</span><br><span class="line">			colLeft++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiral3</span><span class="params">(<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rowTop = <span class="number">0</span>, colLeft = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(rowTop&lt;=a.length-rowTop-<span class="number">1</span> &amp;&amp; colLeft&lt;=a[<span class="number">0</span>].length-colLeft-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//topRow</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=colLeft;i&lt;=a[<span class="number">0</span>].length-colLeft-<span class="number">1</span>;i++)</span><br><span class="line">			System.out.print(a[rowTop][i]+<span class="string">" "</span>);</span><br><span class="line">		rowTop++;</span><br><span class="line">		<span class="comment">//rightCol</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=rowTop;i&lt;=a.length-rowTop;i++)</span><br><span class="line">			System.out.print(a[i][a[<span class="number">0</span>].length-colLeft-<span class="number">1</span>]+<span class="string">" "</span>);</span><br><span class="line">		<span class="comment">//colRight--;</span></span><br><span class="line">		<span class="keyword">if</span>(rowTop&lt;=a.length-rowTop)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=a[<span class="number">0</span>].length-colLeft-<span class="number">2</span>;i&gt;=colLeft;i--)</span><br><span class="line">				System.out.print(a[a.length-rowTop][i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(colLeft&lt;=a[<span class="number">0</span>].length-colLeft-<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-rowTop-<span class="number">1</span>;i&gt;=rowTop;i--)</span><br><span class="line">				System.out.print(a[i][colLeft]+<span class="string">" "</span>);</span><br><span class="line">			colLeft++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiral4</span><span class="params">(<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = Math.min(a.length, a[<span class="number">0</span>].length);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> st=<span class="number">0</span>;st&lt;(num+<span class="number">1</span>)/<span class="number">2</span>;st++)&#123;</span><br><span class="line">		<span class="comment">//complete edge(top)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=st;i&lt;a[<span class="number">0</span>].length-st;i++)</span><br><span class="line">			System.out.print(a[st][i]+<span class="string">" "</span>);</span><br><span class="line">		<span class="comment">//complete edge-top (right)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=st+<span class="number">1</span>;i&lt;a.length-st;i++)</span><br><span class="line">			System.out.print(a[i][a[<span class="number">0</span>].length-<span class="number">1</span>-st]+<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>].length-<span class="number">2</span>-st&gt;st)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=a[<span class="number">0</span>].length-<span class="number">2</span>-st;i&gt;=st;i--)</span><br><span class="line">				System.out.print(a[a.length-st-<span class="number">1</span>][i]+<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">if</span>(a.length-<span class="number">2</span>-st&gt;st+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">2</span>-st;i&gt;=st+<span class="number">1</span>;i--)</span><br><span class="line">				System.out.print(a[i][st]+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(mn)</code>，空间复杂度<code>O(1)</code>。   </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Interviewer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 055 Jump Game</title>
    <url>/2021/12/15/lee-055/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.<br><br>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1,0,4]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>0 &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>参考Jump game II，区别在于如果i &lt;= end才更新，</li>
<li>返回next_end要大于等于(可以cover)最后一个元素下标  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">	end, next_end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> i &lt;= end:</span><br><span class="line">			next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line">		<span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">			end = next_end <span class="comment"># 8</span></span><br><span class="line">	<span class="keyword">return</span> next_end &gt;= len(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 056 Merge Intervals</title>
    <url>/2018/01/28/lee-056/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-interval" target="_blank" rel="noopener">LeetCode 056 Merge Intervals</a></strong></p>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>return <code>[1,6],[8,10],[15,18]</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定几个区间，要求合并重叠区间，返回结果.</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>A公司的考题。这条题难点在于判断是否合并，怎么合并，新区间合并多个区间。</p>
<ol>
<li>按start排序。</li>
<li>定义API：如何合并两个区间（两情况），两个区间是否可以合并</li>
<li>遍历每个区间，产生新区间并将其带入到下一轮循环。这是难点，公式为 新区间=新区间+输入区间[i]，这也分为两种情况，可合并和不可合并<br>不可合并时，前状态的新区间成为结果，公式为新区间=输入区间[i]。  </li>
<li>若不想特别处理循环边界，可加入空区间到末尾（见Java实现，它把新区间=输入区间[i]放入了下一轮）。若不如此做，可将空区间放入开头。  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先按左节点排序  </li>
<li>区间的右端与另一个区间的左端一样，也算重叠，如[1,2],[2,3]。</li>
<li>原输入加入首节点的左边界fake区间。避免for循环的特殊处理。2. 最后一个区间的情况。</li>
<li>合并后生成新区间，要与下一个继续尝试合并。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">	new_interval = [intervals[<span class="number">0</span>][<span class="number">0</span>], intervals[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">		<span class="keyword">if</span> self.can_merge(new_interval, interval):</span><br><span class="line">			new_interval = self.merge_two_intervals(new_interval, interval)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(new_interval)</span><br><span class="line">			new_interval = interval</span><br><span class="line">	res.append(new_interval)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_merge</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> interval[<span class="number">1</span>] &gt;= interval2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_intervals</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [interval[<span class="number">0</span>], max(interval[<span class="number">1</span>], interval2[<span class="number">1</span>])]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">	Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval v1, Interval v2)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> v1.start - v2.start;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	intervals.add(<span class="keyword">new</span> Interval(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br><span class="line">	List&lt;Interval&gt; re = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">	Interval newInterval = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(newInterval==<span class="keyword">null</span>)</span><br><span class="line">			newInterval = intervals.get(i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(canMerge(newInterval,intervals.get(i)))&#123;</span><br><span class="line">			newInterval = mergeIntervals(newInterval,intervals.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			re.add(newInterval);</span><br><span class="line">			newInterval = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设in与in2按start排序，所以只有两情况：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In  -------</span></span><br><span class="line"><span class="comment"> * In2   ---</span></span><br><span class="line"><span class="comment"> * In2   -------- </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(in2.start == Integer.MAX_VALUE)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> in.end&gt;=in2.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Interval <span class="title">mergeIntervals</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Interval(in.start, Math.max(in.end, in2.end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 057 Insert Interval</title>
    <url>/2018/01/29/lee-057/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/insert-interval" target="_blank" rel="noopener">LeetCode 057 Insert Interval</a></strong></p>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>对于给出的互不重叠且按照左端点排序的区间序列，将一个新的区间插入到这个序列当中（合并重叠的区间），使其仍然保持原本的性质。</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	intervals.append(newInterval)</span><br><span class="line">	intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">	new_interval = [intervals[<span class="number">0</span>][<span class="number">0</span>], intervals[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">		<span class="keyword">if</span> self.can_merge(new_interval, interval):</span><br><span class="line">			new_interval = self.merge_two_intervals(new_interval, interval)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(new_interval)</span><br><span class="line">			new_interval = interval</span><br><span class="line">	res.append(new_interval)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_merge</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> interval[<span class="number">1</span>] &gt;= interval2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_intervals</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [interval[<span class="number">0</span>], max(interval[<span class="number">1</span>], interval2[<span class="number">1</span>])]</span><br></pre></td></tr></table></figure>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>与L56题基本一致，但单元测试更加严格，加入含最大整数值的区间。</p>
<ol>
<li>先找到start大于等于待插入区间的区间，然后待插入区间插入其前。</li>
<li>归结成L56题</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先找到start大于等于待插入区间的区间，然后待插入区间插入其前。</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> j &lt; len(intervals):</span><br><span class="line">		<span class="keyword">if</span> intervals[j][<span class="number">0</span>] &gt;= newInterval[<span class="number">0</span>]:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	intervals.insert(j, newInterval)</span><br><span class="line"></span><br><span class="line">	new_interval = [intervals[<span class="number">0</span>][<span class="number">0</span>], intervals[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">		<span class="keyword">if</span> self.can_merge(new_interval, interval):</span><br><span class="line">			new_interval = self.merge_two_intervals(new_interval, interval)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(new_interval)</span><br><span class="line">			new_interval = interval</span><br><span class="line">	res.append(new_interval)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_merge</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> interval[<span class="number">1</span>] &gt;= interval2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_intervals</span><span class="params">(self, interval, interval2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [interval[<span class="number">0</span>], max(interval[<span class="number">1</span>], interval2[<span class="number">1</span>])]</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>判断是否合并的API中，加入in2.start == Integer.MAX_VALUE返回false。</p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;st&lt;intervals.size();st++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(intervals.get(st).start&gt;=newInterval.start)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	intervals.add(st, newInterval);</span><br><span class="line">	</span><br><span class="line">	intervals.add(<span class="keyword">new</span> Interval(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br><span class="line">	List&lt;Interval&gt; re = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">	Interval newInterval2 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(newInterval2==<span class="keyword">null</span>)</span><br><span class="line">			newInterval2 = intervals.get(i-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(canMerge(newInterval2,intervals.get(i)))&#123;</span><br><span class="line">			newInterval2 = mergeIntervals(newInterval2,intervals.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			re.add(newInterval2);</span><br><span class="line">			newInterval2 = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，因为不用排序。</p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol>
<li>先解出L56</li>
<li>再解此题</li>
</ol>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Interviewer</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 062 Unique Paths</title>
    <url>/2022/01/05/lee-062/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.<br><br>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.<br><br>The test cases are generated so that the answer will be less than or equal to <code>2 * 10&lt;sup&gt;9&lt;/sup&gt;</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""><br><br><pre><strong>Input:</strong> m = 3, n = 7<br><strong>Output:</strong> 28<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> m = 3, n = 2<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:<br>1. Right -&gt; Down -&gt; Down<br>2. Down -&gt; Down -&gt; Right<br>3. Down -&gt; Right -&gt; Down<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= m, n &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求矩阵路径总数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值dp[1] = 1而不是dp[0] = 1因为第二行的第一格不能加左边的虚拟格=1</li>
<li>range(m)不是range(len(m))</li>
<li>优化空间用一维</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># remember not dp[0] = 1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m): <span class="comment"># remember no len(m)</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">			dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code> </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 063 Unique Paths II</title>
    <url>/2022/01/05/lee-063/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A robot is located at the top-left corner of a <code>m x n</code> grid (marked ‘Start’ in the diagram below).<br><br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br><br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br><br>An obstacle and space is marked as <code>1</code> and <code>0</code> respectively in the grid.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt=""><br><br><pre><strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:<br>1. Right -&gt; Right -&gt; Down -&gt; Down<br>2. Down -&gt; Down -&gt; Right -&gt; Right<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt=""><br><br><pre><strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == obstacleGrid.length</code>
</em>   <code>n == obstacleGrid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 100</code>
</em>   <code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求矩阵路径总数。有障碍</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1] if obstacle[i][j-1] == 0</span><br><span class="line">         = 0                       if obstacle[i][j-1] == 1</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>obstacleGrid[i][j-1], j-1因为dp从1开始, 但i不是，因为dp不含i。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (len(obstacleGrid[<span class="number">0</span>]) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">			<span class="keyword">if</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">				dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 064 Minimum Path Sum</title>
    <url>/2022/01/05/lee-064/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.<br><br><strong>Note:</strong> You can only move either down or right at any point in time.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,2,3],[4,5,6]]<br><strong>Output:</strong> 12<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code>
</em>   <code>0 &lt;= grid[i][j] &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求矩阵最短路径和。只能向下向右走。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值为最大值，dp[0][1] = dp[1][0] = 0确保左上格正确。</li>
<li>模板四点注意事项  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid) + <span class="number">1</span>)]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 065 Valid Number</title>
    <url>/2022/01/13/lee-065/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A <strong>valid number</strong> can be split up into these components (in order):<br><br>1.  A <strong>decimal number</strong> or an <strong>integer</strong>.<br>2.  (Optional) An <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code>, followed by an <strong>integer</strong>.<br><br>A <strong>decimal number</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One of the following formats:<br>    1.  One or more digits, followed by a dot <code>&#39;.&#39;</code>.<br>    2.  One or more digits, followed by a dot <code>&#39;.&#39;</code>, followed by one or more digits.<br>    3.  A dot <code>&#39;.&#39;</code>, followed by one or more digits.<br><br>An <strong>integer</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One or more digits.<br><br>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code>, while the following are not valid numbers: <code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>valid number</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “0”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “e”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “.”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 20</code>
</em>   <code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求合法小数指数形式</p>
<h3 id="类括号法解题思路-推荐-："><a href="#类括号法解题思路-推荐-：" class="headerlink" title="类括号法解题思路(推荐)："></a><strong>类括号法解题思路(推荐)：</strong></h3><p>有四种symbol，要保证先后关系。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li><p>先写基本框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	seen_sign, seen_num, seen_exp, seen_dot = <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char = <span class="string">'+-'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_sign:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_sign = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line"></span><br><span class="line">			seen_num = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_exp:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_exp = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">elif</span> char == <span class="string">'.'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_dot:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_dot = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>if语句加入前面字符不能出现什么，每种其他字符过一遍。还有字符必须出现什么，此情况只有一种： e字符前必须有数字</p>
</li>
<li>for循环后return语句检查单个字符</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>有四种symbol： 符号，数字，dot，exp。保证先后关系。<strong>exp的前后部分是独立的，唯一区别是后部分不能有dot</strong>，如1e2.2</li>
<li>实现类似于括号题用if语句来分别处理每种symbol：前面不能出现什么符号(<strong>e后面不能出现小数</strong>，也就是小数前面不能出现e)，或必须出现什么符号(仅一种情况：<strong>e前面必须出现数字</strong>)，如1e2. 然后该符号赋True</li>
<li>for循环后检查单个字符且不含数字情况<br>见解题步骤</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	seen_sign, seen_num, seen_exp, seen_dot = <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_sign <span class="keyword">or</span> seen_num <span class="keyword">or</span> seen_dot:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_sign = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line">			seen_num = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_exp <span class="keyword">or</span> <span class="keyword">not</span> seen_num:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_exp = <span class="keyword">True</span></span><br><span class="line">			seen_sign = <span class="keyword">False</span></span><br><span class="line">			seen_num = <span class="keyword">False</span></span><br><span class="line">			seen_dot = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">elif</span> char == <span class="string">'.'</span>:</span><br><span class="line">			<span class="keyword">if</span> seen_dot <span class="keyword">or</span> seen_exp:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			seen_dot = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> (seen_sign <span class="keyword">or</span> seen_exp <span class="keyword">or</span> seen_dot) <span class="keyword">and</span> <span class="keyword">not</span> seen_num <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="DFA算法II解题思路-不推荐-："><a href="#DFA算法II解题思路-不推荐-：" class="headerlink" title="DFA算法II解题思路(不推荐)："></a><strong>DFA算法II解题思路(不推荐)：</strong></h3><p>Deterministic Finite Automaton (DFA)状态机，也就是将状态写入一个map中作为config，代码较简洁，但很难想。</p>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 068 Text Justification</title>
    <url>/2021/12/19/lee-068/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.<br><br>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.<br><br>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.<br><br>For the last line of text, it should be left-justified and no extra space is inserted between words.<br><br><strong>Note:</strong><br><br><em>   A word is defined as a character sequence consisting of non-space characters only.
</em>   Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.<br><em>   The input array <code>words</code> contains at least one word.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”], maxWidth = 16<br><strong>Output:</strong><br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”], maxWidth = 16<br><strong>Output:</strong><br>[<br>  “What   must   be”,<br>  “acknowledgment  “,<br>  “shall be        “<br>]<br><strong>Explanation:</strong> Note that the last line is “shall be    “ instead of “shall     be”, because the last line must be left-justified instead of fully-justified.<br>Note that the second line is also left-justified becase it contains only one word.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> words = [“Science”,”is”,”what”,”we”,”understand”,”well”,”enough”,”to”,”explain”,”to”,”a”,”computer.”,”Art”,”is”,”everything”,”else”,”we”,”do”], maxWidth = 20<br><strong>Output:</strong><br>[<br>  “Science  is  what we”,<br>  “understand      well”,<br>  “enough to explain to”,<br>  “a  computer.  Art is”,<br>  “everything  else  we”,<br>  “do                  “<br>]</pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= words.length &lt;= 300</code><br><em>   <code>1 &lt;= words[i].length &lt;= 20</code>
</em>   <code>words[i]</code> consists of only English letters and symbols.<br><em>   <code>1 &lt;= maxWidth &lt;= 100</code>
</em>   <code>words[i].length &lt;= maxWidth</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>加入尽量均等的空格使得单词组成的每行左右对齐  </p>
<h3 id="Round-Robin加入space解题思路-推荐-："><a href="#Round-Robin加入space解题思路-推荐-：" class="headerlink" title="Round Robin加入space解题思路(推荐)："></a><strong>Round Robin加入space解题思路(推荐)：</strong></h3><p>法二是先将一个space加入到预结果，再计算extra spaces，计算比较复杂。此法与maxWidth比较时，用1个space，而最后不区分正常space和extra space，将space按round robin方法加入，不用考虑法二复杂的计算公式。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>关键变量两个word_list, cur_len. 用目前结果cur_len + 空格个数 + 准加入单词长度与maxWidth比较。1个单词和2个单词以上的空格情况都照顾到了。</li>
<li>i % (len(word_list) - 1)若长度为1时候，不能对0取余，所以此情况要变成1， 加入or 1。word_list中的单词加入空格</li>
<li>最后一行用ljust向左对齐，右边补齐空格</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">	res = []</span><br><span class="line">	word_list, cur_len = [], <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">		<span class="keyword">if</span> cur_len + len(word_list) + len(word) &gt; maxWidth:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(maxWidth - cur_len):</span><br><span class="line">				word_list[i % (len(word_list) - <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">' '</span></span><br><span class="line">			res.append(<span class="string">''</span>.join(word_list))</span><br><span class="line">			word_list, cur_len = [], <span class="number">0</span></span><br><span class="line">		word_list.append(word)</span><br><span class="line">		cur_len += len(word)</span><br><span class="line">	<span class="keyword">return</span> res + [<span class="string">' '</span>.join(word_list).ljust(maxWidth)]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="计算extra-space算法II解题思路："><a href="#计算extra-space算法II解题思路：" class="headerlink" title="计算extra space算法II解题思路："></a><strong>计算extra space算法II解题思路：</strong></h3><p>用公式计算空格数和位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extra_space_num, idx = math.ceil(num_space_left / (len(buffer) - 1)), num_space_left % (len(buffer) - 1)</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>0.1 题目要求： 若空格有多余，尽量分到前面；若某一行只有一个单词，左对齐右补空格；最后一行无论多少个单词都是左对齐右补空格<br>0.2 用buffer记录这一行的单词，count记录单词和空格的长度，若count + 当前单词长度大于maxWidth就处理   </p>
<ol>
<li>公式：extra_space_num, idx = math.ceil(num_space_left / (len(buffer) - 1)), num_space_left % (len(buffer) - 1)<br>有多余空格就分配到单词间隔个数中len(buffer) - 1，而不是单词个数. 商为多余的空格个数，余数为从第几位开始，减一个空格。如x x x x，idx = 1，表示平分后仍多出一个空格，所以分配到第0个到第1个单词之间，也就是[:idx + 1]中，而剩余的buffer[idx + 1:]比上述少一个空格。它们之间的连接用较少空格数  </li>
<li>公式中<strong>若余数为0</strong>， 表示全部平均分配，这时要取extra_space_num + 1，所以令idx = len(buffer) - 1。 extra_space_num + 1里面的1是原本就应该有一个空格，所以此情况并没有额外多空格。   </li>
<li>公式中len(buffer) - 1可能为0，所以要特别处理，对应到题目要求的第二点  </li>
<li>最后一行是buffer的内容，出来for循环后，向右加空格，对应到题目要求的第三点，代码与第二点要求类似   </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="comment"># words.append(' ' * maxWidth)</span></span><br><span class="line">	buffer, count, res = [], <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">		new_length = len(word) <span class="keyword">if</span> len(buffer) == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> + len(word)</span><br><span class="line">		<span class="keyword">if</span> count + new_length &lt;= maxWidth:</span><br><span class="line">			buffer.append(word)</span><br><span class="line">			count += new_length</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			num_space_left = maxWidth - count <span class="comment"># 3</span></span><br><span class="line">			<span class="keyword">if</span> len(buffer) &gt; <span class="number">1</span>:</span><br><span class="line">				extra_space_num, idx = math.ceil(num_space_left / (len(buffer) - <span class="number">1</span>)), num_space_left % (len(buffer) - <span class="number">1</span>) <span class="comment"># 3, 0</span></span><br><span class="line">				<span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">					idx = len(buffer) - <span class="number">1</span></span><br><span class="line">				tmp = (<span class="string">' '</span> * (extra_space_num + <span class="number">1</span>)).join(buffer[:idx + <span class="number">1</span>]) + (<span class="string">' '</span> * extra_space_num) <span class="comment">#</span></span><br><span class="line">				tmp += (<span class="string">' '</span> * extra_space_num).join(buffer[idx + <span class="number">1</span>:])</span><br><span class="line">				res.append(tmp.strip())</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				tmp = buffer[<span class="number">0</span>] + (<span class="string">' '</span> * (maxWidth - len(buffer[<span class="number">0</span>])))</span><br><span class="line">				res.append(tmp)</span><br><span class="line">			buffer = [word]</span><br><span class="line">			count = len(word)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> buffer:</span><br><span class="line">		res.append(<span class="string">' '</span>.join(buffer))</span><br><span class="line">		res[<span class="number">-1</span>] += (<span class="string">' '</span> * (maxWidth - len(res[<span class="number">-1</span>])))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 070 Climbing Stairs</title>
    <url>/2021/12/29/lee-070/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are climbing a staircase. It takes <code>n</code> steps to reach the top.<br><br>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> There are two ways to climb to the top.<br>1. 1 step + 1 step<br>2. 2 steps<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> There are three ways to climb to the top.<br>1. 1 step + 1 step + 1 step<br>2. 1 step + 2 steps<br>3. 2 steps + 1 step<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 45</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>爬楼梯的方法数。一次可以爬一级或二级</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DP的经典题<br>递归式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n] = dp[n - 1] + dp[n - 2]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归式含两个前状态，所以用两个变量。Python的优势是可以同时赋值，所以不需要用临时变量     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[n] = dp[n - 1] + dp[n - 2]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	prev, cur = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>): <span class="comment"># 4</span></span><br><span class="line">		cur, prev = cur + prev, cur <span class="comment"># 5, 3</span></span><br><span class="line">	<span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 071 Simplify Path</title>
    <url>/2021/12/26/lee-071/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>path</code>, which is an <strong>absolute path</strong> (starting with a slash <code>&#39;/&#39;</code>) to a file or directory in a Unix-style file system, convert it to the simplified <strong>canonical path</strong>.<br><br>In a Unix-style file system, a period <code>&#39;.&#39;</code> refers to the current directory, a double period <code>&#39;..&#39;</code> refers to the directory up a level, and any multiple consecutive slashes (i.e. <code>&#39;//&#39;</code>) are treated as a single slash <code>&#39;/&#39;</code>. For this problem, any other format of periods such as <code>&#39;...&#39;</code> are treated as file/directory names.<br><br>The <strong>canonical path</strong> should have the following format:<br><br><em>   The path starts with a single slash <code>&#39;/&#39;</code>.
</em>   Any two directories are separated by a single slash <code>&#39;/&#39;</code>.<br><em>   The path does not end with a trailing <code>&#39;/&#39;</code>.
</em>   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period <code>&#39;.&#39;</code> or double period <code>&#39;..&#39;</code>)<br><br>Return <em>the simplified <strong>canonical path</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> path = “/home/“<br><strong>Output:</strong> “/home”<br><strong>Explanation:</strong> Note that there is no trailing slash after the last directory name.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> path = “/../“<br><strong>Output:</strong> “/“<br><strong>Explanation:</strong> Going one level up from the root directory is a no-op, as the root level is the highest level you can go.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> path = “/home//foo/“<br><strong>Output:</strong> “/home/foo”<br><strong>Explanation:</strong> In the canonical path, multiple consecutive slashes are replaced by a single one.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= path.length &lt;= 3000</code>
</em>   <code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.<br>*   <code>path</code> is a valid absolute Unix path.<br><br></div>


<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>简化路径，遇.表示当前目录不做事，遇..表示到上一个目录</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>路径类似于括号题，利用括号题模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>edge case /../ 表示若stack为空，就不pop。if stack不能加到elif token == ‘..’中  </li>
<li>遇到..返回到上层目录      </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">	path += <span class="string">'/'</span></span><br><span class="line">	token, stack = <span class="string">''</span>, []</span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> path:</span><br><span class="line">		<span class="keyword">if</span> c == <span class="string">'/'</span>:</span><br><span class="line">			<span class="keyword">if</span> token == <span class="string">'.'</span>:</span><br><span class="line">				<span class="keyword">pass</span></span><br><span class="line">			<span class="keyword">elif</span> token == <span class="string">'..'</span>:</span><br><span class="line">				<span class="keyword">if</span> stack: <span class="comment"># remember</span></span><br><span class="line">					stack.pop()</span><br><span class="line">			<span class="keyword">elif</span> token:</span><br><span class="line">				stack.append(token)</span><br><span class="line">			token = <span class="string">''</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			token += c</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 072 Edit Distance</title>
    <url>/2022/01/15/lee-072/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.<br><br>You have the following three operations permitted on a word:<br><br><em>   Insert a character
</em>   Delete a character<br><em>   Replace a character<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> word1 = “horse”, word2 = “ros”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong><br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> word1 = “intention”, word2 = “execution”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong><br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= word1.length, word2.length &lt;= 500</code><br>*   <code>word1</code> and <code>word2</code> consist of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求编辑两个字符串的最短距离。编辑操作含加删一个字符，替换一个字符。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最值且涉及到字符串考虑用DP。递归式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]                                   if word1[i-1] == word[j-1]  </span><br><span class="line">         = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值先word2长度再word1.</li>
<li><strong>初始化上和左边界，表示当一个字符串为空时，另一个字符串的编辑距离是其长度。</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j-1] if word1[i-1] == word[j-1]</span></span><br><span class="line"><span class="comment">#          = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word1) + <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		dp[i][<span class="number">0</span>] = i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">		dp[<span class="number">0</span>][j] = j</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 073 Set Matrix Zeroes</title>
    <url>/2022/01/15/lee-073/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s, and return <em>the matrix</em>.<br><br>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]<br><strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br><strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code>
</em>   <code>n == matrix[0].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong><br><br><em>   A straightforward solution using <code>O(mn)</code> space is probably a bad idea.
</em>   A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.<br>*   Could you devise a constant space solution?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>若矩阵某元素为0，设置它所在的行和列所有元素均为0，不能用额外区间</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0。两大步骤：先统计，再根据结果设置0</li>
<li>第二步中，<strong>根据第0和和第0列的结果回设，均从1开始</strong>，不含左上cell，因为统计结果不保存在它上。它仅在统计第一行和第一列是否有0时用到。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="comment"># calculate</span></span><br><span class="line">	is_zero_row_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> matrix[<span class="number">0</span>] <span class="keyword">if</span> n == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">	is_zero_col_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)) <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">				matrix[i][<span class="number">0</span>], matrix[<span class="number">0</span>][j] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="comment"># Set			</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)): <span class="comment"># remember to start with 1</span></span><br><span class="line">		<span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">				matrix[i][j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])): <span class="comment"># remember to start with 1</span></span><br><span class="line">		<span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">				matrix[i][j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> is_zero_row_zero:</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">			matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> is_zero_col_zero:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">			matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 075 Sort Colors</title>
    <url>/2021/12/05/lee-075/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.<br><br>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.<br><br>You must solve this problem without using the library’s sort function.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,0,2,1,1,0]<br><strong>Output:</strong> [0,0,1,1,2,2]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,0,1]<br><strong>Output:</strong> [0,1,2]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= n &lt;= 300</code><br><em>   <code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.<br><br><em>*Follow up:</em></em> Could you come up with a one-pass algorithm using only constant extra space?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排序3值数组</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于Quicksort的partition，但有三种值，需要有三个指针: left, i, right  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三个指针: left, i, right. 循环不是for每个元素，而是i &lt;= right        </li>
<li>nums[2]的时候，<strong>right要往前移</strong>   </li>
<li>和partition一样： nums[i] == 0，left和i都移动，nums[i] == 1只移动i</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	left, i, right = <span class="number">0</span>, <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= right: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">			nums[left], nums[i] = nums[i], nums[left]</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">elif</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">			right -= <span class="number">1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> middleStart = <span class="number">0</span>, middleEnd = nums.length-<span class="number">1</span>, i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=middleEnd)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i]==<span class="number">2</span>)</span><br><span class="line">			swap(nums,i,middleEnd--);<span class="comment">//no i++ coz 2,0,2,2, swap 2,2 and i can't +1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">			swap(nums,i++,middleStart++);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i++;</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 074 Search a 2D Matrix</title>
    <url>/2022/01/04/lee-074/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:<br><br><em>   Integers in each row are sorted from left to right.
</em>   The first integer of each row is greater than the last integer of the previous row.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code>
</em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 100</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= matrix[i][j], target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中每一行有序，下一行的首元素大于上一行的尾元素。求target是否在矩阵中</p>
<h3 id="列-行搜索解题思路："><a href="#列-行搜索解题思路：" class="headerlink" title="列+行搜索解题思路："></a><strong>列+行搜索解题思路：</strong></h3><p>先对列做二分搜索，再对行</p>
<p>LeetCode 074 Search a 2D Matrix 每一行有序，下一行的首元素大于上一行的尾元素 + 找target<br>LeetCode 240 Search a 2D Matrix II 按行按列有序 + 找target<br>LeetCode 378 Kth Smallest Element in a Sorted Matrix 按行按列有序 + 找第k大<br>矩阵结构方面，第一道每一行都是独立，所以可以独立地按行按列做二分法<br>后两道，矩阵二维连续，所以解法都是类BFS，从某个点开始，然后比较它相邻的两个点。出发点不同，第二道在近似矩阵中点(右上角或左下角)，第三道在左上角出发。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">	col = [matrix[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">	row_idx = bisect.bisect(col, target) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> row_idx &lt; <span class="number">0</span> <span class="keyword">or</span> row_idx &gt;= len(matrix):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">if</span> matrix[row_idx][<span class="number">0</span>] == target:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	col_idx = bisect.bisect(matrix[row_idx], target) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> col_idx &lt; <span class="number">0</span> <span class="keyword">or</span> col_idx &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> matrix[row_idx][col_idx] == target <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(n)</code>, 可以写一个二分法来做列搜索，这样空间为常量。  </p>
<hr>
<h3 id="全矩阵搜索算法II解题思路："><a href="#全矩阵搜索算法II解题思路：" class="headerlink" title="全矩阵搜索算法II解题思路："></a><strong>全矩阵搜索算法II解题思路：</strong></h3><p>对矩阵的左上，右下元素作为start, end得到mid转化成(i, j)找到矩阵位置。</p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (matrix.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> hi = matrix.length*matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">		<span class="comment">// Key is in a[lo..hi] or not present.</span></span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> x = mid/matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> y = mid%matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (target &lt; matrix[x][y])</span><br><span class="line">			hi = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[x][y])</span><br><span class="line">			lo = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(1)</code>。  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 076 Minimum Window Substring</title>
    <url>/2022/01/15/lee-076/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring__, return the empty string</em> <code>&quot;&quot;</code><em>.</em><br><br>The testcases will be generated such that the answer is <strong>unique</strong>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within the string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ADOBECODEBANC”, t = “ABC”<br><strong>Output:</strong> “BANC”<br><strong>Explanation:</strong> The minimum window substring “BANC” includes ‘A’, ‘B’, and ‘C’ from string t.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “a”<br><strong>Output:</strong> “a”<br><strong>Explanation:</strong> The entire string s is the minimum window.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “aa”<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> Both ‘a’s from t must be included in the window.<br>Since the largest window of s only has one ‘a’, return empty string.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == s.length</code>
</em>   <code>n == t.length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.<br><br><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最短摘要：给定s和t两个字符串，求在s中包含所有t的字符的最短子串。这个结果可以包含不在t的字符，某个字符数量也可以多于t中的字符但不能少于。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>提到window substring就用滑动窗口或者同向双指针。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用同向双指针模板。<strong>用map来统计t的字符频率，用unique_count统计满足条件唯一字符个数。while的条件为unique_count达到了map的大小</strong>。 </li>
<li>while里面的统计与while外面的统计本质一样，但相反。若s中某字符多于s中的，map为负值，left指针右移时，负值会变回正值。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">	t_char_to_count = collections.Counter(t)</span><br><span class="line">	left, unique_count, min_len, res = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>), <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">			t_char_to_count[s[i]] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> t_char_to_count[s[i]] == <span class="number">0</span>:</span><br><span class="line">				unique_count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> unique_count == len(t_char_to_count):</span><br><span class="line">			<span class="keyword">if</span> i - left + <span class="number">1</span> &lt; min_len:</span><br><span class="line">				min_len = i - left + <span class="number">1</span></span><br><span class="line">				res = s[left:i + <span class="number">1</span>]</span><br><span class="line">			<span class="keyword">if</span> s[left] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">				t_char_to_count[s[left]] += <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> t_char_to_count[s[left]] == <span class="number">1</span>:</span><br><span class="line">					unique_count -= <span class="number">1</span></span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(m)</code>, n和m分别为s和t的长度  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 077 Combinations</title>
    <url>/2021/12/29/lee-077/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.<br><br>You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 4, k = 2<br><strong>Output:</strong><br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1, k = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 20</code>
</em>   <code>1 &lt;= k &lt;= n</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求大小为k的所有可能组合</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>引入k作为模板API中的target，<strong>k为0作为终止条件</strong>。   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	nums = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">	path, result = [], []</span><br><span class="line">	self.dfs(nums, <span class="number">0</span>, k, path, result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, k, path, result)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">		result.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		self.dfs(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, path, result)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>k</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 078 Subsets</title>
    <url>/2022/01/14/lee-078/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.<br><br>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [[],[0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10</code>
</em>   <code>-10 &lt;= nums[i] &lt;= 10</code><br><em>   All the numbers of <code>nums</code> are <em>*unique</em></em>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>组合知识点</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目要求结果含空集</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res = [[]]</span><br><span class="line">	self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(nums):</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 079 Word Search</title>
    <url>/2021/12/03/lee-079/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.<br><br>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “SEE”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCB”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == board.length</code>
</em>   <code>n = board[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 6</code>
</em>   <code>1 &lt;= word.length &lt;= 15</code><br><em>   <code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.<br><br><em>*Follow up:</em></em> Could you use search pruning to make your solution faster with a larger <code>board</code>?<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>难点在于判断不合法情况的顺序，比DFS模板稍复杂。这些语句都在for循环外，按此顺序： word_index和(start_x, start_y)不合法，该点访问过(模板)，字母不等。<br>然后visited为True，循环后visited为False<br>根据DFS模板visited紧接在return之后(当然先确保不越界)，<strong>visited赋值一定要在所有不合法情况之后，不能紧跟visited比较</strong>   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, i, j, word, <span class="number">0</span>, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, word, word_index, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word_index &gt;= len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> board[start_x][start_y] != word[word_index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board, start_x + dx, start_y + dy, word, word_index + <span class="number">1</span>, visited):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*<em>3</em><sup>L</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向    </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 084 Largest Rectangle in Histogram</title>
    <url>/2022/01/15/lee-084/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,1,5,6,2,3]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> The above is a histogram where width of each bar is 1.<br>The largest rectangle is shown in the red area, which has an area = 10 units.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,4]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= heights.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= heights[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求直方图中最大的矩形面积</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L042 Trapping Rain Water的stack法，但此题水量是反的。所以仍然用Stack，但用递增栈 </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比L042稍简单，不用处理最后一个bar高度和宽度计算，但是用递增栈且公式中宽度计算仍然<strong>采用i - stack[-1] - 1</strong>，因为bar并不一定连续，如212, 最后一个2入栈，栈中剩下[_, 1]第一个2已经出栈了，但是可以有水量的。</li>
<li>原数组头尾加入0，头0是因为公式有stack[-1]避免越界， 尾0是因为让所有留在栈中的bar出栈且计算。</li>
</ol>
<p>大厦题，<strong>首尾加入节点</strong>：<br>LeetCode 084 Largest Rectangle in Histogram<br>LeetCode 218 The Skyline Problem</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">	stack, res = [], <span class="number">0</span></span><br><span class="line">	heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">	heights.append(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">			index = stack.pop()</span><br><span class="line">			res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">		stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 085 Maximal Rectangle</title>
    <url>/2022/01/15/lee-085/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximal-rectangle" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>rows x cols</code> binary <code>matrix</code> filled with <code>0</code>‘s and <code>1</code>‘s, find the largest rectangle containing only <code>1</code>‘s and return <em>its area</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The maximal rectangle is shown in the above picture.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> matrix = [[“0”]]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> matrix = [[“1”]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>rows == matrix.length</code>
</em>   <code>cols == matrix[i].length</code><br><em>   <code>1 &lt;= row, cols &lt;= 200</code>
</em>   <code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>0-1矩阵求全部都是1的最大的子矩阵</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 084 Largest Rectangle in Histogram，按每行生成连续1的直方图，求最大矩形面积。然后逐行调用L084的方法。 </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于L084的方案是修改原数组，所以不能直接调用，必须修改L084的方法，copy一份数组再往首尾插入0. </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">	heights, res = [<span class="number">0</span>] * len(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> matrix[i][j] == <span class="string">'0'</span>:</span><br><span class="line">				heights[j] = <span class="number">0</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				heights[j] += <span class="number">1</span></span><br><span class="line">		area = self.largestRectangleArea(heights)</span><br><span class="line">		res = max(res, area)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height_list: List[int])</span> -&gt; int:</span></span><br><span class="line">	stack, res = [], <span class="number">0</span></span><br><span class="line">	heights = list(height_list)</span><br><span class="line">	heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">	heights.append(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">			index = stack.pop()</span><br><span class="line">			res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">		stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(m)</code>, n, m分别为行数和列数  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
        <tag>Stack</tag>
        <tag>Mtrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 088 Merge Sorted Array</title>
    <url>/2022/01/03/lee-088/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.<br><br><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.<br><br>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br><strong>Output:</strong> [1,2,2,3,5,6]<br><strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0<br><strong>Output:</strong> [1]<br><strong>Explanation:</strong> The arrays we are merging are [1] and [].<br>The result of the merge is [1].<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1<br><strong>Output:</strong> [1]<br><strong>Explanation:</strong> The arrays we are merging are [] and [1].<br>The result of the merge is [1].<br>Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>nums1.length == m + n</code>
</em>   <code>nums2.length == n</code><br><em>   <code>0 &lt;= m, n &lt;= 200</code>
</em>   <code>1 &lt;= m + n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums1[i], nums2[j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br><em>*Follow up:</em></em> Can you come up with an algorithm that runs in <code>O(m + n)</code> time?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>合并两有序数组，最后结果储存在第一个数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从后往前合并</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>i从m - 1而不是len(nums1) - 1开始，m和n是数组实际长度。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, len(nums1) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">			nums1[k] = nums1[i]</span><br><span class="line">			k -= <span class="number">1</span></span><br><span class="line">			i -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nums1[k] = nums2[j]</span><br><span class="line">			k -= <span class="number">1</span></span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">		nums1[k] = nums1[i]</span><br><span class="line">		k -= <span class="number">1</span></span><br><span class="line">		i -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">		nums1[k] = nums2[j]</span><br><span class="line">		k -= <span class="number">1</span></span><br><span class="line">		j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 090 Subsets II</title>
    <url>/2022/01/15/lee-090/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.<br><br>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,2]<br><strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [[],[0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10</code>
</em>   <code>-10 &lt;= nums[i] &lt;= 10</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集，元素可能相同，不能含相同子集</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L078 Subsets，但元素可能相同，所以排序且比较相邻元素，若相等就跳过</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>元素可能相同，所以排序且比较相邻元素，若相等就跳过</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	nums.sort()</span><br><span class="line">	res = [[]]</span><br><span class="line">	self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(nums):</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &gt; st <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 091 Decode Ways</title>
    <url>/2022/01/16/lee-091/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:<br><br><pre>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br></pre><br><br>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:<br><br><em>   <code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code>
</em>   <code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code><br><br>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.<br><br>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.<br><br>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “12”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> “12” could be decoded as “AB” (1 2) or “L” (12).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “226”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> “226” could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “06”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “06” cannot be mapped to “F” because of the leading zero (“6” is different from “06”).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 100</code>
</em>   <code>s</code> contains only digits and may contain leading zero(s).<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数字1-26可以解码成A-Z字母。给定一串数字，求解码方法数。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求种数是DP和DFS，这题有递归关系，所以考虑用DP。类似于Fibonacci数列和LeetCode 070 Climbing Stairs，但此题带限制条件</p>
<p>递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>利用DP五点注意事项</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不合法的情况为空字符和含0. 这是求个数，根据DP知识点(数值到个数DP模板)，dp[0] = 1, 但这与题目空字符要求不同，所以特别处理。至于单个含0在循环中处理’0’ &lt; s[i - 1] &lt;= ‘9’</li>
<li>验证单位范围[1, 9], 双位范围[10, 26]才加入到结果中。由于dp长度只多了一位而递归式含两个前状态，所以要验证i &gt;= 2</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">if</span> <span class="string">'0'</span> &lt; s[i - <span class="number">1</span>] &lt;= <span class="string">'9'</span>:</span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="string">'10'</span> &lt;= s[i - <span class="number">2</span>: i] &lt;= <span class="string">'26'</span>:</span><br><span class="line">			dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="O-1-空间算法II解题思路："><a href="#O-1-空间算法II解题思路：" class="headerlink" title="O(1)空间算法II解题思路："></a><strong>O(1)空间算法II解题思路：</strong></h3><p>类似于Fibonacci数列和LeetCode 070 Climbing Stairs，由于涉及到两个前状态，所以用两个变量来节省空间</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	first, second = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">		res = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">'0'</span> &lt; s[i - <span class="number">1</span>] &lt;= <span class="string">'9'</span>:</span><br><span class="line">			res = second</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="string">'10'</span> &lt;= s[i - <span class="number">2</span>: i] &lt;= <span class="string">'26'</span>:</span><br><span class="line">			res += first</span><br><span class="line">		first, second = second, res</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 092 Reverse Linked List II</title>
    <url>/2022/01/15/lee-092/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4<br><strong>Output:</strong> [1,4,3,2,5]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> head = [5], left = 1, right = 1<br><strong>Output:</strong> [5]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is <code>n</code>.
</em>   <code>1 &lt;= n &lt;= 500</code><br><em>   <code>-500 &lt;= Node.val &lt;= 500</code>
</em>   <code>1 &lt;= left &lt;= right &lt;= n</code><br><br><strong>Follow up:</strong> Could you do it in one pass?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>反转链表中的子链表[left, right]，start和end是1-index位置, inclusive</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>锁定start和end节点，将end的后续节点一个个加到start直接后续</p>
<p>LeetCode 206 Reverse Linked List 反转整个LL<br>LeetCode 092 Reverse Linked List II 反转部分LL，此题更加一般化</p>
<p>模板：<br>不断将end<strong>直接</strong>后面的节点加到start<strong>直接</strong>后面<br>start(group n) -&gt; NodeA （新状态） -&gt; … -&gt; end(group n+1)  -&gt; NodeA （前状态） -&gt; …  </p>
<ol>
<li>找出start和end，start为反转部分的前一个，end为反转部分的首个节点</li>
<li>循环删除end<strong>直接</strong>后，再加入到start<strong>直接</strong>后<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start, end = fake_head, head</span><br><span class="line"><span class="keyword">while</span> &lt;反转链表长度&gt;:</span><br><span class="line">	<span class="comment"># delete the node</span></span><br><span class="line">	moved_node, end.next = end.next, end.next.next</span><br><span class="line">	<span class="comment"># insert the moved_node</span></span><br><span class="line">	start.next, moved_node.next = moved_node, start.next</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>经典题，见LeetCode 2074 Reverse Nodes in Even Length Groups。 思路是<strong>锁定start和end节点，将end的后续节点一个个加到start直接后续</strong></li>
<li>第二个循环中，right要记得减一，否则死循环</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span></span><br><span class="line">	left, right = left - <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">	fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">	fake_head.next = head</span><br><span class="line">	it = fake_head</span><br><span class="line">	<span class="keyword">while</span> left &gt; <span class="number">0</span>:</span><br><span class="line">		it = it.next</span><br><span class="line">		left -= <span class="number">1</span></span><br><span class="line">		right -= <span class="number">1</span></span><br><span class="line">	start, end = it, it.next</span><br><span class="line">	<span class="keyword">while</span> right &gt; <span class="number">0</span>:</span><br><span class="line">		moved_node, end.next = end.next, end.next.next <span class="comment"># delete a node</span></span><br><span class="line">		start.next, moved_node.next = moved_node, start.next <span class="comment"># insert a node</span></span><br><span class="line">		right -= <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 093 Restore IP Addresses</title>
    <url>/2022/01/16/lee-093/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.<br><br><em>   For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.<br><br>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “25525511135”<br><strong>Output:</strong> [“255.255.11.135”,”255.255.111.35”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “0000”<br><strong>Output:</strong> [“0.0.0.0”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “101023”<br><strong>Output:</strong> [“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= s.length &lt;= 20</code><br>*   <code>s</code> consists of digits only.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数字字符串，求以分解成合法IP的所有解。IP每段范围是0-255且不能有前缀0，如06</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有解，所以用DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用DFS模板，属于结果分组型DFS，dfs函数有k。</li>
<li>两个限制条件，不能含leading zero和数字范围在255内</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(s, <span class="number">0</span>, [], res, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, st, path, res, k)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(s) <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">		res.append(<span class="string">'.'</span>.join(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> st == len(s) <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, min(st + <span class="number">3</span>, len(s))):</span><br><span class="line">		segment = s[st:i + <span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> len(segment) &gt; <span class="number">1</span> <span class="keyword">and</span> segment[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment"># no leading 0</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> int(segment) &gt; <span class="number">255</span>: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(segment)</span><br><span class="line">		self.dfs(s, i + <span class="number">1</span>, path, res, k - <span class="number">1</span>)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 由于IP固定是4个部分，每个部分最多3位，所以乘法原理第一个dot的选择有三个位置，其他两个dot如此类推，3x3x3=27  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 098 Validate Binary Search Tree</title>
    <url>/2021/12/05/lee-098/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.<br><br>A <strong>valid BST</strong> is defined as follows:<br><br><em>   The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.
</em>   The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.<br><em>   Both the left and right subtrees must also be binary search trees.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [5,1,4,null,null,3,6]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The root node’s value is 5 but its right child’s value is 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= Node.val &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>验证BST</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用min, max法</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, min_val, max_val)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> min_val &gt;= root.val <span class="keyword">or</span> root.val &gt;= max_val:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(root.left, min_val, root.val) <span class="keyword">and</span> \</span><br><span class="line">		   self.dfs(root.right, root.val, max_val)</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Recommended method: use min max and devide &amp; conquer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// val can be Integer.Min so use long</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(min &gt;= root.val || max &lt;= root.val)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> isValid(root.left, min, root.val) &amp;&amp; </span><br><span class="line">			isValid(root.right, root.val, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method 2: use isVisited</span></span><br><span class="line">TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!isValidBST(root.left))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(lastVisited!=<span class="keyword">null</span> &amp;&amp; lastVisited.val&gt;=root.val)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	lastVisited = root;<span class="comment">//in-order traversal</span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">if</span>(!isValidBST(root.right))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100 Same Tree</title>
    <url>/2022/01/16/lee-100/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.<br><br>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2,3], q = [1,2,3]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2], q = [1,null,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2,1], q = [1,1,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in both trees is in the range <code>[0, 100]</code>.
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断二叉树是否相等</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 101 Symmetric Tree但稍简单, easy题</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101 Symmetric Tree</title>
    <url>/2021/12/30/lee-101/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt=""></p>
<pre>**Input:** root = [1,2,2,3,4,4,3]
**Output:** true
</pre>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt=""></p>
<pre>**Input:** root = [1,2,2,null,3,null,3]
**Output:** false
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断二叉树是否对称</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，但难点是转化成比较两棵树是否对称</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>难点是转化成比较两棵树是否对称    </li>
<li>还要比较值相等，root.val == root2.val</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">return</span> self.is_symmetric(root.left, root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetric</span><span class="params">(self, root, root2)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> root.val == root2.val <span class="keyword">and</span> self.is_symmetric(root.left, root2.right) <span class="keyword">and</span> self.is_symmetric(root.right, root2.left)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1010 Pairs of Songs With Total Durations Divisible by 60</title>
    <url>/2021/12/26/lee-1010/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a list of songs where the i<sup>th</sup> song has a duration of <code>time[i]</code> seconds.<br><br>Return <em>the number of pairs of songs for which their total duration in seconds is divisible by</em> <code>60</code>. Formally, we want the number of indices <code>i</code>, <code>j</code> such that <code>i &lt; j</code> with <code>(time[i] + time[j]) % 60 == 0</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> time = [30,20,150,100,40]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Three pairs have a total duration divisible by 60:<br>(time[0] = 30, time[2] = 150): total duration 180<br>(time[1] = 20, time[3] = 100): total duration 120<br>(time[1] = 20, time[4] = 40): total duration 60<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> time = [60,60,60]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> All three pairs have a total duration of 120, which is divisible by 60.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= time.length &lt;= 6 </em> 10<sup>4</sup><code>*</code>1 &lt;= time[i] &lt;= 500`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组中两数和能被60整除  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两数和的关系第一时间想到two sum。但由于target是60的倍数，并不固定，所以先用公式求所有数的mod，(time[i] + time[j]) % 60 = time[i] % 60 + time[j] % 60, 这样target就是60了<br>第二个难点是此题求个数并不是像two sum一样求可行性，所以value to index改成value to count  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>对所有数对60求mod，map存value到count    </li>
<li>如果输入是60，取模后为0， <strong>求(60 - time_mod[i])要对60取模</strong>，否则60不在map中，因为60 - time_mod[i] = 60.</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (time[i] + time[j]) % 60 = time[i] % 60 + time[j] % 60</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(self, time: List[int])</span> -&gt; int:</span></span><br><span class="line">	time_mod = [t % <span class="number">60</span> <span class="keyword">for</span> t <span class="keyword">in</span> time] <span class="comment"># [30,30]</span></span><br><span class="line">	val_to_count = collections.defaultdict(int)</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(time_mod)):</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">60</span> - time_mod[i]) % <span class="number">60</span> <span class="keyword">in</span> val_to_count:</span><br><span class="line">		   res += val_to_count[(<span class="number">60</span> - time_mod[i]) % <span class="number">60</span>]</span><br><span class="line">		val_to_count[time_mod[i]] += <span class="number">1</span> <span class="comment"># 30:1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 103 Binary Tree Zigzag Level Order Traversal</title>
    <url>/2021/12/30/lee-103/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[3],[20,9],[15,7]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 2000]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按层遍历二叉树。偶数层逆向</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用BFS按层遍历模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>多这一行level.append(node.val)   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res = []</span><br><span class="line">	queue = collections.deque([root])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		level = []</span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			level.append(node.val)</span><br><span class="line">			<span class="keyword">if</span> node.left:</span><br><span class="line">				queue.append(node.left)</span><br><span class="line">			<span class="keyword">if</span> node.right:</span><br><span class="line">				queue.append(node.right)</span><br><span class="line">		<span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">			res.append(level[::<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(level)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102 Binary Tree Level Order Traversal</title>
    <url>/2021/12/30/lee-102/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[3],[9,20],[15,7]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 2000]</code>.
</em>   <code>-1000 &lt;= Node.val &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树按层遍历</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用BFS模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>res.append(level)不是res.append(list(level))因为level = []已重新初始化。 </li>
<li>关键行： 多这一行<strong>level.append(node.val)</strong>，其他一样 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	queue, res = collections.deque([root]), []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		level = []</span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			level.append(node.val)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> node.left:</span><br><span class="line">				queue.append(node.left)</span><br><span class="line">			<span class="keyword">if</span> node.right:</span><br><span class="line">				queue.append(node.right)</span><br><span class="line">		res.append(level)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 Maximum Depth of Binary Tree</title>
    <url>/2021/07/27/lee-104/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104 Maximum Depth of Binary Tree</a></strong></p>
<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt=""></p>
<pre>**Input:** root = [3,9,20,null,null,15,7]
**Output:** 3
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** root = [1,null,2]
**Output:** 2
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** root = []
**Output:** 0
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:** root = [0]
**Output:** 1
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求二叉树高度。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>公式dfs(root)=1+max(dfs(root.left),dfs(root.right))  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1041 Robot Bounded In Circle</title>
    <url>/2021/12/16/lee-1041/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/robot-bounded-in-circle/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>On an infinite plane, a robot initially stands at <code>(0, 0)</code> and faces north. The robot can receive one of three instructions:<br><br><em>   <code>&quot;G&quot;</code>: go straight 1 unit;
</em>   <code>&quot;L&quot;</code>: turn 90 degrees to the left;<br><em>   <code>&quot;R&quot;</code>: turn 90 degrees to the right.<br><br>The robot performs the <code>instructions</code> given in order, and repeats them forever.<br><br>Return <code>true</code> if and only if there exists a circle in the plane such that the robot never leaves the circle.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> instructions = “GGLLGG”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).<br>When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> instructions = “GG”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The robot moves north indefinitely.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> instructions = “GL”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; …</pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= instructions.length &lt;= 100</code><br>*   <code>instructions[i]</code> is <code>&#39;G&#39;</code>, <code>&#39;L&#39;</code> or, <code>&#39;R&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>循环按模式走是否回到原点  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，很难证明。定理是，只要按照给定模式走完，若回到原点或最后方向不是向北，都能回到原点  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isRobotBounded</span><span class="params">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class="line">	DIRECTION_CONVERT_LEFT = &#123;</span><br><span class="line">		(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">		(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">		(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">		(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	DIRECTION_CONVERT_RIGHT = &#123;</span><br><span class="line">		(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">		(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">		(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">		(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	path, direction, position = instructions, (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> path:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'L'</span>:</span><br><span class="line">			direction = DIRECTION_CONVERT_LEFT[direction]</span><br><span class="line">		<span class="keyword">elif</span> char == <span class="string">'R'</span>:</span><br><span class="line">			direction = DIRECTION_CONVERT_RIGHT[direction]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			position = (position[<span class="number">0</span>] + direction[<span class="number">0</span>], position[<span class="number">1</span>] + direction[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> position == (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">or</span> direction != (<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1048 Longest String Chain</title>
    <url>/2021/11/27/lee-1048/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-string-chain/" target="_blank" rel="noopener">LeetCode 1048 Longest String Chain</a></strong></p>
<div><br><br>You are given an array of <code>words</code> where each word consists of lowercase English letters.<br><br><code>word&lt;sub&gt;A&lt;/sub&gt;</code> is a <strong>predecessor</strong> of <code>word&lt;sub&gt;B&lt;/sub&gt;</code> if and only if we can insert <strong>exactly one</strong> letter anywhere in <code>word&lt;sub&gt;A&lt;/sub&gt;</code> <strong>without changing the order of the other characters</strong> to make it equal to <code>word&lt;sub&gt;B&lt;/sub&gt;</code>.<br><br><em>   For example, <code>&quot;abc&quot;</code> is a <strong>predecessor</strong> of <code>&quot;ab&lt;u&gt;a&lt;/u&gt;c&quot;</code>, while <code>&quot;cba&quot;</code> is not a <strong>predecessor</strong> of <code>&quot;bcad&quot;</code>.<br><br>A <strong>word chain</strong>is a sequence of words <code>[word&lt;sub&gt;1&lt;/sub&gt;, word&lt;sub&gt;2&lt;/sub&gt;, ..., word&lt;sub&gt;k&lt;/sub&gt;]</code> with <code>k &gt;= 1</code>, where <code>word&lt;sub&gt;1&lt;/sub&gt;</code> is a <strong>predecessor</strong> of <code>word&lt;sub&gt;2&lt;/sub&gt;</code>, <code>word&lt;sub&gt;2&lt;/sub&gt;</code> is a <strong>predecessor</strong> of <code>word&lt;sub&gt;3&lt;/sub&gt;</code>, and so on. A single word is trivially a <strong>word chain</strong> with <code>k == 1</code>.<br><br>Return <em>the <strong>length</strong> of the <strong>longest possible word chain</strong> with words chosen from the given list of</em> <code>words</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“a”,”b”,”ba”,”bca”,”bda”,”bdca”]<br><strong>Output:</strong> 4<br><strong>Explanation</strong>: One of the longest word chains is [“a”,”<u>b</u>a”,”b<u>d</u>a”,”bd<u>c</u>a”].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“xbc”,”pcxbcf”,”xb”,”cxbc”,”pcxbc”]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> All the words can be put in a word chain [“xb”, “xb<u>c</u>“, “<u>c</u>xbc”, “<u>p</u>cxbc”, “pcxbc<u>f</u>“].<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> words = [“abcd”,”dbqca”]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The trivial word chain [“abcd”] is one of the longest word chains.<br>[“abcd”,”dbqca”] is not a valid word chain because the ordering of the letters is changed.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= words.length &lt;= 1000</code><br><em>   <code>1 &lt;= words[i].length &lt;= 16</code>
</em>   <code>words[i]</code> only consists of lowercase English letters.<br><br></div>

<h3 id="Problem-Overview"><a href="#Problem-Overview" class="headerlink" title="Problem Overview"></a><strong>Problem Overview</strong></h3><p>Get longgest one-character transformation in the given list</p>
<h3 id="Thinking-Process"><a href="#Thinking-Process" class="headerlink" title="Thinking Process"></a><strong>Thinking Process</strong></h3><p>This problem is similar to Word Break (reversed to get neighbors) but it is a multi-source longest path problem. </p>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a><strong>Steps</strong></h3><ol>
<li>Loop through each word  </li>
<li>BFS from each word and get the max distance    </li>
<li>Get the max of distance    </li>
</ol>
<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><ol>
<li>max_dis = 1 by default in BFS  </li>
<li>To improve the complexity, make the distance map global so that the distance of each node will be calculated once.<br>To do that, <strong>sort the list</strong> from longest to shortest and make sure the it is greedy to get the max distance</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">	word_dict, distance = set(words), &#123;&#125;</span><br><span class="line">	max_dis = <span class="number">0</span></span><br><span class="line">	words.sort(key=len, reverse=<span class="keyword">True</span>)  <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">		dis = self.bfs(word, word_dict, distance)</span><br><span class="line">		max_dis = max(max_dis, dis)</span><br><span class="line">	<span class="keyword">return</span> max_dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word, word_dict, distance)</span>:</span></span><br><span class="line">	queue = deque([word])</span><br><span class="line">	visited = &#123;word&#125;</span><br><span class="line">	<span class="keyword">if</span> word <span class="keyword">in</span> distance:  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> distance[word]</span><br><span class="line">	distance[word] = <span class="number">1</span></span><br><span class="line">	max_dis = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> self.get_neighbors(node, word_dict):</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance[neighbor] = distance[node] + <span class="number">1</span></span><br><span class="line">			max_dis = max(max_dis, distance[neighbor])</span><br><span class="line">	<span class="keyword">return</span> max_dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_neighbors</span><span class="params">(self, word, word_dict)</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">		new_word = word[:i] + word[i + <span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> new_word <span class="keyword">in</span> word_dict:</span><br><span class="line">			res.append(new_word)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a><strong>Analysis</strong></h3><p>Though there is a loop and bfs like n^2, actually it is a traversal in a graph. n * L (n is # of nodes, L is max of path<br>single-source) is the num of edges. Another L is to get neighbors.<br>Time complexity<code>O(nlogn + n*<em>L</em><sup>2</sup>)</code>, Space complexity<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>tiktok</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/12/05/lee-105/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt=""><br><br><pre><strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br><strong>Output:</strong> [3,9,20,null,null,15,7]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> preorder = [-1], inorder = [-1]<br><strong>Output:</strong> [-1]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= preorder.length &lt;= 3000</code>
</em>   <code>inorder.length == preorder.length</code><br><em>   <code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code>
</em>   <code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.<br><em>   Each value of <code>inorder</code> also appears in <code>preorder</code>.
</em>   <code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.<br><em>   <code>inorder</code> is <em>*guaranteed</em></em> to be the inorder traversal of the tree.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用递归实现，in_order字符串分左右两段子串递归到左右儿子，<strong>pre_order字符串每轮递归用pop(0)原地去除首位</strong>，再递归到儿子节点  </li>
<li><strong>终止条件为in_order字符串为空</strong>。    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	head = preorder.pop(<span class="number">0</span>)</span><br><span class="line">	index = inorder.index(head)</span><br><span class="line">	left_inorder, right_inorder = inorder[:index], inorder[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	root = TreeNode(head)</span><br><span class="line">	root.left = self.buildTree(preorder, left_inorder)</span><br><span class="line">	root.right = self.buildTree(preorder, right_inorder)</span><br><span class="line">	<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 112 Path Sum</title>
    <url>/2017/12/13/lee-112/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">LeetCode 112 Path Sum</a></strong></p>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p>
<pre>              
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</pre>

<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个二叉树root和一个和sum，决定这个树是否存在一条从根到叶子的路径使得沿路所有节点的和等于给定的sum。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS搜索，二叉树的题。步骤主要是考虑</p>
<ol>
<li>空指针</li>
<li>一个node情况或多个node情况（可合并）</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>叶子节点是不含左儿子和右儿子</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为节点数。空间复杂度为<code>O(h)</code>，h为二叉树高度。</p>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p>LeetCode 112 Path Sum<br>LeetCode 124 Binary Tree Maximum Path Sum</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 114 Flatten Binary Tree to Linked List</title>
    <url>/2021/12/29/lee-114/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div>Given the <code>root</code> of a binary tree, flatten the tree into a “linked list”: <em> The “linked list” should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>. </em> The “linked list” should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank" rel="noopener"><strong>pre-order</strong> <strong>traversal</strong></a> of the binary tree. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,5,3,4,null,6]<br><strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[0, 2000]</code>. </em> <code>-100 &lt;= Node.val &lt;= 100</code> <strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将二叉树转成以右节点相连的LL</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>递归需要知道左右递归末尾节点，这样才可以将右节点的首节点接到左节点的末尾。所以递归函数输入是root，返回LL末尾节点  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归函数输入是root，返回LL末尾节点    </li>
<li>如果left_end是空，也就是<strong>没有左节点，就不用交换</strong>。返回right_end, left_end, root三者中非空者。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	self.dfs(root)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	left_end = self.dfs(root.left)</span><br><span class="line">	right_end = self.dfs(root.right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> left_end: <span class="comment"># remember</span></span><br><span class="line">		left_end.right = root.right</span><br><span class="line">		root.right, root.left = root.left, <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">if</span> right_end:</span><br><span class="line">		<span class="keyword">return</span> right_end</span><br><span class="line">	<span class="keyword">elif</span> left_end:</span><br><span class="line">		<span class="keyword">return</span> left_end</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118 Pascal&#39;s Triangle</title>
    <url>/2022/01/16/lee-118-pascals-triangle/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/pascals-triangle" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.<br><br>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numRows = 5<br><strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numRows = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= numRows &lt;= 30</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n行，产生n行的杨辉三角</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用DP按照定义生成，其实类似于Fibonacci数列，不过是二维的，而不是一维。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值为[1]</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	path, res = [<span class="number">1</span>], []</span><br><span class="line">	res.append(path)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, numRows):</span><br><span class="line">		next_level = []</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(path)):</span><br><span class="line">			next_level.append(path[j - <span class="number">1</span>] + path[j])</span><br><span class="line">		next_level.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		next_level.append(<span class="number">1</span>)</span><br><span class="line">		path = next_level</span><br><span class="line">		res.append(list(path))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(numRows<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1197 Minimum Knight Moves</title>
    <url>/2020/04/20/lee-1197/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-knight-moves/" target="_blank" rel="noopener">LeetCode 1197 Minimum Knight Moves</a></strong></p>
<p>In an infinite chess board with coordinates from <code>-infinity</code> to <code>+infinity</code>, you have a knight at square <code>[0, 0]</code>.</p>
<p>A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" alt=""></p>
<p>Return the minimum number of steps needed to move the knight to the square <code>[x, y]</code>.  It is guaranteed the answer exists.</p>
<p>Example 1:</p>
<pre>Input: x = 2, y = 1
Output: 1
Explanation: [0, 0] → [2, 1]
</pre>

<p>Example 2:</p>
<pre>Input: x = 5, y = 5
Output: 4
Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]
</pre>

<p>Constraints:</p>
<ul>
<li><code>|x| + |y| &lt;= 300</code></li>
</ul>
<p>Because x and y are constrained to be in range[-300, 300], we can use BFS to find the minimum steps needed to reach target(x, y). Furthermore, we can only consider the case that x &gt;=0 &amp;&amp; y &gt;=0 since the chess board is symmetric.  The bfs implementation is pretty straightforward. There are two important points you need to be careful with.</p>
<ol>
<li>Pruning. We can limit the search dimension within 310 * 310. Any moves that lead to a position that is outside this box will not yield an optimal result.</li>
</ol>
<p>2. Initially, you used a Set of type int[] to track visited positions. This caused TLE because you didn’t overwrite the hashCode and equals methods for int[]. As a result, Set uses the default hashCode and equals method when checking if an element is already in the set. For equals(), The default implementation provided by the JDK is based on memory location — two objects are equal if and only if they are stored in the same memory address. For a comprehensive reading, refer to <a href="https://dzone.com/articles/working-with-hashcode-and-equals-in-java" target="_blank" rel="noopener">https://dzone.com/articles/working-with-hashcode-and-equals-in-java</a></p>
<p>O(x * y) runtime and space</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>象棋一样，走日字到达目标点的最小次数。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。用Distance BFS模板</p>
<ol>
<li>建距离map。  </li>
<li>BFS访问。  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>有边界限制</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minKnightMoves</span><span class="params">(self, x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> self.bfs(<span class="number">0</span>, <span class="number">0</span>, x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, start_x, start_y, target_x, target_y)</span>:</span></span><br><span class="line">	directions = &#123;(<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">-1</span>, <span class="number">2</span>), (<span class="number">-2</span>, <span class="number">1</span>), (<span class="number">-2</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">-2</span>), (<span class="number">1</span>, <span class="number">-2</span>), (<span class="number">2</span>, <span class="number">-1</span>)&#125;</span><br><span class="line">	queue = deque([(start_x, start_y)])</span><br><span class="line">	visited = &#123;(start_x, start_y)&#125;</span><br><span class="line">	distance = &#123;(start_x, start_y): <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == (target_x, target_y):</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">			neighbor = (node[<span class="number">0</span>] + direction[<span class="number">0</span>], node[<span class="number">1</span>] + direction[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance[neighbor] = distance[node] + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>用map记录距离一定要将首节点加入到map中，否则求距离时候会NPE。</strong>  </li>
<li>visited我一开始实现用HashSet但因为没有实现equals导致LTE，改成矩阵即可。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] directX = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] directY = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point source, Point destination)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	Queue&lt;Point&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	Map&lt;Point, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	map.put(source, <span class="number">0</span>); <span class="comment">// remember</span></span><br><span class="line">	<span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">	q.offer(source);</span><br><span class="line">	visited[source.x][source.y] = <span class="keyword">true</span>; <span class="comment">// use hashSet is wrong.</span></span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		Point p = q.poll();</span><br><span class="line">		<span class="keyword">if</span>(p.x == destination.x &amp;&amp; p.y == destination.y)</span><br><span class="line">			<span class="keyword">return</span> map.get(p);</span><br><span class="line">		<span class="keyword">for</span>(Point neighbor : getNeighbors(p)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!isValid(grid, neighbor) || visited[neighbor.x][neighbor.y])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			q.offer(neighbor);</span><br><span class="line">			visited[neighbor.x][neighbor.y] = <span class="keyword">true</span>;</span><br><span class="line">			map.put(neighbor, map.get(p) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Point&gt; <span class="title">getNeighbors</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">	List&lt;Point&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">		result.add(<span class="keyword">new</span> Point(point.x + directX[i], point.y + directY[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point point)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(point.x &gt;= <span class="number">0</span> &amp;&amp; point.x &lt; grid.length &amp;&amp; point.y &gt;= <span class="number">0</span> &amp;&amp; point.y &lt; grid[<span class="number">0</span>].length </span><br><span class="line">			&amp;&amp; !grid[point.x][point.y])</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为棋盘大小<code>O(n*m)</code>，空间复杂度<code>O(n)</code>。  </p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1209 Remove All Adjacent Duplicates in String II</title>
    <url>/2021/12/24/lee-1209/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a string <code>s</code> and an integer <code>k</code>, a <code>k</code> <strong>duplicate removal</strong> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.<br><br>We repeatedly make <code>k</code> <strong>duplicate removals</strong> on <code>s</code> until we no longer can.<br><br>Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “abcd”, k = 2<br><strong>Output:</strong> “abcd”<br><strong>Explanation:</strong> There’s nothing to delete.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “deeedbbcccbdaa”, k = 3<br><strong>Output:</strong> “aa”<br><strong>Explanation:</strong> First delete “eee” and “ccc”, get “ddbbbdaa”<br>Then delete “bbb”, get “dddaa”<br>Finally delete “ddd”, get “aa”</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “pbbcggttciiippooaais”, k = 2<br><strong>Output:</strong> “ps”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>2 &lt;= k &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> only contains lower case English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串中去除连续k次的字符</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始用暴力法得到LTE。这题由于需要保持顺序，且元素之间是相等关系且类似于LeetCode 316 Remove Duplicate Letters，考虑用Stack。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Stack中存元素和该元素的连续个数，这样避免往前重新计算连续了几次。若栈顶元素等于遍历元素且栈顶连续个数为k - 1就连续出栈。此情况<strong>此遍历元素不入栈</strong>  </li>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">	stack, res = [], <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i] <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k - <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i]:</span><br><span class="line">				stack.pop()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i]:</span><br><span class="line">				stack.append((s[i], stack[<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				stack.append((s[i], <span class="number">1</span>))</span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		pair = stack.pop()</span><br><span class="line">		res += pair[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Bloomberg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 121 Best Time to Buy and Sell Stock</title>
    <url>/2017/11/27/lee-121/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a></strong></p>
<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong>  </p>
<pre>Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
</pre>

<p><strong>Example 2:</strong>  </p>
<pre>Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>如果你只能进行一次交易（比如购买或者销售一个股票），设计一个算法来获取最大利润。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>利润=当前价格-买入价，利润作为第一个变量求其最大值。由于买入价越低，利润可能会越大，所以第二个变量就要不断更新买入价<br>（最小值）。本题核心思路就是维护两个变量：最低价，利润。为什么不用最高价而选择利润呢？因为最低价和最高价没有顺序，最高价<br>必须在最低价后面，这样的利润才可实现，但如果是最低价和利润，就能确保这个顺序了，因为利润一定是在最低价后，否则这个利<br>润为负，不能为最大值。另一种稍麻烦的方法是凡是min更新，最高价就reset为0，大原则就是保持顺序。</p>
<p><img src="/images/L121.png" alt=""></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组为空</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">	min_buy_idx, max_profit = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">		max_profit = max(max_profit, prices[i] - prices[min_buy_idx])</span><br><span class="line">		<span class="keyword">if</span> prices[i] &lt; prices[min_buy_idx]:</span><br><span class="line">			min_buy_idx = i</span><br><span class="line">	<span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> curProfit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> todayProfit = prices[i]-min;</span><br><span class="line">		<span class="keyword">if</span>(todayProfit&gt;curProfit)</span><br><span class="line">			curProfit = todayProfit;</span><br><span class="line">		<span class="keyword">if</span>(min&gt;prices[i])</span><br><span class="line">			min = prices[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(1)</code>。</p>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 122 Best Time to Buy and Sell Stock II</title>
    <url>/2017/11/28/lee-122/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a></strong></p>
<div><br><br>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> day.<br><br>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.<br><br>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> prices = [7,1,5,3,6,4]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.<br>Total profit is 4 + 3 = 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> prices = [1,2,3,4,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>Total profit is 4.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> prices = [7,6,4,3,1]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= prices.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>0 &lt;= prices[i] &lt;= 10<sup>4</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个算法寻找最大收益。你可以随便完成多少次交易（比如，多次买入卖出）。然而你不能一次进行多次交易。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>仍然是求最大利润，可以交易多次，但要先卖再买。容易想到是求所有上升坡的的总和。更简单而言，若将每一个上升坡，分成一小段(每天的交易)，求这些小段的和即可。<br>如：[6, 1, 2, 3, 4]中的1, 2, 3, 4序列来说，对于两种操作方案：<br>1 在1买入，4卖出<br>2 在1买入，2卖出同时买入，3卖出同时买入，4卖出<br>这两种操作下，收益是一样的。这种方法，避免检测下坡以及计算每段的和。</p>
<p><img src="/images/L122.png" alt=""></p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">		<span class="keyword">if</span> prices[i] - prices[i - <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">			res += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组为空</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(prices[i-<span class="number">1</span>]&lt;prices[i])</span><br><span class="line">			profit += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(1)</code>。</p>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Classic</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 123 Best Time to Buy and Sell Stock III</title>
    <url>/2017/12/24/lee-123/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></strong></p>
<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成两笔交易。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>回顾一下前两题：只能进行一次交易和可以无数次交易。分别是用(min, p),sum(prices[i]-prices[i-1])的方法。这题很明显比较接近只能进行一次交易的题。<br>如果考虑将此问题分为两个子问题(Divide &amp; Conquer,二分法)，prices[0,k]和prices[k,n-1]，只要将k取遍所有值就得到解。</p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> p = maxProfitSingle(Arrays.copyOfRange(prices,<span class="number">0</span>, i+<span class="number">1</span>))</span><br><span class="line">				+ maxProfitSingle(Arrays.copyOfRange(prices,i, prices.length));</span><br><span class="line">		<span class="keyword">if</span>(max&lt;p)</span><br><span class="line">			max = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(1)</code>。</p>
<p>上述解法并非最优，因为计算prices[0,k-1]到prices[0,k]时候再次重复计算用了O(n)，但由只能进行一次交易题解中知道，其实O(1)可得，只要在计算过程中把结果存入left数组中即可。<br>下面的难点在于计算prices[k,n-1]。右端点固定，从右到左计算，所以其实是只能进行一次交易题解的逆运算并把结果存入到right数组。区别是(max, p)。最后只要遍历left[k]+right[k],即可得到最大利润。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组长度为0。</li>
<li>二分法</li>
<li>用数组存储重复计算结果(DP)</li>
</ol>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//前i天最大利润，并非需要第i天卖出</span></span><br><span class="line">	<span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">	<span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> min = prices[<span class="number">0</span>], maxPL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> p = prices[i] - min;</span><br><span class="line">		<span class="keyword">if</span>(maxPL&lt;p)</span><br><span class="line">			maxPL = p;</span><br><span class="line">		left[i] = maxPL;</span><br><span class="line">		<span class="keyword">if</span>(min&gt;prices[i])</span><br><span class="line">			min=prices[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> max=prices[prices.length-<span class="number">1</span>],maxPR=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=prices.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">		<span class="keyword">int</span> p=max-prices[j];</span><br><span class="line">		<span class="keyword">if</span>(maxPR&lt;p)</span><br><span class="line">			maxPR = p;</span><br><span class="line">		right[j] = maxPR;</span><br><span class="line">		<span class="keyword">if</span>(max&lt;prices[j])</span><br><span class="line">			max=prices[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;prices.length;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxP&lt;left[k]+right[k])</span><br><span class="line">			maxP = left[k]+right[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1235 Maximum Profit in Job Scheduling</title>
    <url>/2021/12/05/lee-1235/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>We have <code>n</code> jobs, where every job is scheduled to be done from <code>startTime[i]</code> to <code>endTime[i]</code>, obtaining a profit of <code>profit[i]</code>.<br><br>You’re given the <code>startTime</code>, <code>endTime</code> and <code>profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.<br><br>If you choose a job that ends at time <code>X</code> you will be able to start another job that starts at time <code>X</code>.<br><br><strong>Example 1:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png" alt=""></strong><br><br><pre><strong>Input:</strong> startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]<br><strong>Output:</strong> 120<br><strong>Explanation:</strong> The subset chosen is the first and fourth job.<br>Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.<br></pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png" alt=""></strong><br><br><pre><strong>Input:</strong> startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]<br><strong>Output:</strong> 150<br><strong>Explanation:</strong> The subset chosen is the first, fourth and fifth job.<br>Profit obtained 150 = 20 + 70 + 60.<br></pre><br><br><strong>Example 3:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png" alt=""></strong><br><br><pre><strong>Input:</strong> startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10<sup>9</sup><code>*</code>1 &lt;= profit[i] &lt;= 10<sup>4</sup>`<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DP + 排序<br>一开始以为类似于meeting rooms II，所以用heap，但只能计算conflicts不能计算profits，但排序思想有用。<br>求最值问题第一时间考虑用DP，所以考虑以第i-1个job为结尾的最大利润：  </p>
<p><pre><br>dp[i] = max -&gt; dp[j] + profits[i-1]), 第i个job的startTime[i-1] &gt;= endTime[j], 第j个job与第i个job没有conflicts<br>            -&gt; dp[j]                                                          第j个job与第i个job有conflicts<br></pre><br>复杂度为O(n^2)  </p>
<p>写出递归式后，求startTime &gt;= endTime其实就是按endTime排序，这样有助于搜索这个条件. 这里有个难点是要加强命题至累计利润，因为正如Cooldown股票题一样，dp[j]不应该是以job j为结尾的最大利润，而应该是前j个job的最大利润，这些job不一定都是相邻<br>加强命题dp[i]是累计利润，也就是并不需要计算所有dp[j…i]的值（第一式子），公式变成  </p>
<p><pre><br>dp[i] = max -&gt; dp[j] + profits[i-1]), j = start[i-1]对应的Endtime下标, 第j个job与第i个job没有conflicts<br>            -&gt; dp[j]                                                   第j个job与第i个job有conflicts<br></pre><br>要找出这个j，就对刚才排序了的endtime数组用bisect找下标。类似于LIS, 复杂度为O(nlogn)  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>bisect的使用求大于startTime的endTime下标，此下标j减一正是所求，但dp和数组中下标转换是差1，所以dp[j - 1 + 1]是前值的DP值。      </li>
<li><strong>加强命题至累计利润</strong>dp[i], 见line 9 - 10 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jobScheduling</span><span class="params">(self, startTime: List[int], endTime: List[int], profit: List[int])</span> -&gt; int:</span></span><br><span class="line">	job_by_endtime, dp, max_profit = [], [<span class="number">0</span>] * (len(startTime) + <span class="number">1</span>), <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(startTime)):</span><br><span class="line">		job_by_endtime.append((endTime[i], startTime[i], profit[i]))</span><br><span class="line">	job_by_endtime.sort()</span><br><span class="line">	end_time_sorted = [pair[<span class="number">0</span>] <span class="keyword">for</span> pair <span class="keyword">in</span> job_by_endtime]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		j = bisect.bisect(end_time_sorted, job_by_endtime[i - <span class="number">1</span>][<span class="number">1</span>]) <span class="comment"># previous end time &lt;= current start time</span></span><br><span class="line">		dp[i] = max(max_profit, dp[j] + job_by_endtime[i - <span class="number">1</span>][<span class="number">2</span>]) <span class="comment"># remember</span></span><br><span class="line">		max_profit = max(max_profit, dp[i]) <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
        <tag>Dynamic Programming</tag>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1249 Minimum Remove to Make Valid Parentheses</title>
    <url>/2021/12/07/lee-1249/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <font face="monospace">s</font> of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English characters.<br><br>Your task is to remove the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.<br><br>Formally, a <em>parentheses string</em> is valid if and only if:<br><br><em>   It is the empty string, contains only lowercase characters, or
</em>   It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or<br><em>   It can be written as <code>(A)</code>, where <code>A</code> is a valid string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “lee(t(c)o)de)”<br><strong>Output:</strong> “lee(t(c)o)de”<br><strong>Explanation:</strong> “lee(t(co)de)” , “lee(t(c)ode)” would also be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “a)b(c)d”<br><strong>Output:</strong> “ab(c)d”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “))((“<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> An empty string is also valid.<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> s = “(a(b(c)d)”<br><strong>Output:</strong> “a(b(c)d)”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>s[i]</code> is either<code>&#39;(&#39;</code> , <code>&#39;)&#39;</code>, or lowercase English letter<code>.</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>去掉最小不合法括号数剩下的字符串。</p>
<h3 id="Stack算法思路："><a href="#Stack算法思路：" class="headerlink" title="Stack算法思路："></a><strong>Stack算法思路：</strong></h3><p>括号题优先考虑用Stack。此题将下标存于stack中，stack留下的是不合法括号下标，也就是需要删除的  </p>
<p>LeetCode 1249 Minimum Remove to Make Valid Parentheses 求一个最优解 Medium, Stack<br>LeetCode 921 Minimum Add to Make Parentheses Valid 求一个最优解 Medium, Stack<br>LeetCode 301 Remove Invalid Parentheses 求所有最优解 Hard，此题 答案包含上题, BFS</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当括号配对时才出栈 Line 6  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	stack, res = [], <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">		<span class="keyword">elif</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span> <span class="keyword">and</span> s[i] == <span class="string">')'</span>:  <span class="comment"># remember</span></span><br><span class="line">			stack.pop()</span><br><span class="line">		<span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> set(stack):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		res += s[i]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 124 Binary Tree Maximum Path Sum</title>
    <url>/2017/12/13/lee-124/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">LeetCode 124 Binary Tree Maximum Path Sum</a></strong></p>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<pre>       
       1
      / \
     2   3
</pre>

<p>Return <code>6</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一棵二叉树，寻找最大路径和。路径指的是从任意起始节点出发沿着父亲-孩子链接到达某个终止节点的节点序列。路径不一定要穿过根节点。</p>
<h3 id="DFS解题思路-推荐-："><a href="#DFS解题思路-推荐-：" class="headerlink" title="DFS解题思路(推荐)："></a><strong>DFS解题思路(推荐)：</strong></h3><p>DFS搜索，二叉树的题。步骤主要是考虑</p>
<ol>
<li>空指针</li>
<li>一个node情况或多个node情况（可合并）<br>多个node情况下（比如3个节点），有4种情况下含根节点的和：左子树+根节点，右子树+跟节点，根节点，左子树+根节点+右子树。这些情况包含了所有可能的和的情况。但值得注意的是，前三种<br>情况可以是子问题的解，也就是它返回值将成为此根节点父亲的左或右子树的解，但第四种情况例外，因为此情况形成的路径与根节点父亲并不在一条路径上。所以此情况应在全局变量中比较<br>并不能作为返回值。<br>gmax = max {return max{val,left+val,right+val}  or left+val+right}</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>4种情况: root， root + left, root + right, left + root + right, 不要漏掉最后一种left_sum + root.val + right_sum</li>
<li>全局最大值作为返回值，初始值为负无穷float(‘-inf’)。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	_, path_gsum = self.dfs(root)</span><br><span class="line">	<span class="keyword">return</span> path_gsum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">       <span class="keyword">return</span> float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	left_sum, left_gsum = self.dfs(root.left)</span><br><span class="line">	right_sum, right_gsum = self.dfs(root.right)</span><br><span class="line">	max_path_sum = max(left_sum + root.val, right_sum + root.val, root.val)</span><br><span class="line">	max_path_gsum = max(max_path_sum, left_gsum, right_gsum, left_sum + root.val + right_sum)</span><br><span class="line">	<span class="keyword">return</span> max_path_sum, max_path_gsum</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="算法II迭代解题思路："><a href="#算法II迭代解题思路：" class="headerlink" title="算法II迭代解题思路："></a><strong>算法II迭代解题思路：</strong></h3><p>由上述算法看出，属于后序遍历，因为先left, right, 再计算root。所以用后序遍历模板。然后定义dp[root]为以root为结束点的最大路径值，这与上题也一样。<br>递归式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[node] = max(dp[node.left] + node.val, dp[node.right] + node.val, node.val)</span><br></pre></td></tr></table></figure></p>
<p>res为全局最大值，也和上述一致<br>max_path_sum = dp[node]<br>res = left_gsum, right_gsum</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>occurrence先加再比较</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum2</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	it, stack, res = root, [], float(<span class="string">'-inf'</span>)</span><br><span class="line">	dp = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		stack.append((it, <span class="number">0</span>))</span><br><span class="line">		it = it.left</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		node, occurrence = stack.pop()</span><br><span class="line">		occurrence += <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> occurrence == <span class="number">2</span>:</span><br><span class="line">			dp[node] = max(dp[node.left] + node.val, dp[node.right] + node.val, node.val)</span><br><span class="line">			res = max(res, dp[node], dp[node.left] + node.val + dp[node.right])</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append((node, occurrence))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			n = node.right</span><br><span class="line">			<span class="keyword">while</span> n:</span><br><span class="line">				stack.append((n, <span class="number">0</span>))</span><br><span class="line">				n = n.left</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up"></a><strong>Follow-up</strong></h3><p>若path的起始点均为叶子节点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>叶子节点要返回值，gsum为无穷小。修改max_path_sum和max_path_gsum公式，不含单独root以及gsum不含以root为终点的路径。<br>还有路径可能不存在</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum_fromleaf2leaf</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	path_sum, path_gsum = self.dfs_leaf(root)</span><br><span class="line">	<span class="keyword">return</span> path_gsum <span class="keyword">if</span> path_gsum != float(<span class="string">'-inf'</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_leaf</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">		<span class="keyword">return</span> root.val, float(<span class="string">'-inf'</span>) <span class="comment"># remember no gsum</span></span><br><span class="line">	left_sum, left_gsum = self.dfs_leaf(root.left)</span><br><span class="line">	right_sum, right_gsum = self.dfs_leaf(root.right)</span><br><span class="line">	max_path_sum = max(left_sum + root.val, right_sum + root.val)</span><br><span class="line">	max_path_gsum = max(left_gsum, right_gsum, left_sum + root.val + right_sum)</span><br><span class="line">	<span class="keyword">return</span> max_path_sum, max_path_gsum</span><br></pre></td></tr></table></figure>
<h3 id="Follow-up-2"><a href="#Follow-up-2" class="headerlink" title="Follow-up 2"></a><strong>Follow-up 2</strong></h3><p>若path的起始点均为叶子节点且只能从某些特定的叶子节点出发和结束</p>
<h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同上，只不过加入条件root.val in endnodes</p>
<h3 id="Python代码：-3"><a href="#Python代码：-3" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum_fromSpecificNodes</span><span class="params">(self, root: TreeNode, endnodes)</span> -&gt; int:</span></span><br><span class="line">	path_sum, path_gsum = self.dfs_end_nodes(root, set(endnodes))</span><br><span class="line">	<span class="keyword">return</span> path_gsum <span class="keyword">if</span> path_gsum != float(<span class="string">'-inf'</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_end_nodes</span><span class="params">(self, root: TreeNode, endnodes)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val <span class="keyword">in</span> endnodes:</span><br><span class="line">		<span class="keyword">return</span> root.val, float(<span class="string">'-inf'</span>) <span class="comment"># remember no gsum</span></span><br><span class="line">	left_sum, left_gsum = self.dfs_end_nodes(root.left, endnodes)</span><br><span class="line">	right_sum, right_gsum = self.dfs_end_nodes(root.right, endnodes)</span><br><span class="line">	max_path_sum = max(left_sum + root.val, right_sum + root.val)</span><br><span class="line">	max_path_gsum = max(left_gsum, right_gsum, left_sum + root.val + right_sum)</span><br><span class="line">	<span class="keyword">return</span> max_path_sum, max_path_gsum</span><br></pre></td></tr></table></figure>
<h3 id="Follow-up-3"><a href="#Follow-up-3" class="headerlink" title="Follow-up 3"></a><strong>Follow-up 3</strong></h3><p>若path的起始点可为任意节点且只能从某些特定的叶子节点出发和结束</p>
<h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>若起始节点为非叶子节点，注意将表达式修改为原始表达式。</p>
<h3 id="Python代码：-4"><a href="#Python代码：-4" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum_fromSpecificNodes2</span><span class="params">(self, root: TreeNode, endnodes)</span> -&gt; int:</span></span><br><span class="line">	path_sum, path_gsum = self.dfs_end_nodes2(root, set(endnodes))</span><br><span class="line">	<span class="keyword">return</span> path_gsum <span class="keyword">if</span> path_gsum != float(<span class="string">'-inf'</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_end_nodes2</span><span class="params">(self, root: TreeNode, endnodes)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val <span class="keyword">in</span> endnodes:</span><br><span class="line">		<span class="keyword">return</span> root.val, float(<span class="string">'-inf'</span>) <span class="comment"># remember no gsum</span></span><br><span class="line">	left_sum, left_gsum = self.dfs_end_nodes2(root.left, endnodes)</span><br><span class="line">	right_sum, right_gsum = self.dfs_end_nodes2(root.right, endnodes)</span><br><span class="line">	max_path_sum = max(left_sum + root.val, right_sum + root.val)</span><br><span class="line">	<span class="keyword">if</span> root.val <span class="keyword">in</span> endnodes:</span><br><span class="line">		max_path_sum = max(max_path_sum, root.val)</span><br><span class="line">	max_path_gsum = max(left_gsum, right_gsum, left_sum + root.val + right_sum)</span><br><span class="line">	<span class="keyword">if</span> root.val <span class="keyword">in</span> endnodes:</span><br><span class="line">		max_path_gsum = max(max_path_gsum, max_path_sum)</span><br><span class="line">	<span class="keyword">return</span> max_path_sum, max_path_gsum</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>4种情况</li>
<li>定义全局变量来比较最大值，因为左到右情况不能返回。全局变量初始值为负无穷。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gsum = Integer.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	gsum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a = max(root);</span><br><span class="line">	<span class="keyword">return</span> gsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lmax = max(root.left);</span><br><span class="line">	<span class="keyword">int</span> rmax = max(root.right);</span><br><span class="line">	<span class="keyword">int</span> sum = Math.max(Math.max(lmax, rmax)+root.val,root.val);</span><br><span class="line">	gsum = Math.max(Math.max(gsum, sum), lmax+root.val+rmax);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为节点数。空间复杂度为<code>O(h)</code>，h为二叉树高度。</p>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p>LeetCode 112 Path Sum<br>LeetCode 124 Binary Tree Maximum Path Sum</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>DoorDash</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 126 Word Ladder II</title>
    <url>/2020/05/03/lee-126/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">LeetCode 126 Word Ladder</a></strong></p>
<div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time<br>2.  Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.<br><br><strong>Note:</strong><br><br><em>   Return an empty list if there is no such transformation sequence.
</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.
</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong><br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> []<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求所有最少的变换路径。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>更难于Leetcode 127，BFS用于找最短路径而DFS找路径，此题正是贯彻这一思想，先用BFS找出最短路径，<br>然后根据最短路径值找出所有路径。找BFS解的同时建图用邻接表表示Map<string, list<string="">&gt;(这是<br>部分图，与解相关的图)和解集合Map<string, integer="">(从始点到不同节点的最短距离)，这两个信息正是<br>Dijkistra的图输入和解。DFS从始点开始遍历邻接节点，确保沿着最短路径走，最短路径为<br>map.get(cur)+1=map.get(next)表示当前节点到始点距离+1=儿节点到始点距离，终止条件为找到目标节点。  </string,></string,></p>
<ol>
<li>在遍历所有邻接节点的时候，如果不加筛选对所有邻接节点都做DFS会造成LTE。关键是要利用BFS中所有<br>节点到单源的最短路径来剪枝。只需DFS最短路径上的节点，否则跳过。  </li>
<li>利用了单源最短路径映射表distance后，不需要记录visited，因为重复的节点不会在最短路劲上。  </li>
<li>Cache nextWords的结果。     </li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p>
<ol>
<li>建字典。  </li>
<li>BFS访问，得到图和单源最短路径Map，以及最短路径距离。同时建立邻接表graph[word] = neighbors，DFS时候不用再次找相邻单词    </li>
<li>DFS求路径，按最短路径剪枝dict[neighbor] == dict[startWord] + 1。    </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意题目条件，开始词不在字典中(终结词默认在，否则无结果），要将它加入字典中且距离为1且要加入到path，Line 10。 </li>
<li>建图的邻接表，对没有边的节点也要加到邻接表，所以先对所有点赋空列表，再根据边更新值，Line 29。用defaultdict(list)可解决  </li>
<li>DFS模板中去掉visited部分，因为用了最短距离distance的map来指导访问路径，所以不会存在循环的情况(否则不会是最短距离)<br>而且如果有visited会存在丢解，因为如果一个节点不在最短路径上先被访问就会被标记为visited，真正到最短路径上时就会返回。<br>DFS模板中加入if dict[neighbor] == dict[startWord] + 1来剪边。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> endWord:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	distance, graph = &#123;&#125;, defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">		distance[word] = <span class="number">0</span></span><br><span class="line">	distance[beginWord] = <span class="number">1</span></span><br><span class="line">	self.bfs(beginWord, endWord, distance, graph, set())</span><br><span class="line">	result = []</span><br><span class="line">	self.dfs(graph, beginWord, endWord, [beginWord], result, distance) <span class="comment"># remember [beginWord]</span></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, startWord, endWord, path, res, dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> startWord == endWord:</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="string">'''if startWord in visited: # remember</span></span><br><span class="line"><span class="string">		return</span></span><br><span class="line"><span class="string">	visited.add(startWord)'''</span></span><br><span class="line">	<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[startWord]:</span><br><span class="line">		<span class="keyword">if</span> dict[neighbor] == dict[startWord] + <span class="number">1</span>:</span><br><span class="line">			path.append(neighbor)</span><br><span class="line">			self.dfs(graph, neighbor, endWord, path, res, dict)</span><br><span class="line">			path.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, beginWord, endWord, dict, graph, visited)</span>:</span></span><br><span class="line">	queue = deque([beginWord])</span><br><span class="line">	visited.add(beginWord)</span><br><span class="line">	<span class="comment"># for key in dict.keys():  # remember</span></span><br><span class="line">	<span class="comment">#    graph[key] = []</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		word = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> word == endWord:</span><br><span class="line">			<span class="keyword">return</span> dict[word]</span><br><span class="line"></span><br><span class="line">		neighbors = self.get_next_words(word, dict)</span><br><span class="line">		graph[word] = neighbors</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">				visited.add(neighbor)</span><br><span class="line">				dict[neighbor] = dict[word] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_words</span><span class="params">(self, word, dict)</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">		<span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase: <span class="comment"># or use 'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">			<span class="keyword">if</span> c == word[i]:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			new_word = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> new_word <span class="keyword">in</span> dict:</span><br><span class="line">				res.append(new_word)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">	List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(beginWord == <span class="keyword">null</span> || endWord == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">	Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line">	<span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line">	<span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">	dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line">	HashMap&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">	ladderLength(beginWord, endWord, dict, graph);</span><br><span class="line">	path.add(beginWord);</span><br><span class="line">	dfs(beginWord, endWord, dict, graph, path, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String endWord, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">		HashMap&lt;String, List&lt;String&gt;&gt; graph, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(endWord.equals(cur)) &#123;</span><br><span class="line">		res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(String word : graph.get(cur)) &#123;</span><br><span class="line">		path.add(word);</span><br><span class="line">		<span class="keyword">if</span>(distance.get(word) - <span class="number">1</span> == distance.get(cur)) <span class="comment">// use distance, resolve LTE the most important</span></span><br><span class="line">			dfs(word, endWord, distance, graph, path, res);</span><br><span class="line">		path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache getNextWords</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Map&lt;String, Integer&gt; dict, Map&lt;String, List&lt;String&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(beginWord);</span><br><span class="line">	visited.add(beginWord);</span><br><span class="line">	<span class="keyword">for</span>(String s : dict.keySet()) &#123;<span class="comment">// remember</span></span><br><span class="line">		graph.put(s, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		String word = q.poll();</span><br><span class="line">		<span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line">			<span class="keyword">return</span> dict.get(word);</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line">		graph.put(word, <span class="keyword">new</span> ArrayList&lt;&gt;(nextWords));</span><br><span class="line">		<span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line">			<span class="keyword">if</span>(visited.contains(s))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">			q.offer(s);</span><br><span class="line">			visited.add(s);</span><br><span class="line">			dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">	Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">		map.put(word, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line">			<span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line">			<span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">					newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line">			<span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">				result.add(newWord);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code>产生新字符串需要L<br>时间复杂度为<code>O(n<em><em>L</em><sup>2</sup> + m</em>k)</code>，空间复杂度<code>O(n)</code>，m为答案个数, k为最短路径值，n为单词数。 </p>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1268 Search Suggestions System</title>
    <url>/2021/12/25/lee-1268/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-suggestions-system/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.<br><br>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.<br><br>Return <em>a list of lists of the suggested products after each character of</em> <code>searchWord</code> <em>is typed</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> products = [“mobile”,”mouse”,”moneypot”,”monitor”,”mousepad”], searchWord = “mouse”<br><strong>Output:</strong> [<br>[“mobile”,”moneypot”,”monitor”],<br>[“mobile”,”moneypot”,”monitor”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”]<br>]<br><strong>Explanation:</strong> products sorted lexicographically = [“mobile”,”moneypot”,”monitor”,”mouse”,”mousepad”]<br>After typing m and mo all products match and we show user [“mobile”,”moneypot”,”monitor”]<br>After typing mou, mous and mouse the system suggests [“mouse”,”mousepad”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> products = [“havana”], searchWord = “havana”<br><strong>Output:</strong> [[“havana”],[“havana”],[“havana”],[“havana”],[“havana”],[“havana”]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> products = [“bags”,”baggage”,”banner”,”box”,”cloths”], searchWord = “bags”<br><strong>Output:</strong> [[“baggage”,”bags”,”banner”],[“baggage”,”bags”,”banner”],[“baggage”,”bags”],[“bags”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= products.length &lt;= 1000</code>
</em>   <code>1 &lt;= products[i].length &lt;= 3000</code><br><em>   `1 &lt;= sum(products[i].length) &lt;= 2 </em> 10<sup>4</sup><code>*   All the strings of</code>products<code>are **unique**.
*</code>products[i]<code>consists of lowercase English letters.
*</code>1 &lt;= searchWord.length &lt;= 1000<code>*</code>searchWord` consists of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现搜索结果为3个autocomplete的功能</p>
<h3 id="Prefix解题思路-推荐-："><a href="#Prefix解题思路-推荐-：" class="headerlink" title="Prefix解题思路(推荐)："></a><strong>Prefix解题思路(推荐)：</strong></h3><p>Prefix</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Trie，另一种思路是用prefix，此法采用prefix法，将所有单词按前缀加入到字典中     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products: List[str], searchWord: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">	products.sort()</span><br><span class="line">	prefix_dict = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> products:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">			prefix = word[:i + <span class="number">1</span>]</span><br><span class="line">			<span class="keyword">if</span> len(prefix_dict[prefix]) &lt; <span class="number">3</span>:</span><br><span class="line">				prefix_dict[prefix].append(word)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(searchWord)):</span><br><span class="line">		prefix = searchWord[:i + <span class="number">1</span>]</span><br><span class="line">		res.append(prefix_dict[prefix])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL1 + L2)</code>，空间复杂度<code>O(nL1)</code>, L1为单词列表中最长的长度，L2为搜索单词长度，n为单词个数  </p>
<hr>
<h3 id="Trie-DFS算法II解题思路："><a href="#Trie-DFS算法II解题思路：" class="headerlink" title="Trie + DFS算法II解题思路："></a><strong>Trie + DFS算法II解题思路：</strong></h3><p>建Trie，然后根据搜索的前缀定位到Trie节点，然后对此节点做DFS找到3个单词，因为DFS和字母顺序是一致的，所以DFS可行<br>具体参考Leetcode solution</p>
<hr>
<h3 id="Two-pointers算法III解题思路："><a href="#Two-pointers算法III解题思路：" class="headerlink" title="Two pointers算法III解题思路："></a><strong>Two pointers算法III解题思路：</strong></h3><p>先排序，用双指针相向搜索，根据搜索单词的每一个字母，不断收缩搜索范围，左指针和右指针之间即为满足条件的结果。每轮将左指针往后三个结果加到结果集<br>具体参考Leetcode discussion  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Amazon</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 127 Word Ladder</title>
    <url>/2020/04/20/lee-127/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">LeetCode 127 Word Ladder</a></strong></p>
<div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time.<br>2.  Each transformed word must exist in the word list.<br><br><strong>Note:</strong><br><br><em>   Return 0 if there is no such transformation sequence.
</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.
</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong> 5<br><br><strong>Explanation:</strong> As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> 0<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求最少变换次数。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p>
<ol>
<li>这是图，所以要有visited记录是否重复访问。</li>
<li>字典的实现两个作用： 快速查找，以及记录距离可以省下一轮循环。总共两重循环。  </li>
<li>getNextWords的实现。通过变换每位上字母，比较巧妙。    </li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p>
<ol>
<li>建字典。  </li>
<li>BFS访问。  </li>
<li>求所有距离为1的相邻单词getNextWords。    </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意题目条件，开始词不在字典中(终结词默认在，否则无结果），要将它加入字典中且距离为1。  </li>
<li>用Map来记录解(儿子节点，参考按层搜索)，visited用于记录父节点  </li>
<li>getNextWords的实现不含自己。  </li>
<li>Python中用popleft出列，不是pop</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> endWord:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	distance = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">		distance[word] = <span class="number">0</span></span><br><span class="line">	distance[beginWord] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> self.bfs(beginWord, endWord, distance, set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, beginWord, endWord, dict, visited)</span>:</span></span><br><span class="line">	queue = deque([beginWord])</span><br><span class="line">	visited.add(beginWord)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		word = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> word == endWord:</span><br><span class="line">			<span class="keyword">return</span> dict[word]</span><br><span class="line"></span><br><span class="line">		neighbors = self.get_next_words(word, dict)</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">				visited.add(neighbor)</span><br><span class="line">				dict[neighbor] = dict[word] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_words</span><span class="params">(self, word, dict)</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">		<span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase: <span class="comment"># or use 'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">			<span class="keyword">if</span> c == word[i]:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			new_word = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> new_word <span class="keyword">in</span> dict:</span><br><span class="line">				res.append(new_word)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">	Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line">	<span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line">	<span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">	dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(beginWord);</span><br><span class="line">	visited.add(beginWord);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		String word = q.poll();</span><br><span class="line">		<span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line">			<span class="keyword">return</span> dict.get(word);</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line">		<span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line">			<span class="keyword">if</span>(visited.contains(s))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">			q.offer(s);</span><br><span class="line">			visited.add(s);</span><br><span class="line">			dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">	Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">		map.put(word, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line">			<span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line">			<span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">					newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line">			<span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">				result.add(newWord);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code>产生新字符串需要L<br>时间复杂度为<code>O(n*<em>L</em><sup>2</sup>)</code>，空间复杂度<code>O(n)</code>，n为单词数。  </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>利用双向BFS，参考<a href="https://leetcode-cn.com/problems/open-the-lock/solution/shuang-xiang-bfsliang-mian-bao-jia-zhi-s-hvev/" target="_blank" rel="noopener">双向BFS概念</a><br>如果搜索不够广的话(例如类似于一条直线)，BFS会较慢，用双向BFS可解决此问题。双向BFS就是同时从起点和终点两个方向开始搜索，结果分存在map中，如果节点在另一个map中，<br>就意味着找到了一条连接起点和终点的最短路径。若任一queue为空，表明不会存在路径。如下图，前向BFS找到了结果。<br><img src="/images/bi-bfs.png" alt=""><br>搜索方式分为同步搜索和队列容量较少的先搜。本法采取前者 </p>
<h3 id="解题步骤：-1"><a href="#解题步骤：-1" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>与单向BFS类似，但由于现在是双向，所以将BFS的通用部分提取出来，变量为queue, visited, distance, target_distance, target_distance是查找本方向<br>的节点是否在对方搜索过的路径上代替endWord，距离为本方向的路径+对方的路径。while循环移到调用函数中。  </li>
<li>while循环用两个queue不为空  </li>
<li>为了优化get_next_words重复调用，将结果存在graph中形成邻接表。这样的话，distance不用初始化为0，还可以用于记录重复节点代替visited。    </li>
<li>其他初始化步骤给endWord的BFS复制一次。  </li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>graph = collections.defaultdict(list)避免NPE，dict都尽量用此法  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength2</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> endWord:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	wordList.append(beginWord)</span><br><span class="line">	graph, word_dict = collections.defaultdict(list), set(wordList)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">		graph[word] = self.get_next_words(word, word_dict)</span><br><span class="line">	forward_distance, backward_distance = collections.defaultdict(int), collections.defaultdict(int)</span><br><span class="line">	forward_distance[beginWord], backward_distance[endWord] = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	forward_queue, backward_queue = deque([beginWord]), deque([endWord])</span><br><span class="line">	forward_visited, backward_visited = set([beginWord]), set([endWord])</span><br><span class="line">	<span class="keyword">while</span> forward_queue <span class="keyword">and</span> backward_queue:</span><br><span class="line">		total_dis = self.bfs_from_start_or_end(graph, forward_queue, forward_distance, backward_distance)</span><br><span class="line">		<span class="keyword">if</span> total_dis &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> total_dis</span><br><span class="line">		total_dis = self.bfs_from_start_or_end(graph, backward_queue, backward_distance, forward_distance)</span><br><span class="line">		<span class="keyword">if</span> total_dis &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> total_dis</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_from_start_or_end</span><span class="params">(self, graph, queue, distance, target_dict)</span>:</span></span><br><span class="line">	word = queue.popleft()</span><br><span class="line">	<span class="keyword">if</span> word <span class="keyword">in</span> target_dict <span class="keyword">and</span> target_dict[word] &gt; <span class="number">0</span>:  <span class="comment"># the forward distance has all words initially</span></span><br><span class="line">		<span class="keyword">return</span> distance[word] + target_dict[word]</span><br><span class="line"></span><br><span class="line">	neighbors = graph[word]</span><br><span class="line">	<span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:</span><br><span class="line">		<span class="comment">#if neighbor in visited:</span></span><br><span class="line">		<span class="keyword">if</span> neighbor <span class="keyword">in</span> distance:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		queue.append(neighbor)</span><br><span class="line">		<span class="comment"># visited.add(neighbor)</span></span><br><span class="line">		distance[neighbor] = distance[word] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 125 Valid Palindrome</title>
    <url>/2022/01/16/lee-125-valid-palindrome/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-palindrome" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “A man, a plan, a canal: Panama”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “amanaplanacanalpanama” is a palindrome.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “race a car”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “raceacar” is not a palindrome.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ “<br><strong>Output:</strong> true<br><strong>Explanation:</strong> s is an empty string “” after removing non-alphanumeric characters.<br>Since an empty string reads the same forward and backward, it is a palindrome.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 2 </em> 10<sup>5</sup><code>*</code>s` consists only of printable ASCII characters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求含非字母数字的字符串是否回文，字符串含空格，冒号等. Easy题</p>
<h3 id="双指针解题思路-推荐-："><a href="#双指针解题思路-推荐-：" class="headerlink" title="双指针解题思路(推荐)："></a><strong>双指针解题思路(推荐)：</strong></h3><p>回文首先考虑用相向双指针</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较时，要转换成小写</li>
<li>外循环left &lt; right条件要复制到内循环中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	left, right = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		<span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">			right -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> s[left].lower() != s[right].lower():</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		left += <span class="number">1</span></span><br><span class="line">		right -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="reverse法算法II解题思路："><a href="#reverse法算法II解题思路：" class="headerlink" title="reverse法算法II解题思路："></a><strong>reverse法算法II解题思路：</strong></h3><p>reverse字符串比较</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较时，要转换成小写</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome2</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char.isalpha() <span class="keyword">or</span> char.isdigit():</span><br><span class="line">			res += char.lower()</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> res == res[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 128 Longest Consecutive Sequence</title>
    <url>/2018/05/07/lee-128-longest-consecutive-sequence/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">LeetCode 128 Longest Consecutive Sequence</a></strong></p>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(<em>n</em>) complexity.</p>
<p><strong>Example:</strong></p>
<pre>**Input:** [100, 4, 200, 1, 3, 2]
**Output:** 4
**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给出一个未排序的整数数组，找出最长的连续元素序列的长度。<br>如： 给出[100, 4, 200, 1, 3, 2]，最长的连续元素序列是[1, 2, 3, 4]。返回它的长度：4。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是连通问题，如果用排序方法，很容易，但时间复杂度为O(nlogn)。考虑改进，因为连通集，容易想到HashMap，把每个元素加入到其中，<br>然后对每个元素进行相邻查找。相邻查找就是以此元素为中心，向上向下在Map查找，从而得到此元素的最大连续序列长度。查找过的元素<br>在Map中删除，以免重复计算。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>加入set之后的元素不能再内循环中删除，因为外循环是遍历每一个数，可能会遍历到删除的数，正确做法是用map的value来记录是否访问过。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	num_set = collections.Counter(nums)</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		<span class="keyword">if</span> num_set[n] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		max_len = <span class="number">1</span></span><br><span class="line">		num_set[n] = <span class="number">0</span></span><br><span class="line">		i = n + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> i <span class="keyword">in</span> num_set:</span><br><span class="line">			num_set[i] = <span class="number">0</span></span><br><span class="line">			max_len += <span class="number">1</span></span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		i = n - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> i <span class="keyword">in</span> num_set:</span><br><span class="line">			num_set[i] = <span class="number">0</span></span><br><span class="line">			max_len += <span class="number">1</span></span><br><span class="line">			i -= <span class="number">1</span></span><br><span class="line">		res = max(res, max_len)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Java中在for循环中不能修改hashSet，所以只能用HashMap且value存boolean替代。HashMap表示此Map还是否含有该元素。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	HashMap&lt;Integer,Boolean&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer,Boolean&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">		hm.put(i, <span class="keyword">true</span>);</span><br><span class="line">	</span><br><span class="line">	Iterator it = hm.keySet().iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		<span class="keyword">int</span> key = (<span class="keyword">int</span>)it.next();</span><br><span class="line">		<span class="keyword">int</span> i = key+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(hm.containsKey(i) &amp;&amp; hm.get(i))&#123;</span><br><span class="line">			count++;</span><br><span class="line">			hm.put(i, <span class="keyword">false</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		i = key-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(hm.containsKey(i) &amp;&amp; hm.get(i))&#123;</span><br><span class="line">			count++;</span><br><span class="line">			hm.put(i, <span class="keyword">false</span>);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(count&gt;result)</span><br><span class="line">			result = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1326 Minimum Number of Taps to Open to Water a Garden</title>
    <url>/2021/12/15/lee-1326/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a one-dimensional garden on the x-axis. The garden starts at the point <code>0</code> and ends at the point <code>n</code>. (i.e The length of the garden is <code>n</code>).<br><br>There are <code>n + 1</code> taps located at points <code>[0, 1, ..., n]</code> in the garden.<br><br>Given an integer <code>n</code> and an integer array <code>ranges</code> of length <code>n + 1</code> where <code>ranges[i]</code> (0-indexed) means the <code>i-th</code> tap can water the area <code>[i - ranges[i], i + ranges[i]]</code> if it was open.<br><br>Return <em>the minimum number of taps</em> that should be open to water the whole garden, If the garden cannot be watered return <strong>-1</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png" alt=""><br><br><pre><strong>Input:</strong> n = 5, ranges = [3,4,1,1,0,0]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The tap at point 0 can cover the interval [-3,3]<br>The tap at point 1 can cover the interval [-3,5]<br>The tap at point 2 can cover the interval [1,3]<br>The tap at point 3 can cover the interval [2,4]<br>The tap at point 4 can cover the interval [4,4]<br>The tap at point 5 can cover the interval [5,5]<br>Opening Only the second tap will water the whole garden [0,5]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3, ranges = [0,0,0,0]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> Even if you activate all the four taps you cannot water the whole garden.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 7, ranges = [1,2,1,0,2,1,0,1]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>ranges.length == n + 1</code><br>*   <code>0 &lt;= ranges[i] &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>用多少个水龙头覆盖整个花园</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两个难点，此题类似于jump game，这一层某个水龙头浇到最远点的水龙头也就是这一层的水龙头，这是难点一。<br>难点二是跟jump game不同，这题可以往前跳，也就是如例子中，点2表示从1跳到3，因为它的范围是1. 所以要重新计算每个水龙头的起点=它的左半范围起点  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>第一步转化成jump game，jump game每个数值都是长度。若左半范围起点小于等于0，所有这些水龙头归结到起点0，长度为i + ranges[i], 其余情况是ranges[i] * 2    </li>
<li>完全用jump game的程序</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTaps</span><span class="params">(self, n: int, ranges: List[int])</span> -&gt; int:</span></span><br><span class="line">	end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	nums = [<span class="number">0</span>] * len(ranges)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(ranges)):</span><br><span class="line">		<span class="keyword">if</span> i - ranges[i] &lt;= <span class="number">0</span>:</span><br><span class="line">			nums[<span class="number">0</span>] = max(nums[<span class="number">0</span>], ranges[i] + i)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nums[i - ranges[i]] = max(nums[i - ranges[i]], ranges[i] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>): <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> i &lt;= end:  <span class="comment"># -3 &lt;= 0</span></span><br><span class="line">			next_end = max(next_end, i + nums[i])  <span class="comment"># 3</span></span><br><span class="line">		<span class="keyword">if</span> i == end:</span><br><span class="line">			end = next_end</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res <span class="keyword">if</span> next_end &gt;= len(nums) - <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 133 Clone Graph</title>
    <url>/2020/04/19/lee-133/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">LeetCode 133 Clone Graph</a></strong></p>
<p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory" target="_blank" rel="noopener">connected</a>#Connected_graph)</strong> undirected graph.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> (clone) of the graph.</p>
<p>Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<pre>class Node {
    public int val;
    public List<node> neighbors;
}
</node></pre>

<p><strong>Test case format:</strong></p>
<p>For simplicity sake, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code>val = 1</code>, the second node with <code>val = 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>
<p><strong>Adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>
<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt=""></p>
<pre>**Input:** adjList = [[2,4],[1,3],[2,4],[1,3]]
**Output:** [[2,4],[1,3],[2,4],[1,3]]
**Explanation:** There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
</pre>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" alt=""></p>
<pre>**Input:** adjList = [[]]
**Output:** [[]]
**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** adjList = []
**Output:** []
**Explanation:** This an empty graph, it does not have any nodes.
</pre>

<p><strong>Example 4:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph-1.png" alt=""></p>
<pre>**Input:** adjList = [[2],[1]]
**Output:** [[2],[1]]
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= Node.val &lt;= 100</code></li>
<li><code>Node.val</code> is unique for each node.</li>
<li>Number of Nodes will not exceed 100.</li>
<li>There is no repeated edges and no self-loops in the graph.</li>
<li>The Graph is connected and all nodes can be visited starting from the given node.</li>
</ul>
<p></p>
<p></p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>深度复制图。注意要复制所有邻接节点。 </p>
<h3 id="算法I解题思路-推荐-："><a href="#算法I解题思路-推荐-：" class="headerlink" title="算法I解题思路(推荐)："></a><strong>算法I解题思路(推荐)：</strong></h3><p>三步走。分开写逻辑会显得清晰点。</p>
<ol>
<li>BFS搜索所有节点，变成<del>邻接表</del>节点列表。</li>
<li>复制节点。旧新节点映射存在dict中</li>
<li>根据node.neighbors复制边。 </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>空节点判断Line 2-3</strong>  </li>
<li>BFS访问是收集节点列表，并不是变成邻接表。如果是含循环的图，由于用了visited，所以邻接表只能复制一半的边，不能用邻接表   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	di = &#123;&#125;</span><br><span class="line">	node_list = self.bfs(node)</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> node_list:</span><br><span class="line">		di[n] = Node(n.val)</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> node_list:</span><br><span class="line">		<span class="keyword">for</span> n2 <span class="keyword">in</span> n.neighbors:</span><br><span class="line">			di[n].neighbors.append(di[n2])</span><br><span class="line">	<span class="keyword">return</span> di[node]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, input)</span>:</span></span><br><span class="line">	queue = deque([input])</span><br><span class="line">	visited = &#123;input&#125;</span><br><span class="line">	<span class="comment"># graph = collections.defaultdict(list)</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="comment"># graph[node] = []</span></span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			<span class="comment"># graph[node].append(neighbor)</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another bfs3 method uses 3 steps, convert graph to adjacent list by bfs (flatten the graph), </span></span><br><span class="line"><span class="comment">//clone vertices, clone edges</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs3</span><span class="params">(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;UndirectedGraphNode&gt; nodes = getNodes(node);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Copy vertices</span></span><br><span class="line">	<span class="keyword">for</span>(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">		UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(old.label);</span><br><span class="line">		map.put(old, newNode);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Copy edges</span></span><br><span class="line">	<span class="keyword">for</span>(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">		<span class="keyword">for</span>(UndirectedGraphNode neighbor : old.neighbors) &#123;</span><br><span class="line">			map.get(old).neighbors.add(map.get(neighbor));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;UndirectedGraphNode&gt; <span class="title">getNodes</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">	Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	Set&lt;UndirectedGraphNode&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	q.offer(node);</span><br><span class="line">	result.add(node); <span class="comment">// Use result set so we can save the visited set</span></span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		UndirectedGraphNode n = q.poll();</span><br><span class="line">		<span class="keyword">for</span>(UndirectedGraphNode neighbor : n.neighbors) &#123;</span><br><span class="line">			<span class="keyword">if</span>(result.contains(neighbor))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			q.offer(neighbor);</span><br><span class="line">			result.add(neighbor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ArrayList&lt;UndirectedGraphNode&gt; reList = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">	reList.addAll(result);</span><br><span class="line">	<span class="keyword">return</span> reList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>不分开三步写</p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph2</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	bfs(node, map);</span><br><span class="line">	<span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</span><br><span class="line">	Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.offer(node);</span><br><span class="line">	map.put(node, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		UndirectedGraphNode head = q.poll();</span><br><span class="line">		<span class="keyword">for</span>(UndirectedGraphNode neighbor : head.neighbors) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!map.containsKey(neighbor)) &#123;</span><br><span class="line">				q.offer(neighbor);</span><br><span class="line">				<span class="comment">// Clone children's vertex</span></span><br><span class="line">				map.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Clone edge</span></span><br><span class="line">			map.get(head).neighbors.add(map.get(neighbor));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="算法II解题思路：-1"><a href="#算法II解题思路：-1" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>DFS。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</span><br><span class="line">	HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;Integer, UndirectedGraphNode&gt;();</span><br><span class="line">	return cloneGraphR(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public UndirectedGraphNode cloneGraphR(UndirectedGraphNode node,</span><br><span class="line">		HashMap&lt;Integer, UndirectedGraphNode&gt; map) &#123;</span><br><span class="line">	if (node == null)</span><br><span class="line">		return node;</span><br><span class="line">	if (map.containsKey(node.label))</span><br><span class="line">		return map.get(node.label);</span><br><span class="line"></span><br><span class="line">	UndirectedGraphNode result = new UndirectedGraphNode(node.label);</span><br><span class="line">	map.put(node.label, result);</span><br><span class="line">	for (UndirectedGraphNode child : node.neighbors) &#123;</span><br><span class="line">		result.neighbors.add(cloneGraphR(child, map));</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 134 Gas Station</title>
    <url>/2021/12/09/lee-134/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> station is <code>gas[i]</code>.<br><br>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> station to its next <code>(i + 1)&lt;sup&gt;th&lt;/sup&gt;</code> station. You begin the journey with an empty tank at one of the gas stations.<br><br>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong><br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 4. Your tank = 4 - 1 + 5 = 8<br>Travel to station 0. Your tank = 8 - 2 + 1 = 7<br>Travel to station 1. Your tank = 7 - 3 + 2 = 6<br>Travel to station 2. Your tank = 6 - 4 + 3 = 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong><br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 0. Your tank = 4 - 3 + 2 = 3<br>Travel to station 1. Your tank = 3 - 3 + 3 = 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>gas.length == n</code>
</em>   <code>cost.length == n</code><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= gas[i], cost[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>只要总gas &gt;= 总cost，就总有一个点满足gas-cost为非负  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先判断不合法的情况sum(gas) &lt; sum(cost)   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> sum(gas) &lt; sum(cost):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	sum_gas, sum_cost, pos = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">		sum_gas += gas[i]</span><br><span class="line">		sum_cost += cost[i]</span><br><span class="line">		<span class="keyword">if</span> sum_gas &lt; sum_cost:</span><br><span class="line">			pos = i + <span class="number">1</span></span><br><span class="line">			sum_gas = <span class="number">0</span></span><br><span class="line">			sum_cost = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> pos</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 138 Copy List with Random Pointer</title>
    <url>/2021/07/27/lee-138/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">LeetCode 138 Copy List with Random Pointer</a></strong></p>
<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>
<p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>
<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>
<p>Return <em>the head of the copied linked list</em>.</p>
<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>
<ul>
<li><code>val</code>: an integer representing <code>Node.val</code></li>
<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>
<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt=""></p>
<pre>**Input:** head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
**Output:** [[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt=""></p>
<pre>**Input:** head = [[1,1],[2,1]]
**Output:** [[1,1],[2,1]]
</pre>

<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt=""></strong></p>
<pre>**Input:** head = [[3,null],[3,0],[3,null]]
**Output:** [[3,null],[3,0],[3,null]]
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:** head = []
**Output:** []
**Explanation:** The given linked list is empty (null pointer), so return null.
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>复制含next和random的链表。</p>
<h3 id="解题思路（推荐）："><a href="#解题思路（推荐）：" class="headerlink" title="解题思路（推荐）："></a><strong>解题思路（推荐）：</strong></h3><p>此法较容易实现。先复制next指针，然后利用HashMap存储旧新节点，来复制random指针。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>复制next指针和Map中。<strong>clone题均用此法。</strong>  </li>
<li>Random指针不空才copy</li>
<li>加it = it.next，否则死循环</li>
<li>如果创建新Node用while it.next表示用它的父节点，否则某个field赋值如random用while it</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">	node_map = &#123;&#125;</span><br><span class="line">	fake_head, fake_head_copy = Node(<span class="number">0</span>), Node(<span class="number">0</span>)</span><br><span class="line">	fake_head.next = head</span><br><span class="line">	it, it_copy = fake_head, fake_head_copy</span><br><span class="line">	<span class="keyword">while</span> it.next:</span><br><span class="line">		it_copy.next = Node(it.next.val)</span><br><span class="line">		node_map[it.next] = it_copy.next</span><br><span class="line">		it, it_copy = it.next, it_copy.next</span><br><span class="line"></span><br><span class="line">	it, it_copy = fake_head.next, fake_head_copy.next</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		<span class="keyword">if</span> it.random:</span><br><span class="line">			node_map[it].random = node_map[it.random]</span><br><span class="line">		it, it_copy = it.next, it_copy.next</span><br><span class="line">	<span class="keyword">return</span> fake_head_copy.next</span><br></pre></td></tr></table></figure>
<h3 id="梅花间竹解题思路："><a href="#梅花间竹解题思路：" class="headerlink" title="梅花间竹解题思路："></a><strong>梅花间竹解题思路：</strong></h3><p>第二种方法，梅花间竹，分3部走。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">	fake_head, fake_head_copy = Node(<span class="number">0</span>), Node(<span class="number">0</span>)</span><br><span class="line">	fake_head.next = head</span><br><span class="line"></span><br><span class="line">	<span class="comment"># insert</span></span><br><span class="line">	it = fake_head.next</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		temp = it.next</span><br><span class="line">		it.next = Node(it.val)</span><br><span class="line">		it.next.next = temp</span><br><span class="line">		it = it.next.next</span><br><span class="line"></span><br><span class="line">	<span class="comment"># copy random</span></span><br><span class="line">	it = fake_head.next</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		<span class="keyword">if</span> it.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">			it.next.random = it.random.next</span><br><span class="line">		it = it.next.next</span><br><span class="line"></span><br><span class="line">	<span class="comment"># delete</span></span><br><span class="line">	it, it_copy = fake_head.next, fake_head_copy</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		temp = it.next</span><br><span class="line">		it.next = it.next.next</span><br><span class="line">		it_copy.next = temp</span><br><span class="line">		temp.next = <span class="keyword">None</span></span><br><span class="line">		it, it_copy = it.next, it_copy.next</span><br><span class="line">	<span class="keyword">return</span> fake_head_copy.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><ol>
<li>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</li>
<li>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</li>
</ol>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Python KB</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 139 Word Break</title>
    <url>/2020/05/09/lee-139/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">LeetCode 139 Word Break</a></strong></p>
<div><br><br>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.<br><br><strong>Note:</strong><br><br><em>   The same word in the dictionary may be reused multiple times in the segmentation.
</em>   You may assume the dictionary does not contain duplicate words.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, wordDict = [“leet”, “code”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “applepenapple”, wordDict = [“apple”, “pen”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because <code>&quot;</code>applepenapple<code>&quot;</code> can be segmented as <code>&quot;</code>apple pen apple<code>&quot;</code>.<br>             Note that you are allowed to reuse a dictionary word.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>Output:</strong> false<br></pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，是否能够被“字典集合”（wordDict）中的单词拼接而成。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。如果知道s[0:n-1)很容易知道s[0:n)是否有解，既然和子问题有关，就用DP。  </p>
<ol>
<li>定义dp[i]为字符串s[0,i)是否可以合法分解。</li>
<li>判断一个字符串是否可以合法分解，方案是尝试在每一位进行分解，若其中一个可分解，即有解。<br>递归式为dp[i] |= dp[k] &amp;&amp; isWord(s[k:i)), 0 &lt;= k &lt; i. </li>
<li>方向为从左到右i=0..n, 初始值为dp[0] = true. </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值dp[0] = True。  </li>
<li>递归中dp[i]用或操作符。</li>
<li>s[j:i] in word_set不要忘记上限为i</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	word_set = set(wordDict)</span><br><span class="line">	dp = [<span class="keyword">False</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">			dp[i] |= dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set</span><br><span class="line">	<span class="keyword">return</span> dp[len(dp) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>将两个输入都转换成小写。  </li>
<li>递归中dp[i]用或操作符。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty() || wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">		wordDictLower.add(c.toLowerCase());</span><br><span class="line">	s = s.toLowerCase();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;<span class="comment">//"a"</span></span><br><span class="line">			dp[i] |= dp[k] &amp;&amp; wordDictLower.contains(s.substring(k, i));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。</p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>这题也可以额用DFS来解。如果可以用DP就尽量用DP，只有求所有可能性才只能用DFS而不能用DP。<br>这道题递归子问题dfs[:n]为子串[0:n)是否可合法拆解。对于子问题而言，需要对其范围内i=[0:st)的每个可能位置分解<br>dfs[:i) + word[i:st)从而求出dfs(st)的解，只有任一分解成功，dfs(st)=true，否则false。 </p>
<p>Cache的应用场景： 如果子问题重复就要用Cache。<br>例如dfs(10)=dfs(9)+s[9:9] = (dfs(8) + s[8:8]) + s[9:9]<br>           =dfs(8)+s[8:9]<br>dfs(8)由第一层递归第二个循环s[8:9]和第二层递归s[9:9]达到，这是重复的子问题dfs(8)。如果不cache，dfs(8)的求解<br>是重复的。  </p>
<p><strong>Cache模板：</strong>  </p>
<ol>
<li>key为子问题索引st，value为子问题的解。  </li>
<li>紧跟终结条件，若在cache中，返回子问题的解。  </li>
<li>循环结束，将子问题的结果存于cache。  </li>
</ol>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>将两个输入都转换成小写。</li>
<li>递归中先查询词是否在字典中再递归。如果顺序调转就会LTE，因为这些子问题是白费的。  </li>
<li>递归终结条件为st==0而不是st==s.length()因为子问题递归从右到左。  </li>
</ol>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreakDFS</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty() || wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">		wordDictLower.add(c.toLowerCase());</span><br><span class="line">	s = s.toLowerCase();</span><br><span class="line">	Map&lt;Integer, Boolean&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">return</span> dfs(s, wordDictLower, s.length(), cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subproblem's answer dfs[:st)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> st, Map&lt;Integer, Boolean&gt; cache)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(cache.containsKey(st))</span><br><span class="line">		<span class="keyword">return</span> cache.get(st);</span><br><span class="line">	<span class="keyword">boolean</span> re = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(wordDict.contains(s.substring(i, st)) &amp;&amp; dfs(s, wordDict, i, cache))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cache.put(st, re);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
        <tag>Memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1396 Design Underground System</title>
    <url>/2021/12/14/lee-1396/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-underground-system/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.<br><br>Implement the <code>UndergroundSystem</code> class:<br><br><em>   <code>void checkIn(int id, string stationName, int t)</code>
    </em>   A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.<br>    <em>   A customer can only be checked into one place at a time.
</em>   <code>void checkOut(int id, string stationName, int t)</code><br>    <em>   A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.
</em>   <code>double getAverageTime(string startStation, string endStation)</code><br>    <em>   Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.
    </em>   The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.<br>    <em>   The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.
    </em>   There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.<br><br>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t&lt;sub&gt;1&lt;/sub&gt;</code> then checks out at time <code>t&lt;sub&gt;2&lt;/sub&gt;</code>, then <code>t&lt;sub&gt;1&lt;/sub&gt; &lt; t&lt;sub&gt;2&lt;/sub&gt;</code>. All events happen in chronological order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“UndergroundSystem”,”checkIn”,”checkIn”,”checkIn”,”checkOut”,”checkOut”,”checkOut”,”getAverageTime”,”getAverageTime”,”checkIn”,”getAverageTime”,”checkOut”,”getAverageTime”]<br>[[],[45,”Leyton”,3],[32,”Paradise”,8],[27,”Leyton”,10],[45,”Waterloo”,15],[27,”Waterloo”,20],[32,”Cambridge”,22],[“Paradise”,”Cambridge”],[“Leyton”,”Waterloo”],[10,”Leyton”,24],[“Leyton”,”Waterloo”],[10,”Waterloo”,38],[“Leyton”,”Waterloo”]]<br><br><strong>Output</strong><br>[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]<br><br><strong>Explanation</strong><br>UndergroundSystem undergroundSystem = new UndergroundSystem();<br>undergroundSystem.checkIn(45, “Leyton”, 3);<br>undergroundSystem.checkIn(32, “Paradise”, 8);<br>undergroundSystem.checkIn(27, “Leyton”, 10);<br>undergroundSystem.checkOut(45, “Waterloo”, 15);  // Customer 45 “Leyton” -&gt; “Waterloo” in 15-3 = 12<br>undergroundSystem.checkOut(27, “Waterloo”, 20);  // Customer 27 “Leyton” -&gt; “Waterloo” in 20-10 = 10<br>undergroundSystem.checkOut(32, “Cambridge”, 22); // Customer 32 “Paradise” -&gt; “Cambridge” in 22-8 = 14<br>undergroundSystem.getAverageTime(“Paradise”, “Cambridge”); // return 14.00000. One trip “Paradise” -&gt; “Cambridge”, (14) / 1 = 14<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 11.00000. Two trips “Leyton” -&gt; “Waterloo”, (10 + 12) / 2 = 11<br>undergroundSystem.checkIn(10, “Leyton”, 24);<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 11.00000<br>undergroundSystem.checkOut(10, “Waterloo”, 38);  // Customer 10 “Leyton” -&gt; “Waterloo” in 38-24 = 14<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 12.00000. Three trips “Leyton” -&gt; “Waterloo”, (10 + 12 + 14) / 3 = 12<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input</strong><br>[“UndergroundSystem”,”checkIn”,”checkOut”,”getAverageTime”,”checkIn”,”checkOut”,”getAverageTime”,”checkIn”,”checkOut”,”getAverageTime”]<br>[[],[10,”Leyton”,3],[10,”Paradise”,8],[“Leyton”,”Paradise”],[5,”Leyton”,10],[5,”Paradise”,16],[“Leyton”,”Paradise”],[2,”Leyton”,21],[2,”Paradise”,30],[“Leyton”,”Paradise”]]<br><br><strong>Output</strong><br>[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]<br><br><strong>Explanation</strong><br>UndergroundSystem undergroundSystem = new UndergroundSystem();<br>undergroundSystem.checkIn(10, “Leyton”, 3);<br>undergroundSystem.checkOut(10, “Paradise”, 8); // Customer 10 “Leyton” -&gt; “Paradise” in 8-3 = 5<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 5.00000, (5) / 1 = 5<br>undergroundSystem.checkIn(5, “Leyton”, 10);<br>undergroundSystem.checkOut(5, “Paradise”, 16); // Customer 5 “Leyton” -&gt; “Paradise” in 16-10 = 6<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 5.50000, (5 + 6) / 2 = 5.5<br>undergroundSystem.checkIn(2, “Leyton”, 21);<br>undergroundSystem.checkOut(2, “Paradise”, 30); // Customer 2 “Leyton” -&gt; “Paradise” in 30-21 = 9<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= id, t &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code>
</em>   <code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code><br><em>   All strings consist of uppercase and lowercase English letters and digits.
</em>   There will be at most <code>2 * 10&lt;sup&gt;4&lt;/sup&gt;</code> calls <strong>in total</strong> to <code>checkIn</code>, <code>checkOut</code>, and <code>getAverageTime</code>.<br>*   Answers within <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> of the actual value will be accepted.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两站之间的平均时间。checkin和checkout都会发生，一个人不能连续checkin两次。站都是按先到后。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用两个Map来记录customer id -&gt; 站台和时间，另一个记录起始站pair -&gt; 总距离多少trip pair  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>collections.defaultdict(lambda: [0, 0]) 用于value是pair     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start_to_end_time = &#123;&#125;</span><br><span class="line">        self.start_end_to_total = collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># cant use defaultdict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.start_to_end_time[id] = (stationName, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">not</span> <span class="keyword">in</span> self.start_to_end_time:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        (start_station, start_time) = self.start_to_end_time[id]</span><br><span class="line">        total, n_trips = self.start_end_to_total[(start_station, stationName)]</span><br><span class="line">        total += t - start_time</span><br><span class="line">        n_trips += <span class="number">1</span></span><br><span class="line">        self.start_end_to_total[(start_station, stationName)] = (total, n_trips)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        total, n_trips = self.start_end_to_total[(startStation, endStation)]</span><br><span class="line">        <span class="keyword">return</span> total / n_trips</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Bloomberg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 140 Word Break II</title>
    <url>/2020/05/09/lee-140/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">LeetCode 140 Word Break II</a></strong></p>
<div><br><br>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.<br><br><strong>Note:</strong><br><br><em>   The same word in the dictionary may be reused multiple times in the segmentation.
</em>   You may assume the dictionary does not contain duplicate words.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “<code>catsanddog</code>“<br>wordDict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code><br><strong>Output:</strong> <code>[
  &quot;cats and dog&quot;,
  &quot;cat sand dog&quot;
]</code><br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br><strong>Output:</strong> [<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br><strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>Output:</strong> []</pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，求被“字典集合”（wordDict）中的单词拼接的所有方案。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。求所有可能性想到DFS，前面Lintcode 683提到可能会有重复解。所以用Cache。    </p>
<p><strong>Cache模板：</strong>  </p>
<ol>
<li>key为子问题索引st，value为子问题的解。不含path和res因为类似于Catalan，用子问题返回结果来组成此轮结果。f(input, st, endIndex, cache)  </li>
<li>紧跟终结条件，若在cache中，返回子问题的解。  </li>
<li>循环结束，将子问题的结果存于cache。  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>终止条件返回[‘’]而不是[]，正如L017，空字符串作为初始结果。返回到上层要strip()    </li>
<li>子问题用f=word + f并不是f=f + word, 这样最后结果避免反转。</li>
<li>s[:i + 1]判断是否在字典中，而不是s[:i]，单词包括整个字符串。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">	wordSet = set()</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">		wordSet.add(word)</span><br><span class="line">	cache = &#123;&#125;</span><br><span class="line">	res = self.dfs(s, wordSet, cache)</span><br><span class="line">	<span class="keyword">return</span> [] <span class="keyword">if</span> len(res) == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> res[<span class="number">0</span>] <span class="keyword">else</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, wordSet, cache)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line">	<span class="keyword">if</span> s <span class="keyword">in</span> cache:</span><br><span class="line">		<span class="keyword">return</span> cache[s]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[:i + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> wordSet:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		li = self.dfs(s[i + <span class="number">1</span>:], wordSet, cache)</span><br><span class="line">		<span class="keyword">for</span> ss <span class="keyword">in</span> li:</span><br><span class="line">			res.append((s[:i + <span class="number">1</span>] + <span class="string">' '</span> + ss).strip())</span><br><span class="line"></span><br><span class="line">	cache[s] = res</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>将两个输入都转换成小写。  </li>
<li>复制子问题的解，不能直接在解List<string>上编辑。</string></li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty())</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">		wordDictLower.add(c.toLowerCase());</span><br><span class="line">	s = s.toLowerCase();</span><br><span class="line">	Map&lt;Integer, List&lt;String&gt;&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">return</span> dfs(s, wordDictLower, s.length(), cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> st, Map&lt;Integer, List&lt;String&gt;&gt; cache)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line">	<span class="keyword">if</span>(cache.containsKey(st))</span><br><span class="line">		<span class="keyword">return</span> cache.get(st);</span><br><span class="line">	List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st; i++) &#123;</span><br><span class="line">		String word = s.substring(i, st);</span><br><span class="line">		<span class="keyword">if</span>(!wordDict.contains(word))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; sub = dfs(s, wordDict, i, cache); </span><br><span class="line">		<span class="comment">// copy solution for subproblem, don't edit on sub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sub.size(); j++)</span><br><span class="line">			result.add((sub.get(j) + <span class="string">" "</span> + word).trim());</span><br><span class="line">	&#125;</span><br><span class="line">	cache.put(st, result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度为<code>O(解大小)</code>。</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1429 First Unique Number</title>
    <url>/2021/11/30/lee-1429/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-unique-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You have a queue of integers, you need to retrieve the first unique integer in the queue.<br><br>Implement the <code>FirstUnique</code> class:<br><br><em>   <code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.
</em>   <code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.<br><em>   <code>void add(int value)</code> insert value to the queue.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>[“FirstUnique”,”showFirstUnique”,”add”,”showFirstUnique”,”add”,”showFirstUnique”,”add”,”showFirstUnique”]<br>[[[2,3,5]],[],[5],[],[2],[],[3],[]]<br><strong>Output:</strong><br>[null,2,null,2,null,3,null,-1]<br><strong>Explanation:</strong><br>FirstUnique firstUnique = new FirstUnique([2,3,5]);<br>firstUnique.showFirstUnique(); // return 2<br>firstUnique.add(5);            // the queue is now [2,3,5,5]<br>firstUnique.showFirstUnique(); // return 2<br>firstUnique.add(2);            // the queue is now [2,3,5,5,2]<br>firstUnique.showFirstUnique(); // return 3<br>firstUnique.add(3);            // the queue is now [2,3,5,5,2,3]<br>firstUnique.showFirstUnique(); // return -1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>[“FirstUnique”,”showFirstUnique”,”add”,”add”,”add”,”add”,”add”,”showFirstUnique”]<br>[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]<br><strong>Output:</strong><br>[null,-1,null,null,null,null,null,17]<br><strong>Explanation:</strong><br>FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]);<br>firstUnique.showFirstUnique(); // return -1<br>firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7]<br>firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3]<br>firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3,3]<br>firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7,3,3,7]<br>firstUnique.add(17);           // the queue is now [7,7,7,7,7,7,7,3,3,7,17]<br>firstUnique.showFirstUnique(); // return 17<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong><br>[“FirstUnique”,”showFirstUnique”,”add”,”showFirstUnique”]<br>[[[809]],[],[809],[]]<br><strong>Output:</strong><br>[null,809,null,-1]<br><strong>Explanation:</strong><br>FirstUnique firstUnique = new FirstUnique([809]);<br>firstUnique.showFirstUnique(); // return 809<br>firstUnique.add(809);          // the queue is now [809,809]<br>firstUnique.showFirstUnique(); // return -1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= nums.length &lt;= 10^5</code><br><em>   <code>1 &lt;= nums[i] &lt;= 10^8</code>
</em>   <code>1 &lt;= value &lt;= 10^8</code><br>*   At most <code>50000</code> calls will be made to <code>showFirstUnique</code> and <code>add</code>.<br><br></div>


<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Dict + LL (1次) + Set (2次)。此题非常类似于LRU, 相当于实习LinkedHashMap。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意两种情况，节点不在Map, 在Map中，对应的LL操作同样是add_to_tail和remove_node不过少了move_to_tail。    </li>
<li>头尾dummy node，初始化要相连。    </li>
<li>注意删除顺序，先删map中的entry再删Node。否则会出现NPE。新加入是顺序相反。删除节点要将prev和next赋None</li>
<li>区别还有ListNode不需要key，因为输入是单值，不是key-value对。数据结构多了set来记录出现两次及以上的元素，直接忽略    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstUnique</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    2, 3, 5, 5</span></span><br><span class="line"><span class="string">    dict:</span></span><br><span class="line"><span class="string">    &#123;2:1</span></span><br><span class="line"><span class="string">     3:1</span></span><br><span class="line"><span class="string">     5:2 (remove)</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">    LinkedList: 2, 3, 5(r), 5(r)</span></span><br><span class="line"><span class="string">    dict:</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        2: Node(2)</span></span><br><span class="line"><span class="string">        3: Node(3)</span></span><br><span class="line"><span class="string">        5: Node(5)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># only store unique elements</span></span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.key_to_node = &#123;&#125;  <span class="comment"># only store unique elements</span></span><br><span class="line">        self.non_unique_set = set()</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            self.add(n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showFirstUnique</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.key_to_node) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.head.next.val</span><br><span class="line">    <span class="comment"># 2, 3, 5, 5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">in</span> self.non_unique_set:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            new_node = ListNode(value)</span><br><span class="line">            self.add_to_tail(new_node)</span><br><span class="line">            self.key_to_node[value] = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            to_be_removed_node = self.key_to_node[value]</span><br><span class="line">            self.key_to_node.pop(value)</span><br><span class="line">            self.remove_node(to_be_removed_node)</span><br><span class="line">            self.non_unique_set.add(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor = self.tail.prev</span><br><span class="line">        predecessor.next, node.prev = node, predecessor</span><br><span class="line">        node.next, self.tail.prev = self.tail, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next = None, prev = None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 155 Min Stack</title>
    <url>/2018/06/14/lee-155/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/min-stack" target="_blank" rel="noopener">LeetCode 155 Min Stack</a></strong></p>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong>  </p>
<pre>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个栈，支持在常数时间内push，pop，top，和取最小值。</p>
<p>push(x) – 元素x压入栈<br>pop() – 弹出栈顶元素<br>top() – 获取栈顶元素<br>getMin() – 获取栈中的最小值</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是考察Algorithm和data structure的经典问题。用stack即可实现push，top，pop。难点在于O(1)内实现getMin。看一个例子，<br>按以下顺序加入stack     5, 3, 6, 8, 2<br>最小值                 5, 3, 3, 3, 2<br>可以看出来，最小值是动态变化的，所以需要动态处理，由于存储的方式与stack一致，所以可以考虑再用一个stack来存最小值。<br>如果不用额外stack改用Node，将make_pair(x, curMin)一起压入栈stack<node<int,int>&gt;中，额外空间复杂度O(n)。 见算法2。<br>稍改进空间复杂度，最小值只存变化的值，也就是5,3,2，当最小值变化时再存入最小栈。出栈时候，若出栈元素等于最小栈中的元素，<br>最小栈的元素也要出栈。</node<int,int></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当前最小元素可能相等。相等元素也要入最小栈，如5,3,6,3，最小栈为5,3,3。val &lt;= self.min_stack[-1]一定要取等于。</li>
<li>考虑栈为空时，执行pop和peek的操作。这里存在一个decision point，设计原则与stack的操作一致，也就是暴露出exception。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        val = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> self.min_stack <span class="keyword">and</span> val == self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当前最小元素可能相等。相等元素也要入最小栈，如5,3,6,3，最小栈为5,3,3。x &lt;= minS.peek()一定要取等于。</li>
<li>考虑栈为空时，执行pop和peek的操作。这里存在一个decision point，设计原则与stack的操作一致，也就是暴露出exception。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minS = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minS.isEmpty() || x &lt;= minS.peek())</span><br><span class="line">        	minS.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = s.pop();</span><br><span class="line">        <span class="keyword">if</span>(top == minS.peek())</span><br><span class="line">        	minS.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minS.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; s;</span><br><span class="line">    Stack&lt;Integer&gt; minS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-空间算法分析-不用看-："><a href="#O-1-空间算法分析-不用看-：" class="headerlink" title="O(1)空间算法分析(不用看)："></a><strong>O(1)空间算法分析(不用看)：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>。</p>
<p>算法2也是可以通过leetcode测试的，虽然空间复杂度比上述差。<br><a href="https://dotblogs.com.tw/tsanmmmm2000/2017/05/19/leetcode-practice-min-stack" target="_blank" rel="noopener">存储每个新加值对应的min，更加浪费空间</a></p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>如果用O(1)额外空间，怎么改进算法？ </p>
<p>先考虑最简单的情况，用一个min来记录当前最小值，它可以满足最小值不需更新的情况，解决了问题的一半：<br>x表示要加入的值，m表示最小值的变量，y是真正加入栈的值<br>x 1 5 3<br>m 1 1 1<br>y 1 5 3<br>可以看出无论入栈出栈，最小值均为1.  </p>
<p>比较难的是最小值需要更新时，如下一个要加入0，最小值要更新m=0，但0不能入栈，前一个最小值1的信息就丢失了，所以要设计一个计算y方法(push)满足  </p>
<ol>
<li>已知条件：含有前一个最小值的的信息。x1&lt;m0.  </li>
<li>设计要求：y&lt;m, 因为最小值不更新的时候y值永远大于等于m，必须区分开来，从而知道怎么pop，也就是还原入栈值（最小值）。y1&lt;m1=x1.<br>解决了这个问题就解决了另一半的问题。  </li>
</ol>
<p>以下解释如何推出最小值需要更新时y的计算方式（，以及push和pop的方法：<br><img src="/images/L155.png" alt="">  </p>
<p>以下例子解释Push<br>x 1 5 3 0 6<br>m 1 1 1 0 0<br>y 1 5 3 -1 6</p>
<p>以下例子解释Pop<br>x 6 0 3 5 1<br>m 0 0 1 1 1<br>y 6 -1 3 5 1<br>可以看出真正入栈值可以是原数或者是计算值，取决它与最小值的关系。</p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当前最小元素可能相等。相等元素不用更新最小值，也就是新值直接入栈。</li>
<li>以上递推式的初始条件为：第一个元素是直接加入栈且等于m，无论何种情况都不需任何计算。push时候注意当栈为空，m值为第一个元素的值。</li>
<li>数据溢出。涉及int的加减乘除法，都要预先将其转化为long，否则会溢出。</li>
</ol>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (s.isEmpty())</span><br><span class="line">    		m = x;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">long</span> xx = (<span class="keyword">long</span>)x;</span><br><span class="line">    	<span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">    		s.push(xx);</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		s.push(<span class="number">2</span>*xx-m);</span><br><span class="line">    		m = x;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> top = s.pop();</span><br><span class="line">        <span class="keyword">if</span>(top &lt; m)     </span><br><span class="line">        	m = <span class="number">2</span>*m - top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(s.peek() &gt;= m? s.peek() : m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Long&gt; s;</span><br><span class="line">    <span class="keyword">long</span> m = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>。</p>
<h3 id="考点"><a href="#考点" class="headerlink" title="考点:"></a><strong>考点:</strong></h3><ol>
<li>先不考虑getMin，用什么数据结构实现push, pop, top</li>
<li>暴力法可以实现getMin，怎么实现O(1)。用什么数据结构实现存储min，额外用一个stack</li>
<li>元素可能相等</li>
<li>考虑栈为空时，执行pop和peek的操作</li>
</ol>
]]></content>
      <tags>
        <tag>Design</tag>
        <tag>Interviewer</tag>
        <tag>Amazon</tag>
        <tag>Classic</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 153 Find Minimum in Rotated Sorted Array</title>
    <url>/2021/12/05/lee-153/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:<br><br><em>   <code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.
</em>   <code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.<br><br>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.<br><br>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.<br><br>You must write an algorithm that runs in <code>O(log n) time.</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,4,5,1,2]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [11,13,15,17]<br><strong>Output:</strong> 11<br><strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= n &lt;= 5000</code><br><em>   <code>-5000 &lt;= nums[i] &lt;= 5000</code>
</em>   All the integers of <code>nums</code> are <strong>unique</strong>.<br>*   <code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>二分法  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>如果nums[start] &gt; nums[mid]或nums[mid] &gt; nums[end]都将会是min所在的区间。但是由于无位移数组的min在左边，所以<strong>优先判断后半区间nums[mid] &gt; nums[end]</strong>，否则若用nums[start] &gt; nums[mid] + else会忽略无位移情况。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &gt; nums[end]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> nums[start] &lt; nums[end]:</span><br><span class="line">		<span class="keyword">return</span> nums[start]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[start] &gt; nums[end]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[mid] &lt; nums[end])</span><br><span class="line">				end = mid;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				start = mid;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> nums[start];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nums[start] &lt; nums[end])</span><br><span class="line">		<span class="keyword">return</span> nums[start];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> nums[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1570 Dot Product of Two Sparse Vectors</title>
    <url>/2021/12/21/lee-1570/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two sparse vectors, compute their dot product.<br><br>Implement class <code>SparseVector</code>:<br><br><em>   <code>SparseVector(nums)</code> Initializes the object with the vector <code>nums</code>
</em>   <code>dotProduct(vec)</code> Compute the dot product between the instance of <em>SparseVector</em> and <code>vec</code><br><br>A <strong>sparse vector</strong> is a vector that has mostly zero values, you should store the sparse vector <strong>efficiently</strong> and compute the dot product between two <em>SparseVector</em>.<br><br><strong>Follow up: </strong>What if only one of the vectors is sparse?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 1<em>0 + 0</em>3 + 0<em>0 + 2</em>4 + 3<em>0 = 8<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 00 + 1<em>0 + 0</em>0 + 0<em>0 + 0</em>2 = 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums1.length == nums2.length</code>
</em>   <code>1 &lt;= n &lt;= 10^5</code><br>*   <code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>稀疏数组乘法，设计类来存储且计算乘积</p>
<h3 id="HashMap解题思路："><a href="#HashMap解题思路：" class="headerlink" title="HashMap解题思路："></a><strong>HashMap解题思路：</strong></h3><p>类似于Two sum，也是两种方法。HashMap的方法由于hash函数计算容易冲突，所以算法复杂度不够稳定。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.idx_to_num = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.idx_to_num[i] = n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> vec.idx_to_num.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> self.idx_to_num:</span><br><span class="line">                res += self.idx_to_num[i] * n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p>
<hr>
<h3 id="Mergesort算法II解题思路："><a href="#Mergesort算法II解题思路：" class="headerlink" title="Mergesort算法II解题思路："></a><strong>Mergesort算法II解题思路：</strong></h3><p>初始化复杂度比较稳定  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.non_zero_list = []</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.non_zero_list.append((i,n))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(self.non_zero_list) - <span class="number">1</span> <span class="keyword">and</span> j &lt;= len(vec.non_zero_list) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> self.non_zero_list[i][<span class="number">0</span>] == vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                res += self.non_zero_list[i][<span class="number">1</span>] * vec.non_zero_list[j][<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> self.non_zero_list[i][<span class="number">0</span>] &lt; vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L1 + L2)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 146 LRU Cache</title>
    <url>/2020/05/04/lee-146/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode 146 LRU Cache</a></strong></p>
<div><br><br>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.<br><br><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br><br>The cache is initialized with a <strong>positive</strong> capacity.<br><br><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?<br><br><strong>Example:</strong><br><br><pre>LRUCache cache = new LRUCache( 2 /<em> capacity </em>/ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br></pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计LRU。就是最就的cache会先被删除。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为是Cache，get是O(1)，自然想到用HashMap。如果不限容量，get，put都可以O(1)。限容量的情况下，<br>就要删除部分数据，这里要求按key的时间排序，所以考虑用一个串将keys串联起来。而key的添加和删除<br>也要O(1)，所以考虑用LinkedList。HashMap和LinkedList的组合很常见。这里value就指向LL中的Node，<br>而Node中含key和value，key又可以让Node只向HashMap，做到互相索引。分析get和set，get就只要从Map<br>中读Node的value即可。set比较复杂，含三种情况：  </p>
<ol>
<li>已有节点  </li>
<li>不含节点且少于容量  </li>
<li>不含节点且大于等于容量  </li>
</ol>
<p>对应链表操作为：  </p>
<ol>
<li>删除该节点且插入到末尾（<strong>LL顺序为由旧到新</strong>）  </li>
<li>插入新节点到末尾  </li>
<li>删除头节点且插入新节点到末尾  </li>
</ol>
<p>总结链表操作为两个：  </p>
<ol>
<li>删除某节点  </li>
<li>插入新节点到末尾  </li>
</ol>
<p>实现上可以分为单链表和双链表。单链表要让Map指向节点的父节点。实现上很麻烦，因为更新节点都会涉及<br>两个keys上HashMap更新，即使已有节点换到末尾同样要两次更新Map。但双链表对此情况就避免了Map的更新。  </p>
<p>DummyNode的选择：一开始我只选用了DummyHead，但capacity=1的时候要判断末节点是否为空很麻烦，由于<br>经常性的插入末节点，所以根据若头结点涉及插入删除就应该用dummyNode的原则，末节点也增加dummyNode<br>程序就简洁很多。  </p>
<p>有些解法用单链表，用node映射到对应节点的父节点key_to_prev，这个方法反而不好理解，写的时候也容易错，不推荐  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>set中，若节点存在，更新value。更新节点在链表中的顺序。注意三种情况，已有节点以及不含节点的两种。    </li>
<li>头尾dummy node，初始化要相连。    </li>
<li>注意删除顺序，先删map中的entry再删Node。否则会出现NPE。新加入是顺序相反。删除节点要将prev和next赋None  </li>
<li>双向LL加入新节点有<strong>两个赋值语句</strong>，不要忘记node.prev, node.next = predecessor, successor</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.key_to_node = &#123;&#125;</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = ListNode(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self.move_to_tail(self.key_to_node[key])</span><br><span class="line">        <span class="keyword">return</span> self.key_to_node[key].val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            self.key_to_node[key].val = value</span><br><span class="line">            self.move_to_tail(self.key_to_node[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.key_to_node) == self.capacity:</span><br><span class="line">                self.key_to_node.pop(self.head.next.key)</span><br><span class="line">                self.remove_node(self.head.next)</span><br><span class="line"></span><br><span class="line">            node = ListNode(key, value)</span><br><span class="line">            self.add_to_tail(node)  <span class="comment"># add_to_tail(node)</span></span><br><span class="line">            self.key_to_node[key] = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_to_tail(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = self.tail.prev, self.tail</span><br><span class="line">        predecessor.next, node.prev = node, predecessor</span><br><span class="line">        node.next, successor.prev = successor, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val, next = None, prev = None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.key = key</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">ListNode head; <span class="comment">// from oldest to newest</span></span><br><span class="line">ListNode tail;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L146LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">	head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">	tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">	head.next = tail;</span><br><span class="line">	tail.prev = head;</span><br><span class="line">	map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	pushback(key);</span><br><span class="line">	<span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">		pushback(key);</span><br><span class="line">		map.get(key).val = value; <span class="comment">// remember to update the value</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(map.size() == capacity) &#123;</span><br><span class="line">			map.remove(head.next.key);</span><br><span class="line">			deleteNode(head.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// add new key</span></span><br><span class="line">		ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">		addNodeToTail(newNode);</span><br><span class="line">		map.put(key, newNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushback</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	ListNode curNode = map.get(key);</span><br><span class="line">	deleteNode(curNode);</span><br><span class="line">	addNodeToTail(curNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNodeToTail</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">	ListNode prevTailNode = tail.prev;</span><br><span class="line">	prevTailNode.next = curNode;</span><br><span class="line">	curNode.prev = prevTailNode;</span><br><span class="line">	curNode.next = tail;</span><br><span class="line">	tail.prev = curNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete head node and updated node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">	ListNode nextNode = curNode.next;</span><br><span class="line">	ListNode prevNode = curNode.prev;</span><br><span class="line">	prevNode.next = nextNode;</span><br><span class="line">	nextNode.prev = prevNode;</span><br><span class="line">	curNode.next = <span class="keyword">null</span>;</span><br><span class="line">	curNode.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> ListNode next;</span><br><span class="line">	<span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度为<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 162 Find Peak Element</title>
    <url>/2021/12/23/lee-162/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A peak element is an element that is strictly greater than its neighbors.<br><br>Given an integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.<br><br>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.<br><br>You must write an algorithm that runs in <code>O(log n)</code> time.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,1,3,5,6,4]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br>*   <code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找数组极大值</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>mid - 1 &gt;= 0    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mid &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[mid - <span class="number">1</span>] &lt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">return</span> start <span class="keyword">if</span> nums[start] &gt; nums[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findValleyElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mid &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[mid - <span class="number">1</span>] &gt;= nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">return</span> start <span class="keyword">if</span> nums[start] &lt;= nums[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1650 Lowest Common Ancestor of a Binary Tree III</title>
    <url>/2021/12/28/lee-1650/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two nodes of a binary tree <code>p</code> and <code>q</code>, return <em>their lowest common ancestor (LCA)</em>.<br><br>Each node will have a reference to its parent node. The definition for <code>Node</code> is below:<br><br><pre>class Node {<br>    public int val;<br>    public Node left;<br>    public Node right;<br>    public Node parent;<br>}<br></pre><br><br>According to the <strong><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a></strong>: “The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1,2], p = 1, q = 2<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.
</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> exist in the tree.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求带父节点的树中的两个节点的LCA。节点值唯一，且两输入节点不同，且一定存在</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>某一个节点的左右父节点存入set中，另一节点的每个父节点在set中找     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, p: <span class="string">'Node'</span>, q: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">	parent_set = set()</span><br><span class="line">	it = p</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		parent_set.add(it)</span><br><span class="line">		it = it.parent</span><br><span class="line">	it = q</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		<span class="keyword">if</span> it <span class="keyword">in</span> parent_set:</span><br><span class="line">			<span class="keyword">return</span> it</span><br><span class="line">		it = it.parent</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(n)</code>，n和m为所有父亲路径长  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1654 Minimum Jumps to Reach Home</title>
    <url>/2021/12/05/lee-1654/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-jumps-to-reach-home/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A certain bug’s home is on the x-axis at position <code>x</code>. Help them get there from position <code>0</code>.<br><br>The bug jumps according to the following rules:<br><br><em>   It can jump exactly <code>a</code> positions <strong>forward</strong> (to the right).
</em>   It can jump exactly <code>b</code> positions <strong>backward</strong> (to the left).<br><em>   It cannot jump backward twice in a row.
</em>   It cannot jump to any <code>forbidden</code> positions.<br><br>The bug may jump forward <strong>beyond</strong> its home, but it <strong>cannot jump</strong> to positions numbered with <strong>negative</strong> integers.<br><br>Given an array of integers <code>forbidden</code>, where <code>forbidden[i]</code> means that the bug cannot jump to the position <code>forbidden[i]</code>, and integers <code>a</code>, <code>b</code>, and <code>x</code>, return <em>the minimum number of jumps needed for the bug to reach its home</em>. If there is no possible sequence of jumps that lands the bug on position <code>x</code>, return <code>-1.</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11<br><strong>Output:</strong> -1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> One jump forward (0 -&gt; 16) then one jump backward (16 -&gt; 7) will get the bug home.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= forbidden.length &lt;= 1000</code>
</em>   <code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code><br><em>   <code>0 &lt;= x &lt;= 2000</code>
</em>   All the elements in <code>forbidden</code> are distinct.<br>*   Position <code>x</code> is not forbidden.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求从0到x的最小步数，可以往前跳a步，往后跳b步，不能跳到负数，不能连续两次往前跳，不能跳到被禁止的位置。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于Jump game，不过此题要用真的BFS，用三个元素push如queue: (point, distance, is_backward), is_backward记录是否回退两次而剪枝，distance是结果。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用BFS模板，但此题到了某个位置可以有两个状态：向前跳和向后跳。所以<strong>visited不能只含位置，必须包含方向</strong>，(position, is_backward). if (neighbor, neighbor_is_backward) in visited也记得包含方向，否则LTE，因为Python不会检查是否tuple  </li>
<li>upper limit为max(x, max(forbidden)) + a + b，否则LTE，这个比较推导，可以这么理解max(x, max(forbidden))之后可以自由不受限制地走，必定存在一个点之后会重复且无意义，如a和b的最小倍数。举个例子找规律，a=2, b=1, x=10, 要走到11的话就要先到x+a+b再往回走     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumJumps</span><span class="params">(self, forbidden: List[int], a: int, b: int, x: int)</span> -&gt; int:</span></span><br><span class="line">	forbidden_set = set(forbidden)</span><br><span class="line">	limit = max(x, max(forbidden)) + a + b</span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">False</span>)])</span><br><span class="line">	visited = set([(<span class="number">0</span>, <span class="keyword">False</span>)])  <span class="comment"># remember two states</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node[<span class="number">0</span>] == x:</span><br><span class="line">			<span class="keyword">return</span> node[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> [node[<span class="number">0</span>] + a, node[<span class="number">0</span>] - b]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> forbidden_set <span class="keyword">or</span> neighbor &lt; <span class="number">0</span> <span class="keyword">or</span> neighbor &gt; limit: <span class="comment"># remember limit</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> neighbor == node[<span class="number">0</span>] - b <span class="keyword">and</span> node[<span class="number">2</span>]: <span class="comment"># no backward twice</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			neighbor_is_backward = <span class="keyword">True</span> <span class="keyword">if</span> neighbor == node[<span class="number">0</span>] - b <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">			<span class="keyword">if</span> (neighbor, neighbor_is_backward) <span class="keyword">in</span> visited: <span class="comment"># remember not neighbor in visited - LTE</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((neighbor, node[<span class="number">1</span>] + <span class="number">1</span>, neighbor_is_backward))</span><br><span class="line">			visited.add((neighbor, neighbor_is_backward))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(max(x, max(forbidden)) + a + b)</code>，空间复杂度<code>O(max(x, max(forbidden)) + a + b)</code>  </p>
]]></content>
      <tags>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 166 Fraction to Recurring Decimal</title>
    <url>/2022/01/03/lee-166/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.<br><br>If the fractional part is repeating, enclose the repeating part in parentheses.<br><br>If multiple answers are possible, return <strong>any of them</strong>.<br><br>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10&lt;sup&gt;4&lt;/sup&gt;</code> for all the given inputs.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numerator = 1, denominator = 2<br><strong>Output:</strong> “0.5”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numerator = 2, denominator = 1<br><strong>Output:</strong> “2”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> numerator = 4, denominator = 333<br><strong>Output:</strong> “0.(012)”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= numerator, denominator &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code>
</em>   <code>denominator != 0</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体  </p>
<p><img src="/images/L166.PNG" alt=""> </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体</strong>，并不是digit一样，而是余数。类似于L003 Longest Substring Without Repeating Characters，记录余数到商下标。循环中顺序很重要，与长除法一致(上图)。分子为remainder，查看remainder是否重复，若否，<strong>加入到map</strong>，乘以10，求商和新余数，进入下一轮迭代。</li>
<li>输入均为负数或其一为负数的情况，计算结果符号，分子分母分别转成正数</li>
<li>分子大于分母或分子小于分母的情况都归结为用分子除以分母，加入到结果，若有余数，再加小数点</li>
</ol>
<p>Line 26 - 27与Line 16 - 17一致</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span><span class="params">(self, numerator: int, denominator: int)</span> -&gt; str:</span></span><br><span class="line">	res, remainder_to_pos = <span class="string">''</span>, collections.defaultdict(int)</span><br><span class="line">	is_negative, remainder = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> numerator / denominator &lt; <span class="number">0</span>:</span><br><span class="line">		is_negative = <span class="number">-1</span></span><br><span class="line">	numerator = abs(numerator)</span><br><span class="line">	denominator = abs(denominator)</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	if numerator &lt; denominator:</span></span><br><span class="line"><span class="string">		res = '0.'</span></span><br><span class="line"><span class="string">		remainder = numerator</span></span><br><span class="line"><span class="string">	else:</span></span><br><span class="line"><span class="string">		res = str(numerator // denominator)</span></span><br><span class="line"><span class="string">		remainder = numerator % denominator</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	res = str(numerator // denominator)</span><br><span class="line">	remainder = numerator % denominator</span><br><span class="line">	<span class="keyword">if</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line">		res += <span class="string">'.'</span></span><br><span class="line">	<span class="keyword">while</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> remainder <span class="keyword">in</span> remainder_to_pos:</span><br><span class="line">			res = res[:remainder_to_pos[remainder]] + <span class="string">'('</span> + res[remainder_to_pos[remainder]:] + <span class="string">')'</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		remainder_to_pos[remainder] = len(res)  <span class="comment"># remember</span></span><br><span class="line">		remainder *= <span class="number">10</span> <span class="comment"># remember not numerator * 10 // denominator</span></span><br><span class="line">		res += str(remainder // denominator)</span><br><span class="line">		remainder %= denominator</span><br><span class="line">	<span class="keyword">return</span> res <span class="keyword">if</span> is_negative == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'-'</span> + res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Math</tag>
        <tag>Airbnb</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1710 Maximum Units on a Truck</title>
    <url>/2021/12/23/lee-1710/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-units-on-a-truck" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are assigned to put some amount of boxes onto <strong>one truck</strong>. You are given a 2D array <code>boxTypes</code>, where <code>boxTypes[i] = [numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;, numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt;]</code>:<br><br><em>   <code>numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;</code> is the number of boxes of type <code>i</code>.
</em>   <code>numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt;</code>is the number of units in each box of the type <code>i</code>.<br><br>You are also given an integer <code>truckSize</code>, which is the <strong>maximum</strong> number of <strong>boxes</strong> that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed <code>truckSize</code>.<br><br>Return <em>the <strong>maximum</strong> total number of <strong>units</strong> that can be put on the truck.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> There are:<br>- 1 box of the first type that contains 3 units.<br>- 2 boxes of the second type that contain 2 units each.<br>- 3 boxes of the third type that contain 1 unit each.<br>You can take all the boxes of the first and second types, and one box of the third type.<br>The total number of units will be = (1 <em> 3) + (2 </em> 2) + (1 <em> 1) = 8.<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10<br><strong>Output:</strong> 91<br></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= boxTypes.length &lt;= 1000</code><br><em>   <code>1 &lt;= numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;, numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt; &lt;= 1000</code>
</em>   <code>1 &lt;= truckSize &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>货车能装的最大unit数，每种类型的盒都能装一定数量的units，而每种盒子占地方一样。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于每种盒子占地一样，所以当然是先放unit大的。贪婪法。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>按unit数倒序排序   </li>
<li>pair是一个数组，要加pair[i][0]  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumUnits</span><span class="params">(self, boxTypes: List[List[int]], truckSize: int)</span> -&gt; int:</span></span><br><span class="line">	pairs = [(li[<span class="number">1</span>], li[<span class="number">0</span>]) <span class="keyword">for</span> li <span class="keyword">in</span> boxTypes]</span><br><span class="line">	pairs.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">	res, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">		res += pair[<span class="number">0</span>] * min(pair[<span class="number">1</span>], truckSize)</span><br><span class="line">		truckSize -= pair[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> truckSize &lt;= <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 173 Binary Search Tree Iterator</title>
    <url>/2020/04/26/lee-173/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></strong></p>
<div><br><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br><br>Calling <code>next()</code> will return the next smallest number in the BST.<br><br><strong>Example:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt=""></strong><br><br><pre>BSTIterator iterator = new BSTIterator(root);<br>iterator.next();    // return 3<br>iterator.next();    // return 7<br>iterator.hasNext(); // return true<br>iterator.next();    // return 9<br>iterator.hasNext(); // return true<br>iterator.next();    // return 15<br>iterator.hasNext(); // return true<br>iterator.next();    // return 20<br>iterator.hasNext(); // return false<br></pre><br><br><strong>Note:</strong><br><br><em>   <code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.
</em>   You may assume that <code>next()</code> call will always be valid, that is, there will be at least a next smallest number in the BST when <code>next()</code> is called.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现BST的Iterator</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>参照KB中BST的非递归中序遍历。将其分拆为初始化以及去掉stack不为空的循环分别为所求。 </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始化，将root所有左节点加入到stack。先写next，出栈栈顶节点，将它的右儿子的所有左节点入栈。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        it = root</span><br><span class="line">        <span class="keyword">while</span> it:</span><br><span class="line">            self.stack.append(it)</span><br><span class="line">            it = it.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        node = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            n = node.right</span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                self.stack.append(n)</span><br><span class="line">                n = n.left</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L173BinarySearchTreeIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	TreeNode head = root;</span><br><span class="line">	<span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">		s.push(head);</span><br><span class="line">		head = head.left;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recommended</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TreeNode node = s.pop(); </span><br><span class="line">	<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;<span class="comment">// left node has been visited</span></span><br><span class="line">		TreeNode n = node.right; </span><br><span class="line">		<span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">			s.push(n);</span><br><span class="line">			n = n.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !s.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next的平均时间复杂度(amortized complexity)为<code>O(1)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>。</p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 174 Dungeon Game</title>
    <url>/2021/12/22/lee-174/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.<br><br>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.<br><br>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight’s health (represented by positive integers).<br><br>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.<br><br>Return <em>the knight’s minimum initial health so that he can rescue the princess</em>.<br><br><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg" alt=""><br><br><pre><strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> dungeon = [[0]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == dungeon.length</code>
</em>   <code>n == dungeon[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code>
</em>   <code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>保持正数健康值从左上走到右下  </p>
<h3 id="DP解题思路-推荐-："><a href="#DP解题思路-推荐-：" class="headerlink" title="DP解题思路(推荐)："></a><strong>DP解题思路(推荐)：</strong></h3><p>坐标型DP。<br>dp[n][m]为通过<strong>这一格前</strong>的最小健康值，也就是题目所求，这意味着需要保证通过最后一个后的健康值为1，所以引入它相邻的两个cell为1<br>递归式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n][m] = -dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span><br><span class="line">         = max&#123;1, min(dp[n+1][m], dp[n][m+1]) - dungeon[n][m]&#125; if dungeon[n][m] &gt; 0</span><br></pre></td></tr></table></figure></p>
<p>由于-dungeon[n][m] + min(dp[n+1][m]一定为正数，所以可以归并两种情况：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n][m] = max&#123;1, min(dp[n+1][m], dp[n][m+1]) - dungeon[n][m]&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>从右下走回左上倒推初始值。每一格的最小健康值在为1，而初始健康值也最小为1.  </li>
<li>递归式：一开始的递归式跟下和右格的极小值有关，所以DP数组(比原数组多出的)最右和最下边界初始值为正无穷；但根据公式，右下格会出现正无穷，所以需要特别处理，<strong>将右下格的相邻下右两格初始为1</strong>，可以这样理解，从右下格走出健康值必须是1    </li>
<li>递归式：一开始写若该格dungeon值为负数，1 - dungeon[n][m] + min(dp[n+1][m], dp[n][m+1])这个1的确保证了最小健康值为1，但其实它只要加一次，而上述右下边界已经处理，所以<strong>递归式不需要+1</strong>，如[[-2, -3]], dp[0][1]=4, 而dp[0][0]为6即可  </li>
<li>递归式：当dungeon为正数时，可以抵消它相邻格所要求的最低健康值，当然要保证健康值大于1，如[5, 4, -2], dp[0][0] = 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[n][m] = 1 - dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span></span><br><span class="line"><span class="comment">#          = 1 + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &gt; 0</span></span><br><span class="line"><span class="comment"># dp[n][m] = -dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span></span><br><span class="line"><span class="comment">#          = min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(dungeon[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(dungeon) + <span class="number">1</span>)]</span><br><span class="line">	dp[<span class="number">-1</span>][<span class="number">-2</span>] = dp[<span class="number">-2</span>][<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(dungeon))):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(len(dungeon[<span class="number">0</span>]))):</span><br><span class="line">			<span class="string">'''</span></span><br><span class="line"><span class="string">			min_neighbor = float('inf')</span></span><br><span class="line"><span class="string">			if i + 1 &lt; len(dungeon):</span></span><br><span class="line"><span class="string">				min_neighbor = min(min_neighbor, dp[i + 1][j])</span></span><br><span class="line"><span class="string">			if j + 1 &lt; len(dungeon[0]):</span></span><br><span class="line"><span class="string">				min_neighbor = min(min_neighbor, dp[i][j + 1])</span></span><br><span class="line"><span class="string">			if min_neighbor == float('inf'):</span></span><br><span class="line"><span class="string">				min_neighbor = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			if dungeon[i][j] &lt; 0:</span></span><br><span class="line"><span class="string">				dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]</span></span><br><span class="line"><span class="string">			else:</span></span><br><span class="line"><span class="string">				dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</span></span><br><span class="line"><span class="string">			'''</span></span><br><span class="line">			dp[i][j] = max(<span class="number">1</span>, min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
<hr>
<h3 id="Binary-select算法II解题思路："><a href="#Binary-select算法II解题思路：" class="headerlink" title="Binary select算法II解题思路："></a><strong>Binary select算法II解题思路：</strong></h3><p>Binary select + DP<br>暴力法，假设某个初始健康值，然后用从左到右从上到下计算<strong>这一格后的健康值</strong>，dp[m][n] = max{dp[m-1][n], dp[m][n-1]} + dungeon[r][c], 可以看出dp定义和递归式max都是跟上述方法相反。求最后一个是否正数<br>暴力法是O(n^2), 而用binary select试0, 1000 * (m + n) + 1，1000是cell的最大值，m+n是路径长度，1是最小健康值，二分法试每个数值  </p>
<p>参考<a href="https://leetcode.com/problems/dungeon-game/discuss/1498367" target="_blank" rel="noopener">https://leetcode.com/problems/dungeon-game/discuss/1498367</a>  </p>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)logn</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1857 Largest Color Value in a Directed Graph</title>
    <url>/2021/12/05/lee-1857/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/largest-color-value-in-a-directed-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.<br><br>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a&lt;sub&gt;j&lt;/sub&gt;, b&lt;sub&gt;j&lt;/sub&gt;]</code> indicates that there is a <strong>directed edge</strong> from node <code>a&lt;sub&gt;j&lt;/sub&gt;</code> to node <code>b&lt;sub&gt;j&lt;/sub&gt;</code>.<br><br>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x&lt;sub&gt;1&lt;/sub&gt; -&gt; x&lt;sub&gt;2&lt;/sub&gt; -&gt; x&lt;sub&gt;3&lt;/sub&gt; -&gt; ... -&gt; x&lt;sub&gt;k&lt;/sub&gt;</code> such that there is a directed edge from <code>x&lt;sub&gt;i&lt;/sub&gt;</code> to <code>x&lt;sub&gt;i+1&lt;/sub&gt;</code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.<br><br>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or</em> <code>-1</code> <em>if the graph contains a cycle</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" alt=""><br><br><pre><strong>Input:</strong> colors = “abaca”, edges = [[0,1],[0,2],[2,3],[3,4]]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" alt=""><br><br><pre><strong>Input:</strong> colors = “a”, edges = [[0,0]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There is a cycle from 0 to 0.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == colors.length</code>
</em>   <code>m == edges.length</code><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= m &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>colors</code> consists of lowercase English letters.
</em>   <code>0 &lt;= a&lt;sub&gt;j&lt;/sub&gt;, b&lt;sub&gt;j&lt;/sub&gt; &lt; n</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个图，有n个节点，每个节点的颜色已知，用a-z表示，求所有不循环路径上同种颜色的最大节点数，若有循环返回-1.</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>拓扑排序 + DP  </p>
<ol>
<li>看到侦测循环考虑用拓扑排序  </li>
<li>拓扑排序的同时，如果知道父亲节点有最大的同种颜色数，容易计算儿子的同种颜色数dp[child]<br>dp[child] = max(dp[parent]) for all the parents for the child<br>由于有26种颜色，扩展到最大的第i种颜色数<strong>dp[child][i]表示以child为结尾的路径上第i种颜色的累计最大节点数</strong>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[child][i] = max(dp[parent][i] + 1) if color[child] == color[parent] for all the immediate parents for the child, i = 1..26 </span><br><span class="line">			= max(dp[parent][i])     if color[child] != color[parent]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>见到最值且跟图相关，就考虑用BFS，而且要侦测循环就要用拓扑排序。要记录父节点颜色的累计和，考虑用DP，DP跟颜色相关且颜色都是小写字母，也就是26种    </li>
<li>递归式是<strong>所有直接父节点的最大值</strong>。因为若有两条路径到达child这个节点，路径1第a种颜色有2个，而路径上第a种颜色有5个。 </li>
<li>计算dp值在知道边的始点和终点上，也就是入度数减一之前。 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestPathValue</span><span class="params">(self, colors: str, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(colors))]</span><br><span class="line">	in_degree = [<span class="number">0</span>] * len(colors)</span><br><span class="line">	<span class="keyword">for</span> _edge <span class="keyword">in</span> edges:</span><br><span class="line">		graph[_edge[<span class="number">0</span>]].append(_edge[<span class="number">1</span>])</span><br><span class="line">		in_degree[_edge[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">	res = []</span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">26</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(colors))]</span><br><span class="line">	initial_nodes = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(in_degree)) <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _node <span class="keyword">in</span> initial_nodes:</span><br><span class="line">		dp[_node][ord(colors[_node]) - ord(<span class="string">'a'</span>)] = <span class="number">1</span></span><br><span class="line">	queue = collections.deque(initial_nodes)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">				dp[j][i] = max(dp[j][i], dp[node][i] + (<span class="number">1</span> <span class="keyword">if</span> ord(colors[j]) - ord(<span class="string">'a'</span>) == i <span class="keyword">else</span> <span class="number">0</span>)) <span class="comment"># remember max(dp[j][i]</span></span><br><span class="line">			in_degree[j] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> in_degree[j] == <span class="number">0</span>:</span><br><span class="line">				queue.append(j)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> len(colors) != len(res) <span class="keyword">else</span> max(map(max, dp))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 198 House Robber</title>
    <url>/2021/12/05/lee-198/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.<br><br>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,1]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,7,9,3,1]<br><strong>Output:</strong> 12<br><strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>Total amount you can rob = 2 + 9 + 1 = 12.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 100</code>
</em>   <code>0 &lt;= nums[i] &lt;= 400</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>循环不是模板中的1开始，而是从2开始，因为i-2&gt;=0     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">		dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1762 Buildings With an Ocean View</title>
    <url>/2021/12/20/lee-1762/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There are <code>n</code> buildings in a line. You are given an integer array <code>heights</code> of size <code>n</code> that represents the heights of the buildings in the line.<br><br>The ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a <strong>smaller</strong> height.<br><br>Return a list of indices <strong>(0-indexed)</strong> of buildings that have an ocean view, sorted in increasing order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> heights = [4,2,3,1]<br><strong>Output:</strong> [0,2,3]<br><strong>Explanation:</strong> Building 1 (0-indexed) does not have an ocean view because building 2 is taller.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> heights = [4,3,2,1]<br><strong>Output:</strong> [0,1,2,3]<br><strong>Explanation:</strong> All the buildings have an ocean view.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> heights = [1,3,2,4]<br><strong>Output:</strong> [3]<br><strong>Explanation:</strong> Only building 3 has an ocean view.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= heights.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>1 &lt;= heights[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>大海在右边，求看到大海的大厦的下标  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数组元素之间大小关系且保持顺序，用stack</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span><span class="params">(self, heights: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &gt;= heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">			stack.pop()</span><br><span class="line">		stack.append(i) <span class="comment"># 4 3 1</span></span><br><span class="line">	<span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="算法II解题思路-推荐-："><a href="#算法II解题思路-推荐-：" class="headerlink" title="算法II解题思路(推荐)："></a><strong>算法II解题思路(推荐)：</strong></h3><p>数组元素之间大小关系且保持顺序，用stack</p>
<h3 id="解题步骤：-1"><a href="#解题步骤：-1" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>类似于Leetcode 42的trapping rain water，看不到大海表示在低位。此题只求单边，从右往左扫描一次。  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings2</span><span class="params">(self, heights: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	right_max, res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(heights))):</span><br><span class="line">		<span class="keyword">if</span> heights[i] &gt; right_max:</span><br><span class="line">			res.append(i)</span><br><span class="line">		right_max = max(right_max, heights[i])</span><br><span class="line">	<span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200 Number of Islands</title>
    <url>/2017/12/23/lee-200/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/number-of-islands" target="_blank" rel="noopener">LeetCode 200 Number of Islands</a></strong></p>
<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. </p>
<p><strong><em>Example 1:</em></strong></p>
<pre><code>11110
11010
11000
00000
</code></pre><p>Answer: 1</p>
<p><strong><em>Example 2:</em></strong></p>
<pre><code>11000
11000
00100
00011
</code></pre><p>Answer: 3</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。</p>
<h3 id="BFS解题思路："><a href="#BFS解题思路：" class="headerlink" title="BFS解题思路："></a><strong>BFS解题思路：</strong></h3><p>BFS入列后立即标记为已访问，否则会有空间和时间问题。<br>二维变成一维，不但节省空间，还可以避免创建Point的新class。a = x * C + y(C为列数) &lt;=&gt; x = a/C, y = a%C</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意到题目给定输入数组的类型，用其来标记已访问的单元（节点）。</li>
<li>BFS中如果cell为<strong>0或X</strong>就要跳过，不要漏掉0，因为如果是海不应做BFS。根据题目要求，可能还要将X恢复为1.</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    self.bfs(grid, i, j)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        queue = deque([(i, j)])</span><br><span class="line">        nums[i][j] = <span class="string">'X'</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            island = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">                x, y = island[<span class="number">0</span>] + dx, island[<span class="number">1</span>] + dy</span><br><span class="line">                <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= len(nums) <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= len(nums[<span class="number">0</span>]) <span class="keyword">or</span> nums[x][y] <span class="keyword">in</span> [<span class="string">'0'</span>, <span class="string">'X'</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((x, y))</span><br><span class="line">                nums[x][y] = <span class="string">'X'</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands2</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (grid ==<span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">	<span class="keyword">int</span> islands = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span> || visited[i][j])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">			bfs3(grid, i, j, visited);</span><br><span class="line">			islands++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> islands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs3</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">	Queue&lt;Point&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">	q.offer(<span class="keyword">new</span> Point(a, b));</span><br><span class="line">	visited[a][b] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">		Point point = q.poll();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			Point neighbor = <span class="keyword">new</span> Point(point.x + directions[i][<span class="number">0</span>], point.y + directions[i][<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(!isValid(grid, neighbor.x, neighbor.y) || visited[neighbor.x][neighbor.y])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">			q.offer(neighbor);</span><br><span class="line">			visited[neighbor.x][neighbor.y] = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(min{M,N})</code>。M,N分别为矩阵长宽。因为最坏情况下，以矩形中心为root，最大的一层为矩形里面的最大正方形，它的长度为min{M,N}。<br><img src="/images/L200.png" alt=""></p>
<h3 id="DFS解题思路："><a href="#DFS解题思路：" class="headerlink" title="DFS解题思路："></a><strong>DFS解题思路：</strong></h3><p>遍历矩阵的每一个元素，对每个元素进行DFS四个方位搜索陆地，访问过的元素在原数组中进行标记。每次DFS搜索后，层数加1。</p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">			<span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">				dfs(grid,i,j);</span><br><span class="line">				layer++;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!isValid(grid,a,b))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	grid[a][b] = <span class="string">'x'</span>;</span><br><span class="line">	dfs(grid, a+<span class="number">1</span>, b);</span><br><span class="line">	dfs(grid, a-<span class="number">1</span>, b);</span><br><span class="line">	dfs(grid, a, b+<span class="number">1</span>);</span><br><span class="line">	dfs(grid, a, b-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=grid.length||y&lt;<span class="number">0</span>||y&gt;=grid[<span class="number">0</span>].length||grid[x][y]!=<span class="string">'1'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。最坏情况，全为陆地，DFS退化成线性。</p>
<h3 id="Union-Find解题思路："><a href="#Union-Find解题思路：" class="headerlink" title="Union Find解题思路："></a><strong>Union Find解题思路：</strong></h3><p>见Union Find算法详解。</p>
<ol>
<li>初始化UnionFind类，包括3个属性：count（独立连通数）, parent（某节点的父节点）, rank（连通集排名）。合格的节点的parent初始化为自己的id，rank为0，count为所有合格节点数量。</li>
<li>遍历所有节点，<strong>union</strong>此节点及其相邻的节点（如上下左右）</li>
<li>union时候，先<strong>find</strong>两节点的根节点，若相同忽略。若不同，合并此两连通集：rank大的连通集，作为rank小的连通集的父节点。若rank相等，选任一作为另一个的父节点且把它的rank加1。count减1。<br>如下图，union 6和11的，find(6)会进行压缩路径，把6接到5下。<br><img src="/images/union-find-2.png" alt=""></li>
<li>find寻找根节点的同时，压缩成与根节点路径为1的连通。  </li>
</ol>
<h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">// # of connected components</span></span><br><span class="line">	<span class="keyword">int</span>[] parent;</span><br><span class="line">	<span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> m = grid.length;</span><br><span class="line">		<span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">		parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">		rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					parent[i * n + j] = i * n + j;</span><br><span class="line">					++count;</span><br><span class="line">				&#125;</span><br><span class="line">				rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">			parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> parent[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// union with rank</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rootx = find(x);</span><br><span class="line">		<span class="keyword">int</span> rooty = find(y);</span><br><span class="line">		<span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">				parent[rooty] = rootx;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">				parent[rootx] = rooty;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				parent[rooty] = rootx;</span><br><span class="line">				rank[rootx] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			--count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands3</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr = grid.length;</span><br><span class="line">	<span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">	UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">				grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">				<span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123; </span><br><span class="line">					uf.union(r * nc + c, (r - <span class="number">1</span>) * nc + c);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, (r + <span class="number">1</span>) * nc + c);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。遍历每个节点，而每个节点只会遍历4个相邻节点。</p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol>
<li>打印所有island坐标</li>
<li>计算湖的数量。湖是被island维住的水域，与海有区别。解法是先从四条边界的海域进行DFS，标记为-1，然后采用上述算法，只要将搜寻1改为搜寻0即可。</li>
<li>如果内存有限，不能一次读整个矩阵。方案是分块做，然后保留边界信息作为下一块的输入。</li>
<li>地图中途被改动。分情况，若0-&gt;1，若此单元邻居只有一种label（即使多个邻居），岛屿数不变。无邻居，岛屿数+1。邻居有多种label为n，岛屿数减少n-1。Union Find也是一个更简洁方案。<br>此情况比较简单，只要查看邻居即可，因为它只会增加连接。<br>若1-&gt;0, 对此单元相邻的四个单元进行DFS重新label新数，新数的种数-四单元的DSF岛屿个数=岛屿增加的个数。<br>此情况需要重新做DFS，因为它破坏连接，可能导致连通性变小。</li>
</ol>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2073 Time Needed to Buy Tickets</title>
    <url>/2021/11/14/lee-2073/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/time-needed-to-buy-tickets/" target="_blank" rel="noopener">LeetCode 2073 Time Needed to Buy Tickets</a></strong></p>
<div><br><br>There are <code>n</code> people in a line queuing to buy tickets, where the <code>0&lt;sup&gt;th&lt;/sup&gt;</code> person is at the <strong>front</strong> of the line and the <code>(n - 1)&lt;sup&gt;th&lt;/sup&gt;</code> person is at the <strong>back</strong> of the line.<br><br>You are given a <strong>0-indexed</strong> integer array <code>tickets</code> of length <code>n</code> where the number of tickets that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> person would like to buy is <code>tickets[i]</code>.<br><br>Each person takes <strong>exactly 1 second</strong> to buy a ticket. A person can only buy <strong>1 ticket at a time</strong> and has to go back to <strong>the end</strong> of the line (which happens <strong>instantaneously</strong>) in order to buy more tickets. If a person does not have any tickets left to buy, the person will <strong>leave</strong> the line.<br><br>Return <em>the <strong>time taken</strong> for the person at position</em> <code>k</code><strong><em>(0-indexed)</em> </strong><em>to finish buying tickets</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> tickets = [2,3,2], k = 2<br><strong>Output:</strong> 6<br><strong>Explanation:</strong><br>- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].<br>- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].<br>The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> tickets = [5,1,1,1], k = 0<br><strong>Output:</strong> 8<br><strong>Explanation:</strong><br>- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].<br>- In the next 4 passes, only the person in position 0 is buying tickets.<br>The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == tickets.length</code>
</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>1 &lt;= tickets[i] &lt;= 100</code>
</em>   <code>0 &lt;= k &lt; n</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排队买票，每个人都有不同的票数需求。每人每次只能买一张，买完后重新排队。买一张票需要1秒，求第k个人买票的总时间。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始按照题目要求老老实实每个元素减一，按照流程计算，但效率较低。考虑若所有人票数大于0，每轮计算结果是一样的：<br>当前排队人数乘以排队的人中的最小票数。当最小票数人离队后，公式会改变。如此循环直到第k个人票数也变成0为止。         </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>求最小值  </li>
<li>计算票数</li>
<li>更新人数，继续循环</li>
<li>结果减去排在第k个人后的人数  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>结果要减去排在第k个人后的还在排队的人数（tickets数不为负数，可以等于0，因为是同时在同一轮买到足够票）。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeRequiredToBuy</span><span class="params">(self, tickets: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	sum, ppl, min_tickets = <span class="number">0</span>, len(tickets), <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> tickets[k] &gt; <span class="number">0</span>:</span><br><span class="line">		min_tickets = min(t <span class="keyword">for</span> t <span class="keyword">in</span> tickets <span class="keyword">if</span> t &gt; <span class="number">0</span>)</span><br><span class="line">		sum += min_tickets * ppl</span><br><span class="line">		tickets = [t - min_tickets <span class="keyword">for</span> t <span class="keyword">in</span> tickets]</span><br><span class="line">		ppl -= tickets.count(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	after_k = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(k + <span class="number">1</span>, len(tickets)) <span class="keyword">if</span> tickets[i] &gt;= <span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> sum - len(after_k)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2074 Reverse Nodes in Even Length Groups</title>
    <url>/2021/11/13/lee-2074/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-nodes-in-even-length-groups/" target="_blank" rel="noopener">LeetCode 2074 Reverse Nodes in Even Length Groups</a></strong></p>
<div><br><br>You are given the <code>head</code> of a linked list.<br><br>The nodes in the linked list are <strong>sequentially</strong> assigned to <strong>non-empty</strong> groups whose lengths form the sequence of the natural numbers (<code>1, 2, 3, 4, ...</code>). The <strong>length</strong> of a group is the number of nodes assigned to it. In other words,<br><br><em>   The <code>1&lt;sup&gt;st&lt;/sup&gt;</code> node is assigned to the first group.
</em>   The <code>2&lt;sup&gt;nd&lt;/sup&gt;</code> and the <code>3&lt;sup&gt;rd&lt;/sup&gt;</code> nodes are assigned to the second group.<br><em>   The <code>4&lt;sup&gt;th&lt;/sup&gt;</code>, <code>5&lt;sup&gt;th&lt;/sup&gt;</code>, and <code>6&lt;sup&gt;th&lt;/sup&gt;</code> nodes are assigned to the third group, and so on.<br><br>Note that the length of the last group may be less than or equal to <code>1 + the length of the second to last group</code>.<br><br><strong>Reverse</strong> the nodes in each group with an <strong>even</strong> length, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/10/25/eg1.png" alt=""><br><br><pre><strong>Input:</strong> head = [5,2,6,3,9,1,7,3,8,4]<br><strong>Output:</strong> [5,6,2,3,9,1,4,8,3,7]<br><strong>Explanation:</strong><br>- The length of the first group is 1, which is odd, hence no reversal occurrs.<br>- The length of the second group is 2, which is even, hence the nodes are reversed.<br>- The length of the third group is 3, which is odd, hence no reversal occurrs.<br>- The length of the last group is 4, which is even, hence the nodes are reversed.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/10/25/eg2.png" alt=""><br><br><pre><strong>Input:</strong> head = [1,1,0,6]<br><strong>Output:</strong> [1,0,1,6]<br><strong>Explanation:</strong><br>- The length of the first group is 1. No reversal occurrs.<br>- The length of the second group is 2. The nodes are reversed.<br>- The length of the last group is 1. No reversal occurrs.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/10/28/eg3.png" alt=""><br><br><pre><strong>Input:</strong> head = [2,1]<br><strong>Output:</strong> [2,1]<br><strong>Explanation:</strong><br>- The length of the first group is 1. No reversal occurrs.<br>- The length of the last group is 1. No reversal occurrs.<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> head = [8]<br><strong>Output:</strong> [8]<br><strong>Explanation:</strong> There is only one group whose length is 1. No reversal occurrs.<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the list is in the range <code>[1, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.<br>*   <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>把链表分成1,2,3..n大小的组。若该组大小为偶数，反转链表。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑分奇偶组来处理，但忽略了最后一组也可能为偶数。用stack来，先做统计，若为偶数，就出栈且反转。<br>后来为了程序更加简洁，就独立一个函数出来按组处理。而每组用迭代将后续节点一个个加到上一组末节点和首节点之间。    </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>按组处理  </li>
<li>每组先统计个数，如果为偶数，反转链表  </li>
</ol>
<p>start(group n) -&gt; end(group n+1, head of group n+1 will become new tail after reversed)  -&gt; …<br>不断将end<strong>直接</strong>后面的节点加到start<strong>直接</strong>后面<br>start(group n) -&gt; NodeA （新状态） -&gt; … -&gt; end(group n+1)  -&gt; NodeA （前状态） -&gt; …   </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若最后一组不满为偶数，也要逆转。    </li>
<li>反转链表时，个数为这组大小减一，因为该组的首节点不用反转。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseEvenLengthGroups</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">	group, cur = <span class="number">2</span>, head</span><br><span class="line">	<span class="keyword">while</span> cur.next:</span><br><span class="line">		cur = self.process_one_group(cur, group)</span><br><span class="line">		group += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_one_group</span><span class="params">(self, tail_of_last: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">	cur, count = tail_of_last, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> cur.next <span class="keyword">and</span> count &lt; n:</span><br><span class="line">		cur = cur.next</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		start, end = tail_of_last, tail_of_last.next</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(count - <span class="number">1</span>):</span><br><span class="line">			<span class="comment"># delete the node</span></span><br><span class="line">			moved_node, end.next = end.next, end.next.next</span><br><span class="line">			<span class="comment"># insert the moved_node</span></span><br><span class="line">			start.next, moved_node.next = moved_node, start.next</span><br><span class="line">	cur = tail_of_last</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">		cur = cur.next</span><br><span class="line">	<span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2079 Watering Plants</title>
    <url>/2021/11/20/lee-2079/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/watering-plants/" target="_blank" rel="noopener">LeetCode 2079 Watering Plants</a></strong></p>
<p>You want to water <code>n</code> plants in your garden with a watering can. The plants are arranged in a row and are labeled from <code>0</code> to <code>n - 1</code> from left to right where the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> plant is located at <code>x = i</code>. There is a river at <code>x = -1</code> that you can refill your watering can at.</p>
<p>Each plant needs a specific amount of water. You will water the plants in the following way:</p>
<ul>
<li>Water the plants in order from left to right.</li>
<li>After watering the current plant, if you do not have enough water to <strong>completely</strong> water the next plant, return to the river to fully refill the watering can.</li>
<li>You <strong>cannot</strong> refill the watering can early.</li>
</ul>
<p>You are initially at the river (i.e., <code>x = -1</code>). It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis.</p>
<p>Given a <strong>0-indexed</strong> integer array <code>plants</code> of <code>n</code> integers, where <code>plants[i]</code> is the amount of water the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> plant needs, and an integer <code>capacity</code> representing the watering can capacity, return <em>the <strong>number of steps</strong> needed to water all the plants</em>.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** plants = [2,2,3,3], capacity = 5
**Output:** 14
**Explanation:** Start at the river with a full watering can:
- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.
- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.
- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).
- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.
- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).
- Walk to plant 3 (4 steps) and water it.
Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** plants = [1,1,1,4,2,3], capacity = 4
**Output:** 30
**Explanation:** Start at the river with a full watering can:
- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).
- Water plant 3 (4 steps). Return to river (4 steps).
- Water plant 4 (5 steps). Return to river (5 steps).
- Water plant 5 (6 steps).
Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.
</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** plants = [7,7,7,7,7,7,7], capacity = 8
**Output:** 49
**Explanation:** You have to refill before watering each plant.
Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == plants.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= plants[i] &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></li>
<li><code>max(plants[i]) &lt;= capacity &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>x坐标上分别是浇每棵植物需要的水量，用数组plants表示，-1上为河水可以打水，capacity是容器大小。若发现水不够，就要回到河里将容器打满水。问浇完所有植物的总步数  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题类似于Leetcode 2073，可以按部就班按每个plant计算，但是为了提高效率，一般采取归结为更高一层次计算。<br>这题更高层次是每次去洒水再回去河边作为一个循环。最后一个循环不用回河边所以是单程。       </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>计算一次来回的距离，条件为剩余的水不够浇该次的植物  </li>
<li>退出循环后，计算单程距离  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>如果满足capacity也要递归到下一轮再计算，也就是Line 5取等号</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wateringPlants</span><span class="params">(self, plants: List[int], capacity: int)</span> -&gt; int:</span></span><br><span class="line">	sum, steps = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(plants):</span><br><span class="line">		sum += plants[i]</span><br><span class="line">		<span class="keyword">if</span> sum &lt;= capacity:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		steps += i * <span class="number">2</span>  <span class="comment"># back to river</span></span><br><span class="line">		sum = plants[i]</span><br><span class="line">	<span class="keyword">if</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">		steps += len(plants)</span><br><span class="line">	<span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2080 Range Frequency Queries</title>
    <url>/2021/11/20/lee-2080/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-frequency-queries/" target="_blank" rel="noopener">LeetCode 2080 Range Frequency Queries</a></strong></p>
<p>Design a data structure to find the <strong>frequency</strong> of a given value in a given subarray.</p>
<p>The <strong>frequency</strong> of a value in a subarray is the number of occurrences of that value in the subarray.</p>
<p>Implement the <code>RangeFreqQuery</code> class:</p>
<ul>
<li><code>RangeFreqQuery(int[] arr)</code> Constructs an instance of the class with the given <strong>0-indexed</strong> integer array <code>arr</code>.</li>
<li><code>int query(int left, int right, int value)</code> Returns the <strong>frequency</strong> of <code>value</code> in the subarray <code>arr[left...right]</code>.</li>
</ul>
<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array. <code>arr[left...right]</code> denotes the subarray that contains the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> (<strong>inclusive</strong>).</p>
<p><strong>Example 1:</strong></p>
<pre>**Input**
["RangeFreqQuery", "query", "query"]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
**Output**
[null, 1, 2]

**Explanation**
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // return 1\. The value 4 occurs 1 time in the subarray [33, 4]
rangeFreqQuery.query(0, 11, 33); // return 2\. The value 33 occurs 2 times in the whole array.
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li><code>1 &lt;= arr[i], value &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
<li>At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>query</code></li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构，支持在指定的子数组中某target的频数。    </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题有意思，有望成为经典题。第一种方法写用以每个字母为结尾的frequency_dict作为数据结构，query只需要用frequency_dict[right]-frequency_dict[left-1]，<br>空间复杂度为<code>O(n<sup>2</sup>)</code>得到TLE。第二种方法用bucket sort，就是将值作为key存到dict中，而value是下标List，query时候得到对应List，遍历<br>一次即可，但仍然得到TLE。第三种方法改进用Binary search得到下标List的左右界。二分法用greater_or_equal_position以及small_or_equal_position.<br>所以最终方案采取bucket sort + binary search</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>dict记录值到下标列表的映射  </li>
<li>二分法找left和right的index从而求个数  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Binary search用greater_or_equal_position以及small_or_equal_position. </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span>:</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">        self.frequency_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> self.frequency_dict:</span><br><span class="line">                self.frequency_dict[n] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.frequency_dict[n].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, left: int, right: int, value: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> self.frequency_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        index_list = self.frequency_dict[value]</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        count = 0</span></span><br><span class="line"><span class="string">        for index in index_list:</span></span><br><span class="line"><span class="string">            if left &lt;= index &lt;= right:</span></span><br><span class="line"><span class="string">                count += 1</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        left_pos = self.greater_or_equal_position(index_list, left)</span><br><span class="line">        right_pos = self.smaller_or_equal_position(index_list, right)</span><br><span class="line">        <span class="keyword">if</span> left_pos == <span class="number">-1</span> <span class="keyword">or</span> right_pos == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> right_pos - left_pos + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater_or_equal_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smaller_or_equal_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[end] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">if</span> nums[start] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>用defaultdict(list)和bisect来优化程序  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">	self.frequency_dict = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">		self.frequency_dict[n].append(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, left: int, right: int, value: int)</span> -&gt; int:</span></span><br><span class="line">	index_list = self.frequency_dict[value]</span><br><span class="line">	left_pos = bisect.bisect(index_list, left - <span class="number">1</span>)</span><br><span class="line">	right_pos = bisect.bisect(index_list, right)</span><br><span class="line">	<span class="keyword">return</span> right_pos - left_pos</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209 Minimum Size Subarray Sum</title>
    <url>/2021/12/05/lee-209/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[nums&lt;sub&gt;l&lt;/sub&gt;, nums&lt;sub&gt;l+1&lt;/sub&gt;, ..., nums&lt;sub&gt;r-1&lt;/sub&gt;, nums&lt;sub&gt;r&lt;/sub&gt;]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 4, nums = [1,4,4]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>1 &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br><em>*Follow up:</em></em> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.</div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>求最小值，所以min_len初始化最大值  </li>
<li>长度为i - j + 1写例子来计算     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	min_len, num_sum, left = float(<span class="string">'inf'</span>), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		num_sum += nums[i]</span><br><span class="line">		<span class="keyword">while</span> num_sum &gt;= target:</span><br><span class="line">			min_len = min(min_len, i - left + <span class="number">1</span>)</span><br><span class="line">			num_sum -= nums[left]</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2104 Sum of Subarray Ranges</title>
    <url>/2021/12/12/lee-2104/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sum-of-subarray-ranges/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>nums</code>. The <strong>range</strong> of a subarray of <code>nums</code> is the difference between the largest and smallest element in the subarray.<br><br>Return <em>the <strong>sum of all</strong> subarray ranges of</em> <code>nums</code><em>.</em><br><br>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The 6 subarrays of nums are the following:<br>[1], range = largest - smallest = 1 - 1 = 0<br>[2], range = 2 - 2 = 0<br>[3], range = 3 - 3 = 0<br>[1,2], range = 2 - 1 = 1<br>[2,3], range = 3 - 2 = 1<br>[1,2,3], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The 6 subarrays of nums are the following:<br>[1], range = largest - smallest = 1 - 1 = 0<br>[3], range = 3 - 3 = 0<br>[3], range = 3 - 3 = 0<br>[1,3], range = 3 - 1 = 2<br>[3,3], range = 3 - 3 = 0<br>[1,3,3], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [4,-2,-3,4,1]<br><strong>Output:</strong> 59<br><strong>Explanation:</strong> The sum of all subarray ranges of nums is 59.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code>
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子数组的最大值最小值之差的和</p>
<h3 id="Stack算法思路："><a href="#Stack算法思路：" class="headerlink" title="Stack算法思路："></a><strong>Stack算法思路：</strong></h3><p>参考Leetcode 907，分别求子数组最小值的相反数，子数组的最大值，这两个值的和即为所求  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>最小值用递增栈，最大值用递减栈       </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subArrayRanges</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	arr = list(nums)</span><br><span class="line">	arr.insert(<span class="number">0</span>, -sys.maxsize)</span><br><span class="line">	arr.append(-sys.maxsize)</span><br><span class="line">	stack, res, = [], <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &lt; arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">			prev_idx = stack.pop()</span><br><span class="line">			res -= arr[prev_idx] * (prev_idx - stack[<span class="number">-1</span>]) * (i - prev_idx)</span><br><span class="line">		stack.append(i)</span><br><span class="line"></span><br><span class="line">	arr = list(nums)</span><br><span class="line">	arr.insert(<span class="number">0</span>, sys.maxsize)</span><br><span class="line">	arr.append(sys.maxsize)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &gt; arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">			prev_idx = stack.pop()</span><br><span class="line">			res += arr[prev_idx] * (prev_idx - stack[<span class="number">-1</span>]) * (i - prev_idx)</span><br><span class="line">		stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="累计和算法II解题思路："><a href="#累计和算法II解题思路：" class="headerlink" title="累计和算法II解题思路："></a><strong>累计和算法II解题思路：</strong></h3><p>比暴力法稍优，两重循环覆盖所有子数组[i, j]，每轮循环得到最大最小值，然后O(1)内求该区间内所有最大最小值差值和。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subArrayRanges</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">		min_value, max_value = nums[i], nums[i]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">			min_value = min(min_value, nums[j])</span><br><span class="line">			max_value = max(max_value, nums[j])</span><br><span class="line">			sum += max_value - min_value</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^2)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 210 Course Schedule II</title>
    <url>/2021/12/05/lee-210/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that you <strong>must</strong> take course <code>b&lt;sub&gt;i&lt;/sub&gt;</code> first if you want to take course <code>a&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br><em>   For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.<br><br>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]<br><strong>Output:</strong> [0,1]<br><strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]<br><strong>Output:</strong> [0,2,1,3]<br><strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> numCourses = 1, prerequisites = []<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= numCourses &lt;= 2000</code><br><em>   `0 &lt;= prerequisites.length &lt;= numCourses </em> (numCourses - 1)<code>*</code>prerequisites[i].length == 2<code>*</code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses<code>*</code>a<sub>i</sub> != b<sub>i</sub><code>*   All the pairs</code>[a<sub>i</sub>, b<sub>i</sub>]` are <strong>distinct</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>课程有先修课要求，求修课的顺序</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>拓扑排序的经典题  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意题目要求课程可能存在循环，记得第四部侦测循环   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">	in_degree = [<span class="number">0</span>] * numCourses</span><br><span class="line">	graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> prerequisites:</span><br><span class="line">		in_degree[li[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">		graph[li[<span class="number">1</span>]].append(li[<span class="number">0</span>])</span><br><span class="line">	queue = collections.deque([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(in_degree)) <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>])</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> in_degree[neighbor] == <span class="number">0</span>:</span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">	<span class="keyword">return</span> res <span class="keyword">if</span> numCourses == len(res) <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">	ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">		graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	<span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">	<span class="comment">//populate inDegree &amp; convert to graph</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">		<span class="comment">//[0,1] means 1-&gt;0</span></span><br><span class="line">		inDegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">		graph.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">			q.offer(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		Integer v = q.poll();</span><br><span class="line">		res.add(v);</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line">			<span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">0</span>)</span><br><span class="line">				q.add(neighbor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count != numCourses)</span><br><span class="line">		res.clear();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2106 Maximum Fruits Harvested After at Most K Steps</title>
    <url>/2021/12/12/lee-2106/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array <code>fruits</code> where <code>fruits[i] = [position&lt;sub&gt;i&lt;/sub&gt;, amount&lt;sub&gt;i&lt;/sub&gt;]</code> depicts <code>amount&lt;sub&gt;i&lt;/sub&gt;</code> fruits at the position <code>position&lt;sub&gt;i&lt;/sub&gt;</code>. <code>fruits</code> is already <strong>sorted</strong> by <code>position&lt;sub&gt;i&lt;/sub&gt;</code> in <strong>ascending order</strong>, and each <code>position&lt;sub&gt;i&lt;/sub&gt;</code> is <strong>unique</strong>.<br><br>You are also given an integer <code>startPos</code> and an integer <code>k</code>. Initially, you are at the position <code>startPos</code>. From any position, you can either walk to the <strong>left or right</strong>. It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis, and you can walk <strong>at most</strong> <code>k</code> steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.<br><br>Return <em>the <strong>maximum total number</strong> of fruits you can harvest</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/1.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4<br><strong>Output:</strong> 9<br><strong>Explanation:</strong><br>The optimal way is to:<br>- Move right to position 6 and harvest 3 fruits<br>- Move right to position 8 and harvest 6 fruits<br>You moved 3 steps and harvested 3 + 6 = 9 fruits in total.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/2.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4<br><strong>Output:</strong> 14<br><strong>Explanation:</strong><br>You can move at most k = 4 steps, so you cannot reach position 0 nor 10.<br>The optimal way is to:<br>- Harvest the 7 fruits at the starting position 5<br>- Move left to position 4 and harvest 1 fruit<br>- Move right to position 6 and harvest 2 fruits<br>- Move right to position 7 and harvest 4 fruits<br>You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/3.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2<br><strong>Output:</strong> 0<br><strong>Explanation:</strong><br>You can move at most k = 2 steps and cannot reach any position with fruits.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= fruits.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>fruits[i].length == 2</code><br><em>   `0 &lt;= startPos, position<sub>i</sub> &lt;= 2 </em> 10<sup>5</sup><code>*</code>position<sub>i-1</sub> &lt; position<sub>i</sub><code>for any</code>i &gt; 0<code>(**0-indexed**)
*</code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup><code>*</code>0 &lt;= k &lt;= 2 * 10<sup>5</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>向左向右在规定步数内采集每一格的水果，求最大水果数  </p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始考虑用BFS，但由于每个点可以走两次，如先往左再往右，所以不能用BFS<br>每个点不能走3次，因为贪婪法。所以只要计算单向路径的水果数，单向路径水果数只要计算[startPos - k - 1, startPos + k + 1]的这个区间即可<br>然后重复路径的范围是[0, k/2 + 1], 枚举这些值然后用<strong>presum</strong>得到单向路径水果数。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先判断不合法的情况sum(gas) &lt; sum(cost)   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxTotalFruits</span><span class="params">(self, fruits: List[List[int]], startPos: int, k: int)</span> -&gt; int:</span></span><br><span class="line">	pos_to_fruits = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> pair <span class="keyword">in</span> fruits:</span><br><span class="line">		pos_to_fruits[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>]</span><br><span class="line">	presum = collections.defaultdict(int)</span><br><span class="line">	presum[startPos - k - <span class="number">1</span>] = pos_to_fruits[startPos - k - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(startPos - k, startPos + k + <span class="number">1</span>):</span><br><span class="line">		presum[i] += presum[i<span class="number">-1</span>] + pos_to_fruits[i]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(k//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">		res = max(res, presum[startPos + k - i * <span class="number">2</span>] - presum[startPos - i - <span class="number">1</span>])</span><br><span class="line">		res = max(res, presum[startPos + i] - presum[startPos - k + i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k + n)</code>，空间复杂度<code>O(n + k)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 212 Word Search II</title>
    <url>/2021/12/03/lee-212/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.<br><br>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[“o”,”a”,”a”,”n”],[“e”,”t”,”a”,”e”],[“i”,”h”,”k”,”r”],[“i”,”f”,”l”,”v”]], words = [“oath”,”pea”,”eat”,”rain”]<br><strong>Output:</strong> [“eat”,”oath”]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[“a”,”b”],[“c”,”d”]], words = [“abcb”]<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == board.length</code>
</em>   <code>n == board[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 12</code>
</em>   <code>board[i][j]</code> is a lowercase English letter.<br><em>   `1 &lt;= words.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>1 &lt;= words[i].length &lt;= 10<code>*</code>words[i]<code>consists of lowercase English letters.
*   All the strings of</code>words` are unique.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Trie来保存单词列表，这样每次DFS的每一步都可以O(1)时间知道是否和单词吻合，而不是O(n)</li>
<li>难点1: Trie的接口有startswith, search, insert，仅insert可以用，其他两个不支持与DFS同步搜索。所以要写一个新函数：其实修改startsWith将for循环去掉当然DFS的API也要改，去掉word, word_index加入trie, trie_node, path, res  </li>
<li>TLE错误，因为比如矩阵为[abc]，单词列表为abc, abc, abc，这样abc加入到结果后就不应该再搜abc，因为结果不能重且效率大打折扣。如果找到了单词，就应该将它从Trie中去掉，避免无谓的搜索，条件是该节点children长度为0，就父节点就将key删除。如果还有儿子节点只能标记is_end为False。Line 29 - 31和35 - 36</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        trie, res = Trie(), []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(word)</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, visited, trie, trie.get_head(), <span class="string">''</span>, res)</span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, visited, trie, trie_node, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        trie_child = trie.search_one_node(board[start_x][start_y], trie_node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trie_child:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        path += board[start_x][start_y]</span><br><span class="line">        <span class="keyword">if</span> trie_child.is_end:</span><br><span class="line">            res.append(path)</span><br><span class="line">            trie_child.is_end = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">                trie_node.children.pop(board[start_x][start_y])</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            self.dfs(board, start_x + dx, start_y + dy, visited, trie, trie_child, path, res)</span><br><span class="line">        path = path[:<span class="number">-1</span>]</span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            trie_node.children.pop(board[start_x][start_y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_one_node</span><span class="params">(self, c: str, trie_node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> trie_node.children[c]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>上述代码比较复杂，可以先写这个LTE版本, 它在最后结果去重，但是对于重复单词会LTE，如[‘a’, … ‘a’]. 所以演变成最优版本，需要删除Trie的节点</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> list(set(res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, visited, trie, trie_node, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	trie_child = trie.search_one_node(board[start_x][start_y], trie_node)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> trie_child:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">	path += board[start_x][start_y]</span><br><span class="line">	<span class="keyword">if</span> trie_child.is_end:</span><br><span class="line">		res.append(path)</span><br><span class="line">	<span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">		self.dfs(board, start_x + dx, start_y + dy, visited, trie, trie_child, path, res)</span><br><span class="line">	path = path[:<span class="number">-1</span>]</span><br><span class="line">	visited[start_x][start_y] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*4*3<sup>L-1</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向,第一个可以4个方向，其他步是3个方向    </p>
<p>有一个方法是不用Trie而是将单词所有prefix放入到set中，但会TLE，因为时间复杂度为<code>O(<em>n</em><sup>2</sup><em>3</em><sup>n*n</sup>)</code>，它不会剪枝，从顶点出发，最差情况是z型走完board，此时路径长度为n*n.  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2121 Intervals Between Identical Elements</title>
    <url>/2021/12/25/lee-2121/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/intervals-between-identical-elements/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a <strong>0-indexed</strong> array of <code>n</code> integers <code>arr</code>.<br><br>The <strong>interval</strong> between two elements in <code>arr</code> is defined as the <strong>absolute difference</strong> between their indices. More formally, the <strong>interval</strong> between <code>arr[i]</code> and <code>arr[j]</code> is <code>|i - j|</code>.<br><br>Return <em>an array</em> <code>intervals</code> <em>of length</em> <code>n</code> <em>where</em> <code>intervals[i]</code> <em>is <strong>the sum of intervals</strong> between</em> <code>arr[i]</code> <em>and each element in</em> <code>arr</code> <em>with the same value as</em> <code>arr[i]</code><em>.</em><br><br><strong>Note:</strong> <code>|x|</code> is the absolute value of <code>x</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> arr = [2,1,3,1,2,3,3]<br><strong>Output:</strong> [4,2,7,2,4,4,5]<br><strong>Explanation:</strong><br>- Index 0: Another 2 is found at index 4. |0 - 4| = 4<br>- Index 1: Another 1 is found at index 3. |1 - 3| = 2<br>- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7<br>- Index 3: Another 1 is found at index 1. |3 - 1| = 2<br>- Index 4: Another 2 is found at index 0. |4 - 0| = 4<br>- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4<br>- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> arr = [10,5,10,10]<br><strong>Output:</strong> [5,0,3,4]<br><strong>Explanation:</strong><br>- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5<br>- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.<br>- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3<br>- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == arr.length</code>
</em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>1 &lt;= arr[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求相同元素的下标差的和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是TLE，由于存在重复计算。用prefix和suffix来优化。<br>prefix为从某个元素为起点到前继节点下标差之和<br>suffix为从某个元素为起点到后继节点下标差之和<br>结果 = prefix[i] + suffix[i]</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>用Map来存储相同元素的下标  </li>
<li>用prefix和suffix来计算每个元素的结果</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>一开始用presum表示从起点到其他下标的差之和。这不能用于某个元素的前继元素下标差之和。所以要改成<strong>从某个元素为起点到前继节点下标差之和</strong>    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	val_to_index = collections.defaultdict(list)</span><br><span class="line">	res = [<span class="number">0</span>] * len(arr)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">		val_to_index[arr[i]].append(i)</span><br><span class="line">	<span class="keyword">for</span> val, indices <span class="keyword">in</span> val_to_index.items():</span><br><span class="line">		prefix, suffix = [<span class="number">0</span>], [<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(indices)):</span><br><span class="line">			prefix.append(prefix[<span class="number">-1</span>] + i * abs(indices[i] - indices[i - <span class="number">1</span>]))</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(indices) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			suffix.append(suffix[<span class="number">-1</span>] + (len(indices) - i - <span class="number">1</span>) * abs(indices[i] - indices[i + <span class="number">1</span>]))</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(indices)):</span><br><span class="line">			res[indices[i]] = prefix[i] + suffix[len(indices) - i - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2140 Solving Questions With Brainpower</title>
    <url>/2022/01/15/lee-2140/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/solving-questions-with-brainpower/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a <strong>0-indexed</strong> 2D integer array <code>questions</code> where <code>questions[i] = [points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt;]</code>.<br><br>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code>0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code>i</code> will <strong>earn</strong> you <code>points&lt;sub&gt;i&lt;/sub&gt;</code> points but you will be <strong>unable</strong> to solve each of the next <code>brainpower&lt;sub&gt;i&lt;/sub&gt;</code> questions. If you skip question <code>i</code>, you get to make the decision on the next question.<br><br><em>   For example, given <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>:
    </em>   If question <code>0</code> is solved, you will earn <code>3</code> points but you will be unable to solve questions <code>1</code> and <code>2</code>.<br>    <em>   If instead, question <code>0</code> is skipped and question <code>1</code> is solved, you will earn <code>4</code> points but you will be unable to solve questions <code>2</code> and <code>3</code>.<br><br>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> questions = [[3,2],[4,3],[4,4],[2,5]]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 0 and 3.<br>- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 1 and 2<br>- Solve question 3: Earn 2 points<br>Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 1 and 4.<br>- Skip question 0<br>- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 2 and 3<br>- Solve question 4: Earn 5 points<br>Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= questions.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>questions[i].length == 2</code>
</em>   <code>1 &lt;= points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>(points, brainpower)解决一个问题得到points分，但是接下来的brainpower个问题都不能回答。求最大分数</p>
<h3 id="一维DP解题思路-推荐-："><a href="#一维DP解题思路-推荐-：" class="headerlink" title="一维DP解题思路(推荐)："></a><strong>一维DP解题思路(推荐)：</strong></h3><p>类似于LeetCode 198 House Robber，但此不再是固定的相邻不能偷，而是动态多个不能偷。<br>这题求最值，且数组有序访问，暴力法是多项式复杂度，所以考虑用DP。详见解法二。考虑优化算法二<br>首先考虑用累计dp，但是即使这样，由于前n-1个问题每个不能回答的范围都不同，并不能容易由第n-1个累计DP获得dp[n]<br>巧妙地利用从后往前计算，这样dp值不能回答范围包含在了已经计算的dp值中，如计算dp[3] &lt;- dp[i + questions[3][1] + 1] + questions[3][0], 后者最大的话，当前结果也是最大，符合归纳条件。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>如哈雷彗星，限制条件是向后，所以从后往前计算</li>
<li>用累计DP： F[i] = max(F[i + 1], f)</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (len(questions) + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">		next_val = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> i + questions[i][<span class="number">1</span>] + <span class="number">1</span> &lt; len(dp):</span><br><span class="line">			next_val = dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>]</span><br><span class="line">		dp[i] = max(dp[i + <span class="number">1</span>], questions[i][<span class="number">0</span>] + next_val)</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="二维DP算法II解题思路："><a href="#二维DP算法II解题思路：" class="headerlink" title="二维DP算法II解题思路："></a><strong>二维DP算法II解题思路：</strong></h3><p>一开始我的思路是比较直接，此算法TLE。 dp[i]为以回答了第i个问题及之前的问题所得分数。递归式为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[j] + questions[i][0]) if j + questions[j][1] &lt; i, 0 &lt;= j &lt; i</span><br></pre></td></tr></table></figure>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints2</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * len(questions)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">		dp[i] = questions[i][<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">			<span class="keyword">if</span> j + questions[j][<span class="number">1</span>] &lt; i:</span><br><span class="line">				dp[i] = max(dp[i], dp[j] + questions[i][<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2139 Minimum Moves to Reach Target Score</title>
    <url>/2022/01/15/lee-2139/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-moves-to-reach-target-score/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are playing a game with integers. You start with the integer <code>1</code> and you want to reach the integer <code>target</code>.<br><br>In one move, you can either:<br><br><em>   <strong>Increment</strong> the current integer by one (i.e., <code>x = x + 1</code>).
</em>   <strong>Double</strong> the current integer (i.e., <code>x = 2 * x</code>).<br><br>You can use the <strong>increment</strong> operation <strong>any</strong> number of times, however, you can only use the <strong>double</strong> operation <strong>at most</strong> <code>maxDoubles</code> times.<br><br>Given the two integers <code>target</code> and <code>maxDoubles</code>, return <em>the minimum number of moves needed to reach</em> <code>target</code> <em>starting with</em> <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 5, maxDoubles = 0<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Keep incrementing by 1 until you reach target.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 19, maxDoubles = 2<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Initially, x = 1<br>Increment 3 times so x = 4<br>Double once so x = 8<br>Increment once so x = 9<br>Double again so x = 18<br>Increment once so x = 19<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 10, maxDoubles = 4<br><strong>Output:</strong> 4<br><strong>Explanation:</strong>Initially, x = 1<br>Increment once so x = 2<br>Double once so x = 4<br>Increment once so x = 5<br>Double again so x = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>0 &lt;= maxDoubles &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>加1或者乘2达到target，乘2有次数限制，求到达target的最小步数</p>
<h3 id="DFS解题思路-推荐-："><a href="#DFS解题思路-推荐-：" class="headerlink" title="DFS解题思路(推荐)："></a><strong>DFS解题思路(推荐)：</strong></h3><p>由于是最值，一开始用DP，但得到TLE，分析后觉得是因为加法太慢，所以用贪心法，尽量用乘法。此题类似于求幂值。改用DFS。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若允许乘法次数为0，直接返回加法次数，而不应再用递归，否则会出现超过系统栈深度</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> maxDoubles == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> target - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> self.minMoves(target // <span class="number">2</span>, maxDoubles - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> self.minMoves(target - <span class="number">1</span>, maxDoubles) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>TLE</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j], dp[i // 2][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span>] * (maxDoubles + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> j &gt;= <span class="number">1</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">				dp[i][j] = min(dp[i][j], dp[i // <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n x maxDoubles)</code>，空间复杂度<code>O(n x maxDoubles)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 215 Kth Largest Element in an Array</title>
    <url>/2021/12/11/lee-215/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k&lt;sup&gt;th&lt;/sup&gt;</code> <em>largest element in the array</em>.<br><br>Note that it is the <code>k&lt;sup&gt;th&lt;/sup&gt;</code> largest element in the sorted order, not the <code>k&lt;sup&gt;th&lt;/sup&gt;</code> distinct element.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2<br><strong>Output:</strong> 5<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4<br><strong>Output:</strong> 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= k &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求第k大的数(1th index)</p>
<h3 id="Heap算法思路："><a href="#Heap算法思路：" class="headerlink" title="Heap算法思路："></a><strong>Heap算法思路：</strong></h3><p>求第k个最大也就是用最小堆(大-&gt;小)  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>N/A</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	res = []  <span class="comment"># min heap</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i &lt; k:</span><br><span class="line">			heapq.heappush(res, nums[i])</span><br><span class="line">		<span class="keyword">elif</span> nums[i] &gt; res[<span class="number">0</span>]:</span><br><span class="line">			heapq.heapreplace(res, nums[i])</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(k)</code> </p>
<hr>
<h3 id="Quickselect算法II解题思路："><a href="#Quickselect算法II解题思路：" class="headerlink" title="Quickselect算法II解题思路："></a><strong>Quickselect算法II解题思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归调用仍用m，而不是跟pivot_pos相关，因为m是下标位置  </li>
<li>partition中range用[start, end)而不是len    </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	m = len(nums) - k</span><br><span class="line">	<span class="keyword">return</span> self.quick_select(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>, m)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_select</span><span class="params">(self, nums, start, end, m)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt; end:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	pivot_pos = self.partition(nums, start, end)</span><br><span class="line">	<span class="keyword">if</span> m == pivot_pos:</span><br><span class="line">		<span class="keyword">return</span> nums[pivot_pos]</span><br><span class="line">	<span class="keyword">elif</span> m &lt; pivot_pos:</span><br><span class="line">		<span class="keyword">return</span> self.quick_select(nums, start, pivot_pos - <span class="number">1</span>, m)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> self.quick_select(nums, pivot_pos + <span class="number">1</span>, end, m)  <span class="comment"># remember use m not related to pivot_pos</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">	pivot, no_smaller_index = nums[end], start</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):  <span class="comment"># remember use start and end not len</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">			nums[i], nums[no_smaller_index] = nums[no_smaller_index], nums[i]</span><br><span class="line">			no_smaller_index += <span class="number">1</span></span><br><span class="line">	nums[no_smaller_index], nums[end] = nums[end], nums[no_smaller_index]</span><br><span class="line">	<span class="keyword">return</span> no_smaller_index</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>T(n) = T(n/2)+n, 时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
<hr>
<h3 id="排序算法III解题思路："><a href="#排序算法III解题思路：" class="headerlink" title="排序算法III解题思路："></a><strong>排序算法III解题思路：</strong></h3><p>先排序  </p>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>Heap</tag>
        <tag>Quickselect</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 216 Combination Sum III</title>
    <url>/2021/12/29/lee-216/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:<br><br><em>   Only numbers <code>1</code> through <code>9</code> are used.
</em>   Each number is used <strong>at most once</strong>.<br><br>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> k = 3, n = 7<br><strong>Output:</strong> [[1,2,4]]<br><strong>Explanation:</strong><br>1 + 2 + 4 = 7<br>There are no other valid combinations.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> k = 3, n = 9<br><strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]<br><strong>Explanation:</strong><br>1 + 2 + 6 = 9<br>1 + 3 + 5 = 9<br>2 + 3 + 4 = 9<br>There are no other valid combinations.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> k = 4, n = 1<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no valid combinations.<br>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= k &lt;= 9</code>
</em>   <code>1 &lt;= n &lt;= 60</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数字1-9的组合个数为k的组合和等于k，每个元素最多用一次</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Leetcode 40和77的结合。个数和target都要达到。用if k == 0 and target == 0   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	nums = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(nums, <span class="number">0</span>, k, n, [], res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, start, k, target, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> target == <span class="number">0</span>:</span><br><span class="line">		res.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		self.dfs(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, target - nums[i], path, res)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>k</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 224 Basic Calculator</title>
    <url>/2021/12/08/lee-224/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.<br><br><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “1 + 1”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ 2-1 + 2 “<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “(1+(4+5+2)-3)+(6+8)”<br><strong>Output:</strong> 23<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 3 </em> 10<sup>5</sup><code>*</code>s<code>consists of digits,</code>‘+’<code>,</code>‘-‘<code>,</code>‘(‘<code>,</code>‘)’<code>, and</code>‘ ‘<code>.
*</code>s<code>represents a valid expression.
*</code>‘+’<code>is **not** used as a unary operation (i.e.,</code>“+1”<code>and</code>“+(2 + 3)”<code>is invalid).
*</code>‘-‘<code>could be used as a unary operation (i.e.,</code>“-1”<code>and</code>“-(2 + 3)”` is valid).<br><em>   There will be no two consecutive operators in the input.
</em>   Every number and running calculation will fit in a signed 32-bit integer.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减，但有括号。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>括号题优先考虑用Stack。这里Stack不能只存数，因为括号前可以是正负，所以将这个信息以+1或-1也压入栈（栈不能混合字符和数字）<br>所以用<strong>一个stack</strong>，num是一个数，res是括号内的累积结果。num在处理完每一个数都要重设，res和sign在处理完每个括号都要重设。    </p>
<p>运用模板，代码中含五种情况：空格，运算符，数字，左右括号。左括号将res和sign入栈，右括号将res和sign出栈，计算结果存在res  </p>
<p><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a> 括号加减法, 同一层括号内求和遇括号入栈<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a> 加减乘除, 和的每一项入栈，方便出栈计乘除<br><a href="https://shineboy2013.github.io/2022/03/01/leetcode-772-basic-calculator-iii/" target="_blank" rel="noopener">LeetCode 772 Basic Calculator III</a> 加减乘除括号, L227的递归版</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>括号前可以是正负，所以将这个信息以+1或-1也压入栈</strong>         </li>
<li>左括号无论前面是正负都要入栈  </li>
<li>num在处理完每一个数都要重设，res和sign在处理完每个括号都要重设    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1-(2+3)+(4+5)</span></span><br><span class="line"><span class="comment"># 1+2+3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	res, num, stack, sign = <span class="number">0</span>, <span class="number">0</span>, [], <span class="number">1</span></span><br><span class="line">	s += <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">			res += sign * num</span><br><span class="line">			sign = <span class="number">1</span></span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'-'</span>:</span><br><span class="line">			res += sign * num</span><br><span class="line">			sign = <span class="number">-1</span></span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			stack.append(res) <span class="comment"># [-4+]</span></span><br><span class="line">			stack.append(sign) <span class="comment">#</span></span><br><span class="line">			sign = <span class="number">1</span></span><br><span class="line">			res = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">			res += sign * num <span class="comment"># 9</span></span><br><span class="line">			prev_sign = stack.pop() <span class="comment"># +</span></span><br><span class="line">			tmp = stack.pop() <span class="comment"># -4</span></span><br><span class="line">			res = tmp + prev_sign * res <span class="comment"># -4 +9</span></span><br><span class="line">			<span class="comment"># sign = 1 next one will be +-, so num = 0 and sign doesn't matter</span></span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">		<span class="comment"># else:</span></span><br><span class="line">		 <span class="comment">#   res += char</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 227 Basic Calculator II</title>
    <url>/2021/12/06/lee-227/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.<br><br>The integer division should truncate toward zero.<br><br>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>.<br><br><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “3+2<em>2”<br><strong>Output:</strong> 7<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ 3/2 “<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ 3+5 / 2 “<br><strong>Output:</strong> 5<br></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= s.length &lt;= 3 * 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>s</code> consists of integers and operators `(‘+’, ‘-‘, ‘</em>‘, ‘/‘)<code>separated by some number of spaces.
*</code>s<code>represents **a valid expression**.
*   All the integers in the expression are non-negative integers in the range</code>[0, 2<sup>31</sup> - 1]`.<br><em>   The answer is <strong>guaranteed</strong> to fit in a <em>*32-bit integer</em></em>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除，但无括号。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>逆波兰式的实现用Stack。Stack只存数，而且<strong>只存加号操作符</strong>的数，也就是说，<br>如果是减，就将-num入栈，<br>如果是乘除，立刻计算stack[-1]乘除num的结果再压入栈，因为乘除是最高优先级可以直接计算，而加减不可以。<br>所以用<strong>一个stack</strong>  </p>
<p>代码中含三种情况：空格，运算符，数字</p>
<p><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a> 括号加减法, 同一层括号内求和遇括号入栈<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a> 加减乘除, 和的每一项入栈，方便出栈计乘除<br><a href="https://shineboy2013.github.io/2022/03/01/leetcode-772-basic-calculator-iii/" target="_blank" rel="noopener">LeetCode 772 Basic Calculator III</a> 加减乘除括号, L227的递归版</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>此题没有括号，不能用模板，要借用op来记录前一个操作符  </p>
<ol>
<li>op记录前一个运算符，char为运算符或当前字符。计算时候根据op，因为char(+)只是第二个操作数(1-2+)的终结字符，此时表明操作数stack[-1], num以及操作符op均已完成，可以计算         </li>
<li>最容易错的是向下取整Line 18, 题目返回要求整数。所以<strong>要除法后取整int(prev / num)</strong></li>
<li>s末尾加入加号，方便parse最后一个num  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	s += <span class="string">'+'</span></span><br><span class="line">	res, num, stack, op = <span class="number">0</span>, <span class="number">0</span>, [], <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">			stack.append(-num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">			stack.append(num) <span class="comment"># [4+2*1]</span></span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(prev * num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(int(prev / num))  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">			op = char</span><br><span class="line">    <span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 230 Kth Smallest Element in a BST</title>
    <url>/2021/12/05/lee-230/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k&lt;sup&gt;th&lt;/sup&gt;</code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,1,4,null,2], k = 1<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is <code>n</code>.
</em>   <code>1 &lt;= k &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br><em>*Follow up:</em></em> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求BST的第k个最小元素（k从1开始）</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用返回值(count, 结果). 递归右节点，用k - 1 - left_count</li>
<li>Line 9不能用if left_val，因为left_val可能是0，用is not None</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">	count, val = self.dfs(root, k)</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">	left_count, left_val = self.dfs(root.left, k)</span><br><span class="line">	<span class="keyword">if</span> left_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>: <span class="comment"># remember if left_val is wrong</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, left_val</span><br><span class="line">	<span class="keyword">if</span> left_count + <span class="number">1</span> == k:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, root.val</span><br><span class="line">	right_count, right_val = self.dfs(root.right, k - left_count - <span class="number">1</span>) <span class="comment"># remember k-1-left_count</span></span><br><span class="line">    <span class="keyword">if</span> right_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, right_val</span><br><span class="line">	<span class="keyword">return</span> left_count + <span class="number">1</span> + right_count, right_val</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> kthSmallest2R(root, k).result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">kthSmallest2R</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">	ResultType leftResult = kthSmallest2R(root.left, k);</span><br><span class="line"></span><br><span class="line">	Integer result = leftResult.result;</span><br><span class="line">	<span class="keyword">if</span>(result != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResultType(result, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(leftResult.count + <span class="number">1</span> == k)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResultType(root.val, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	ResultType rightResult = kthSmallest2R(root.right, k - <span class="number">1</span> - leftResult.count);</span><br><span class="line">	result = rightResult.result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ResultType(result, leftResult.count + <span class="number">1</span> + rightResult.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> </span>&#123;</span><br><span class="line">	Integer result;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ResultType</span><span class="params">(Integer r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		result = r;</span><br><span class="line">		count = c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 236 Lowest Common Ancestor of a Binary Tree</title>
    <url>/2021/12/04/lee-236/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br><br>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1,2], p = 1, q = 2<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.
</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> will exist in the tree.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树中求给定的两节点的最低共同父亲节点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>pq一定存在，所以有**三种情况： 1) p或q是root，另一是其子孙。 2) p，q分列root两边。 3) p，q在root的一边</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">	right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">	<span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	<span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>BFS遍历树（可以找到就停止），然后记录子节点到父节点的映射，将所有父节点放到set中，同样查找另一个节点的父节点们，找到第一个在set中的节点。  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 238 Product of Array Except Self</title>
    <url>/2021/12/28/lee-238/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.<br><br>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br><br>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4]<br><strong>Output:</strong> [24,12,8,6]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1,1,0,-3,3]<br><strong>Output:</strong> [0,0,9,0,0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-30 &lt;= nums[i] &lt;= 30</code><br><em>   The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br><br><strong>Follow up:</strong> Can you solve the problem in <code>O(1)</code>extra space complexity? (The output array <em>*does not</em></em> count as extra space for space complexity analysis.)<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求每个数对应的结果： 数组出自己外全部相乘  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>累计思想</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>两轮计算，从左到右，再从右到左，用res数组作为临时计算结果。从左到右，计算res[i] = num[0] x nums[i - 1], 从右到左类似   </li>
<li>res初始值为1，因为从左到右是跳过第0个值的，而从右到左中res[i] *= product，若初始为0，结果res[i] = 0   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	n = len(nums)</span><br><span class="line">	res, product = [<span class="number">1</span>] * n, nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">		res[i] = product <span class="comment"># [1, 1]</span></span><br><span class="line">		product *= nums[i]</span><br><span class="line">	product = nums[<span class="number">-1</span>] <span class="comment"># 2</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">		res[i] *= product <span class="comment"># [2, 1]</span></span><br><span class="line">		product *= nums[i]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="若可以用除法算法II解题思路："><a href="#若可以用除法算法II解题思路：" class="headerlink" title="若可以用除法算法II解题思路："></a><strong>若可以用除法算法II解题思路：</strong></h3><p>按照定义用数学方法，但只要注意一个0和两个0的情况</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	product, zero_count = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		<span class="keyword">if</span> n != <span class="number">0</span>:</span><br><span class="line">			product *= n</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			zero_count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> zero_count &gt; <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> [<span class="number">0</span>] * len(nums)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">			res.append(product)</span><br><span class="line">		<span class="keyword">elif</span> zero_count &gt; <span class="number">0</span>:</span><br><span class="line">			res.append(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(int(product / nums[i]))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 244 Shortest Word Distance II</title>
    <url>/2021/12/25/lee-244/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-word-distance-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.<br><br>Implement the <code>WordDistance</code> class:<br><br><em>   <code>WordDistance(String[] wordsDict)</code> initializes the object with the strings array <code>wordsDict</code>.
</em>   <code>int shortest(String word1, String word2)</code> returns the shortest distance between <code>word1</code> and <code>word2</code> in the array <code>wordsDict</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“WordDistance”, “shortest”, “shortest”]<br>[[[“practice”, “makes”, “perfect”, “coding”, “makes”]], [“coding”, “practice”], [“makes”, “coding”]]<br><strong>Output</strong><br>[null, 3, 1]<br><br><strong>Explanation</strong><br>WordDistance wordDistance = new WordDistance([“practice”, “makes”, “perfect”, “coding”, “makes”]);<br>wordDistance.shortest(“coding”, “practice”); // return 3<br>wordDistance.shortest(“makes”, “coding”);    // return 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= wordsDict.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>1 &lt;= wordsDict[i].length &lt;= 10<code>*</code>wordsDict[i]<code>consists of lowercase English letters.
*</code>word1<code>and</code>word2<code>are in</code>wordsDict<code>.
*</code>word1 != word2<code>*   At most</code>5000<code>calls will be made to</code>shortest`.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构返回单词列表中两单词下标最短距离。单词列表含重复单词</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>记录word到下标列表。可以用logn搜索另一个列表，总时间复杂度为O(nlogn)。不如用mergesort的merge来计算，复杂度为O(n)</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wordsDict: List[str])</span>:</span></span><br><span class="line">        self.word_to_indices = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordsDict)):</span><br><span class="line">            self.word_to_indices[wordsDict[i]].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        indices1 = self.word_to_indices[word1]</span><br><span class="line">        indices2 = self.word_to_indices[word2]</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(indices1) <span class="keyword">and</span> j &lt; len(indices2):</span><br><span class="line">            res = min(res, abs(indices1[i] - indices2[j]))</span><br><span class="line">            <span class="keyword">if</span> indices1[i] &lt;= indices2[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>shortest时间复杂度为<code>O(L)</code>，空间复杂度<code>O(1)</code>。L为两单词下标列表的最短长度  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 239 Sliding Window Maximum</title>
    <url>/2021/12/06/lee-239/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCode 239 Sliding Window Maximum</a></strong></p>
<div><br><br>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.<br><br>Return <em>the max sliding window</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3<br><strong>Output:</strong> [3,3,5,5,6,7]<br><strong>Explanation:</strong><br>Window position                Max<br>—————               —–<br>[1  3  -1] -3  5  3  6  7       <strong>3</strong><br> 1 [3  -1  -3] 5  3  6  7       <strong>3</strong><br> 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong><br> 1  3  -1 [-3  5  3] 6  7       <strong>5</strong><br> 1  3  -1  -3 [5  3  6] 7       <strong>6</strong><br> 1  3  -1  -3  5 [3  6  7]      <strong>7</strong><br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1], k = 1<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>1 &lt;= k &lt;= nums.length</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>LL + 递减栈<br>难点是什么时候输出结果，并不是出栈时候，而是每轮遍历时，就可以计算当轮的最大值，也就是当前的队首  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>每轮遍历时，计算<strong>当轮的最大值就是当前的队首</strong>      </li>
<li>注意程序顺序，先递减栈模板，在计算结果，最后移出越界元素。如例子[876], i = 2, 窗口大小满足了，计算结果为8,8在下一轮会越界，所以移除。  </li>
<li>结果数小于数组大小，注意line 8的条件</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	queue, res = collections.deque(), []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">while</span> queue <span class="keyword">and</span> nums[i] &gt; nums[queue[<span class="number">-1</span>]]:</span><br><span class="line">			queue.pop()</span><br><span class="line">		queue.append(i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i + <span class="number">1</span> &gt;= k:</span><br><span class="line">			res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">		<span class="keyword">if</span> i - queue[<span class="number">0</span>] + <span class="number">1</span> &gt;= k:</span><br><span class="line">			queue.popleft()</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 251 Flatten 2D Vector</title>
    <url>/2022/01/03/lee-251/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-2d-vector/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design an iterator to flatten a 2D vector. It should support the <code>next</code> and <code>hasNext</code> operations.<br><br>Implement the <code>Vector2D</code> class:<br><br><em>   <code>Vector2D(int[][] vec)</code> initializes the object with the 2D vector <code>vec</code>.
</em>   <code>next()</code> returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to <code>next</code> are valid.<br><em>   <code>hasNext()</code> returns <code>true</code> if there are still some elements in the vector, and <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Vector2D”, “next”, “next”, “next”, “hasNext”, “hasNext”, “next”, “hasNext”]<br>[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]<br><strong>Output</strong><br>[null, 1, 2, 3, true, true, 4, false]<br><br><strong>Explanation</strong><br>Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]);<br>vector2D.next();    // return 1<br>vector2D.next();    // return 2<br>vector2D.next();    // return 3<br>vector2D.hasNext(); // return True<br>vector2D.hasNext(); // return True<br>vector2D.next();    // return 4<br>vector2D.hasNext(); // return False<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= vec.length &lt;= 200</code><br><em>   <code>0 &lt;= vec[i].length &lt;= 500</code>
</em>   <code>-500 &lt;= vec[i][j] &lt;= 500</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>next</code> and <code>hasNext</code>.<br><br><em>*Follow up:</em></em> As an added challenge, try to code it using only <a href="http://www.cplusplus.com/reference/iterator/iterator/" target="_blank" rel="noopener">iterators in C++</a> or <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">iterators in Java</a>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现二维Vector的Iterator</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用两个指针</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>单一Vector可以是空，所以next要循环找到非空的vector</li>
<li>next要col_id加一</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vec: List[List[int]])</span>:</span></span><br><span class="line">        self.vec = vec</span><br><span class="line">        self.row_id = <span class="number">0</span></span><br><span class="line">        self.col_id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            val = self.vec[self.row_id][self.col_id]</span><br><span class="line">            self.col_id += <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.row_id &lt; len(self.vec) <span class="keyword">and</span> self.col_id == len(self.vec[self.row_id]): <span class="comment"># remember while coz []</span></span><br><span class="line">            self.row_id += <span class="number">1</span></span><br><span class="line">            self.col_id = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.row_id == len(self.vec):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(1)</code>, N为所有数，V为vector数，O(N + V)/N. O(1)如果vector都不会空</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 253 Meeting Rooms II</title>
    <url>/2018/01/29/lee-253/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">LeetCode 253 Meeting Rooms II</a></strong></p>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>输入[[0, 30],[5, 10],[15, 20]]表示每个会议的开始结束时间，求最少需要多少会议室能够安排所有的会议。</p>
<h3 id="最小堆解题思路："><a href="#最小堆解题思路：" class="headerlink" title="最小堆解题思路："></a><strong>最小堆解题思路：</strong></h3><p>基于merging interval题目，首先按start排序。并且merge条件是start小于上一个会议的end。</p>
<ol>
<li>写几个例子感受一下。<br><img src="/images/L253.png" alt=""><br>有两个重叠的会议，现在插入新的会议。是否再需要一个会议室取决于该新会议的开始时间小于这两个目前会议的终止时间的最小值。<br>所以思路是用End time min-heap维护目前会议End time。若新会议start time小于堆顶元素，入栈且activeMeeting++，否则循环地出栈且activeMeeting–直到<br>start time小于堆顶。<br>这过程activeMeeting的最大值即所求。<br>最坏情况是所有会议都重叠，复杂度为n* 2logn因为n个元素入堆出堆各一次，所以复杂度为nlogn，但会议一般不会集中，平均情况比排序法稍优。 </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Heap为结束时间的heap。 </li>
<li>类似于递减栈模板，用开始时间与堆顶的结束时间比较（表示这些会议均已结束），若大于堆顶，连续出堆。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	intervals.sort()</span><br><span class="line">	heap = [] <span class="comment"># heap for end time</span></span><br><span class="line">	max = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals)):</span><br><span class="line">		<span class="comment"># start time of the new meeting is earlier than on-going endtime</span></span><br><span class="line">		<span class="keyword">while</span> heap <span class="keyword">and</span> intervals[i][<span class="number">0</span>] &gt;= heap[<span class="number">0</span>]:</span><br><span class="line">			heappop(heap)</span><br><span class="line">		heappush(heap, (intervals[i][<span class="number">1</span>]))</span><br><span class="line">		<span class="keyword">if</span> len(heap) &gt; max:</span><br><span class="line">			max = len(heap)</span><br><span class="line">	<span class="keyword">return</span> max</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>由于输入无序，所以先要排序O(nlogn), 而循环复杂度为O(nlogk), 所以总时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(k)</code>, k为所求也就是需要的会议室数。     </p>
<h3 id="排序法解题思路-推荐-："><a href="#排序法解题思路-推荐-：" class="headerlink" title="排序法解题思路(推荐)："></a><strong>排序法解题思路(推荐)：</strong></h3><ol>
<li>证明解与具体间隔无关，只与end time的值有关。<br><img src="/images/L253-2.png" alt=""></li>
<li>基于1和2，对end time进行排序，题解只与start-end的相对顺序有关。既然这样，我们可以把所有start，end一起排序，也就是按时间轴排列，排成一个2n大小的数组，<br>遇到start，activeMeeting++，遇到end，activeMeeting–。 这过程activeMeeting的最大值即所求。<br>当然，上述方法直观，但实现起来需要建立一个class Node{value, startOrEnd}。本质上等价于对排序后的start数组和排序后的end数组进行<strong>合并排序</strong>。<br>合并排序的结果等价于时间轴上两个数组的统一排序。当然，不需要剩余部分的合并排序，因为这部分不会增加activeMeeting的值。</li>
</ol>
<p>解题步骤：</p>
<ol>
<li>排序start</li>
<li>排序end</li>
<li>合并排序，start小就activeMeeting++，否则activeMeeting–。求activeMeeting的最大值。</li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若endpoint值相同情况下，要确保第二个排序先结束点，再出发点，因为相同点不算有重复飞机</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	start = [(i[<span class="number">0</span>], <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> intervals]</span><br><span class="line">	ends = [(i[<span class="number">1</span>], <span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> intervals]</span><br><span class="line">	endpoints = start + ends</span><br><span class="line">	endpoints.sort()</span><br><span class="line">	active_meetings, max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(endpoints)):</span><br><span class="line">		<span class="keyword">if</span> endpoints[i][<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">			active_meetings += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			active_meetings -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> active_meetings &gt; max:</span><br><span class="line">			max = active_meetings</span><br><span class="line">	<span class="keyword">return</span> max</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Python KB</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 248 Strobogrammatic Number III</title>
    <url>/2020/03/08/lee-248/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/strobogrammatic-number-iii/" target="_blank" rel="noopener">LeetCode 248 Strobogrammatic Number III</a></strong></p>
<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p>
<p><strong>Example:</strong> </p>
<pre>**Input: low = "50", high = "100"

**Output:** 3 

Explanation: 69, 88, and 96 are three strobogrammatic numbers.
</pre>

<p><strong>Note:</strong> Because the range might be a large number, the lowand high numbers are represented as string.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求某范围的旋转数的个数。旋转数是这个数旋转180度还是一样，如0, 1, 8， 还含两位的如69， 96. </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>低频题。这是M公司的题目。这题不能用乘法原理，因为情况多变，要实实在在地找出每一个可能性。<br>类似于L351安卓解码种数，数字间有关系，求[m, n]范围间种数。用DFS将每一位填上合法位，此题区别是<br>需要它有对称性，所以DFS从中间向两边。API为f(res, low, high, map), res为当前结果字符串，map为旋转数的映射关系，<br>终止条件为res超过high，若在范围内，结果+1，也就是先将自己加入到结果中，然后两边加入旋转字符，进入下一轮递归，<br>累加到结果中。  </p>
<p>注意: 与上题一样，和最左位不能为0除了0自己本身。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>带限制条件的填位法DFS。</li>
<li>奇偶位。对称中心既可以是奇数位也可以是偶数位。所以DFS有空字符，单个字符0, 1, 8等4种。  </li>
<li>此题难点在验证： <strong>三种情况</strong>，需要比较字符串，所以要比较长度<br>1) 当前结果长度大于high, 长度等于high但大于high，返回0. <strong>只有这种情况是终止条件</strong><br>2) 当前结果长度大于low, 长度等于low但大于等于low，res = 1<br>3) 最左位为0，不合法如0880，但0本身除外， res = 0  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strobogrammaticInRange</span><span class="params">(self, low: str, high: str)</span> -&gt; int:</span></span><br><span class="line">	stro_dict = &#123;<span class="string">'0'</span>: <span class="string">'0'</span>, <span class="string">'1'</span>: <span class="string">'1'</span>, <span class="string">'8'</span>: <span class="string">'8'</span>, <span class="string">'6'</span>: <span class="string">'9'</span>, <span class="string">'9'</span>: <span class="string">'6'</span>&#125;</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	res += self.dfs(<span class="string">''</span>, low, high, stro_dict)</span><br><span class="line">	res += self.dfs(<span class="string">'0'</span>, low, high, stro_dict)</span><br><span class="line">	res += self.dfs(<span class="string">'1'</span>, low, high, stro_dict)</span><br><span class="line">	res += self.dfs(<span class="string">'8'</span>, low, high, stro_dict)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, low, high, stro_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(s) &gt; len(high) <span class="keyword">or</span> (len(s) == len(high) <span class="keyword">and</span> s &gt; high):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> len(s) &gt; len(low) <span class="keyword">or</span> (len(s) == len(low) <span class="keyword">and</span> s &gt;= low):</span><br><span class="line">		res = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment"># i.e. 08</span></span><br><span class="line">		res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> key, val <span class="keyword">in</span> stro_dict.items():</span><br><span class="line">		res += self.dfs(key + s + val, low, high, stro_dict)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>奇偶位。对称中心既可以是奇数位也可以是偶数位。  </li>
<li>最左位为0，不合法如0880，但0本身除外。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strobogrammaticInRange</span><span class="params">(String low, String high)</span> </span>&#123;</span><br><span class="line">	Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	map.put(<span class="string">"6"</span>, <span class="string">"9"</span>);</span><br><span class="line">	map.put(<span class="string">"9"</span>, <span class="string">"6"</span>);</span><br><span class="line">	map.put(<span class="string">"1"</span>, <span class="string">"1"</span>);</span><br><span class="line">	map.put(<span class="string">"8"</span>, <span class="string">"8"</span>);</span><br><span class="line">	map.put(<span class="string">"0"</span>, <span class="string">"0"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	result += dfs(<span class="string">""</span>, low, high, map);</span><br><span class="line">	result += dfs(<span class="string">"1"</span>, low, high, map);</span><br><span class="line">	result += dfs(<span class="string">"0"</span>, low, high, map);</span><br><span class="line">	result += dfs(<span class="string">"8"</span>, low, high, map);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String res, String low, String high, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(res.length() &gt; high.length() || (res.length() == high.length() &amp;&amp; res.compareTo(high) &gt; <span class="number">0</span>)) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((res.length() == low.length() &amp;&amp; res.compareTo(low) &gt;= <span class="number">0</span>)  || res.length() &gt; low.length()) </span><br><span class="line">		result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(res.length() &gt; <span class="number">1</span> &amp;&amp; res.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">		result += dfs(entry.getKey() + res + entry.getValue(), low, high, map);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 254 Factor Combinations</title>
    <url>/2021/12/29/lee-254/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Numbers can be regarded as the product of their factors.<br><br><em>   For example, <code>8 = 2 x 2 x 2 = 2 x 4</code>.<br><br>Given an integer <code>n</code>, return <em>all possible combinations of its factors</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Note</strong> that the factors should be in the range <code>[2, n - 1]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 12<br><strong>Output:</strong> [[2,6],[3,4],[2,2,3]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 37<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有因式分解</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有解，所以用DFS。类似于LeetCode 039 Combination Sum元素可复用。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>类似于元素可复用的组合和。但更似<strong>全组合模板，append发生在循环中</strong>，而不是终止条件中。比如12，遇到2就把商[2, 6]加入到结果  </li>
<li>数值区间的组合，start和target都是数值，而不是数组长度。i是从start开始，而不是从2开始，<strong>保证path里的数有序</strong>   </li>
<li>target // i &lt; i <strong>保证path里的数有序</strong>，否则12=232，不可行  </li>
<li>i从start循环到math.sqrt(n) + 1，否则会TLE   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFactors</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(n, <span class="number">2</span>, n, [], res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, start, target, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, int(math.sqrt(n) + <span class="number">1</span>)): <span class="comment"># remember to use start</span></span><br><span class="line">		<span class="keyword">if</span> target % i != <span class="number">0</span> <span class="keyword">or</span> target // i &lt; i: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(i)</span><br><span class="line">		res.append(list(path + [target // i]))</span><br><span class="line">		self.dfs(n, i, target // i, path, res) </span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(# of prime factors)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 264 Ugly Number II</title>
    <url>/2021/11/30/lee-264/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p><br><br><p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p><br><br><p>&nbsp;</p><br><p><strong>Example 1:</strong></p><br><br><pre><strong>Input:</strong> n = 10<br><strong>Output:</strong> 12<br><strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.<br></pre><br><br><p><strong>Example 2:</strong></p><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.<br></pre><br><br><p>&nbsp;</p><br><p><strong>Constraints:</strong></p><br><br><ul><br>    <li><code>1 &lt;= n &lt;= 1690</code></li><br></ul><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求第n个丑数，丑数是由2,3,5相乘获得</p>
<h3 id="Heap算法思路-推荐-："><a href="#Heap算法思路-推荐-：" class="headerlink" title="Heap算法思路(推荐)："></a><strong>Heap算法思路(推荐)：</strong></h3><p>Heap</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>与BFS模板一样，visited要在if里面。可以理解为一个数有三条边产生三个新数，所以和BFS模板一样   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	heap, visited = [<span class="number">1</span>], set([<span class="number">1</span>])</span><br><span class="line">	primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> n &gt;= <span class="number">1</span>:</span><br><span class="line">		res = heappop(heap)</span><br><span class="line">		<span class="keyword">for</span> factor <span class="keyword">in</span> primes:</span><br><span class="line">			tmp = factor * res</span><br><span class="line">			<span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">				heappush(heap, tmp)</span><br><span class="line">				visited.add(tmp)</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>.</p>
<hr>
<h3 id="双指针算法II解题思路："><a href="#双指针算法II解题思路：" class="headerlink" title="双指针算法II解题思路："></a><strong>双指针算法II解题思路：</strong></h3><p>比较难想，不推荐，但思路可用于其他题如L373。<strong>指针的数乘以指向数组的数</strong>，此题中指针为p2, p3, p5, 分别代表2， 3， 5， 数组为res数组，每次比较它们的积。    </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>与上题一样要去重，此时，3个乘积中可能会相同且最小，同时移动这些指针     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            num = min(<span class="number">2</span> * res[p2], <span class="number">3</span> * res[p3], <span class="number">5</span> * res[p5])</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">2</span> * res[p2]:</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">3</span> * res[p3]:</span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">5</span> * res[p5]:</span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">            res.append(num)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 269 Alien Dictionary</title>
    <url>/2021/11/29/lee-269/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/alien-dictionary/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.<br><br>You are given a list of strings <code>words</code> from the alien language’s dictionary, where the strings in <code>words</code> are <strong>sorted lexicographically</strong> by the rules of this new language.<br><br>Return <em>a string of the unique letters in the new alien language sorted in <strong>lexicographically increasing order</strong> by the new language’s rules. If there is no solution, return</em> <code>&quot;&quot;</code><em>. If there are multiple solutions, return <strong>any of them</strong></em>.<br><br>A string <code>s</code> is <strong>lexicographically smaller</strong> than a string <code>t</code> if at the first letter where they differ, the letter in <code>s</code> comes before the letter in <code>t</code> in the alien language. If the first <code>min(s.length, t.length)</code> letters are the same, then <code>s</code> is smaller if and only if <code>s.length &lt; t.length</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“wrt”,”wrf”,”er”,”ett”,”rftt”]<br><strong>Output:</strong> “wertf”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“z”,”x”]<br><strong>Output:</strong> “zx”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> words = [“z”,”x”,”z”]<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> The order is invalid, so return <code>&quot;&quot;</code>.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= words.length &lt;= 100</code>
</em>   <code>1 &lt;= words[i].length &lt;= 100</code><br>*   <code>words[i]</code> consists of only lowercase English letters.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目要求： 空字符顺序前于非空字母，否则字典不合法，如abc -&gt; ab, c不能前于空字符，无解。简而言之，后面单词不能是前面的前缀return False if len(word) &gt; len(word2) else True     </li>
<li>模板问题： graph要含所有节点，包括没有边的节点。否则结果会有遗漏graph = Counter({c: [] for word in words for c in word})    </li>
<li>模板问题： in_degree初始化要对所有节点赋0， in_degree[c] = 0。in_degree = collections.defaultdict(int)并不能产生key  </li>
<li>模板问题： 第四步判断是否含循环必不可少，题目要求可能不合法，return res if len(graph) == len(res) else ‘’  </li>
<li>语法错误： graph.items()记得加items。res是str不是list  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alienOrder</span><span class="params">(self, words: List[str])</span> -&gt; str:</span></span><br><span class="line">	<span class="comment"># graph = collections.defaultdict(list)</span></span><br><span class="line">	graph = Counter(&#123;c: [] <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">for</span> c <span class="keyword">in</span> word&#125;)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(words)):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.populate_one_order(words[i - <span class="number">1</span>], words[i], graph):</span><br><span class="line">			<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">	in_degree = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> graph.keys():</span><br><span class="line">		in_degree[c] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> key, li <span class="keyword">in</span> graph.items():</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)):</span><br><span class="line">			in_degree[li[j]] += <span class="number">1</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	queue = deque([node <span class="keyword">for</span> node, in_degree_num <span class="keyword">in</span> in_degree.items() <span class="keyword">if</span> in_degree_num == <span class="number">0</span>])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res += node</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> in_degree[neighbor] == <span class="number">0</span>:</span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">	<span class="keyword">return</span> res <span class="keyword">if</span> len(graph) == len(res) <span class="keyword">else</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">populate_one_order</span><span class="params">(self, word, word2, graph)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(word), len(word2))):</span><br><span class="line">		<span class="keyword">if</span> word[j] != word2[j]:</span><br><span class="line">			graph[word[j]].append(word2[j])</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len(word) &gt; len(word2) <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(O + E)</code>，V为节点数，E为边数，n为单词数，L为最长单词长度，O = nL， E = L，而空间复杂度图的空间为O + E，而queue空间最多为26条边，26个字母，in_degree空间为O(V)。所以总的时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(nL)</code></p>
]]></content>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 272 Closest Binary Search Tree Value II</title>
    <url>/2020/04/26/lee-272/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="noopener">LeetCode 272 Closest Binary Search Tree Value II</a></strong></p>
<p>Given a non-empty binary search tree and a target value, find <em>k</em> values in the BST that are closest to the target.</p>
<p>Note:</p>
<ul>
<li>Given target value is a floating point.</li>
<li>You may assume <em>k</em> is always valid, that is: <em>k</em>≤ total nodes.</li>
<li>You are guaranteed to have only one unique set of <em>k</em> values in the BST that are closest to the target.</li>
</ul>
<p>Example:</p>
<pre>Input: root = [4,2,5,1,3], target = 3.714286, and _k_ = 2

    4
   / \
  2   5
 / \
1   3

Output: [4,3]</pre>

<p>Follow up:<br>Assume that the BST is balanced, could you solve it in less than <em>O</em>(<em>n</em>) runtime (where <em>n</em> = total nodes)?</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找BST中给定目标的最接近的k个值。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>首先观察得到最接近的节点一定在二叉树的搜索路径上的节点的其中一个。这样可以分成两组<br>前驱节点和后驱节点（比target大），加入到两个stack中，由BST的iterator可以知道这两个<br>stack的越靠近栈首就越接近target，所以出栈的一定是最接近target的。只要比较两栈首元素<br>即可。如果某个节点出栈要找其儿子节点填充。找前驱节点和后驱节点的方法是相反的。这里可<br>参照KB的BST非递归中序遍历。    </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>找最接近target的节点，<strong>不用判断左右儿子是否为空</strong>，因为若为空，表示root更接近。大于target的放入successors，否则是predecessors</li>
<li>然后判断两栈首谁大，谁大的就获得相应的比它远离target的节点入栈。如predecessors是左节点的所有右儿子。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestKValues</span><span class="params">(self, root: TreeNode, target: float, k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	predecessors, successors = [], []</span><br><span class="line">	it = root</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		<span class="keyword">if</span> target &lt; it.val:</span><br><span class="line">			successors.append(it)</span><br><span class="line">			it = it.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			predecessors.append(it)</span><br><span class="line">			it = it.right</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> predecessors <span class="keyword">and</span> (<span class="keyword">not</span> successors <span class="keyword">or</span> target - predecessors[<span class="number">-1</span>].val &lt; successors[<span class="number">-1</span>].val - target):</span><br><span class="line">			node = predecessors.pop()</span><br><span class="line">			<span class="keyword">if</span> node.left:</span><br><span class="line">				n = node.left</span><br><span class="line">				<span class="keyword">while</span> n:</span><br><span class="line">					predecessors.append(n)</span><br><span class="line">					n = n.right</span><br><span class="line">			res.append(node.val)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node = successors.pop()</span><br><span class="line">			<span class="keyword">if</span> node.right:</span><br><span class="line">				n = node.right</span><br><span class="line">				<span class="keyword">while</span> n:</span><br><span class="line">					successors.append(n)</span><br><span class="line">					n = n.left</span><br><span class="line">			res.append(node.val)</span><br><span class="line">		k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>target - preOrder.peek().val &lt; postOrder.peek().val - target的条件前<br>记得加上!preOrder.isEmpty()</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123;</span><br><span class="line">	List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">	if(root == null)</span><br><span class="line">		return res;</span><br><span class="line">	Stack&lt;TreeNode&gt; preOrder = new Stack&lt;&gt;();</span><br><span class="line">	Stack&lt;TreeNode&gt; postOrder = new Stack&lt;&gt;();</span><br><span class="line">	findTargetAndPopulateStacks(preOrder, postOrder, root, target);</span><br><span class="line">	</span><br><span class="line">	while(k-- &gt; 0) &#123;</span><br><span class="line">		if(postOrder.isEmpty() || (!preOrder.isEmpty() &amp;&amp; </span><br><span class="line">				target - preOrder.peek().val &lt; postOrder.peek().val - target))</span><br><span class="line">			getPredecessor(preOrder, res);</span><br><span class="line">		else </span><br><span class="line">			getSuccessor(postOrder, res);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findTargetAndPopulateStacks(Stack&lt;TreeNode&gt; preOrder, Stack&lt;TreeNode&gt; postOrder, </span><br><span class="line">		TreeNode root, double target) &#123;</span><br><span class="line">	TreeNode node = root;</span><br><span class="line">	while(node != null) &#123;</span><br><span class="line">		if(node.val &lt; target) &#123; </span><br><span class="line">			preOrder.push(node);</span><br><span class="line">			node = node.right;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			postOrder.push(node);</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getSuccessor(Stack&lt;TreeNode&gt; postOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">	TreeNode node = postOrder.pop();</span><br><span class="line">	res.add(node.val);</span><br><span class="line">	if(node.right != null) &#123;</span><br><span class="line">		TreeNode n = node.right;</span><br><span class="line">		while(n != null) &#123;</span><br><span class="line">			postOrder.push(n);</span><br><span class="line">			n = n.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPredecessor(Stack&lt;TreeNode&gt; preOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">	TreeNode node = preOrder.pop();</span><br><span class="line">	res.add(node.val);</span><br><span class="line">	if(node.left != null) &#123;</span><br><span class="line">		TreeNode n = node.left;</span><br><span class="line">		while(n != null) &#123;</span><br><span class="line">			preOrder.push(n);</span><br><span class="line">			n = n.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为O(k + logn)，空间复杂度O(logn)。  </p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Stack</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 273 Integer to English Words</title>
    <url>/2018/04/30/lee-273/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/integer-to-english-words" target="_blank" rel="noopener">LeetCode 273 Integer to English Words</a></strong></p>
<p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** 123
**Output:** "One Hundred Twenty Three"
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** 12345
**Output:** "Twelve Thousand Three Hundred Forty Five"</pre>

<p><strong>Example 3:</strong></p>
<pre>**Input:** 1234567
**Output:** "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
</pre>

<p><strong>Example 4:</strong></p>
<pre>**Input:** 1234567891
**Output:** "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>这是将非负整数转化为其英文单词表示。给定输入确保小于 2 ^ 31 - 1</p>
<h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>第二种方法是按千位递归的。下面的方法是按20以下，100以下，百位，千位…递归，递归的颗粒度更小，程序更简单。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>在入口方法中，若num为0，则返回Zero，要单独列出。</li>
<li>在递归中，num为0要单独列出，因为0表示此位不存在，可以记在dict中或返回空字符串。</li>
<li>strip来去掉空格。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NUM_DICT = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'One'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Two'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'Three'</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">'Four'</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">'Five'</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">'Six'</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">'Seven'</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">'Eight'</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">'Nine'</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">'Ten'</span>,</span><br><span class="line">    <span class="number">11</span>: <span class="string">'Eleven'</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="string">'Twelve'</span>,</span><br><span class="line">    <span class="number">13</span>: <span class="string">'Thirteen'</span>,</span><br><span class="line">    <span class="number">14</span>: <span class="string">'Fourteen'</span>,</span><br><span class="line">    <span class="number">15</span>: <span class="string">'Fifteen'</span>,</span><br><span class="line">    <span class="number">16</span>: <span class="string">'Sixteen'</span>,</span><br><span class="line">    <span class="number">17</span>: <span class="string">'Seventeen'</span>,</span><br><span class="line">    <span class="number">18</span>: <span class="string">'Eighteen'</span>,</span><br><span class="line">    <span class="number">19</span>: <span class="string">'Nineteen'</span>,</span><br><span class="line">    <span class="number">20</span>: <span class="string">'Twenty'</span>,</span><br><span class="line">    <span class="number">30</span>: <span class="string">'Thirty'</span>,</span><br><span class="line">    <span class="number">40</span>: <span class="string">'Forty'</span>,</span><br><span class="line">    <span class="number">50</span>: <span class="string">'Fifty'</span>,</span><br><span class="line">    <span class="number">60</span>: <span class="string">'Sixty'</span>,</span><br><span class="line">    <span class="number">70</span>: <span class="string">'Seventy'</span>,</span><br><span class="line">    <span class="number">80</span>: <span class="string">'Eighty'</span>,</span><br><span class="line">    <span class="number">90</span>: <span class="string">'Ninety'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberToWords</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Zero'</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> NUM_DICT[num]</span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> (NUM_DICT[num // <span class="number">10</span> * <span class="number">10</span>] + <span class="string">' '</span> + self.dfs(num % <span class="number">10</span>)).strip()</span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">            <span class="keyword">return</span> (NUM_DICT[num // <span class="number">100</span>] + <span class="string">' Hundred '</span> + self.dfs(num % <span class="number">100</span>)).strip()</span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">1000000</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.dfs(num // <span class="number">1000</span>) + <span class="string">' Thousand '</span> + self.dfs(num % <span class="number">1000</span>)).strip()</span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">1000000000</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.dfs(num // <span class="number">1000000</span>) + <span class="string">' Million '</span> + self.dfs(num % <span class="number">1000000</span>)).strip()</span><br><span class="line">        <span class="keyword">elif</span> num &lt; <span class="number">1000000000000</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.dfs(num // <span class="number">1000000000</span>) + <span class="string">' Billion '</span> + self.dfs(num % <span class="number">1000000000</span>)).strip()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>空格总加在新数前面，只需要加在有返回值的时候，也就是tens和lows中，其他如numberToWordsR(number/1000)<br>可能返回空值，此时不在前面加空格。</li>
<li>在递归中，num为0要单独列出，因为0表示此位不存在，也就是无返回值。</li>
<li>在入口方法中，若num为0，则返回Zero，要单独列出。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (number == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> numberToWordsR(number).trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">numberToWordsR</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">20</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">" "</span> + lows[number];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">100</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">" "</span> + tens[number / <span class="number">10</span>] + numberToWordsR(number % <span class="number">10</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">" "</span> + lows[number / <span class="number">100</span>] + <span class="string">" Hundred"</span> + numberToWordsR(number % <span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> numberToWordsR(number / <span class="number">1000</span>) + <span class="string">" Thousand"</span> + numberToWordsR(number % <span class="number">1000</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">1000000000</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> numberToWordsR(number / <span class="number">1000000</span>) + <span class="string">" Million"</span> + numberToWordsR(number % <span class="number">1000000</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> numberToWordsR(number / <span class="number">1000000000</span>) + <span class="string">" Billion"</span> + numberToWordsR(number % <span class="number">1000000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="算法II每三位解题思路："><a href="#算法II每三位解题思路：" class="headerlink" title="算法II每三位解题思路："></a><strong>算法II每三位解题思路：</strong></h3><p>这是logical and maintainable的经典题。按照英语的习惯，每三位是一组，所以实现的时候，也是按千为分组，有一个方法去处理一千<br>内的数。一千以内也分为三种情况，20以内，几十，其他。20以内和几十都是特殊情况的单词，所以可以放入数组或HashMap，数组比较<br>好，因为可以直接用索引读出。大于一千的数，可以用递归来做，从人的习惯，从低位到高位，每三位加一个逗号分隔。所以同样，算法<br>也是从低位开始，若千位内的数大于0，加入Thousand, Million等，每三位调用千位方法，再递归。<br>group的引入作为递归的层次来决定Thousand还是Million。<br>由于从低位递归，所以倒着做，要reverse地加入到结果，最终结果再reverse回来。  </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>空格总加在新数前面，也就是append前先加空格</li>
<li>低3位大于0才加Thousand, Million等词，也就是低三位在1-999之间，若为0如1 million。</li>
</ol>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] lows = &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, </span><br><span class="line">   <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>,<span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>,<span class="string">"Fifteen"</span>,<span class="string">"Sixteen"</span>,<span class="string">"Seventeen"</span>,<span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] tens = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Zero"</span>;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">	translateThreeR(number, result, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> result.reverse().toString().trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translateThreeR</span><span class="params">(<span class="keyword">int</span> number, StringBuilder result, <span class="keyword">int</span> group)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lower = number % <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">int</span> thousands = number / <span class="number">1000</span>;     </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (group == <span class="number">1</span> &amp;&amp; lower &gt; <span class="number">0</span>)</span><br><span class="line">		result.append(reverse(<span class="string">" Thousand"</span>));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (group==<span class="number">2</span> &amp;&amp; lower &gt; <span class="number">0</span>)</span><br><span class="line">		result.append(reverse(<span class="string">" Million"</span>));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (group==<span class="number">3</span> &amp;&amp; lower &gt; <span class="number">0</span>)</span><br><span class="line">		result.append(reverse(<span class="string">" Billion"</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(lower&gt;<span class="number">0</span>)</span><br><span class="line">		result.append(reverse(translateThree(lower)));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(thousands &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		translateThreeR(thousands, result, ++group);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translateThree</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">if</span>(number &gt; <span class="number">99</span>) &#123;</span><br><span class="line">		result.append(<span class="string">" "</span>+lows[number / <span class="number">100</span>]);</span><br><span class="line">		result.append(<span class="string">" Hundred"</span>);</span><br><span class="line">		number = number % <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(number &gt; <span class="number">19</span>) &#123;</span><br><span class="line">		result.append(<span class="string">" "</span>);</span><br><span class="line">		result.append(tens[number/<span class="number">10</span>]);</span><br><span class="line">		number = number % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remainder is under 20</span></span><br><span class="line">	result.append(<span class="string">" "</span>+lows[number]);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">" "</span>+result.toString().trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">new</span> StringBuilder()).append(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>n为位数，时间复杂度为O(n)，空间复杂度O(1)。  </p>
<h3 id="Follow-up："><a href="#Follow-up：" class="headerlink" title="Follow-up："></a><strong>Follow-up：</strong></h3><p>integer, minus, decimals, internationlization(localization)。  </p>
]]></content>
      <tags>
        <tag>Interviewer</tag>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 275 H-Index II</title>
    <url>/2021/11/13/lee-275/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/h-index-ii/" target="_blank" rel="noopener">LeetCode 275 H-Index II</a></strong></p>
<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i&lt;sup&gt;th&lt;/sup&gt;</code> paper and <code>citations</code> is sorted in an <strong>ascending order</strong>, return compute the researcher’s <code>h</code><strong>-index</strong>.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: A scientist has an index <code>h</code> if <code>h</code> of their <code>n</code> papers have at least <code>h</code> citations each, and the other <code>n − h</code> papers have no more than <code>h</code> citations each.</p>
<p>If there are several possible values for <code>h</code>, the maximum one is taken as the <code>h</code><strong>-index</strong>.</p>
<p>You must write an algorithm that runs in logarithmic time.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** citations = [0,1,3,5,6]
**Output:** 3
**Explanation:** [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** citations = [1,2,100]
**Output:** 2
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == citations.length</code></li>
<li><code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个人的学术文章有n篇分别被引用了n次及以上，那么H指数就是n  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数组有序，论文数从小到大有序(符合引用次数的论文数从右向左递减)，引用次数由小到大排序，所以只要从右向左遍历数组，数值和索引相交的值就是所求。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>二分法可提高效率，用的是</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>此题是寻找单一目标，所以等号可以并入任一个if statement，但循环出来后，start必须先比较，因为贪婪法，下标越向左，越容易获得更大的结果。从这一意义上看，此题接近于first_position  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> citations <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(citations) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(citations) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> citations[mid] &gt;= len(citations) - mid:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">if</span> citations[start] &gt;= len(citations) - start:</span><br><span class="line">		<span class="keyword">return</span> len(citations) - start</span><br><span class="line">	<span class="keyword">if</span> citations[end] &gt;= len(citations) - end:</span><br><span class="line">		<span class="keyword">return</span> len(citations) - end</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 278 First Bad Version</title>
    <url>/2021/12/05/lee-278/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.<br><br>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.<br><br>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5, bad = 4<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>call isBadVersion(3) -&gt; false<br>call isBadVersion(5) -&gt; true<br>call isBadVersion(4) -&gt; true<br>Then 4 is the first bad version.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1, bad = 1<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= bad &lt;= n &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目是先good再bad，所以用first position模板     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">	start, end = <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">if</span> isBadVersion(start):</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	<span class="keyword">if</span> isBadVersion(end):</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">1</span>, end = n;</span><br><span class="line">	<span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(isBadVersion(mid)) </span><br><span class="line">			end = mid;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			start = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(isBadVersion(start))</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 281 Zigzag Iterator</title>
    <url>/2022/01/03/lee-281/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/zigzag-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two vectors of integers <code>v1</code> and <code>v2</code>, implement an iterator to return their elements alternately.<br><br>Implement the <code>ZigzagIterator</code> class:<br><br><em>   <code>ZigzagIterator(List&lt;int&gt; v1, List&lt;int&gt; v2)</code> initializes the object with the two vectors <code>v1</code> and <code>v2</code>.
</em>   <code>boolean hasNext()</code> returns <code>true</code> if the iterator still has elements, and <code>false</code> otherwise.<br><em>   <code>int next()</code> returns the current element of the iterator and moves the iterator to the next element.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> v1 = [1,2], v2 = [3,4,5,6]<br><strong>Output:</strong> [1,3,2,4,5,6]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> v1 = [1], v2 = []<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> v1 = [], v2 = [1]<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= v1.length, v2.length &lt;= 1000</code><br><em>   <code>1 &lt;= v1.length + v2.length &lt;= 2000</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= v1[i], v2[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> What if you are given <code>k</code> vectors? How well can your code be extended to such cases?<br><br><strong>Clarification for the follow-up question:</strong><br><br>The “Zigzag” order is not clearly defined and is ambiguous for <code>k &gt; 2</code> cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”.<br><br><strong>Follow-up Example:</strong><br><br><pre><strong>Input:</strong> v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]<br><strong>Output:</strong> [1,4,8,2,5,9,3,6,7]<br></pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两数组轮替取值的Iterator</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>将数组和数组下标分别存于新数组中。用一个list_index来记录要取哪个数组</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Iterator模板，hasNext也是找到下一个元素为止，由于只有两个数组，所以不用循环。取值是一个<strong>二维数组</strong>val = self.input[self.list_index][self.index[self.list_index]]</li>
<li>next中取值后指针要后移。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZigzagIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v1: List[int], v2: List[int])</span>:</span></span><br><span class="line">        self.input = [v1, v2]</span><br><span class="line">        self.index = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        self.list_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            val = self.input[self.list_index][self.index[self.list_index]]</span><br><span class="line">            self.index[self.list_index] += <span class="number">1</span></span><br><span class="line">            self.list_index = (self.list_index + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.index[self.list_index] &lt; len(self.input[self.list_index]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        self.list_index = (self.list_index + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.index[self.list_index] &lt; len(self.input[self.list_index])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 284 Peeking Iterator</title>
    <url>/2022/01/03/lee-284/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/peeking-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.<br><br>Implement the <code>PeekingIterator</code> class:<br><br><em>   <code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.
</em>   <code>int next()</code> Returns the next element in the array and moves the pointer to the next element.<br><em>   <code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.
</em>   <code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.<br><br><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“PeekingIterator”, “next”, “peek”, “next”, “next”, “hasNext”]<br>[[[1, 2, 3]], [], [], [], [], []]<br><strong>Output</strong><br>[null, 1, 2, 2, 3, false]<br><br><strong>Explanation</strong><br>PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]<br>peekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].<br>peekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].<br>peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]<br>peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]<br>peekingIterator.hasNext(); // return False<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code>
</em>   <code>1 &lt;= nums[i] &lt;= 1000</code><br><em>   All the calls to <code>next</code> and <code>peek</code> are valid.
</em>   At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.<br><br><strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现数组的peeking Iterator。数组的Iterator是给定的。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>预读一个数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>预读一个next数</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterator)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.iterator = iterator</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.num</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 289 Game of Life</title>
    <url>/2021/12/24/lee-289/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>According to <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”<br><br>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <strong>live</strong> (represented by a <code>1</code>) or <strong>dead</strong> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank" rel="noopener">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):<br><br>1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.<br>2.  Any live cell with two or three live neighbors lives on to the next generation.<br>3.  Any live cell with more than three live neighbors dies, as if by over-population.<br>4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br><br><span>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</span><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]<br><strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[1,1],[1,0]]<br><strong>Output:</strong> [[1,1],[1,1]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == board.length</code>
</em>   <code>n == board[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 25</code>
</em>   <code>board[i][j]</code> is <code>0</code> or <code>1</code>.<br><br><strong>Follow up:</strong><br><br><em>   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.
</em>   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据临近8个细胞的情况来决定生死。若该细胞是live和临近有2-3个是live，仍然live。若该细胞是dead和临近有3个是live，复生。其他都变成dead</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>board[:] = res赋值到原数组一定要用冒号     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                live_neighbor_num = self.get_live_neighbor_num(board, i, j)</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> live_neighbor_num == <span class="number">3</span>:</span><br><span class="line">                    res[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> live_neighbor_num <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">                    res[i][j] = <span class="number">1</span></span><br><span class="line">        board[:] = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_live_neighbor_num</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            x, y = i + _dx, j + _dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[x][y] == <span class="number">1</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(8n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
<hr>
<h3 id="算法II解题思路O-1-Space："><a href="#算法II解题思路O-1-Space：" class="headerlink" title="算法II解题思路O(1) Space："></a><strong>算法II解题思路O(1) Space：</strong></h3><p>用一个数字来记录前后状态，2表示从0到1,3表示从1到0</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不同之处有两个： Line 11不再是board[i][j]为1的情况，而是从1变成0的情况： live_neighbor_num <strong>not</strong> in [2, 3]     </li>
<li>最后扫一遍矩阵，将2和3变回1和0  </li>
<li>board[i][j] == 0和board[i][j] == 1不用改，因为从左到有从上到下扫描，到该格时，该格的值并未变，只能是0或1，它的左和上3邻居才变了。  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife2</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># STATUS = &#123;2: (0, 1), 3: (1, 0)&#125;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                live_neighbor_num = self.get_live_neighbor_num2(board, i, j)</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> live_neighbor_num == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> live_neighbor_num <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">                    board[i][j] = <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">2</span>:</span><br><span class="line">                    board[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_live_neighbor_num2</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            x, y = i + _dx, j + _dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[x][y] <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(8n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code></p>
<hr>
<h3 id="算法III解题思路"><a href="#算法III解题思路" class="headerlink" title="算法III解题思路"></a><strong>算法III解题思路</strong></h3><p>另外一条follow up是如果matrix无界，可以假设大部分是死细胞，先收集live细胞的list，然后计算live细胞的临近细胞即可</p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 295 Find Median from Data Stream</title>
    <url>/2021/12/06/lee-295/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.<br><br><em>   For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.
</em>   For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.<br><br>Implement the MedianFinder class:<br><br><em>   <code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.
</em>   <code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.<br><em>   <code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> of the actual answer will be accepted.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br><strong>Output</strong><br>[null, null, null, 1.5, null, 2.0]<br><br><strong>Explanation</strong><br>MedianFinder medianFinder = new MedianFinder();<br>medianFinder.addNum(1);    // arr = [1]<br>medianFinder.addNum(2);    // arr = [1, 2]<br>medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)<br>medianFinder.addNum(3);    // arr[1, 2, 3]<br>medianFinder.findMedian(); // return 2.0<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= num &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   There will be at least one element in the data structure before calling <code>findMedian</code>.
</em>   At most <code>5 * 10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.<br><br><strong>Follow up:</strong><br><br><em>   If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?
</em>   If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求动态中位数</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>用max_heap, min_heap, 保证min_heap个数永远等于max_heap或多一个。插入元素先进max_heap, 再heappop将堆顶元素加入min_heap, 若此时比max_heap多2个，就再heappop加入到max_heap. </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>中位数有1-2个  </li>
<li>Python中的max_heap用负数实现，<strong>入堆出堆都要取反</strong>        </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        heapq.heappush(self.max_heap, -num)</span><br><span class="line">        max_value = -heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, max_value)</span><br><span class="line">        <span class="keyword">if</span> len(self.min_heap) - len(self.max_heap) &gt;= <span class="number">2</span>:</span><br><span class="line">            min_value = heapq.heappop(self.min_heap)</span><br><span class="line">            heapq.heappush(self.max_heap, -min_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">            <span class="keyword">return</span> (-self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.min_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 297 Serialize and Deserialize Binary Tree</title>
    <url>/2020/04/20/lee-297/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">LeetCode 297 Serialize and Deserialize Binary Tree</a></strong></p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p><strong>Example: </strong></p>
<pre>You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as `"[1,2,3,null,null,4,5]"`
</pre>

<p><strong>Clarification:</strong> The above format is the same as <a href="/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note: </strong>Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>序列化和反序列化二叉树。</p>
<h2 id="Python解法"><a href="#Python解法" class="headerlink" title="Python解法"></a><strong>Python解法</strong></h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>BFS解码，空节点也要入列，因为要转成#，且不让代码往下执行</li>
<li>难点是用#补充空节点，令每个非空节点必有左右儿子，这样解码就可以固定地每轮扫描两个。出列一个父节点，<strong>p扫描两个儿子且生成节点</strong>，若为#即空节点不入列，这和编码不同。主要因为编码的长度比节点数多，所以生成节点时，不需要再处理空节点。<br>Line 25 - 32有重复，这里放在一起方便理解，也可以封装成函数  </li>
<li><strong>类型转换int和str, Python用popleft不是pop</strong>  </li>
<li>Line 11非空节点值要记得加入  </li>
<li>空节点或空字符单独处理</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">	queue = collections.deque([root])</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node:</span><br><span class="line">			res.append(str(node.val))</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(<span class="string">'#'</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		queue.append(node.left)</span><br><span class="line">		queue.append(node.right)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">','</span>.join(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	vals = data.split(<span class="string">','</span>)</span><br><span class="line">	p = <span class="number">0</span></span><br><span class="line">	root = TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">	queue = collections.deque([root])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line"></span><br><span class="line">		p += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> vals[p] != <span class="string">'#'</span>:</span><br><span class="line">			node.left = TreeNode(int(vals[p]))</span><br><span class="line">			queue.append(node.left)</span><br><span class="line">		p += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> vals[p] != <span class="string">'#'</span>:</span><br><span class="line">			node.right = TreeNode(int(vals[p]))</span><br><span class="line">			queue.append(node.right)</span><br><span class="line">	<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Java解法"><a href="#Java解法" class="headerlink" title="Java解法"></a><strong>Java解法</strong></h2><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS可以涉及三重循环</p>
<ol>
<li>q不为空  </li>
<li>是否按层遍历  </li>
<li>是否为图  </li>
</ol>
<p>这题不需要按层遍历，所以不用第二重。而且只是二叉树，不用第三重循环。</p>
<p>编码方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	      1</span><br><span class="line">	    /   \</span><br><span class="line">	   #     3</span><br><span class="line">	        /  \</span><br><span class="line">	       2   #</span><br><span class="line">	      / \</span><br><span class="line">	     #   #</span><br><span class="line">=&gt; 1,#,3,2,#,#,#</span><br></pre></td></tr></table></figure></p>
<h3 id="BFS解题步骤："><a href="#BFS解题步骤：" class="headerlink" title="BFS解题步骤："></a><strong>BFS解题步骤：</strong></h3><p>serialize:  </p>
<ol>
<li>建queue，然后首节点入列</li>
<li>进入q的非空循环，队首出列，分别加入左右子树。由于空子树也会被遍历，所以左右子树可能为空，队首为空时continue<br>且val加入到结果字符串</li>
<li>用#代替null且删去末尾的#和，  </li>
</ol>
<p>deserialize:<br>这方法难实现点。用两个指针来代表遍历上一层和该层节点们。q出列的节点是上一层节点head，而idx指向的是<br>该层节点。这样head.left = Node(tokens[idx])就建立了它们的关系。两指针分别向后一位。每轮循环父指针<br>向后一位，而idx向后两位，因为有左右儿子。</p>
<ol>
<li>建queue，然后首节点入列</li>
<li>进入q的非空循环，队首出列，分别生成非空左右子树，且建立父子关系。idx走两步，非空儿子加入q。  </li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>#也要入栈，因为结果需要  </li>
<li>解码需要一个字符串扫描指针（类全局指针），左右儿子无条件扫两位。这点DFS也是一样的。  </li>
<li>deserialize中循环条件要加入idx &lt; tokens.length因为serialize末尾#已经删除。  </li>
<li>字符串相等判断用equals，不用==。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	q.add(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty()) &#123;		</span><br><span class="line">		TreeNode n = q.poll();</span><br><span class="line">		sb.append(n == <span class="keyword">null</span> ? <span class="string">"null"</span> : n.val);</span><br><span class="line">		sb.append(<span class="string">","</span>);</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		q.add(n.left);</span><br><span class="line">		q.add(n.right);</span><br><span class="line">	&#125;</span><br><span class="line">	String res = sb.toString().replaceAll(<span class="string">"null"</span>, <span class="string">"#"</span>);</span><br><span class="line">	<span class="keyword">int</span> endIdx = res.length() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(res.charAt(endIdx) == <span class="string">','</span> || res.charAt(endIdx) == <span class="string">'#'</span>)</span><br><span class="line">		endIdx--;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"&#123;"</span> + res.substring(<span class="number">0</span>, endIdx + <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize2</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">	String str = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	String[] tokens = str.split(<span class="string">","</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">	Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[<span class="number">0</span>]));</span><br><span class="line">	q.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty() &amp;&amp; idx &lt; tokens.length) &#123;</span><br><span class="line">		TreeNode head = q.poll();</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		head.left = generateChildNode(idx++, tokens, q);</span><br><span class="line">		head.right = generateChildNode(idx++, tokens, q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">generateChildNode</span><span class="params">(<span class="keyword">int</span> idx, String[] tokens, Queue&lt;TreeNode&gt; q)</span> </span>&#123;</span><br><span class="line">	TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(idx &lt; tokens.length &amp;&amp; !<span class="string">"#"</span>.equals(tokens[idx])) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[idx]));</span><br><span class="line">		q.offer(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DFS算法II解题思路："><a href="#DFS算法II解题思路：" class="headerlink" title="DFS算法II解题思路："></a><strong>DFS算法II解题思路：</strong></h3><p>DFS的serialize很简单，但deserialize比较难。有点类似于前序遍历的递归版。因为编码时候就是前序遍历，解码时候也是先root再左右。<br>需要维护一个指针p来记录已处理的字符串。  </p>
<p>编码方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">  2   3</span><br><span class="line">5  6</span><br><span class="line">=&gt; 1,2,5,#,#,6,#,#,3,#,#</span><br></pre></td></tr></table></figure></p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">	String rootStr = root.val+<span class="string">""</span>;</span><br><span class="line">	String lStr = serialize(root.left);</span><br><span class="line">	String rStr = serialize(root.right);</span><br><span class="line">	<span class="keyword">return</span> rootStr+<span class="string">","</span>+lStr+<span class="string">","</span>+rStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">String[] items = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">	p = <span class="number">0</span>;</span><br><span class="line">	items = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">return</span> deserializeR(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeR</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(data==<span class="keyword">null</span>||data.length()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&gt;=data.length())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	String curVal = getNext(data);</span><br><span class="line">	<span class="keyword">if</span>(curVal.equals(<span class="string">"#"</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	TreeNode newRoot = <span class="keyword">new</span> TreeNode(Integer.parseInt(curVal));</span><br><span class="line">	newRoot.left = deserializeR(data);</span><br><span class="line">	newRoot.right = deserializeR(data);</span><br><span class="line">	<span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNext</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(items==<span class="keyword">null</span>)</span><br><span class="line">		items = s.split(<span class="string">","</span>);</span><br><span class="line">	<span class="keyword">return</span> items[p++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 291 Word Pattern II</title>
    <url>/2021/12/04/lee-291/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-pattern-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>pattern</code> and a string <code>s</code>, return <code>true</code> <em>if</em> <code>s</code> <em><strong>matches</strong> the</em> <code>pattern</code><em>.</em><br><br>A string <code>s</code> <strong>matches</strong> a <code>pattern</code> if there is some <strong>bijective mapping</strong> of single characters to strings such that if each character in <code>pattern</code> is replaced by the string it maps to, then the resulting string is <code>s</code>. A <strong>bijective mapping</strong> means that no two characters map to the same string, and no character maps to two different strings.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> pattern = “abab”, s = “redblueredblue”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible mapping is as follows:<br>‘a’ -&gt; “red”<br>‘b’ -&gt; “blue”</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> pattern = “aaaa”, s = “asdasdasdasd”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible mapping is as follows:<br>‘a’ -&gt; “asd”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> pattern = “abab”, s = “asdasdasdasd”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible mapping is as follows:<br>‘a’ -&gt; “a”<br>‘b’ -&gt; “sdasd”<br>Note that ‘a’ and ‘b’ cannot both map to “asd” since the mapping is a bijection.<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> pattern = “aabb”, s = “xyzabcxzyabc”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= pattern.length, s.length &lt;= 20</code>
</em>   <code>pattern</code> and <code>s</code> consist of only lower-case English letters.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于word break，但由于要存储处理过map和set，DP不能处理，所以只能用DFS    </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较映射，用Map比较A-&gt;B的映射，如已有a-&gt;dog, 另一对映射a-&gt;cat通过查找Map知道不合法。B-&gt;A的映射可通过将map的所有value存到一个set中知道。如a-&gt;dog, b-&gt;dog. b不在Map中但b对应的dog在set中，不合法。<br>DFS的API为dfs(pattern, word, pattern_to_word, used_set)  </li>
<li>若pattern的字母出现过，如aba，不应进入循环，更不应该加入到map和set中，应该用startswith比较word判断是否合法，若是，直接下一轮DFS(Line 11 -15)     </li>
<li>1中的两情况的第一种情况以及第二种情况的前半部分(b不在map中)在2中已经处理，所以只要在循环中处理第二种情况后半部分(b对应的dog在set中)即可(Line 22 - 23)</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordPatternMatch</span><span class="params">(self, pattern: str, s: str)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> pattern <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(pattern, s, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, pattern, s, start_p, start_s, pattern_to_s, s_set)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">and</span> start_s &gt;= len(s):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">or</span> start_s &gt;= len(s):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	char = pattern[start_p]</span><br><span class="line">	<span class="keyword">if</span> char <span class="keyword">in</span> pattern_to_s:</span><br><span class="line">		word = pattern_to_s[char]</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> s[start_s:].startswith(word):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">return</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, start_s + len(word), pattern_to_s, s_set)</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(start_s, len(s)):</span><br><span class="line">		matched_word = s[start_s:j + <span class="number">1</span>]</span><br><span class="line">		<span class="string">'''if char in pattern_to_s and pattern_to_s[char] != matched_word:</span></span><br><span class="line"><span class="string">			continue</span></span><br><span class="line"><span class="string">		if char not in pattern_to_s and matched_word in s_set:  # remembers</span></span><br><span class="line"><span class="string">			continue'''</span></span><br><span class="line">		<span class="keyword">if</span> matched_word <span class="keyword">in</span> s_set:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		pattern_to_s[char] = matched_word</span><br><span class="line">		s_set.add(matched_word)</span><br><span class="line">		<span class="keyword">if</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, j + <span class="number">1</span>, pattern_to_s, s_set):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		s_set.remove(matched_word)</span><br><span class="line">		pattern_to_s.pop(char)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度为<code>O(解大小)</code>。   </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300 Longest Increasing Subsequence</title>
    <url>/2021/12/01/lee-300/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, return the length of the longest strictly increasing subsequence.<br><br>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,2,3]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [7,7,7,7,7,7,7]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 2500</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br><strong>Follow up:</strong> Can you come up with an algorithm that runs in <code>O(n log(n))</code> time complexity?<br><br></div>

<h3 id="DP算法思路："><a href="#DP算法思路：" class="headerlink" title="DP算法思路："></a><strong>DP算法思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始化从1开始，因为一个数是递增序列  </li>
<li>返回值不是dp[-1]，而是所有dp的最大值    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">dp[i] = max(dp[j]) + <span class="number">1</span>, <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; nums[j<span class="number">-1</span>], <span class="number">1</span> &lt;= j &lt; i</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = <span class="number">1</span></span><br><span class="line">	<span class="comment"># dp = [0, 1, 0]</span></span><br><span class="line">	dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="comment"># i = 2</span></span><br><span class="line">		<span class="comment"># j = 1</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">			<span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">		res = max(res, dp[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>.</p>
<hr>
<h3 id="打印路径算法思路："><a href="#打印路径算法思路：" class="headerlink" title="打印路径算法思路："></a><strong>打印路径算法思路：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>path数组大小和原数组一样，因为path数组的下标和值都是下标，这样不用-1，直接nums[pos]，不容易错  </li>
<li>多了Line 11 - 12和14 - 15，需要记录产生最大值的下标  </li>
<li>打印的时候path数组的下标和值都是下标，而值是前一个下标，所以是pos = positions[pos]，循环次数为dp值，开始下标为dp值对应的下标path[:biggest_pos + 1]。   </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS_with_path</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res, path = <span class="number">1</span>, [<span class="number">0</span>] * len(nums)  <span class="comment"># remember no + 1</span></span><br><span class="line">	biggest_pos = <span class="number">-1</span></span><br><span class="line">	dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">			<span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span> dp[i] == dp[j] + <span class="number">1</span>:</span><br><span class="line">					path[i - <span class="number">1</span>] = j - <span class="number">1</span></span><br><span class="line">		res = max(res, dp[i])</span><br><span class="line">		<span class="keyword">if</span> res == dp[i]:</span><br><span class="line">			biggest_pos = i - <span class="number">1</span></span><br><span class="line">	path_list = self.print_path(nums, path[:biggest_pos + <span class="number">1</span>], res)</span><br><span class="line">	<span class="keyword">return</span> path_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(self, nums, path, dp_value)</span>:</span></span><br><span class="line">	pos, res = len(path) - <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(dp_value):</span><br><span class="line">		res.append(nums[pos])</span><br><span class="line">		pos = path[pos]</span><br><span class="line">	<span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="bisect算法II解题思路："><a href="#bisect算法II解题思路：" class="headerlink" title="bisect算法II解题思路："></a><strong>bisect算法II解题思路：</strong></h3><p>N/A  </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>bisect_left类似于greater_or_equal_position但若equal时，取第一个，但greater_or_equal_position是取最后一个，此题没关系，因为相等的数会被替换掉，递增序列中不会存在相等的数    </li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		pos = bisect.bisect_left(res, nums[i])</span><br><span class="line">		<span class="keyword">if</span> pos &lt; len(res):</span><br><span class="line">			res[pos] = nums[i]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(nums[i])</span><br><span class="line">	<span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 301 Remove Invalid Parentheses</title>
    <url>/2021/12/06/lee-301/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.<br><br>Return <em>all the possible results</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “()())()”<br><strong>Output:</strong> [“(())()”,”()()()”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “(a)())()”<br><strong>Output:</strong> [“(a())()”,”(a)()()”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “)(“<br><strong>Output:</strong> [“”]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 25</code>
</em>   <code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.<br>*   There will be at most <code>20</code> parentheses in <code>s</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最小去掉不合法括号数之后的所有结果</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最值问题考虑用DP和BFS，DP难以拆分子问题。所以考虑用BFS + 括号是否合法  </p>
<p>LeetCode 1249 Minimum Remove to Make Valid Parentheses 求一个最优解 Medium, Stack<br>LeetCode 921 Minimum Add to Make Parentheses Valid 求一个最优解 Medium, Stack<br>LeetCode 301 Remove Invalid Parentheses 求所有最优解 Hard，此题 答案包含上题, BFS</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于()())() -&gt; (())()，所以去掉的括号不一定都不合法，所以<strong>BFS要尝试删除每一个括号</strong>。若节点合法，加入结果且记录最小删除数，因为要求同一距离下的所有结果，所以<strong>用这个最小数来剪枝</strong>。</li>
<li>输入含小写字母，所以<strong>无论是判断括号是否合法还是生成儿子节点都要跳过</strong></li>
<li>模板中含if neighbor in visited，不能忘记写</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">	queue = collections.deque([s])</span><br><span class="line">	visited = set([s])</span><br><span class="line">	res, min_dis = [], float(<span class="string">'inf'</span>)</span><br><span class="line">	distance = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> self.is_valid(node):</span><br><span class="line">			res.append(node)</span><br><span class="line">			min_dis = min(min_dis, distance[node])</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> distance[node] &gt; min_dis:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)):</span><br><span class="line">			<span class="keyword">if</span> node[i] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			child = node[:i] + node[i + <span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> child <span class="keyword">in</span> visited: <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(child)</span><br><span class="line">			visited.add(child)</span><br><span class="line">			distance[child] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, s)</span>:</span> <span class="comment"># remember not to use get_invalid_index ()())() -&gt; (())()</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span> <span class="keyword">and</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span>:</span><br><span class="line">			stack.pop()</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</title>
    <url>/2017/12/11/lee-309/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a></strong></p>
<p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<p><strong>Example:</strong>  </p>
<pre>
prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，第i个元素代表某只股票在第i天的价格。 设计一个算法计算最大收益。你可以完成多次交易（多次买入、卖出同一只股票），需要满足下列限制：<br>你不可以在同一时间参与多个交易（在买入股票之前必须卖出）。<br>在卖出股票之后，你不可以在第二天马上买入。（需要一天的冷却（CD）时间）。<strong>也就是卖出后过两天才能买入。</strong></p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为有限制条件，所以没有特别方法，只能计算所有结果，也就是用动态规划。动态规划首先是写出递归式（数学归纳法）。</p>
<ol>
<li>定义f(n)为第n日卖出股票（一定要卖出，不能持有）的利润，加强了命题。</li>
<li>递归式如下图，f(n)只能由f(n-1)卖出后立刻买入（相当于n-1时候不卖出）或者f(n-3)卖出n-1时候买入两种情况。<br><img src="/images/L309.png" alt=""><br>现在可以写出递归式：<br><img src="/images/L309-2.png" alt=""><br>F(x)=max{f(1),…,f(n)}求加强命题最大值即为本题解。<br>这里考虑到负数，方便程序实现，否则，f(n)的前3个值计算就不能放入循环而要特别处理了。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组为空或者1个</li>
<li>负数组的实现方法</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		sell[i] = Math.max(f(i-<span class="number">3</span>, sell), f(i-<span class="number">1</span>, sell))+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(sell[i]&gt;max)</span><br><span class="line">			max = sell[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> r[i];</span><br></pre></td></tr></table></figure>
<p>这个实现有个错误就是忽略了一种重要的情况：f(n-4),…,f(1)的情况。看以下例子：[6,1,6,4,3,0,2]</p>
<table>
<thead>
<tr>
<th>Index</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
</tr>
</thead>
<tbody>
<tr>
<td>price</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>f(n)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>按照上面算法结果为5，但是很容易看出来1-&gt;6, 0-&gt;2结果是7。问题出在最后一个f(6)=max{f(3),f(5)}+2=max{3,2}+2。很明显，第3天卖出获利为3并不是最佳，第二天卖出获利为5才是最佳，我们忽略了f(n-3)之前的所有情况。解决方案是再创建一个数组维护前n天最大获利值。<br>定义g(n)为第n日（包括第n日）前卖出股票（不一定要第n天卖出）的利润。修改递归式为，把f(n-3)改为g(n-3)：<br><img src="/images/L309-3.png" alt=""></p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">	<span class="keyword">int</span> preSell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		sell[i] = Math.max(g(i-<span class="number">3</span>, preSell), f(i-<span class="number">1</span>, sell))+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(sell[i]&gt;max)</span><br><span class="line">			max = sell[i];</span><br><span class="line">		</span><br><span class="line">		preSell[i] = Math.max(preSell[i-<span class="number">1</span>], sell[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> r[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] g)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> g[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为数组长度，空间复杂度<code>O(n)</code>。</p>
<p>current, first分别通过f和g的计算公式计算，second是通过current获得</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># g(n) = max&#123;f(n), g(n-1)&#125;</span></span><br><span class="line"><span class="comment"># f(n) = A[n] - A[n - 1] + max&#123;f(n - 1), g(n-3)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="comment"># g(n-3), f(n-2), f(n-1)</span></span><br><span class="line">	first, second, current = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">		current, second, first = prices[i] - prices[i - <span class="number">1</span>] + max(current, first), current, max(second, first)</span><br><span class="line">	<span class="keyword">return</span> max(current, second, first)</span><br></pre></td></tr></table></figure>
<h3 id="空间优化："><a href="#空间优化：" class="headerlink" title="空间优化："></a><strong>空间优化：</strong></h3><p>由于此题目，f(n)只与前三个状态有关f(n-1), f(n-2)(虽然没直接关系，但程序实现需要记录),g(n-3)。四个状态可以用三个变量<br>推进，如sell=Math.max(preSell, sell)，同一个变量旧状态更新到新状态，所以可以避免维护数组开销。<br>代入preSell=g(n-3), sell_1=f(n-2), sell=f(n-1)到公式即得<br>f(n) = sell = max{preSell, sell}+prices[n]-prices[i-1]<br>g(n-2) = preSell = max{g(n-3), f(n-2)} = max{preSell, sell_1}<br>f(n-1) = sell_1 = PreValue(sell)<br>本题解就是preSell, sell_1, sell的最大值。</p>
<h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">	<span class="comment">//g(n-3), f(n-2), f(n-1)</span></span><br><span class="line">	<span class="keyword">int</span> preSell=<span class="number">0</span>, sell_1=<span class="number">0</span>, sell = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = sell;</span><br><span class="line">		sell = Math.max(preSell, sell)+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">		preSell = Math.max(preSell, sell_1);</span><br><span class="line">		sell_1 = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(Math.max(preSell, sell_1), sell);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为数组长度，空间复杂度<code>O(1)</code>。本题有更简单解法但比较难想出。</p>
<h3 id="最后注意事项："><a href="#最后注意事项：" class="headerlink" title="最后注意事项："></a><strong>最后注意事项：</strong></h3><ol>
<li>数组为空或者1个</li>
<li>三种情况f(n-1),f(n-3),g(n-3)可以得到f(n)。解就是preSell, sell_1, sell的最大值。</li>
<li>DP流程，定义函数（是否加强）、递归式、空间优化。</li>
</ol>
<h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 310 Minimum Height Trees</title>
    <url>/2017/12/04/lee-310/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-height-trees" target="_blank" rel="noopener">LeetCode 310 Minimum Height Trees</a></strong></p>
<p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>
<p><strong>Example 1:</strong></p>
<p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p>
<pre>        0
        |
        1
       / \
      2   3
</pre>

<p>return <code>[1]</code></p>
<p><strong>Example 2:</strong></p>
<p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p>
<pre>     0  1  2
      \ | /
        3
        |
        4
        |
        5
</pre>

<p>return <code>[3, 4]</code></p>
<p><strong>Note</strong>:</p>
<p>(1) According to the <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory" target="_blank" rel="noopener">definition of tree on Wikipedia</a>): “a tree is an undirected graph in which any two vertices are connected by <em>exactly</em> one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>对于一棵无向树，我们可以选择它的任意节点作为根。得到的结果就是有根树。在所有可能的有根树中，高度最小的称为最小高度树（MHT）。<br>给定一个无向图，编写函数找出所有的最小高度树，并返回其根标号的列表。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题本质上求最长路径上的中间1-2个节点。由于根节点不确定，从叶节点出发，层层剥离，这就是拓扑排序(inDegree数组)。而且需要知道最后一层的1-2个节点，所以考虑用按层遍历BFS（两数组）。见KB。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于最后一层可能是1-2个节点，所以要用一个变量res把最后一层记录下来, res = list(queue)在开始和循环中。</li>
<li>还有一点要注意的是这是无向图，所以入度=1而不是0时候即入队列。</li>
<li>单一节点(没有边)返回空列表</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> edges:</span><br><span class="line">		<span class="keyword">return</span> [<span class="number">0</span>] <span class="comment"># remember</span></span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	in_degree = [<span class="number">0</span>] * n</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> edges:</span><br><span class="line">		graph[li[<span class="number">0</span>]].append(li[<span class="number">1</span>])</span><br><span class="line">		graph[li[<span class="number">1</span>]].append(li[<span class="number">0</span>])</span><br><span class="line">		in_degree[li[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">		in_degree[li[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">	queue = collections.deque([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(in_degree)) <span class="keyword">if</span> in_degree[i] == <span class="number">1</span>])</span><br><span class="line">	res = list(queue) <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">				in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> in_degree[neighbor] == <span class="number">1</span>:</span><br><span class="line">					queue.append(neighbor)</span><br><span class="line">		<span class="keyword">if</span> queue: <span class="comment"># remember</span></span><br><span class="line">			res = list(queue)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于最后一层可能是1-2个节点，所以要用一个变量把最后一层记录下来。</li>
<li>还有一点要注意的是这是无向图，所以入度=1而不是0时候即入队列。</li>
</ol>
<p>Topological:</p>
<ol>
<li>根据边统计每个节点的入度数记入in[i]</li>
<li>找出度数为0的节点加入到Queue</li>
<li>取出队首节点，把此节点邻接的节点度数减1，如果度数为0，加入到队列，循环直到队列为空</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; edges.length==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> num = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	<span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="comment">//populate inDegree &amp; convert to graph</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">		inDegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">		inDegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">		graph.get(edges[i][<span class="number">1</span>]).add(edges[i][<span class="number">0</span>]);</span><br><span class="line">		graph.get(edges[i][<span class="number">0</span>]).add(edges[i][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">1</span>)</span><br><span class="line">			q.offer(i);</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Integer&gt; lastLayerQ = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(q);</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		Integer v = q.poll();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line">			<span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">1</span>)</span><br><span class="line">				q2.offer(neighbor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(q.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">			q = q2;</span><br><span class="line">			q2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">			lastLayerQ = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(q);</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (List)lastLayerQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Breadth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 312 Burst Balloons</title>
    <url>/2017/12/28/lee-312/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="noopener">LeetCode 312 Burst Balloons</a></strong></p>
<p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p>
<p><strong>Example:</strong></p>
<p>Given <code>[3, 1, 5, 8]</code></p>
<p>Return <code>167</code></p>
<pre>    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n个气球，下标为0到n-1。每个气球上都标有一个数字，用数组nums表示。你被要求扎破所有气球。扎破第i个气球可以获得nums[left] &times; nums[i] &times; nums[right]枚硬币。这里left和right是与i相邻的下标。扎破气球以后，left和right就变成相邻的了。<br>寻找最优策略下可以获得的硬币数。</p>
<p>注意：<br>(1) 你可以假设nums[-1] = nums[n] = 1. 它们并非真实的因此不能扎破。<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol>
<li>此题遍历所有可能性，所以考虑用DP  </li>
<li>因为一个参数不足以描述问题，因为并不能固定nums左端或右端，所以考虑二元DP，左右边界为参数。DP流程一：定义函数f(i,j)为nums[i..j]之间的最大硬币数。  </li>
<li>下一步写递归式，由于这是二元DP，参考Floyd和矩阵链乘法算法，一遍要定义一个k，二分法得到两个子问题的解f(i,k)和f(k,j)，求解它们的关系是难点。先写几个例子培养下思路：<br> 2,3,4<br> f([2,4])=2&times;3&times;4同时消去了3变成[2,4],再写一个<br> 2,3,4,5,6,7,8<br> k=5, 数组变成[2,5,8]所以我们定义中忽略了一个重要事实，修改为f(i,j)为nums[i..j]之间的最大硬币数<strong>及其它们之间的元素已经消去。</strong><br> 这样的话，关系就很明朗了，只要消去5就可以得到f([2,8])，k的定义要可以清晰了：最后一个消去的元素。<br> <strong>f(i,j)=max{f(i,m)+ nums[i]&times;nums[m]&times;nums[j] +f(m,j)}, i&lt;m&lt;j，m为整数</strong>  </li>
<li>我们还要试试nums为单元素和双元素情况下是否适用。比如单元素5，根据题目意思首先前后补1<br>1,5,1 -&gt; f(1,5)+1&times;5&times;1+f(5,1)=5这是正确的因为f(x,y)默认为0.<br>1,5,3,1, k=5, f(1,5)+1&times;5&times;1+f(5,1)=0+5+(5&times;3&times;1)=20 | k=3, f(1,3)+1&times;3&times;1+f(3,1)=(1&times;5&times;3)+3+0=18.所以也是正确，且f(x,y)默认为0没问题。  </li>
<li><p>遍历顺序。一开始我用i,j,m三重循环，但结果不对。主要因为这个计算过程与演算过程不一致，我们刚才的演算过程是先计算所有i和j之间的值。例如，<br>1,                      5,                               3,          1<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   j<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j<br>&nbsp;&nbsp;&nbsp;&nbsp;i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j  </p>
<p>在第二次循环的时候f(i,j)已经计算出来很显然是不对的。</p>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>二元DP([i,j],k的递归式)+二分法。 二元DP中k的引入参考Floyd按步长计算。nums[i] * nums[m] * nums[j]而不是nums[m-1] * nums[m] * nums[m+1]  </li>
<li>原数组前后补1，这样巧妙地让递归式适用于一个元素的情况，避免特别处理。因此步长可以k=2开始，i&lt;m&lt;j不取等号。dp数组以新数组为边界    </li>
<li>遍历顺序也类似于Floyd，先k(步长且至少为2)，再遍历矩阵i和j。<strong>特别注意i&lt;n-k</strong>而不是i&lt;n  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	ary = list(nums)</span><br><span class="line">	ary.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	ary.append(<span class="number">1</span>)</span><br><span class="line">	N = len(ary)</span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, N):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N - k):</span><br><span class="line">			j = i + k</span><br><span class="line">			<span class="keyword">for</span> m <span class="keyword">in</span> range(i + <span class="number">1</span>, j):</span><br><span class="line">				dp[i][j] = max(dp[i][j], dp[i][m] + ary[i] * ary[m] * ary[j] + dp[m][j])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">		coins[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">	coins[<span class="number">0</span>] = coins[n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;n;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n - k;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = i+k;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> m=i+<span class="number">1</span>;m&lt;j;m++)</span><br><span class="line">				dp[i][j] = Math.max(dp[i][j], dp[i][m]+coins[i]*coins[m]*coins[j] + dp[m][j]);</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>。</p>
]]></content>
      <tags>
        <tag>Divide and Conquer</tag>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 314 Binary Tree Vertical Order Traversal</title>
    <url>/2021/12/24/lee-314/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em><strong>the vertical order traversal</strong> of its nodes’ values</em>. (i.e., from top to bottom, column by column).<br><br>If two nodes are in the same row and column, the order should be from <strong>left to right</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7]<br><strong>Output:</strong> [[4],[9],[3,0,1],[8],[7]]<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7,null,null,null,2,5]<br><strong>Output:</strong> [[4],[9,5],[3,0,1],[8,2],[7]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 100]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序打印二叉树  </p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p><strong>从root开始从0编号，左右节点分别为-1, 1</strong>，如此类推，就可以标记所有节点，从而将这些节点加入结果集。  </p>
<p>LeetCode 314 Binary Tree Vertical Order Traversal 同一列，从上到下，从左到右排序<br>LeetCode 987 Vertical Order Traversal of a Binary Tree 同一列，从上到下，同一行值从小到大排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>BFS引入(vertical_id, root)来做计算。由于结果列表如vertical_id = -1, 1可以从左或右加入，用dict来记录vertical到list更好合理   </li>
<li>由于vertical_id是连续的，所以不妨用min_col, max_col来记录dict的范围，保证从dict到结果集是按顺序加入。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line">	min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		vertical_id, node = queue.popleft()</span><br><span class="line">		min_col, max_col = min(min_col, vertical_id), max(max_col, vertical_id)</span><br><span class="line">		idx_to_list[vertical_id].append(node.val)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">		res.append(idx_to_list[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="BFS算法II解题思路："><a href="#BFS算法II解题思路：" class="headerlink" title="BFS算法II解题思路："></a><strong>BFS算法II解题思路：</strong></h3><p>先写了这个，优化后才得到算法I。区别在于keys需要排序  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder1_1</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		vertical_id, node = queue.popleft()</span><br><span class="line">		idx_to_list[vertical_id].append(node.val)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line">	sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">		res.append(idx_to_list[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="DFS算法III解题思路-不推荐-："><a href="#DFS算法III解题思路-不推荐-：" class="headerlink" title="DFS算法III解题思路(不推荐)："></a><strong>DFS算法III解题思路(不推荐)：</strong></h3><p>最开始的思路，很容易错，因为不符合题目的按层遍历的顺序。题目要求同一column的节点是从上到下，从左到右。DFS与此违反。    </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>要将同一个column节点从上到下从左到右排序，就要记录height和左到右的顺序(height_id, len(idx_to_list[vertical_id]) - 1, root.val)</li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder2</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">	self.dfs(root, <span class="number">0</span>, <span class="number">0</span>, idx_to_list)</span><br><span class="line">	sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">		li = sorted(idx_to_list[i])</span><br><span class="line">		res.append([node[<span class="number">2</span>] <span class="keyword">for</span> node <span class="keyword">in</span> li])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, height_id, vertical_id, idx_to_list)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	idx_to_list[vertical_id].append((height_id, len(idx_to_list[vertical_id]) - <span class="number">1</span>, root.val))</span><br><span class="line">	self.dfs(root.left, height_id + <span class="number">1</span>, vertical_id - <span class="number">1</span>, idx_to_list)</span><br><span class="line">	self.dfs(root.right, height_id + <span class="number">1</span>, vertical_id + <span class="number">1</span>, idx_to_list)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Binary Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 316 Remove Duplicate Letters</title>
    <url>/2017/12/31/lee-316/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-duplicate-letters" target="_blank" rel="noopener">LeetCode 316 Remove Duplicate Letters</a></strong></p>
<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p><strong>Example:</strong>  </p>
<p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p>
<p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个只包含小写字母的字符串，从中移除重复字母使得每个字母只出现一次。你必须确保结果的字典序最小。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是保持原顺序输出结果，所以考虑用递减栈(<strong>递增栈，从栈底递增，求最小即用递增</strong>，如求k个最大用最小堆一样)。先看例子bcabc-&gt;abc，a入栈倒逼<br>bc出栈，可解此题。因为既然bc在栈外还有，就可以出栈，保证第一个字母最小（题目要求）。再看cbacdcbc，acd时候b入栈，不能倒逼cd出栈<br>因为d是唯一一个，所以还要维护一个hashMap来记录每个字母的词频。所以入栈条件为准入栈元素小于栈顶元素且栈顶元素为最后一个（频数&gt;0）。<br>hashMap作用有两个，第一个为统计词频，第二个为记录未入栈的字母的频数。<br>resultSet记录stack中所有唯一元素，用于判断是否需要入栈。这是难点，对于已在栈中的重复元素不需要再入栈，因为它在栈中的位置已经是目前<br>最小的位置，如果要出现更小的结果只能通过非栈内元素倒逼产生新结果。如acabc，第二个a不需要逼c出来，b可以做到这一点，a已在最小位置。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>已在栈内的<strong>重复元素</strong>不入栈，也不倒逼任何元素出栈，也就是直接忽略它，只要将其频数减一即可，表示已处理。比如abacb，第二个a不能倒逼b。<strong>用两个数据结构：set保证不重复加入到栈内，map保证外面还有元素可入栈</strong>  </li>
<li>进入循环后频数立刻减一，不要出列时候才做，参见BFS。  </li>
<li>出栈条件：栈不为空，准入栈元素小于栈顶元素，<strong>栈顶元素频数&gt;0</strong>（表示栈外还有元素可以入栈）。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	stack, stack_set = [], set()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		char_to_count[s[i]] -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> s[i] <span class="keyword">in</span> stack_set:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> s[i] &lt; stack[<span class="number">-1</span>] <span class="keyword">and</span> char_to_count[stack[<span class="number">-1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">			stack_set.remove(stack[<span class="number">-1</span>])</span><br><span class="line">			stack.pop()</span><br><span class="line">		stack.append(s[i])</span><br><span class="line">		stack_set.add(s[i])</span><br><span class="line">	<span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">	Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">	Set&lt;Character&gt; result = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">		Character c = s.charAt(i);</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(c))</span><br><span class="line">			map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			map.put(c, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">		Character c = s.charAt(i);</span><br><span class="line">		map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Stack已经有c就不加入</span></span><br><span class="line">		<span class="keyword">if</span>(result.contains(c))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; c&lt;stack.peek() &amp;&amp; map.get(stack.peek())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			result.remove(stack.peek());</span><br><span class="line">			stack.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		stack.push(c);</span><br><span class="line">		result.add(c);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">		sb.append(stack.pop());</span><br><span class="line">	<span class="keyword">return</span> sb.reverse().toString();  	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>所有元素入栈出栈最多一次，所以时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Greedy</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 322 Coin Change</title>
    <url>/2021/12/06/lee-322/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br><br>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.<br><br>You may assume that you have an infinite number of each kind of coin.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> coins = [1,2,5], amount = 11<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 11 = 5 + 5 + 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> coins = [2], amount = 3<br><strong>Output:</strong> -1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> coins = [1], amount = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> coins = [1], amount = 1<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong> coins = [1], amount = 2<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= coins.length &lt;= 12</code>
</em>   <code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br>*   <code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求兑换硬币的最小个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用数值-&gt;个数DP模板</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>amount为0时候，返回0，表示不用coin也能满足，属于合法情况, dp[0] = 0(第二步)  </li>
<li>返回值，若dp[-1]为初始值，表示无解，返回-1(第5步)  </li>
<li>实现中dp[i] = min(dp[i], dp[i - j] + 1), +1在min内而不是min外。  </li>
<li>此题内外循环顺序不重要，跟LeetCode 518 Coin Change 2有区别</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">	coins.sort()</span><br><span class="line">	dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">			<span class="keyword">if</span> i + coin &lt;= amount:</span><br><span class="line">				dp[i + coin] = min(dp[i + coin], dp[i] + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] &lt; float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*amount)</code>，空间复杂度<code>O(amount)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 332 Reconstruct Itinerary</title>
    <url>/2018/01/09/lee-332/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reconstruct-itinerary" target="_blank" rel="noopener">LeetCode 332 Reconstruct Itinerary</a></strong></p>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p>
<p><strong>Note:</strong>  </p>
<ol>
<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
<li>All airports are represented by three capital letters (IATA code).</li>
<li>You may assume all tickets form at least one valid itinerary.</li>
</ol>
<p><strong>Example 1:</strong><br><code>tickets</code> = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code>.  </p>
<p><strong>Example 2:</strong><br><code>tickets</code> = <code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>.<br>Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>. But it is larger in lexical order.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一组机票，用出发机场和到达机场[from, to]来表示，重建行程的顺序。所有的机票都属于一个从JFK（肯尼迪国际机场）出发的旅客。因此，行程必须从JFK开始。</p>
<p>注意：</p>
<p>如果存在多重有效的行程，你应当返回字典序最小的那个。例如，行程[“JFK”, “LGA”]的字典序比[“JFK”, “LGB”]要小。<br>所有的机场用3个大写字母表示（IATA编码）。<br>你可以假设所有的机票均至少包含一条有效的行程。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这条题实质是记录DFS路径的题目，且对儿子节点的选择是有顺序的。值得注意的是并不是所有路径都是可形成回路，所以需要DFS搜索。<br>既然是要记录路径就需要用数组保存结果，而有顺序则表示要排序。</p>
<ol>
<li>建图，用邻接表来表示HashMap<string, linkedlist<string="">&gt; graph</string,></li>
<li>对每个节点的邻节点LinkList进行排序</li>
<li>从JFK开始dfs。1)终止条件为所有ticket都遍历了(达成回路)或者不能够遍历完。2)路径存在数组中。 3)通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>通过删除节点表示已访问DFS该节点后图要恢复成原状态。用下标i来删除，这样才能保证删除再加入仍然有序。另一种方法是用visited边来记录避免修改图。本文用前者</li>
<li>剪枝： 如果找到结果就返回</li>
<li>这题只有一条path，不是所有可能性，但让需要用res，复制path到res，因为path会恢复状态。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary2</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> tickets:</span><br><span class="line">		graph[li[<span class="number">0</span>]].append(li[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> graph.values():</span><br><span class="line">		li.sort()</span><br><span class="line">	path, res = [<span class="string">'JFK'</span>], []</span><br><span class="line">	self.dfs2(graph, <span class="string">'JFK'</span>, len(tickets), path, res)</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, graph, start, ticket_left, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> ticket_left == <span class="number">0</span>:</span><br><span class="line">		res.append(list(path)) <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">for</span> i, neighbor <span class="keyword">in</span> enumerate(graph[start]):</span><br><span class="line">		path.append(neighbor)</span><br><span class="line">		graph[start].pop(i) <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> self.dfs2(graph, neighbor, ticket_left - <span class="number">1</span>, path, res):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		graph[start].insert(i, neighbor)</span><br><span class="line">		path.pop()</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>终止条件为所有ticket都遍历了(达成完整路)或者不能够遍历完Dfs API含ticketLeft。如{“JFK”,”KUL”},{“JFK”,”NRT”},{“NRT”,”JFK”}，虽然KUL在NRT前，但KUL不能组成回路。</li>
<li>DFS路径尽量存在数组中，否则用ArrayList中就要先add再remove。</li>
<li>通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">	HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;String&gt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tickets.length;i++)&#123;</span><br><span class="line">		LinkedList&lt;String&gt; neighbor = graph.get(tickets[i][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(neighbor==<span class="keyword">null</span>)</span><br><span class="line">			neighbor = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		neighbor.add(tickets[i][<span class="number">1</span>]);</span><br><span class="line">		graph.put(tickets[i][<span class="number">0</span>], neighbor);</span><br><span class="line">	&#125;</span><br><span class="line">	Iterator&lt;String&gt; it = graph.keySet().iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		String key = it.next();</span><br><span class="line">		LinkedList&lt;String&gt; neighbor = graph.get(key);</span><br><span class="line">		Collections.sort(neighbor);</span><br><span class="line">		graph.put(key, neighbor);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] re = <span class="keyword">new</span> String[tickets.length+<span class="number">1</span>];</span><br><span class="line">	String cur = <span class="string">"JFK"</span>;</span><br><span class="line">	re[<span class="number">0</span>] = cur;</span><br><span class="line">	isDFS(graph,cur,tickets.length,tickets.length,re);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(re));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDFS</span><span class="params">(HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph, String departCity</span></span></span><br><span class="line"><span class="function"><span class="params">		,<span class="keyword">int</span> ticketLeft, <span class="keyword">int</span> ticketNum, String[] re)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ticketLeft==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;    	</span><br><span class="line">	LinkedList&lt;String&gt; desCity = graph.get(departCity);</span><br><span class="line">	<span class="keyword">if</span>(desCity==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;desCity.size();i++)&#123;</span><br><span class="line">		String cur = desCity.get(i);</span><br><span class="line">		re[ticketNum-ticketLeft+<span class="number">1</span>] = cur;</span><br><span class="line">		desCity.remove(i);</span><br><span class="line">		graph.put(departCity, desCity);</span><br><span class="line">		<span class="keyword">if</span>(isDFS(graph,cur,ticketLeft-<span class="number">1</span>,ticketNum,re))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;;</span><br><span class="line">		desCity.add(i,cur);</span><br><span class="line">		graph.put(departCity, desCity);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。    </p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 339 Nested List Weight Sum</title>
    <url>/2022/01/04/lee-339/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.<br><br>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer’s value set to its <strong>depth</strong>.<br><br>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>depth</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex1.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Four 1’s at depth 2, one 2 at depth 1. 1<em>2 + 1</em>2 + 2<em>1 + 1</em>2 + 1<em>2 = 10.<br></em></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex2.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [1,[4,[6]]]<br><strong>Output:</strong> 27<br><strong>Explanation:</strong> One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 11 + 4<em>2 + 6</em>3 = 27.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nestedList = [0]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nestedList.length &lt;= 50</code>
</em>   The values of the integers in the nested list is in the range <code>[-100, 100]</code>.<br><em>   The maximum <em>*depth</em></em> of any integer is less than or equal to <code>50</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求NestedInteger的和。越深，权重越高</p>
<h3 id="最后计算权重解题思路-推荐-："><a href="#最后计算权重解题思路-推荐-：" class="headerlink" title="最后计算权重解题思路(推荐)："></a><strong>最后计算权重解题思路(推荐)：</strong></h3><p>BFS按层遍历</p>
<p>Nested List题目：<br>LeetCode 341 Flatten Nested List Iterator Iterator - Stack<br>LeetCode 339 Nested List Weight Sum - BFS<br>LeetCode 364 Nested List Weight Sum II - BFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Line 9中，需要将NestedInteger展开，里面的所有的NestedInteger入列。Python中，用extend来加入list中所有元素到另一个list，而不是append</li>
<li>按层遍历模板中，不需要level变量，for可以达到。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">	queue = collections.deque(nestedList)</span><br><span class="line">	sums, max_depth, res = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		layer_sum = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">if</span> node.isInteger():</span><br><span class="line">				layer_sum += node.getInteger()</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line">		sums.append(layer_sum)</span><br><span class="line">		max_depth += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(sums):</span><br><span class="line">		res += n * (i + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>, k为每层最多节点数 + 最大层数  </p>
<hr>
<h3 id="每层计算权重算法II解题思路："><a href="#每层计算权重算法II解题思路：" class="headerlink" title="每层计算权重算法II解题思路："></a><strong>每层计算权重算法II解题思路：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">	queue = collections.deque(nestedList)</span><br><span class="line">	res, layer = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		level_sum = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> node.isInteger():</span><br><span class="line">				queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				level_sum += node.getInteger()</span><br><span class="line">		res += level_sum * layer</span><br><span class="line">		layer += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>LinkedIn</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 329 Longest Increasing Path in a Matrix</title>
    <url>/2018/01/10/lee-329/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="noopener">LeetCode 329 Longest Increasing Path in a Matrix</a></strong></p>
<p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Example 1:</strong></p>
<pre>nums = [
  [<font color="red">9</font>,9,4],
  [<font color="red">6</font>,6,8],
  [<font color="red">2</font>,<font color="red">1</font>,1]
]
</pre>

<p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>
<p><strong>Example 2:</strong></p>
<pre>nums = [
  [<font color="red">3</font>,<font color="red">4</font>,<font color="red">5</font>],
  [3,2,<font color="red">6</font>],
  [2,2,1]
]
</pre>

<p>Return <code>4</code><br>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个整数矩阵，计算其最长递增路径的长度。<br>从每一个单元格出发，你可以向四个方向移动：左右上下。你不可以沿着对角线移动也不能移出边界。（亦即，环绕是不允许的）。</p>
<h3 id="Floyd解题思路："><a href="#Floyd解题思路：" class="headerlink" title="Floyd解题思路："></a><strong>Floyd解题思路：</strong></h3><p>这是经典题，类似于LIS题，只要将以每个点为终点的最长路径长度存起来，就可以类推它的邻近点的最长长度（DP）。f(x,y)=max{f(x,y),4个邻近点的f+1}<br>由于这是求最长路径题且为矩阵，可以考虑按步长计算，就是Floyd的思路，就是先计算步长为1,2一直到所以最长路径长度矩阵长度不再更新为止。<br>另一个思路也是用矩阵存起每个点最长路径长度，但用DFS搜索，直至这个点的值不为初始值为止，详见书影博客。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>矩阵为空或长度为0</li>
<li>当任何值没有更新时，Floyd停止计算</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">			path[i][j] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> nextPath = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(nextPath)&#123;</span><br><span class="line">		nextPath = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(changeCell(matrix, path, i, j))</span><br><span class="line">					nextPath = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">			<span class="keyword">if</span>(path[i][j]&gt;max)</span><br><span class="line">				max = path[i][j];</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">changeCell</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] path, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pre = path[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i-<span class="number">1</span>][j]&lt;matrix[i][j] &amp;&amp;  path[i-<span class="number">1</span>][j]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">		path[i][j] = path[i-<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i+<span class="number">1</span>&lt;matrix.length &amp;&amp; matrix[i+<span class="number">1</span>][j]&lt;matrix[i][j] &amp;&amp;  path[i+<span class="number">1</span>][j]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">		path[i][j] = path[i+<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i][j-<span class="number">1</span>]&lt;matrix[i][j] &amp;&amp;  path[i][j-<span class="number">1</span>]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">		path[i][j] = path[i][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(j+<span class="number">1</span>&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[i][j+<span class="number">1</span>]&lt;matrix[i][j] &amp;&amp;  path[i][j+<span class="number">1</span>]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">		path[i][j] = path[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(pre!=path[i][j])</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>k为最长路径长度，时间复杂度为<code>O(k<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>。   </p>
<hr>
<h3 id="DP算法II解题思路-推荐-："><a href="#DP算法II解题思路-推荐-：" class="headerlink" title="DP算法II解题思路(推荐)："></a><strong>DP算法II解题思路(推荐)：</strong></h3><p>求最值，考虑用DP，但DP的应用条件为有序，所以不妨将所有值排序。<br>先对所有数的值排序作为新的输入数组，按这个顺序，计算DP，每个点的往前4个方向的DP值+1。<br>如题第一个例子, 元祖里第一个为值，后两个为xy坐标<br>[(1, 2, 1), (1, 2, 2)…]<br>递归公式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[x][y] = dp[x + dx][y + dy] + 1, ifmatrix[x][y] &gt; matrix[x + dx][y + dy]:</span><br></pre></td></tr></table></figure></p>
<p>最后计算max(dp)  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当递增时，才更新DP，Line 13</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	ary = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">		   ary.append((matrix[i][j], i, j))</span><br><span class="line">	ary.sort()</span><br><span class="line">	dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">	<span class="keyword">for</span> val, _x, _y <span class="keyword">in</span> ary:</span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = _x + _dx, _y + _dy</span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= len(matrix) <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> matrix[x][y] &gt; matrix[_x][_y]:</span><br><span class="line">				dp[x][y] = max(dp[x][y], dp[_x][_y] + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> max(map(max, dp))</span><br></pre></td></tr></table></figure>
<h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h2><p>排序是n^2logn^2 = n^2logn, dp计算是n^2<br>所以时间复杂度为<code>O(<em>n</em><sup>2</sup>logn)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code></p>
<hr>
<h3 id="算法III解题思路："><a href="#算法III解题思路：" class="headerlink" title="算法III解题思路："></a><strong>算法III解题思路：</strong></h3><p>这题也可以额用记忆性搜索DFS来解。</p>
]]></content>
      <tags>
        <tag>Classic</tag>
        <tag>Depth-first Search</tag>
        <tag>Memoization</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 341 Flatten Nested List Iterator</title>
    <url>/2022/01/03/lee-341/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-nested-list-iterator" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.<br><br>Implement the <code>NestedIterator</code> class:<br><br><em>   <code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.
</em>   <code>int next()</code> Returns the next integer in the nested list.<br><em>   <code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.<br><br>Your code will be tested with the following pseudocode:<br><br><pre>initialize iterator with nestedList<br>res = []<br>while iterator.hasNext()<br>    append iterator.next() to the end of res<br>return res<br></pre><br><br>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<br><strong>Output:</strong> [1,1,2,1,1]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nestedList = [1,[4,[6]]]<br><strong>Output:</strong> [1,4,6]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= nestedList.length &lt;= 500</code><br>*   The values of the integers in the nested list is in the range <code>[-10&lt;sup&gt;6&lt;/sup&gt;, 10&lt;sup&gt;6&lt;/sup&gt;]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现Nested List的Iterator。Nested List是NestedInteger的数组，NestedInteger可以是int，也可以是Nested List</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>有点似括号题但区别是从前往后读取。用Queue或Stack都可以，插入或删除其一需要反序，删除nestedinteger(=list)后要将它里面所有nestedinteger加入。Queue要从队首加入和删除，Stack要从栈顶加入和删除，用Stack比较方便。</p>
<p>Nested List题目：<br>LeetCode 341 Flatten Nested List Iterator Iterator - Stack<br>LeetCode 339 Nested List Weight Sum - BFS<br>LeetCode 364 Nested List Weight Sum II - BFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Stack，<strong>逆序将nestedList中nestedinteger加入到stack，直到栈顶元素为int，hasNext才算结束</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop().getInteger()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> <span class="keyword">not</span> self.stack[<span class="number">-1</span>].isInteger():</span><br><span class="line">            nestedList = self.stack.pop().getList()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">                self.stack.append(nestedList[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(L + N)</code>, N为所有数，V为nested list数，O(N + V)/N. O(1)如果不存在nested list </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 347 Top K Frequent Elements</title>
    <url>/2017/12/31/lee-347/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a></strong></p>
<p>Given a non-empty array of integers, return the <strong><em>k</em></strong> most frequent elements.</p>
<p>For example,<br>Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.</p>
<p><strong>Note:</strong>  </p>
<ul>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个非空整数数组，返回其前k个出现次数最多的元素。</p>
<p>注意：<br>你可以假设k总是有效的，1 ≤ k ≤ 独立元素的个数。<br>你的算法时间复杂度必须优于O(n log n)，其中n是数组的长度。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题，解法是HeapSelect：求最大k个数，就先对前k个元素建最小堆，然后遍历k到最后一个数，若它大于栈顶就替换且做minHeapify。最后结果是<br>最大的k个数在数组的前k个位置且堆顶（数组第一个数）为k个数的最小。堆并没有排序。<br>结果并不需要从大到小输出。</p>
<ol>
<li>统计词频</li>
<li>建key-value数组</li>
<li>heapSelect</li>
<li>把数组前k个数加入到结果集中</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>如果需要按大到小输出结果，需要对result进行排序O(klogk)，数组第一个也就是最小堆堆顶是这k个数中最小。</li>
<li>key-pair版堆选择算法。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapreplace, heappush</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	dict = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">			dict[nums[i]] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			dict[nums[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	freq_dict = [(v, k) <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.items()]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(freq_dict)):</span><br><span class="line">		<span class="keyword">if</span> i &lt; k:</span><br><span class="line">			heappush(res, freq_dict[i])</span><br><span class="line">		<span class="keyword">elif</span> freq_dict[i][<span class="number">0</span>] &gt; res[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">			heapreplace(res, freq_dict[i])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>
<p>统计词频部分可以用Counter优化。freq_dict有两个作用：将key和频率互换，还可以将dict转换成list方便和k比较<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapreplace, heappush</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	dict = Counter(nums)</span><br><span class="line">	freq_dict = [(v, k) <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.items()]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(freq_dict)):</span><br><span class="line">		<span class="keyword">if</span> i &lt; k:</span><br><span class="line">			heappush(res, freq_dict[i])</span><br><span class="line">		<span class="keyword">elif</span> freq_dict[i][<span class="number">0</span>] &gt; res[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">			heapreplace(res, freq_dict[i])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure></p>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">			map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] f = <span class="keyword">new</span> Node[map.size()];</span><br><span class="line">	Iterator it = map.entrySet().iterator();</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">		Node node = <span class="keyword">new</span> Node((<span class="keyword">int</span>)pair.getKey(), (<span class="keyword">int</span>)pair.getValue());</span><br><span class="line">		f[j++] = node;</span><br><span class="line">	&#125;</span><br><span class="line">	hselect(f, k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">		result.add(f[i].key);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hselect</span><span class="params">(Node a[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">// min heap with size=k</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		minHeapify(a, i, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].value &gt; a[<span class="number">0</span>].value) &#123;</span><br><span class="line">			swap(a, i, <span class="number">0</span>);</span><br><span class="line">			minHeapify(a, <span class="number">0</span>, k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(Node[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> smallest = i;</span><br><span class="line">	<span class="keyword">int</span> l = left(i);</span><br><span class="line">	<span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l].key &lt; arr[smallest].key)</span><br><span class="line">		smallest = l;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r].key &lt; arr[smallest].key)</span><br><span class="line">		smallest = r;</span><br><span class="line">	<span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">		swap(arr, i, smallest);</span><br><span class="line">		minHeapify(arr, smallest, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">	Node tmp = arr[index1];</span><br><span class="line">	arr[index1] = arr[index2];</span><br><span class="line">	arr[index2] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		key = k;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"("</span>+key+<span class="string">","</span>+value+<span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>。时间复杂度是O(n)+O(nlogk),空间复杂度为O(m)+O(1),m为不重复的元素个数(unique element)。</p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>此题关于数组频数，所以考虑用桶排序(bucket sort)</p>
<ol>
<li>统计词频（元素-&gt;频数）</li>
<li>桶排序：n+1个桶（n为原数组大小），把元素放入频数对应的桶号（频数-&gt;元素），用List把这些元素串起来。</li>
<li>逆序（从大到小）遍历不为空的桶，输入结果直至k个。<br>与上面算法不同的是结果是从大到小输出。数据类型有两个HashMap存储元素对应的频数，而List数组List<integer>[]反过来存储频数对应的元素。</integer></li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>桶排序要用List串联起元素，例如[1,2],k=2，频数为1的元素有两个，所以桶的内容应该是List。Python用[[] for _ in range(len(nums) + 1)]  </li>
<li>桶数量为原数组大小+1，例如一个元素[1], 它的频数为1，而频数为0是不会出现。  </li>
<li>逆序遍历所有桶，只要结果集个数为k，就停止循环。  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	di = Counter(nums)</span><br><span class="line">	freq = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums) + <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> key, val <span class="keyword">in</span> di.items():</span><br><span class="line">		freq[val].append(key)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(freq) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> freq[i]:</span><br><span class="line">			<span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">				res.append(n)</span><br><span class="line">				k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	 List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	 HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">			map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	 List&lt;Integer&gt;[] f = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">	 Iterator it = map.entrySet().iterator();</span><br><span class="line">	 <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		 Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">		 <span class="keyword">if</span>(f[(<span class="keyword">int</span>)pair.getValue()]==<span class="keyword">null</span>)</span><br><span class="line">			 f[(<span class="keyword">int</span>)pair.getValue()] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		 f[(<span class="keyword">int</span>)pair.getValue()].add((<span class="keyword">int</span>)pair.getKey());</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i=f.length-<span class="number">1</span>;i&gt;<span class="number">0</span> &amp;&amp; result.size()&lt;k;i--)</span><br><span class="line">		 <span class="keyword">if</span>(f[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			 result.addAll(f[i]);</span><br><span class="line">		 &#125;</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。时间复杂度是O(n)+O(n),空间复杂度为O(m)+O(n),m为不重复的元素个数(unique element)。</p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol>
<li>题目可以包装成：给定一个文档，返回其前k个出现次数最多的单词。<br>Given a document, return the k most frequent words. Assume punctuation are removed.<br>Given a non-empty array of strings, return the k most frequent elements.  </li>
<li>如果写出了桶排序，可以考虑假设机器memory有限，只够O(m)，不能一次性读出整个文档，也就是不能用桶排序，只能用堆选择。</li>
<li>如果写出了堆选择，可以考虑k比较大，如果进一步提高时间复杂度，也就是只能O(n),符合这个要求就只有计数排序，基数排序和桶排序。</li>
</ol>
<p>这是priorityQueue实现的Heap（对于基本数据类型默认是最小堆，但由于Node是自定义，必须实现Comparator），由于PQ需要额外空间，所以<br>较少用。</p>
<h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	 List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	 HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">			map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	 Node[] f = <span class="keyword">new</span> Node[map.size()];</span><br><span class="line">	 Iterator it = map.entrySet().iterator();</span><br><span class="line">	 <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">		Node node = <span class="keyword">new</span> Node((<span class="keyword">int</span>)pair.getKey(), (<span class="keyword">int</span>)pair.getValue());</span><br><span class="line">		f[j++] = node;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(k,</span><br><span class="line">			<span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">			minHeap.offer(f[i]);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Node minNode = minHeap.peek();</span><br><span class="line">			<span class="keyword">if</span> (f[i].value &gt; minNode.value) &#123;</span><br><span class="line">				minHeap.poll();</span><br><span class="line">				minHeap.offer(f[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!minHeap.isEmpty())</span><br><span class="line">		result.add(minHeap.poll().key);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Interviewer</tag>
        <tag>Python KB</tag>
        <tag>Classic</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 350 Intersection of Two Arrays II</title>
    <url>/2017/12/31/lee-350/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="noopener">LeetCode 350 Intersection of Two Arrays II</a></strong></p>
<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2, 2]</code>.</p>
<p><strong>Note:</strong>  </p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong>  </p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li>
<li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p>
<p>注意：<br>结果中的每个元素的出现次数应与其在两个数组中同时出现的次数一样多。 结果可以采用任意顺序。  </p>
<p>进一步思考：<br>如果数组已经排好序，怎样优化你的算法？<br>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L349，但由于可允许重复，所以改hashSet成hashMap记录频数。具体而言，将较小的数组的所有元素放入hashMap且统计频数，<br>然后遍历另一个数组判断是否相同，相同的话放入ArrayList的结果集中且频数减一。</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	num_to_count = collections.Counter(nums1)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">		<span class="keyword">if</span> n <span class="keyword">in</span> num_to_count <span class="keyword">and</span> num_to_count[n] &gt; <span class="number">0</span>:</span><br><span class="line">			num_to_count[n] -= <span class="number">1</span></span><br><span class="line">			res.append(n)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">	<span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line">	<span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">		nums1 = nums2;</span><br><span class="line">		nums2 = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums1[i]))</span><br><span class="line">			map.put(nums1[i], map.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			map.put(nums1[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums2[i]) &amp;&amp; map.get(nums2[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			result.add(nums2[i]);</span><br><span class="line">			map.put(nums2[i], map.get(nums2[i])-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result.stream().mapToInt(i-&gt;i).toArray();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。    </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>另一个解题思路是，先对它们排序，然后类似于mergeSort算法维持两个指针分别在两个数组搜索相同元素。</p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">	List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line">	Arrays.sort(nums1);</span><br><span class="line">	Arrays.sort(nums2);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">			result.add(nums1[i]);</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">else</span> j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result.stream().mapToInt(k-&gt;k).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(mlogm)</code>，空间复杂度<code>O(1)</code>。此算法空间较优，但时间稍逊。</p>
<ol>
<li>如果数组已经排好序，怎样优化你的算法？<br>用第二个算法，时间复杂度为O(m),但空间复杂度可以优化为O(1)  </li>
<li>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>方法一更优，因为nums1空间用的比较少情况下</li>
<li>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？<br>也应该用方法一，因为它不需要把nums2数组一次性加载到内存中。假设内存大小为L，每次L大小的内存可解决<br>部分问题，时间复杂度为O(m),然后有n/L次，最后结果为<code>O(mn)</code>，表示空间有限时候，hashSet的方法不比先排序快。</li>
</ol>
<p>第三种方法是一个数组排序，另一个可以不排序。不排序数组的每个元素在排序数组中用二分法查找。</p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Binary Search</tag>
        <tag>Classic</tag>
        <tag>Two Pointers</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 349 Intersection of Two Arrays</title>
    <url>/2017/12/31/lee-349/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">LeetCode 349 Intersection of Two Arrays</a></strong></p>
<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p>
<p><strong>Note:</strong>  </p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p>
<p>注意：<br>结果中的每个元素一定是唯一的。<br>结果可以采用任意顺序。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>将较小的数组的所有元素放入hashSet，然后遍历另一个数组判断是否相同，相同的话放入hashSet的结果集中。所以需要两个hashSet。</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">return</span> list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">	<span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line">	<span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">		nums1 = nums2;</span><br><span class="line">		nums2 = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Set&lt;Integer&gt; hash=<span class="keyword">new</span> HashSet();</span><br><span class="line">	Set&lt;Integer&gt; result=<span class="keyword">new</span> HashSet();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)</span><br><span class="line">		hash.add(nums1[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hash.contains(nums2[i]))</span><br><span class="line">			result.add(nums2[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] r=<span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : result)</span><br><span class="line">		r[k++]=i;</span><br><span class="line">	<span class="keyword">return</span> r;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Binary Search</tag>
        <tag>Two Pointers</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 354 Russian Doll Envelopes</title>
    <url>/2021/12/05/lee-354/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w&lt;sub&gt;i&lt;/sub&gt;, h&lt;sub&gt;i&lt;/sub&gt;]</code> represents the width and the height of an envelope.<br><br>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope’s width and height.<br><br>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.<br><br><strong>Note:</strong> You cannot rotate an envelope.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= envelopes.length &lt;= 5000</code>
</em>   <code>envelopes[i].length == 2</code><br>*   <code>1 &lt;= w&lt;sub&gt;i&lt;/sub&gt;, h&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>信封套信封，能套上的条件是内信封的宽度和高度均小于外信封。求最多有多少个信封能套在一次</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于LIS，先排序宽度，高度就变成LIS问题。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>宽度和高度都是严格递增，所以排序envelopes的时候，先顺序排序宽度，再逆序排高度，<strong>逆序是防止同一宽度但高度不同的信封成为合法结果</strong>，如[3, 4], [3, 5], 高度LIS变成[4, 5]但不合法。还要注意Python语法：envelopes.sort(key=lambda x: (x[0], -x[1]))</li>
<li>用bisect_left因为，若高度相等，原地替换并不往后加。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span><span class="params">(self, envelopes: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>])) <span class="comment"># remember format and reversed order</span></span><br><span class="line">	sorted_height = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(envelopes)):</span><br><span class="line">		index = bisect.bisect_left(sorted_height, envelopes[i][<span class="number">1</span>]) <span class="comment"># remember left</span></span><br><span class="line">		<span class="keyword">if</span> index &lt; len(sorted_height):</span><br><span class="line">			sorted_height[index] = envelopes[i][<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			sorted_height.append(envelopes[i][<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> len(sorted_height)</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || </span><br><span class="line">			envelopes[<span class="number">0</span>] == <span class="keyword">null</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="comment">// remember for 2d array</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">				<span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]; <span class="comment">// remember the reverse order for [4,5], [4,6] case must strictly increasing for width and height</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[] lis = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span>[] e : envelopes) &#123;</span><br><span class="line">		<span class="keyword">int</span> index = Arrays.binarySearch(lis, <span class="number">0</span>, len, e[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			index = -index - <span class="number">1</span>;</span><br><span class="line">			lis[index] = e[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			lis[index] = e[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(index == len)</span><br><span class="line">			len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>Insert时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 362 Design Hit Counter</title>
    <url>/2021/12/24/lee-362/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-hit-counter/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a hit counter which counts the number of hits received in the past <code>5</code> minutes (i.e., the past <code>300</code> seconds).<br><br>Your system should accept a <code>timestamp</code> parameter (<strong>in seconds</strong> granularity), and you may assume that calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing). Several hits may arrive roughly at the same time.<br><br>Implement the <code>HitCounter</code> class:<br><br><em>   <code>HitCounter()</code> Initializes the object of the hit counter system.
</em>   <code>void hit(int timestamp)</code> Records a hit that happened at <code>timestamp</code> (<strong>in seconds</strong>). Several hits may happen at the same <code>timestamp</code>.<br><em>   <code>int getHits(int timestamp)</code> Returns the number of hits in the past 5 minutes from <code>timestamp</code> (i.e., the past <code>300</code> seconds).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“HitCounter”, “hit”, “hit”, “hit”, “getHits”, “hit”, “getHits”, “getHits”]<br>[[], [1], [2], [3], [4], [300], [300], [301]]<br><strong>Output</strong><br>[null, null, null, null, 3, null, 4, 3]<br><br><strong>Explanation</strong><br>HitCounter hitCounter = new HitCounter();<br>hitCounter.hit(1);       // hit at timestamp 1.<br>hitCounter.hit(2);       // hit at timestamp 2.<br>hitCounter.hit(3);       // hit at timestamp 3.<br>hitCounter.getHits(4);   // get hits at timestamp 4, return 3.<br>hitCounter.hit(300);     // hit at timestamp 300.<br>hitCounter.getHits(300); // get hits at timestamp 300, return 4.<br>hitCounter.getHits(301); // get hits at timestamp 301, return 3.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= timestamp &lt;= 2 * 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All the calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing).
</em>   At most <code>300</code> calls will be made to <code>hit</code> and <code>getHits</code>.<br><br><strong>Follow up:</strong> What if the number of hits per second could be huge? Does your design scale?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计统计hits系统。题目要求：同一个时间可以有多个hits，hit是按时间顺序的。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用一个固定大小为300的数组来记录timestamp和对应的hits的总数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目要求：同一个时间可以有多个hits，hit是按时间顺序的。所以固定数组只要比较现在的timestamp是否和last_timestamp一样，不是的话reset hit。用<strong>循环数组</strong>记录   </li>
<li>getHist是统计300以内（<strong>不包括300</strong>）的hit数。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitCounter</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.hits = [(<span class="number">0</span>, <span class="number">0</span>)] * <span class="number">300</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hit</span><span class="params">(self, timestamp: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        last_timestamp, count = self.hits[timestamp % <span class="number">300</span>]</span><br><span class="line">        <span class="keyword">if</span> last_timestamp <span class="keyword">and</span> timestamp != last_timestamp:</span><br><span class="line">            self.hits[timestamp % <span class="number">300</span>] = (timestamp, <span class="number">0</span>)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        self.hits[timestamp % <span class="number">300</span>] = (timestamp, count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHits</span><span class="params">(self, timestamp: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t, count <span class="keyword">in</span> self.hits:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">and</span> timestamp - t &lt; <span class="number">300</span>:</span><br><span class="line">                res += count</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>hit时间复杂度为<code>O(1)</code>，getHits时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 368 Largest Divisible Subset</title>
    <url>/2020/05/10/lee-368/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">LeetCode 368 Largest Divisible Subset</a></strong></p>
<p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (S<sub>i</sub>, S<sub>j</sub>) of elements in this subset satisfies:</p>
<p>S<sub>i</sub> % S<sub>j</sub> = 0 or S<sub>j</sub> % S<sub>i</sub> = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p><strong>Example 1:</strong></p>
<div>

<pre>**Input:** <span id="example-input-1-1">[1,2,3]</span>
**Output:** <span id="example-output-1">[1,2]</span> (of course, [1,3] will also be ok)
</pre>

<div>

<p><strong>Example 2:</strong></p>
<pre>**Input:** <span id="example-input-2-1">[1,2,4,8]</span>
**Output:** <span id="example-output-2">[1,2,4,8]</span>
</pre>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个数组，让我们求这样一个子集合，集合中的任意两个数相互取余均为0。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于知道子问题有助于求解考虑用DP。它就是LIS的翻版。这道题还需要打印DP路径。    </p>
<ol>
<li>定义dp[i]为num[i-1]这个数对应的最大可整除子集合个数。  </li>
<li>递归式为dp[i] = max{dp[j-1] + 1}, 0&lt;j&lt;i, 若num[i-1]可被num[j-1]整除     </li>
<li>方向为从左到右。初始值为dp = 1。  </li>
<li>path数组记录解的下标+1，每求得一个解dp[i] = dp[j] + 1就记录对应上一层解的下标，也就是到此解的路径。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>初始值dp = 1。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	<span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(nums[<span class="number">0</span>]);</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span> maxPos = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) <span class="comment">// remember to init to 1</span></span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i-<span class="number">1</span>] % nums[j-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">				path[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dp[i] &gt; max) &#123; <span class="comment">// the biggest value might not be the last one, keep track of the start pos for the path</span></span><br><span class="line">			max = dp[i];</span><br><span class="line">			maxPos = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = maxPos;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp[maxPos]; i++) &#123;</span><br><span class="line">		res.add(nums[pos-<span class="number">1</span>]);</span><br><span class="line">		pos = path[pos];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Collections.sort(res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>。</p>
</div></div>]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 373 Find K Pairs with Smallest Sums</title>
    <url>/2021/12/04/lee-373/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>ascending order</strong> and an integer <code>k</code>.<br><br>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.<br><br>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u&lt;sub&gt;1&lt;/sub&gt;, v&lt;sub&gt;1&lt;/sub&gt;), (u&lt;sub&gt;2&lt;/sub&gt;, v&lt;sub&gt;2&lt;/sub&gt;), ..., (u&lt;sub&gt;k&lt;/sub&gt;, v&lt;sub&gt;k&lt;/sub&gt;)</code> <em>with the smallest sums</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3<br><strong>Output:</strong> [[1,2],[1,4],[1,6]]<br><strong>Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,1,2], nums2 = [1,2,3], k = 2<br><strong>Output:</strong> [[1,1],[1,1]]<br><strong>Explanation:</strong> The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,2], nums2 = [3], k = 3<br><strong>Output:</strong> [[1,3],[2,3]]<br><strong>Explanation:</strong> All possible pairs are returned from the sequence: [1,3],[2,3]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums1.length, nums2.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   <code>nums1</code> and <code>nums2</code> both are sorted in <strong>ascending order</strong>.
</em>   <code>1 &lt;= k &lt;= 1000</code><br><br></div>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>类似于BFS模板，只不过是将queue换成heap。  </li>
<li>将两数和加入到heap中，而不是下标的和(粗心)  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSET = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span><span class="params">(self, nums1: List[int], nums2: List[int], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	heap, res = [(nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)], []</span><br><span class="line">	visited = set([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		node = heapq.heappop(heap)</span><br><span class="line">		res.append([nums1[node[<span class="number">1</span>]], nums2[node[<span class="number">2</span>]]])</span><br><span class="line">		<span class="keyword">if</span> len(res) == k:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">			_x, _y = node[<span class="number">1</span>] + _dx, node[<span class="number">2</span>] + _dy</span><br><span class="line">			<span class="keyword">if</span> _x &lt; len(nums1) <span class="keyword">and</span> _y &lt; len(nums2) <span class="keyword">and</span> (_x, _y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">				heapq.heappush(heap, (nums1[_x] + nums2[_y], _x, _y))</span><br><span class="line">				visited.add((_x, _y))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Heap</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 377 Combination Sum IV</title>
    <url>/2021/12/29/lee-377/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-iv/submissions/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.<br><br>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3], target = 4<br><strong>Output:</strong> 7<br><strong>Explanation:</strong><br>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>Note that different sequences are counted as different combinations.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [9], target = 3<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 200</code>
</em>   <code>1 &lt;= nums[i] &lt;= 1000</code><br><em>   All the elements of <code>nums</code> are <strong>unique</strong>.
</em>   <code>1 &lt;= target &lt;= 1000</code><br><br><strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有可能组合的和等于target。元素可以复用且顺序在组合中可以任意。   </p>
<p>LeetCode 377 Combination Sum IV 题目基本一样，唯一区别是结果元素有序，属于排列<br>LeetCode 518 Coin Change 2 题目基本一样，唯一区别是结果元素无序，属于组合</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题似组合又似排列，是组合的结果再全排列。求种数另一种的方法是DP. dp[n]为target=n所有的所有组合种数。属于数值-&gt;个数型DP<br>递归公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n + num[i]] = dp[n], n = [1, tgt], i = [0, len(nums) - 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp[i + nums[j]] += dp[i] 而不是dp[i] + 1 </li>
<li>dp[0] = 1表示数值为0，可以不用任何数就能获得，所以是1种     </li>
<li>先排序，否则如[3, 1, 2, 4]，返回dp[1] = 0, 但应该是dp[1] = 1  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[n + num[i]] = dp[n], n = [1, tgt], i = [0, len(nums) - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">	nums.sort() <span class="comment"># remember</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">			<span class="keyword">if</span> i + nums[j] &gt; target:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			dp[i + nums[j]] += dp[i] <span class="comment"># remember no +1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*target)</code>，空间复杂度<code>O(target)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 380 Insert Delete GetRandom O(1)</title>
    <url>/2021/11/30/lee-380/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement the <code>RandomizedSet</code> class:<br><br><em>   <code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.
</em>   <code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.<br><em>   <code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.
</em>   <code>int getRandom()</code> Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.<br><br>You must implement the functions of the class such that each function works in <strong>average</strong> <code>O(1)</code> time complexity.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“RandomizedSet”, “insert”, “remove”, “insert”, “getRandom”, “remove”, “insert”, “getRandom”]<br>[[], [1], [2], [2], [], [1], [2], []]<br><strong>Output</strong><br>[null, true, false, true, 2, true, false, 2]<br><br><strong>Explanation</strong><br>RandomizedSet randomizedSet = new RandomizedSet();<br>randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.<br>randomizedSet.remove(2); // Returns false as 2 does not exist in the set.<br>randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].<br>randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.<br>randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].<br>randomizedSet.insert(2); // 2 was already in the set, so return false.<br>randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= val &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code>
</em>   At most <code>2 * ``10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.<br><em>   There will be <em>*at least one</em></em> element in the data structure when <code>getRandom</code> is called.<br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Dict + List  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>检查若删除最后一个元素发现问题，remove中删除key要放在最后，不能放中间  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.key_to_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.key_to_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        self.key_to_index[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        index = self.key_to_index[val]</span><br><span class="line">        last_val = self.nums[len(self.nums) - <span class="number">1</span>]</span><br><span class="line">        self.nums[index] = last_val</span><br><span class="line">        self.key_to_index[last_val] = index</span><br><span class="line">        self.key_to_index.pop(val)  <span class="comment"># remember to put it last</span></span><br><span class="line">        self.nums.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 378 Kth Smallest Element in a Sorted Matrix</title>
    <url>/2021/11/14/lee-378/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">LeetCode 378 Kth Smallest Element in a Sorted Matrix</a></strong></p>
<p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k&lt;sup&gt;th&lt;/sup&gt;</code> <em>smallest element in the matrix</em>.</p>
<p>Note that it is the <code>k&lt;sup&gt;th&lt;/sup&gt;</code> smallest element <strong>in the sorted order</strong>, not the <code>k&lt;sup&gt;th&lt;/sup&gt;</code> <strong>distinct</strong> element.</p>
<p>You must find a solution with complexity better than <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code>.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
**Output:** 13
**Explanation:** The elements in the matrix are [1,5,9,10,11,12,13,<u>**13**</u>,15], and the 8<sup>th</sup> smallest number is 13
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** matrix = [[-5]], k = 1
**Output:** -5
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li>
<li><code>1 &lt;= k &lt;= n&lt;sup&gt;2&lt;/sup&gt;</code></li>
</ul>
<p><strong>Follow up:</strong> Could you solve the problem in <code>O(n)</code> time complexity?</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按行按列有序矩阵中，找第k大的数。  </p>
<h3 id="Heap解题思路-推荐-："><a href="#Heap解题思路-推荐-：" class="headerlink" title="Heap解题思路(推荐)："></a><strong>Heap解题思路(推荐)：</strong></h3><p>见Heap知识点。 分别将(value, i, j)放入heap中，取出堆顶元素后，去(i, j)相邻右和下节点放入堆中。这个方法容易实现，所以推荐。</p>
<p>LeetCode 074 Search a 2D Matrix 每一行有序，下一行的首元素大于上一行的尾元素 + 找target<br>LeetCode 240 Search a 2D Matrix II 按行按列有序 + 找target<br>LeetCode 378 Kth Smallest Element in a Sorted Matrix 按行按列有序 + 找第k大<br>矩阵结构方面，第一道每一行都是独立，所以可以独立地按行按列做二分法<br>后两道，矩阵二维连续，所以解法都是类BFS，从某个点开始，然后比较它相邻的两个点。出发点不同，第二道在近似矩阵中点(右上角或左下角)，第三道在左上角出发。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>将(value, i, j)放入heap中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest4</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">	OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">	heap = [(matrix[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">	visited = set([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		node = heapq.heappop(heap)</span><br><span class="line">		k -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> node[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = node[<span class="number">1</span>] + _dx, node[<span class="number">2</span>] + _dy</span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= len(matrix) <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= len(matrix[<span class="number">0</span>]) <span class="keyword">or</span> (x, y) <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			heapq.heappush(heap, (matrix[x][y], x, y))</span><br><span class="line">			visited.add((x, y))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>for循环是k个，每次循环理论上产生2个节点，所以总共是2^k个，复杂度为<code>O(klog(<em>2</em><sup>k</sup>)</code>, 也就是<code>O(<em>k</em><sup>2</sup>)</code><br>由于矩阵最多n^2个元素，所以复杂度为<code>O(klog(<em>n</em><sup>2</sup>)</code><br>所以时间复杂度为<code>O(klogn)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>。</p>
<hr>
<h3 id="数值二分法算法II解题思路："><a href="#数值二分法算法II解题思路：" class="headerlink" title="数值二分法算法II解题思路："></a><strong>数值二分法算法II解题思路：</strong></h3><p>第k的数运用数值二分法  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>数值二分法  </li>
<li>难点在于统计小于mid的个数。若遍历全矩阵比较慢，采用按行遍历，每行再用二分法找到小于mid的数的个数，再求和。  </li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>注意k–, k从1开始</li>
<li>每行统计小于mid个数用find smaller的模板。返回值要加1，因为下标转换成个数。     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">	k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	N, M = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">	start, end, epsilon = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[N - <span class="number">1</span>][M - <span class="number">1</span>], <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = sum([self.get_count(matrix[i], mid) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)])</span><br><span class="line">		<span class="keyword">if</span> k &lt; count:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> k &gt; count:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">return</span> math.floor(end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(self, nums: List[int], target: float)</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> nums[end] &lt; target:</span><br><span class="line">		<span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> nums[start] &lt; target:</span><br><span class="line">		<span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>用bisect优化  </p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">	k -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	N, M = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">	start, end, epsilon = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[N - <span class="number">1</span>][M - <span class="number">1</span>], <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = sum([bisect.bisect(matrix[i], mid) + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)])</span><br><span class="line">		<span class="keyword">if</span> k &lt; count:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> k &gt; count:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			start = mid</span><br><span class="line">	<span class="keyword">return</span> math.floor(end)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>while循环有log[(max - min)/epsilon]个，假设数字平均分布，复杂度是log(n), 每个循环按每行(n行)统计小于mid的个数，<br>每次统计调用get_count用了log(n)，<br>所以总时间复杂度为<code>O(log(n) * nlogn)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
        <tag>Binary Search</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 387 First Unique Character in a String</title>
    <url>/2022/01/04/lee-387/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “loveleetcode”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aabb”<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s</code> consists of only lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串中第一个唯一的字符下标</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题。先统计频率，然后再遍历一次字符串找到频率为1的字符</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> char_to_count[s[i]] == <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>, 26个字母为常量空间  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 395 Longest Substring with At Least K Repeating Characters</title>
    <url>/2022/01/01/lee-395/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aaabb”, k = 3<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest substring is “aaa”, as ‘a’ is repeated 3 times.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ababbc”, k = 2<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s</code> consists of only lowercase English letters.<br>*   <code>1 &lt;= k &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最长每种字符至少k个的子串  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L003 Longest Substring Without Repeating Characters用双指针法，难点是每种字符，用26字母存储法解决。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>按多少种不同字符来做sliding window。有1-26种。  </li>
<li>子函数求给定种数下的最长子串，所以满足条件在外循环不在内循环，还需进一步统计每种字符是否符合k个。内循环为不满足条件的情况len(char_to_count) == n + 1   </li>
<li>char_to_count记录每种字符个数, valid_count是子串[left, i]之间满足题意中个数大于等于k的种数。   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestSubstring</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">		res = max(res, self.longest_substring(s, k, i))</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_substring</span><span class="params">(self, s, k, n)</span> -&gt; int:</span></span><br><span class="line">	left, char_to_count = <span class="number">0</span>, collections.defaultdict(int)</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		char_to_count[ord(s[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> len(char_to_count) == n + <span class="number">1</span>:</span><br><span class="line">			char_to_count[ord(s[left]) - ord(<span class="string">'a'</span>)] -= <span class="number">1</span> <span class="comment"># use left not i</span></span><br><span class="line">			<span class="keyword">if</span> char_to_count[ord(s[left]) - ord(<span class="string">'a'</span>)] == <span class="number">0</span>:</span><br><span class="line">				char_to_count.pop(ord(s[left]) - ord(<span class="string">'a'</span>))</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		valid_count = len([_ <span class="keyword">for</span> _ <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> _ &gt;= k])</span><br><span class="line">		<span class="keyword">if</span> len(char_to_count) == valid_count:</span><br><span class="line">			res = max(res, i - left + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(26*26n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 394 Decode String</title>
    <url>/2021/12/13/lee-394/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an encoded string, return its decoded string.<br><br>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.<br><br>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.<br><br>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “3[a]2[bc]”<br><strong>Output:</strong> “aaabcbc”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “3[a2[c]]”<br><strong>Output:</strong> “accaccacc”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “2[abc]3[cd]ef”<br><strong>Output:</strong> “abcabccdcdcdef”<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> s = “abc3[cd]xyz”<br><strong>Output:</strong> “abccdcdcdxyz”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 30</code>
</em>   <code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.<br><em>   <code>s</code> is guaranteed to be <strong>a valid</strong> input.
</em>   All the integers in <code>s</code> are in the range <code>[1, 300]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将循环体表示展开</p>
<h3 id="Stack解题思路-推荐-："><a href="#Stack解题思路-推荐-：" class="headerlink" title="Stack解题思路(推荐)："></a><strong>Stack解题思路(推荐)：</strong></h3><p>见到括号就考虑用Stack，此题有字符和数字，所以考虑用<strong>两个Stack</strong>  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>运用模板</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>同级为括号外（包括括号以左，以右），但数字和字符分别存于<strong>两个stack</strong>。括号内为另一级，入栈。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	res, num, stack_num, stack_str = <span class="string">''</span>, <span class="number">0</span>, [], []</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">if</span> char.isalpha():</span><br><span class="line">			res += char</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'['</span>:</span><br><span class="line">			stack_num.append(num) <span class="comment"># [3]</span></span><br><span class="line">			stack_str.append(res) <span class="comment"># 2c</span></span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">			res = <span class="string">''</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">']'</span>:</span><br><span class="line">			tmp = stack_str.pop() <span class="comment"># '2c'</span></span><br><span class="line">			n = stack_num.pop() <span class="comment"># 3</span></span><br><span class="line">			res = tmp + n * res <span class="comment"># 2c + 3*d=ccddd</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="递归算法II解题思路-不推荐-："><a href="#递归算法II解题思路-不推荐-：" class="headerlink" title="递归算法II解题思路(不推荐)："></a><strong>递归算法II解题思路(不推荐)：</strong></h3><p>用index作为全局变量，扫每一个字符，类似于Leetcode 297。<br>遇到字符append到result，遇到数字记录次数k，遇到左括号就递归decodeString(s), 递归返回decodedString, 跳过右括号，result.append(decodedString) k次，最后返回result。  </p>
<p>如3[a2[c]]  </p>
<h3 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a><strong>伪代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decodeString(<span class="string">'3[a2[c]]'</span>)</span><br><span class="line">    k = <span class="number">3</span>  </span><br><span class="line">    acc = decodeString(<span class="string">'a2[c]'</span>)</span><br><span class="line">         result = a</span><br><span class="line">         k = <span class="number">2</span></span><br><span class="line">         <span class="string">'c'</span>  = decodeString(<span class="string">'c'</span>)</span><br><span class="line">         result = acc</span><br><span class="line">   result = accaccacc</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 415 Add Strings</title>
    <url>/2017/11/02/lee-415/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener">LeetCode 415 Add Strings</a></strong></p>
<p>Given two non-negative numbers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>
<li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>
<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给出两个字符串形式的非负数num1和num2，返回num1和num2之和。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>对每一位进行加法，注意进位和长度不一，类似于merge sort里面merge的实现。最要注意的是进位carry的edge case：for循环后最后值要特别处理。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三个循环后carry要特殊处理</li>
<li>Python中，题目要求不能用int函数，就只能用ord(num1[i]) - ord(‘0’)  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">	num1, num2 = num1[::<span class="number">-1</span>], num2[::<span class="number">-1</span>]</span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	i, j, carry = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(num1) <span class="keyword">or</span> j &lt; len(num2):</span><br><span class="line">		tmp = carry</span><br><span class="line">		<span class="keyword">if</span> i &lt; len(num1):</span><br><span class="line">			tmp += ord(num1[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> j &lt; len(num2):</span><br><span class="line">			tmp += ord(num2[j]) - ord(<span class="string">'0'</span>)</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		carry = <span class="number">1</span> <span class="keyword">if</span> tmp &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">		res += str(tmp % <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">		res += str(carry)</span><br><span class="line">	<span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	<span class="keyword">int</span> i=num1.length()-<span class="number">1</span>,j=num2.length()-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = Integer.parseInt(num1.charAt(i)+<span class="string">""</span>)+Integer.parseInt(num2.charAt(j)+<span class="string">""</span>)+carry;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)</span><br><span class="line">			carry = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">		sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">		i--;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = Integer.parseInt(num1.charAt(i)+<span class="string">""</span>)+carry;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)</span><br><span class="line">			carry = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">		sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = Integer.parseInt(num2.charAt(j)+<span class="string">""</span>)+carry;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)</span><br><span class="line">			carry = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">		sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(carry&gt;<span class="number">0</span>)</span><br><span class="line">		sb.append(carry);</span><br><span class="line">	<span class="keyword">return</span> sb.reverse().toString();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串较长者长度。空间复杂度为<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Facebook</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 423 Reconstruct Original Digits from English</title>
    <url>/2021/12/11/lee-423/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div>Given a string <code>s</code> containing an out-of-order English representation of digits <code>0-9</code>, return <em>the digits in <strong>ascending</strong> order</em>. <strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “owoztneoer”<br><strong>Output:</strong> “012”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “fviefuro”<br><strong>Output:</strong> “45”<br></pre><br><br><strong>Constraints:</strong> <em> <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code> </em> <code>s[i]</code> is one of the characters <code>[&quot;e&quot;,&quot;g&quot;,&quot;f&quot;,&quot;i&quot;,&quot;h&quot;,&quot;o&quot;,&quot;n&quot;,&quot;s&quot;,&quot;r&quot;,&quot;u&quot;,&quot;t&quot;,&quot;w&quot;,&quot;v&quot;,&quot;x&quot;,&quot;z&quot;]</code>. <em> <code>s</code> is <em>*guaranteed</em></em> to be valid.</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数字用英语单词表示如12 -&gt; onetwo, 但打乱顺序otwone. 求如何获得原数字</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>统计每个字母的个数，根据个数来决定数字<br>规律见代码： 有些字母但唯一的，如two，w可以知道数字含2<br>但有些字母是多个数字的和如s，six和seven都含有s，减去用上述的six的个数就知道seven的个数   </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">originalDigits</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	char_to_num = &#123;</span><br><span class="line">		<span class="string">'z'</span>: <span class="string">'0'</span>,</span><br><span class="line">		<span class="string">'w'</span>: <span class="string">'2'</span>,</span><br><span class="line">		<span class="string">'u'</span>: <span class="string">'4'</span>,</span><br><span class="line">		<span class="string">'x'</span>: <span class="string">'6'</span>,</span><br><span class="line">		<span class="string">'g'</span>: <span class="string">'8'</span>,</span><br><span class="line">		<span class="string">'o'</span>: <span class="string">'1'</span>,  <span class="comment"># decided by previous keys</span></span><br><span class="line">		<span class="string">'h'</span>: <span class="string">'3'</span>,  <span class="comment"># decided by previous keys</span></span><br><span class="line">		<span class="string">'f'</span>: <span class="string">'5'</span>,  <span class="comment"># decided by previous keys</span></span><br><span class="line">		<span class="string">'s'</span>: <span class="string">'7'</span>,  <span class="comment"># decided by previous keys</span></span><br><span class="line">		<span class="string">'i'</span>: <span class="string">'9'</span>,  <span class="comment"># decided by previous keys</span></span><br><span class="line">	&#125;</span><br><span class="line">	res = []</span><br><span class="line">	char_to_freq = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		char_to_freq[char] += <span class="number">1</span></span><br><span class="line">	char_to_freq[<span class="string">'o'</span>] -= char_to_freq[<span class="string">'z'</span>] + char_to_freq[<span class="string">'w'</span>] + char_to_freq[<span class="string">'u'</span>]</span><br><span class="line">	char_to_freq[<span class="string">'h'</span>] -= char_to_freq[<span class="string">'g'</span>]</span><br><span class="line">	char_to_freq[<span class="string">'f'</span>] -= char_to_freq[<span class="string">'u'</span>]</span><br><span class="line">	char_to_freq[<span class="string">'s'</span>] -= char_to_freq[<span class="string">'x'</span>]</span><br><span class="line">	char_to_freq[<span class="string">'i'</span>] -= char_to_freq[<span class="string">'x'</span>] + char_to_freq[<span class="string">'g'</span>] + char_to_freq[<span class="string">'f'</span>]</span><br><span class="line">	<span class="keyword">for</span> char, num <span class="keyword">in</span> char_to_num.items():</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> char_to_freq <span class="keyword">and</span> char_to_freq[char] &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">for</span> _ <span class="keyword">in</span> range(char_to_freq[char]):</span><br><span class="line">				res.append(num)</span><br><span class="line">	res.sort()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(10n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 416 Partition Equal Subset Sum</title>
    <url>/2018/01/27/lee-416/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">LeetCode 416 Partition Equal Subset Sum</a></strong></p>
<p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong>  </p>
<ol>
<li>Each of the array element will not exceed 100.</li>
<li>The array size will not exceed 200.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre>Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
</pre>

<p><strong>Example 2:</strong></p>
<pre>Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
</pre>


<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个只包含正整数的非空数组，判断数组是否可以分成两个和相等的子数组。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题转化为求是否有子序列的和等于数组和的一半，这就是0-1背包问题。价值和重量是一样数组的背包问题。背包问题递归式：<br>f[j] = Math.max(f[j], f[j-w[i]]+v[i]);<br>背包问题最后的解为容量为C的背包能装的最大价值，也就是在这题中，容量为数组一半和的背包能装的最大价值是否为数组一半。如果能，即有解。<br>表示存在前i个数它的和（最大价值）等于和的一半。<br>举例说明，容量一半表示刚好可以凑到几个数和为一半，如[1,5,11,5]，容量为11，就可以凑到[1,5,5]重量和价值均为一半。<br>如[1,2,3,10]和为16，容量为8，只能找到[1,2,3]价值为6达不到一半。所以这里C是限制条件并不是一定要达到。但刚好达到即为解。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组和为奇数，无解</li>
<li>背包问题的解若为数组一半的和即有解</li>
<li>背包问题解法C向前滚</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">		sum+=nums[i];</span><br><span class="line">	<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span>[] result = knapsack(nums,nums,sum/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(sum/<span class="number">2</span>==result[result.length-<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] knapsack(<span class="keyword">int</span> v[], <span class="keyword">int</span> w[], <span class="keyword">int</span> C)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = v.length;</span><br><span class="line">	<span class="comment">//int[][] re = new int[n][C+1];</span></span><br><span class="line">	<span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[C+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=C;j&gt;=w[i];j--)&#123;</span><br><span class="line">			f[j] = Math.max(f[j], f[j-w[i]]+v[i]);</span><br><span class="line">			<span class="comment">//if(f[j]==f[j-w[i]]+v[i])</span></span><br><span class="line">			   <span class="comment">// re[i][j] = 1;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nC)</code>，空间复杂度<code>O(C)</code>。C为数组和的一半，n为数组个数。</p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 427 Construct Quad Tree</title>
    <url>/2022/01/04/lee-427/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/construct-quad-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>n * n</code> matrix <code>grid</code> of <code>0&#39;s</code> and <code>1&#39;s</code> only. We want to represent the <code>grid</code> with a Quad-Tree.<br><br>Return <em>the root of the Quad-Tree</em> representing the <code>grid</code>.<br><br>Notice that you can assign the value of a node to <strong>True</strong> or <strong>False</strong> when <code>isLeaf</code> is <strong>False</strong>, and both are <strong>accepted</strong> in the answer.<br><br>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:<br><br><em>   <code>val</code>: True if the node represents a grid of 1’s or False if the node represents a grid of 0’s.
</em>   <code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.<br><br><pre>class Node {<br>    public boolean val;<br>    public boolean isLeaf;<br>    public Node topLeft;<br>    public Node topRight;<br>    public Node bottomLeft;<br>    public Node bottomRight;<br>}</pre><br><br>We can construct a Quad-Tree from a two-dimensional area using the following steps:<br><br>1.  If the current grid has the same value (i.e all <code>1&#39;s</code> or all <code>0&#39;s</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.<br>2.  If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.<br>3.  Recurse for each of the children with the proper sub-grid.<br><br><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt=""><br><br>If you want to know more about the Quad-Tree, you can refer to the <a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank" rel="noopener">wiki</a>.<br><br><strong>Quad-Tree format:</strong><br><br>The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.<br><br>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.<br><br>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1],[1,0]]<br><strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]<br><strong>Explanation:</strong> The explanation of this example is shown below:<br>Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.<br><img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt=""><br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]<br><strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]<br><strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.<br>The topLeft, bottomLeft and bottomRight each has the same value.<br>The topRight have different values so we divide it into 4 sub-grids where each has the same value.<br>Explanation is shown in the photo below:<br><img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt=""><br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == grid.length == grid[i].length</code>
</em>   <code>n == 2&lt;sup&gt;x&lt;/sup&gt;</code> where <code>0 &lt;= x &lt;= 6</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>由矩阵建四叉树。矩阵有0和1组成。按以下步骤：若子矩阵(变成为2的幂)只含1或0，生成一个叶子节点，值为该值；子矩阵含0和1混合，值为0或1(均为答案)，非叶子节点，递归四个同样大小的矩阵生成相应节点。<br>矩阵大小为2的幂，最小长度为1.  </p>
<h3 id="单格DFS算法II解题思路-推荐-："><a href="#单格DFS算法II解题思路-推荐-：" class="headerlink" title="单格DFS算法II解题思路(推荐)："></a><strong>单格DFS算法II解题思路(推荐)：</strong></h3><p>也是DFS，但递归终止条件为长度1，也就是每个cell都是叶子节点，先递归然后再归纳，若四个儿子节点都是叶子节点且值都相等，合并为一个叶子节点。否则为非叶子节点。<br>此算法实现更简单，但比较难想出。上述方法思想是按照题意。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>size = 1作为终止条件</li>
<li>两个条件该轮递归的节点为叶子节点，第一值相等，第二<strong>儿子节点都是叶子节点</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(self, grid: List[List[int]])</span> -&gt; 'Node':</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(grid, <span class="number">0</span>, <span class="number">0</span>, len(grid))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, start_x, start_y, n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> Node(grid[start_x][start_y], <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">	top_left = self.dfs(grid, start_x, start_y, n // <span class="number">2</span>)</span><br><span class="line">	top_right = self.dfs(grid, start_x, start_y + n // <span class="number">2</span>, n // <span class="number">2</span>)</span><br><span class="line">	bottom_left = self.dfs(grid, start_x + n // <span class="number">2</span>, start_y, n // <span class="number">2</span>)</span><br><span class="line">	bottom_right = self.dfs(grid, start_x + n // <span class="number">2</span>, start_y + n // <span class="number">2</span>, n // <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> top_left.val == top_right.val == bottom_left.val == bottom_right.val <span class="keyword">and</span> \</span><br><span class="line">			top_left.isLeaf <span class="keyword">and</span> top_right.isLeaf <span class="keyword">and</span> bottom_left.isLeaf <span class="keyword">and</span> bottom_right.isLeaf: <span class="comment"># remmember</span></span><br><span class="line">		<span class="keyword">return</span> Node(top_left.val, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> Node(<span class="number">1</span>, <span class="keyword">False</span>, top_left, top_right, bottom_left, bottom_right)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code><code>，空间复杂度</code>O(1)`   </p>
<hr>
<h3 id="presum解题思路-不推荐-："><a href="#presum解题思路-不推荐-：" class="headerlink" title="presum解题思路(不推荐)："></a><strong>presum解题思路(不推荐)：</strong></h3><p>这是我的方法，按照定义求解，定义是递归的，所以用DFS。而统计子矩阵和用presum提高效率。但实现比较复杂</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>子矩阵presum用模板</li>
<li>终止条件为子矩阵sum是0或n平方</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(self, grid: List[List[int]])</span> -&gt; 'Node':</span></span><br><span class="line">	presum = self.get_presum(grid)</span><br><span class="line">	<span class="keyword">return</span> self.dfs(grid, (<span class="number">0</span>, <span class="number">0</span>), (len(grid) - <span class="number">1</span>, len(grid[<span class="number">0</span>]) - <span class="number">1</span>), presum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">	grim_sum = self.get_grid_sum(top_left, bottom_right, presum)</span><br><span class="line">	<span class="keyword">if</span> grim_sum == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> Node(<span class="number">0</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">	<span class="keyword">if</span> grim_sum == (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>) * (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">return</span> Node(<span class="number">1</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">	node = Node(<span class="number">1</span>, <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">	row_mid = top_left[<span class="number">0</span>] + (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">	col_mid = top_left[<span class="number">1</span>] + (bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]) // <span class="number">2</span></span><br><span class="line">	node.topLeft = self.dfs(grid, top_left, (row_mid, col_mid), presum)</span><br><span class="line">	node.topRight = self.dfs(grid, (top_left[<span class="number">0</span>], col_mid + <span class="number">1</span>), (row_mid, bottom_right[<span class="number">1</span>]), presum)</span><br><span class="line">	node.bottomLeft = self.dfs(grid, (row_mid + <span class="number">1</span>, top_left[<span class="number">1</span>]), (bottom_right[<span class="number">0</span>], col_mid), presum)</span><br><span class="line">	node.bottomRight = self.dfs(grid, (row_mid + <span class="number">1</span>, col_mid + <span class="number">1</span>), bottom_right, presum)</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grid_sum</span><span class="params">(self, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">	left = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[bottom_right[<span class="number">0</span>]][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">	top = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][bottom_right[<span class="number">1</span>]]</span><br><span class="line">	diag = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">or</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> presum[bottom_right[<span class="number">0</span>]][bottom_right[<span class="number">1</span>]] - left - top + diag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_presum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">	presum = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">		row_sum = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">			row_sum += grid[i][j]</span><br><span class="line">			presum[i][j] = row_sum + (presum[i - <span class="number">1</span>][j] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> presum</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>`，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Matrix</tag>
        <tag>Uber</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 443 String Compression</title>
    <url>/2021/12/20/lee-443/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-compression/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of characters <code>chars</code>, compress it using the following algorithm:<br><br>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:<br><br><em>   If the group’s length is <code>1</code>, append the character to <code>s</code>.
</em>   Otherwise, append the character followed by the group’s length.<br><br>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.<br><br>After you are done <strong>modifying the input array</strong>, return <em>the new length of the array</em>.<br><br>You must write an algorithm that uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>Explanation:</strong> The groups are “aa”, “bb”, and “ccc”. This compresses to “a2b2c3”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> chars = [“a”]<br><strong>Output:</strong> Return 1, and the first character of the input array should be: [“a”]<br><strong>Explanation:</strong> The only group is “a”, which remains uncompressed since it’s a single character.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br><strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”].<br><strong>Explanation:</strong> The groups are “a” and “bbbbbbbbbbbb”. This compresses to “ab12”.</pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”a”,”b”,”b”,”a”,”a”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”3”,”b”,”2”,”a”,”2”].<br><strong>Explanation:</strong> The groups are “aaa”, “bb”, and “aa”. This compresses to “a3b2a2”. Note that each group is independent even if two groups have the same character.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= chars.length &lt;= 2000</code>
</em>   <code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>相邻相同字母用数字压缩</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目要求，如果是超过10，也要将这个数按多个字符populate到原数组，见populate_count的实现，用字符串处理  </li>
<li>在循环外处理最后一部分    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class="line">	res, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(chars)):</span><br><span class="line">		<span class="keyword">if</span> chars[i - <span class="number">1</span>] == chars[i]:</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">				res = self.populate_count(chars, res, count)</span><br><span class="line">			count = <span class="number">1</span></span><br><span class="line">			chars[res] = chars[i]</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">		res = self.populate_count(chars, res, count)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">populate_count</span><span class="params">(self, chars, res, count)</span>:</span></span><br><span class="line">	num_str = str(count)</span><br><span class="line">	chars[res:res + len(num_str)] = [c <span class="keyword">for</span> c <span class="keyword">in</span> num_str]</span><br><span class="line">	res += len(num_str)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 453 Minimum Moves to Equal Array Elements</title>
    <url>/2021/12/26/lee-453/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.<br><br>In one move, you can increment <code>n - 1</code> elements of the array by <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Only three moves are needed (remember each move increments two elements):<br>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,1]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   The answer is guaranteed to fit in a <strong>32-bit</strong> integer.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最小移动步数使得数组所有数相等。每次移动是将n-1个元素加1</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最小值考虑用DP。但比较难写递归式，以[1, 2, 3]为例，值为3，现在是[1, 2, 3, 6]，由于dp[3]的最终状态为[4, 4, 4], 而最终状态加上新元素为[4, 4, 4, 9], 由6变成9是因为dp[3] = 3，表示移动了3步，新元素6，移动的3步全部参与了，所以变成9<br>由[4, 4, 4, 9], 4变9，需要5步，所以结果dp[4] = dp[3] + 5 = 8  </p>
<p>公式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + (nums[i] + dp[i] - equal_num)  </span><br><span class="line">equal_num = nums[i] + dp[i]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组要排序  </li>
<li>equal_num初始值为nums[0]    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	dp, equal_num = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		dp, equal_num = dp + (n + dp - equal_num), n + dp <span class="comment"># 2</span></span><br><span class="line">	<span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 460 LFU Cache</title>
    <url>/2021/12/05/lee-460/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design and implement a data structure for a <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank" rel="noopener">Least Frequently Used (LFU)</a> cache.<br><br>Implement the <code>LFUCache</code> class:<br><br><em>   <code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.
</em>   <code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.<br><em>   <code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.<br><br>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.<br><br>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.<br><br>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]<br><strong>Output</strong><br>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]<br><br><strong>Explanation</strong><br>// cnt(x) = the use counter for key x<br>// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)<br>LFUCache lfu = new LFUCache(2);<br>lfu.put(1, 1);   // cache=[1,_], cnt(1)=1<br>lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1<br>lfu.get(1);      // return 1<br>                 // cache=[1,2], cnt(2)=1, cnt(1)=2<br>lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.<br>                 // cache=[3,1], cnt(3)=1, cnt(1)=2<br>lfu.get(2);      // return -1 (not found)<br>lfu.get(3);      // return 3<br>                 // cache=[3,1], cnt(3)=2, cnt(1)=2<br>lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.<br>                 // cache=[4,3], cnt(4)=1, cnt(3)=2<br>lfu.get(1);      // return -1 (not found)<br>lfu.get(3);      // return 3<br>                 // cache=[3,4], cnt(4)=1, cnt(3)=3<br>lfu.get(4);      // return 4<br>                 // cache=[3,4], cnt(4)=2, cnt(3)=3<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= capacity &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= key &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= value &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   At most `2 </em> 10<sup>5</sup><code>calls will be made to</code>get<code>and</code>put`.<br><br><span style="display: none;"> </span></div>

<h3 id="双Map-分区LL解题思路-推荐-："><a href="#双Map-分区LL解题思路-推荐-：" class="headerlink" title="双Map+分区LL解题思路(推荐)："></a><strong>双Map+分区LL解题思路(推荐)：</strong></h3><p>类似于LRU，但本质上区别较大。一开始思路可参考算法II，它的缺点是move_up需要从该层的某个位置删除加入到上一个freq较大的下一层的末尾。为了避免此问题，考虑不用单一链表，而是对应不同freq的多个链表。所以引入freq_map来记录每个LL的起点。由于每个LL都是从旧到新（跟LRU一样），新的插入到末尾，删除的从头删除，所以需要是循环链表，最终是一个循环双向LL。ListNode的next和prev都指向自己   </p>
<p>move_up解决了，另一个难点是get_lfu_node，这里引入min_freq来记录当前最小的freq。它的更新由三方面引起:新节点min_freq=1，get的move_up和旧节点move_up。后两者是一样的，都是move_up后查看min_freq所以的LL是否为空。</p>
<p>总结一下与LRU的区别：    </p>
<ul>
<li>set也是三种情况但要更新min_freq  </li>
<li><strong>ListNode多了freq，next prev指向自己形成循环LL，key，val含默认值</strong>  </li>
<li><strong>Cache中多了freq map和min_freq</strong>  </li>
<li>链表操作为move_up和get_lru_node，这点和算法II一样  </li>
<li>节点操作为remove_node, add_to_tail和LRU一样。add_to_tail是分层LL末尾不是总链表末尾  </li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用了一小时debug min_freq的更新，move_up发生时候，<strong>检查min_freq所在的LL</strong>，若为空，增加1，而不是检查node_freq所在的LL。新节点令min_freq变成1  </li>
<li>思路上：LRU是Map to Node in 全局双向LL，而LRU是Map to Node in 分区双向循环LL。存在多条LL，每个LL的起点终点存在freq map中。min_freq记录要删除的LFU节点对应的频率。  </li>
<li>思路上：再LRU基础上增加freq域默认为1，key, val默认为0，prev和next指向自己，形成双向循环LL  </li>
<li>capacity可能为0，LRU那天capacity大于0  </li>
<li>双向LL加入新节点有两个赋值语句，不要忘记node.prev, node.next = predecessor, successor</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.key_to_node = collections.defaultdict(ListNode)</span><br><span class="line">        self.freq_to_head = collections.defaultdict(ListNode)</span><br><span class="line">        self.min_freq = <span class="number">1</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            node = self.key_to_node[key]</span><br><span class="line">            node_freq = node.freq</span><br><span class="line">            self.move_up(node)</span><br><span class="line">            <span class="comment"># if self.freq_to_head[node_freq].next == self.freq_to_head[node_freq]:</span></span><br><span class="line">              <span class="comment">#  self.min_freq = node.freq</span></span><br><span class="line">            <span class="keyword">if</span> self.freq_to_head[self.min_freq].next == self.freq_to_head[self.min_freq]:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            node = self.key_to_node[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_up(node)</span><br><span class="line">            <span class="keyword">if</span> self.freq_to_head[self.min_freq].next == self.freq_to_head[self.min_freq]:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.capacity &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.key_to_node) == self.capacity:</span><br><span class="line">                lru_node = self.get_lru_node()</span><br><span class="line">                self.key_to_node.pop(lru_node.key)</span><br><span class="line">                self.remove_node(lru_node)</span><br><span class="line">            new_node = ListNode(key, value)</span><br><span class="line">            self.add_to_tail(new_node)</span><br><span class="line">            self.key_to_node[key] = new_node</span><br><span class="line">            self.min_freq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_up</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        node.freq += <span class="number">1</span></span><br><span class="line">        self.add_to_tail(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_lru_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        head = self.freq_to_head[self.min_freq]</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        head = self.freq_to_head[node.freq]</span><br><span class="line">        predecessor, successor = head.prev, head</span><br><span class="line">        predecessor.next, successor.prev = node, node</span><br><span class="line">        node.prev, node.next = predecessor, successor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, val=<span class="number">0</span>, freq=<span class="number">1</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.prev = self <span class="comment"># self-pointed</span></span><br><span class="line">        self.next = self</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>Insert时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="类LRU算法II解题思路-不推荐-："><a href="#类LRU算法II解题思路-不推荐-：" class="headerlink" title="类LRU算法II解题思路(不推荐)："></a><strong>类LRU算法II解题思路(不推荐)：</strong></h3><p>似乎Leetcode改变了要求，之前此法是可以通过的，但现在put要求O(1)了，所以TLE了。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>再LRU基础上增加freq域默认为1，新节点插入doubly LL末尾，LL以freq从大到小，同一个频率从最旧到最新(LRU)。所以若满容量要删除节点从freq=1中往前找到该层的首节点  </li>
<li>capacity可能为0，LRU那天capacity大于0  </li>
<li>move_up是往前搜索, it = it.prev而不是用next。比较条件为it.freq &lt; node.freq，加入到同一频率的末尾    </li>
<li>双向LL加入新节点有两个赋值语句，不要忘记node.prev, node.next = predecessor, successor</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.key_to_node = collections.defaultdict(ListNode)</span><br><span class="line">        <span class="comment"># newly inserted to tail</span></span><br><span class="line">        self.head, self.tail = ListNode(<span class="number">0</span>, <span class="number">0</span>), ListNode(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            self.move_up(self.key_to_node[key])</span><br><span class="line">            <span class="keyword">return</span> self.key_to_node[key].val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            self.key_to_node[key].val = value</span><br><span class="line">            self.move_up(self.key_to_node[key])</span><br><span class="line">        <span class="keyword">elif</span> self.capacity &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">if</span> len(self.key_to_node) == self.capacity:</span><br><span class="line">                node = self.get_lfu_node()</span><br><span class="line">                self.key_to_node.pop(node.key)</span><br><span class="line">                self.remove(node)</span><br><span class="line">            new_node = ListNode(key, value)</span><br><span class="line">            self.add_to_tail(new_node)</span><br><span class="line">            self.key_to_node[key] = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_lfu_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        it = self.tail.prev</span><br><span class="line">        min_freq = it.freq</span><br><span class="line">        <span class="keyword">while</span> it != self.head <span class="keyword">and</span> it.freq == min_freq:</span><br><span class="line">            it = it.prev <span class="comment"># remember prev not next</span></span><br><span class="line">        <span class="keyword">return</span> it.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_up</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.freq += <span class="number">1</span></span><br><span class="line">        it = node.prev</span><br><span class="line">        self.remove(node)</span><br><span class="line">        <span class="keyword">while</span> it != self.head <span class="keyword">and</span> it.freq &lt; node.freq: <span class="comment"># remember &lt;=</span></span><br><span class="line">            it = it.prev <span class="comment"># remember prev not next</span></span><br><span class="line">        predecessor, successor = it, it.next</span><br><span class="line">        predecessor.next, successor.prev = node, node</span><br><span class="line">        node.prev, node.next = predecessor, successor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = self.tail.prev, self.tail</span><br><span class="line">        predecessor.next, successor.prev = node, node</span><br><span class="line">        node.prev, node.next = predecessor, successor <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val, freq=<span class="number">1</span>, prev=None, next=None)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>在LRU基础上，ListNode引入freq域， 当频率增加时候，找到新的频率对应的末节点插入。其它基本不变。插入最差是O(n). 要提高的话，需要加入map<freq, listnodehead="">和minFreq来迅速定位下一个插入位置。第一个Map不变，但LL不再是一串，而是按频率大小的多串。          </freq,></li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">ListNode head; <span class="comment">// from most frequent to less</span></span><br><span class="line">ListNode tail;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L460LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">	head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">	tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>, Integer.MIN_VALUE);</span><br><span class="line">	head.next = tail;</span><br><span class="line">	tail.prev = head;</span><br><span class="line">	map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	moveUp(key);</span><br><span class="line">	<span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(capacity == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">		moveUp(key);</span><br><span class="line">		map.get(key).val = value; <span class="comment">// remember to update the value</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(map.size() == capacity) &#123;</span><br><span class="line">			map.remove(tail.prev.key);</span><br><span class="line">			deleteNode(tail.prev);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// add new key</span></span><br><span class="line">		ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">		addNode(newNode, tail);</span><br><span class="line">		map.put(key, newNode);</span><br><span class="line">		moveUp(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveUp</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	ListNode curNode = map.get(key);</span><br><span class="line">	curNode.addOne();</span><br><span class="line">	ListNode iterNode = curNode;</span><br><span class="line">	<span class="keyword">while</span>(iterNode.freq &lt;= curNode.freq)</span><br><span class="line">		iterNode = iterNode.prev;</span><br><span class="line">	<span class="keyword">if</span>(iterNode != curNode) &#123;</span><br><span class="line">		deleteNode(curNode);</span><br><span class="line">		addNode(curNode, iterNode.next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(ListNode curNode, ListNode nextNode)</span> </span>&#123;</span><br><span class="line">	ListNode prevNode = nextNode.prev;</span><br><span class="line">	prevNode.next = curNode;</span><br><span class="line">	curNode.prev = prevNode;</span><br><span class="line">	curNode.next = nextNode;</span><br><span class="line">	nextNode.prev = curNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete head node and updated node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">	ListNode nextNode = curNode.next;</span><br><span class="line">	ListNode prevNode = curNode.prev;</span><br><span class="line">	prevNode.next = nextNode;</span><br><span class="line">	nextNode.prev = prevNode;</span><br><span class="line">	curNode.next = <span class="keyword">null</span>;</span><br><span class="line">	curNode.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> ListNode next;</span><br><span class="line">	<span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val, <span class="keyword">int</span> freq)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.freq = freq;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		freq++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>Insert时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 490 The Maze</title>
    <url>/2021/12/05/lee-490/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/the-maze/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a ball in a <code>maze</code> with empty spaces (represented as <code>0</code>) and walls (represented as <code>1</code>). The ball can go through the empty spaces by rolling <strong>up, down, left or right</strong>, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.<br><br>Given the <code>m x n</code> <code>maze</code>, the ball’s <code>start</code> position and the <code>destination</code>, where <code>start = [start&lt;sub&gt;row&lt;/sub&gt;, start&lt;sub&gt;col&lt;/sub&gt;]</code> and <code>destination = [destination&lt;sub&gt;row&lt;/sub&gt;, destination&lt;sub&gt;col&lt;/sub&gt;]</code>, return <code>true</code> if the ball can stop at the destination, otherwise return <code>false</code>.<br><br>You may assume that <strong>the borders of the maze are all walls</strong> (see examples).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/31/maze1-2-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == maze.length</code>
</em>   <code>n == maze[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 100</code>
</em>   <code>maze[i][j]</code> is <code>0</code> or <code>1</code>.<br><em>   <code>start.length == 2</code>
</em>   <code>destination.length == 2</code><br><em>   <code>0 &lt;= start&lt;sub&gt;row&lt;/sub&gt;, destination&lt;sub&gt;row&lt;/sub&gt; &lt;= m</code>
</em>   <code>0 &lt;= start&lt;sub&gt;col&lt;/sub&gt;, destination&lt;sub&gt;col&lt;/sub&gt; &lt;= n</code><br><em>   Both the ball and the destination exist in an empty space, and they will not be in the same position initially.
</em>   The maze contains <strong>at least 2 empty spaces</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>球在玉米迷宫上滚，当遇到边界或玉米会停下，停下后可以转任意方向。求能否停在目标上。</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>二维数组求目标第一时间想到用BFS，此题求能停下的点而不是所有点。所以属于<strong>一组节点作为一层的BFS</strong>，也就是说只有能停下的位置才算BFS的一层，才加入都队列，其他停不来的点均忽略。这是此题的难点。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>属于<strong>一组节点作为一层的BFS</strong>，能停下的点才加入到queue。比标准模板多了Line 10 - 11. 停下包括边界和<strong>玉米(maze[x][y] == 1</strong>)</li>
<li>要滚回一步Line 12 - 15，因为line 10循环的终结状态为出界或玉米上。要滚回一步到空地上。 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, maze: List[List[int]], start: List[int], destination: List[int])</span> -&gt; bool:</span></span><br><span class="line">	queue = collections.deque([(start[<span class="number">0</span>], start[<span class="number">1</span>])])</span><br><span class="line">	visited = set([(start[<span class="number">0</span>], start[<span class="number">1</span>])])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node[<span class="number">0</span>] == destination[<span class="number">0</span>] <span class="keyword">and</span> node[<span class="number">1</span>] == destination[<span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = node[<span class="number">0</span>], node[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">while</span> <span class="number">0</span> &lt;= x &lt; len(maze) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(maze[<span class="number">0</span>]) <span class="keyword">and</span> maze[x][y] == <span class="number">0</span>: <span class="comment"># remember maze[x][y] == 0</span></span><br><span class="line">				x, y = x + _dx, y + _dy</span><br><span class="line">			<span class="keyword">if</span> (x - _dx, y - _dy) <span class="keyword">in</span> visited: <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((x - _dx, y - _dy))</span><br><span class="line">			visited.add((x - _dx, y - _dy))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 493 Reverse Pairs</title>
    <url>/2018/04/30/lee-493/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-pairs" target="_blank" rel="noopener">LeetCode 493 Reverse Pairs</a></strong></p>
<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>
<p>A reverse pair is a pair <code>(i, j)</code> where <code>0 &lt;= i &lt; j &lt; nums.length</code> and <code>nums[i] &gt; 2 * nums[j]</code>.</p>
<p><strong>Example 1:</strong></p>
<pre>**Input:** nums = [1,3,2,3,1]
**Output:** 2
</pre>

<p><strong>Example 2:</strong></p>
<pre>**Input:** nums = [2,4,3,5,1]
**Output:** 3
</pre>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li><code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组的逆序数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol>
<li>Merge sort模板  </li>
<li>merge分两部分写，一个部分比较求个数，另一部分排序</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>merge分两部分写，一个部分比较，另一部分排序</li>
<li>计算个数由两部分组成，两指针部分和剩余元素部分。若以后半数组为主，就是前半数组指针i的后面个数(程序用此)<br> 若以前半数组为主(加入到res时候)，就是后半数组指针j的前面个数</li>
<li>nums[start:end+1] = res，前面是nums不是res</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> self.m_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m_sort</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	count += self.m_sort(nums, start, mid)</span><br><span class="line">	count += self.m_sort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">	count += self.merge(nums, start, mid, end)</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, start, mid, end)</span>:</span></span><br><span class="line">	i, j, res, count = start, mid + <span class="number">1</span>, [], <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= <span class="number">2</span> * nums[j]:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			count += mid - i + <span class="number">1</span></span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= end:</span><br><span class="line">		count += mid - i + <span class="number">1</span></span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	i, j, res = start, mid + <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">			res.append(nums[i])</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(nums[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">		res.append(nums[i])</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= end:</span><br><span class="line">		res.append(nums[j])</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	nums[start:end + <span class="number">1</span>] = res</span><br><span class="line">	<span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>。   </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Python KB</tag>
        <tag>Divide and Conquer</tag>
        <tag>Merge Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 503 Next Greater Element II</title>
    <url>/2018/01/28/lee-503/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/next-greater-element-ii" target="_blank" rel="noopener">LeetCode 503 Next Greater Element II</a></strong></p>
<p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<p><strong>Example 1:</strong>  </p>
<pre><b>Input:</b> [1,2,1]
<b>Output:</b> [2,-1,2]
<b>Explanation:</b> The first 1's next greater number is 2;   
The number 2 can't find next greater number;   
The second 1's next greater number needs to search circularly, which is also 2.
</pre>

<p><strong>Note:</strong> The length of given array won’t exceed 10000.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个循环数组（末尾元素的下一个元素为起始元素），输出每一个元素的下一个更大的数字（Next Greater Number）。Next Greater Number是指位于某元素右侧，大于该元素，且距离最近的元素。如果不存在这样的元素，则输出-1。</p>
<p>注意：给定数组长度不超过10000。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最直接的思路是遍历每个元素，对每个元素，遍历它的后面所有元素。最差情况是递减数列，时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>。<br>这题关于局部递增数组，所以考虑用递减栈。首先不考虑循环数组的情况，例如8,5,4,6,栈存入8,5,4，当6准备进栈时，5,4比6小，它们都出栈且它们的结果集为6。<br>循环数组其实只要将原数组复制一倍，按原算法处理，结果集取前n个元素即可。</p>
<ol>
<li>栈不为空，准入栈元素逼出比其小的元素且赋予其结果。</li>
<li>该元素入栈。、</li>
<li>栈剩下元素的结果集赋值为-1</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>栈存储元素下标，结果集存储元素值。</li>
<li>栈剩下元素的结果集赋值为-1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	num_list = nums * <span class="number">2</span></span><br><span class="line">	result, stack = [<span class="number">0</span>] * len(num_list), []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(num_list)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> num_list[i] &gt; num_list[stack[<span class="number">-1</span>]]:</span><br><span class="line">			index = stack.pop()</span><br><span class="line">			result[index] = num_list[i]</span><br><span class="line">		stack.append(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> stack:</span><br><span class="line">		index = stack.pop()</span><br><span class="line">		result[index] = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">return</span> result[:len(nums)]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">	<span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span>[] re2 = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++)&#123;</span><br><span class="line">		nums2[i] = nums[i%nums.length];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!s.isEmpty() &amp;&amp; nums2[i]&gt;nums2[(<span class="keyword">int</span>)s.peek()])&#123;</span><br><span class="line">			<span class="keyword">int</span> topIdx = (<span class="keyword">int</span>)s.pop();</span><br><span class="line">			re2[topIdx] = nums2[i];</span><br><span class="line">		&#125;</span><br><span class="line">		s.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">		<span class="keyword">int</span> topIdx = (<span class="keyword">int</span>)s.pop();</span><br><span class="line">		re2[topIdx] = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] re = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">		re[i] = re2[i];</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
<p>有人考虑用TreeMap，<br> 2<br>1 3<br>但TreeMap不能保留顺序，如这个TreeMap可以对应两种数组,[2,1,3], [2,3,1]并非一一对应。</p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol>
<li>Given an integer array, print the Next Greater Number for every element.先从不循环数组考起。<br>3,8,5,4,6,7 =&gt; 8,-1,6,6,7,-1</li>
<li>先让其写出暴力法brute force</li>
<li>再优化，第0个提示是考虑用一些数据结构，第一个提示为Stack。第二个提示，给定两个stack，怎么排序一个数组。如1,4,3,2.<br>一个stack用于维护当前递增栈，另一个用于缓冲。过程：栈1从底到顶14，3准入，因为比4小，不能维持递增顺序，4入栈2，然后3入栈1，再把栈2所有元素入栈1。同理4,3入栈2,2入栈1。</li>
<li>最后如果是循环数组circular array，如果解决。<br>3,8,5,4,6,7 =&gt; 8,-1,6,6,7,8</li>
<li>第一个层次暴力法，第二层次思路从第二个提示到联系到此题解法，Meets bar。最后能实现且解决follow-up，raise bar。</li>
</ol>
]]></content>
      <tags>
        <tag>Interviewer</tag>
        <tag>Python KB</tag>
        <tag>Classic</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 516 Longest Palindromic Subsequence</title>
    <url>/2021/12/05/lee-516/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, find <em>the longest palindromic <strong>subsequence</strong>‘s length in</em> <code>s</code>.<br><br>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bbbab”<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> One possible longest palindromic subsequence is “bbbb”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “cbbd”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> One possible longest palindromic subsequence is “bb”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 1000</code>
</em>   <code>s</code> consists only of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串中最长回文序列</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始看到子序列如LIS就想用DP，dp[i]表示以s[i]为结尾的最长回文子序列。但不容易推导公式，难点是没有限制左边界<br>所以应该扩展到二维dp[i][j]表示[i, j]之间的最长回文子序列。公式就简单多了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] + 2,             s[i] == s[j]</span><br><span class="line">         = max(dp[i+1][j], dp[i][j-1]),  s[i] != s[j]</span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>难点是想到用二维DP(区间型DP)。用区间型递归模板，注意dp[i + 1][j]并不是i - 1</li>
<li>初始值为dp[i][i] = 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		dp[i][i] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - k):</span><br><span class="line">			j = i + k</span><br><span class="line">			<span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">				dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*n)</code>，空间复杂度<code>O(n*n)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 526 Beautiful Arrangement</title>
    <url>/2021/12/26/lee-526/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Suppose you have <code>n</code> integers labeled <code>1</code> through <code>n</code>. A permutation of those <code>n</code> integers <code>perm</code> (<strong>1-indexed</strong>) is considered a <strong>beautiful arrangement</strong> if for every <code>i</code> (<code>1 &lt;= i &lt;= n</code>), <strong>either</strong> of the following is true:<br><br><em>   <code>perm[i]</code> is divisible by <code>i</code>.
</em>   <code>i</code> is divisible by <code>perm[i]</code>.<br><br>Given an integer <code>n</code>, return <em>the <strong>number</strong> of the <strong>beautiful arrangements</strong> that you can construct</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>The first beautiful arrangement is [1,2]:<br>    - perm[1] = 1 is divisible by i = 1<br>    - perm[2] = 2 is divisible by i = 2<br>The second beautiful arrangement is [2,1]:<br>    - perm[1] = 2 is divisible by i = 1<br>    - i = 2 is divisible by perm[2] = 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 15</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组中所有排列中下标（从1开始）和数值能整除（下标整除数值或反之）的个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑用DP，因为求个数且类似于L368 Largest Divisible Subset，但问题与子问题的具体排位有关，所以DP不可行。考虑用Stack，但数组顺序可变。<br>只能用暴力法，也就是DFS中排列求解  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用排列模板，但此题不涉及具体数组。用set来记录访问过的数值而不是下标，start来记录模拟结果path中的位置    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> self.permute(n, <span class="number">1</span>, set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, n, start, visited)</span>:</span> <span class="comment"># 2, 1, [F,F,F]</span></span><br><span class="line">	<span class="keyword">if</span> start == n + <span class="number">1</span>: <span class="comment"># remember n + 1</span></span><br><span class="line">		<span class="comment">#print(path)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	res = <span class="number">0</span> <span class="comment"># 1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># [1,3)</span></span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> i % start == <span class="number">0</span> <span class="keyword">or</span> start % i == <span class="number">0</span>:</span><br><span class="line">			visited.add(i)</span><br><span class="line">			<span class="comment">#path.append(i)</span></span><br><span class="line">			res += self.permute(n, start + <span class="number">1</span>, visited) <span class="comment"># 2, 2, [FFT]</span></span><br><span class="line">			<span class="comment">#path.pop()</span></span><br><span class="line">			visited.remove(i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 528 Random Pick with Weight</title>
    <url>/2021/12/14/lee-528/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> index.<br><br>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.<br><br><em>   For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”]<br>[[[1]],[]]<br><strong>Output</strong><br>[null,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1]);<br>solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”]<br>[[[1,3]],[],[],[],[],[]]<br><strong>Output</strong><br>[null,1,1,1,1,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1, 3]);<br>solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.<br><br>Since this is a randomization problem, multiple answers are allowed.<br>All of the following outputs can be considered correct:<br>[null,1,1,1,1,0]<br>[null,1,1,1,1,1]<br>[null,1,1,1,0,0]<br>[null,1,1,1,0,1]<br>[null,1,0,1,0,0]<br>……<br>and so on.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= w.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>1 &lt;= w[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>pickIndex</code> will be called at most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> times.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据数组每个元素的weight来决定其出现的概率： weight/sum of weight  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>模拟运算过程，先求和，然后根据上述公式分配概率： 如[1, 3], 小于0.25属于第一个元素，大于属于后一个元素，我们不用小数，还原回整数<br>所以数值小于1属于第一个元素，大于1小于4属于后一个，想到用presum，然后在presum搜索某个value，就想到二分法。  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>random.randint前闭后闭      </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, w: List[int])</span>:</span></span><br><span class="line">        self.presum = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> w:</span><br><span class="line">            sum += n</span><br><span class="line">            self.presum.append(sum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        rand_value = random.randint(<span class="number">0</span>, self.presum[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect(self.presum, rand_value)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1ogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
        <tag>Randomized</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 529 Minesweeper</title>
    <url>/2021/12/25/lee-529/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Let’s play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game" target="_blank" rel="noopener">Wikipedia</a>), <a href="http://minesweeperonline.com" target="_blank" rel="noopener">online game</a>)!<br><br>You are given an <code>m x n</code> char matrix <code>board</code> representing the game board where:<br><br><em>   <code>&#39;M&#39;</code> represents an unrevealed mine,
</em>   <code>&#39;E&#39;</code> represents an unrevealed empty square,<br><em>   <code>&#39;B&#39;</code> represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
</em>   digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) represents how many mines are adjacent to this revealed square, and<br><em>   <code>&#39;X&#39;</code> represents a revealed mine.<br><br>You are also given an integer array <code>click</code> where <code>click = [click&lt;sub&gt;r&lt;/sub&gt;, click&lt;sub&gt;c&lt;/sub&gt;]</code> represents the next click position among all the unrevealed squares (<code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>).<br><br>Return <em>the board after revealing this position according to the following rules</em>:<br><br>1.  If a mine <code>&#39;M&#39;</code> is revealed, then the game is over. You should change it to <code>&#39;X&#39;</code>.<br>2.  If an empty square <code>&#39;E&#39;</code> with no adjacent mines is revealed, then change it to a revealed blank <code>&#39;B&#39;</code> and all of its adjacent unrevealed squares should be revealed recursively.<br>3.  If an empty square <code>&#39;E&#39;</code> with at least one adjacent mine is revealed, then change it to a digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) representing the number of adjacent mines.<br>4.  Return the board when no more squares will be revealed.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“E”,”E”,”E”,”E”,”E”],[“E”,”E”,”M”,”E”,”E”],[“E”,”E”,”E”,”E”,”E”],[“E”,”E”,”E”,”E”,”E”]], click = [3,0]<br><strong>Output:</strong> [[“B”,”1”,”E”,”1”,”B”],[“B”,”1”,”M”,”1”,”B”],[“B”,”1”,”1”,”1”,”B”],[“B”,”B”,”B”,”B”,”B”]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“B”,”1”,”E”,”1”,”B”],[“B”,”1”,”M”,”1”,”B”],[“B”,”1”,”1”,”1”,”B”],[“B”,”B”,”B”,”B”,”B”]], click = [1,2]<br><strong>Output:</strong> [[“B”,”1”,”E”,”1”,”B”],[“B”,”1”,”X”,”1”,”B”],[“B”,”1”,”1”,”1”,”B”],[“B”,”B”,”B”,”B”,”B”]]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == board.length</code><br><em>   <code>n == board[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 50</code><br><em>   <code>board[i][j]</code> is either <code>&#39;M&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;B&#39;</code>, or a digit from <code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>.
</em>   <code>click.length == 2</code><br><em>   <code>0 &lt;= click&lt;sub&gt;r&lt;/sub&gt; &lt; m</code>
</em>   <code>0 &lt;= click&lt;sub&gt;c&lt;/sub&gt; &lt; n</code><br>*   <code>board[click&lt;sub&gt;r&lt;/sub&gt;][click&lt;sub&gt;c&lt;/sub&gt;]</code> is either <code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定扫雷版上的某一个状态，计算扫雷版上的下一个状态</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三种情况： 1. 踩雷，只需更改此格。 2. 踩到数字格也就是雷相邻的格，计算此格的临近雷数，更改此格。 3. 从此格开始BFS访问全版，节点出列后如果是数字格不加入到queue中，否则继续BFS访问，更改此格。     </li>
<li>x, y = node[0] + _dx, node[1] + _dy用node[0], node[1]不要用i, j  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span><span class="params">(self, board: List[List[str]], click: List[int])</span> -&gt; List[List[str]]:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>:</span><br><span class="line">		board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span></span><br><span class="line">		<span class="keyword">return</span> board</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		mine_num = self.get_neighboring_mine_num(board, click[<span class="number">0</span>], click[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> mine_num &gt; <span class="number">0</span>:</span><br><span class="line">			board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = str(mine_num)</span><br><span class="line">			<span class="keyword">return</span> board</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> self.bfs(board, click[<span class="number">0</span>], click[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">	queue = collections.deque([(i, j)])</span><br><span class="line">	visited = set([(i, j)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		mine_num = self.get_neighboring_mine_num(board, node[<span class="number">0</span>], node[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> mine_num &gt; <span class="number">0</span>:</span><br><span class="line">			board[node[<span class="number">0</span>]][node[<span class="number">1</span>]] = str(mine_num)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			board[node[<span class="number">0</span>]][node[<span class="number">1</span>]] = <span class="string">'B'</span></span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = node[<span class="number">0</span>] + _dx, node[<span class="number">1</span>] + _dy <span class="comment"># remember not to use i, j</span></span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= len(board) <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> (x, y) <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((x, y))</span><br><span class="line">			visited.add((x, y))</span><br><span class="line">	<span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_neighboring_mine_num</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">	num = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">		x, y = i + _dx, j + _dy</span><br><span class="line">		<span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[x][y] == <span class="string">'M'</span>:</span><br><span class="line">			num += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Matrix</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 540 Single Element in a Sorted Array</title>
    <url>/2019/02/26/lee-540/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/single-element-in-a-sorted-array" target="_blank" rel="noopener">LeetCode 540 Single Element in a Sorted Array</a></strong></p>
<p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p>
<p><strong>Example 1:</strong>  </p>
<pre>**Input:** [1,1,2,3,3,4,4,8,8]
**Output:** 2
</pre>

<p><strong>Example 2:</strong>  </p>
<pre>**Input:** [3,3,7,7,10,11,11]
**Output:** 10
</pre>

<p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个有序数组中，每个数字都出现了两次，只有一个数字出现了一次，求出现一次的数字。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是A公司Problem solving的题目。类似于L136。此题数组有序且要求O(logn)时间，所以考虑用二分法。由于没有输入tgt，有点似<br>算法文档中用二分法求峰值，就是比较相邻两个数做二分法。考虑一个结论，若数组为偶数个数，就一定不存在只出现一次的元素。<br>所以必须考虑奇偶位，若下标mid为偶数，其后一位与其相等，就一定在右半边搜索left=mid+2(不会是mid和mid+1)，如第二个<br>例子，因为mid左边个数为偶数，利用结论可知不会在左边。同理与后一位不等，搜左边right=mid(可能为mid)。注意边界。<br>若mid为奇数，mid前面有奇数个，mid包括自己的后面有偶数个，所以mid和mid+1上的数相等，就应在左半搜，所以与偶数位的<br>情况正好相反，但是边界不同，产生了4个if语句。<br>法二：改进一下，若mid为奇数位，就mid–归结为偶数位的情况，这样if变成两个。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>类似于Leetcode 033，四种情况，前两种中的第二种全包第一种。  </li>
<li>for循环后，答案一定在start和end其中一个。end前面有偶数个与start不同就肯定在start上。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">		mid = start + (end - start) //<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> mid &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[mid - <span class="number">1</span>] == nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">elif</span> mid % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">			end = mid</span><br><span class="line">		<span class="keyword">elif</span> mid % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> mid &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[mid - <span class="number">1</span>] != nums[mid]:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">if</span> end % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> nums[start] != nums[end]:</span><br><span class="line">		<span class="keyword">return</span> nums[start] <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>边界也就是mid的赋值，写出例子来理解。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = nums.length;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = N - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">		<span class="keyword">boolean</span> isEven = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) isEven = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> ((isEven &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>]) )</span><br><span class="line">			right = mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isEven &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">			left = mid + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!isEven &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">			right = mid-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">int</span> N = nums.length;</span><br><span class="line">	  <span class="keyword">int</span> left = <span class="number">0</span>, right = N - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		  <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">		  <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) mid--;</span><br><span class="line">		  <span class="keyword">if</span> (nums[mid] != nums[mid + <span class="number">1</span>])</span><br><span class="line">			  right = mid;</span><br><span class="line">		  <span class="keyword">else</span></span><br><span class="line">			  left = mid + <span class="number">2</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。  </p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>首先问L316 Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br>XOR解法，不用实现。<br>Follow up问题是L260 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.<br>分三步。若只有一个数出现1次，只要把所有数异或^即可(相同数异或=0)。如果有两个此数，异或结果是这两数不同的位。只要选为1且最低位(或任意为1的位)lowBit=a-(a&amp;(a-1))。再扫所有数，根据它们在lowBit上=0和=1分组异或num1, num2，最后分组异或后它们为所求</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Interviewer</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 560 Subarray Sum Equals K</title>
    <url>/2021/12/13/lee-560/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,1], k = 2<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3], k = 3<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 2 </em> 10<sup>4</sup><code>*</code>-1000 &lt;= nums[i] &lt;= 1000<code>*</code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>子数组和等于k的个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>子数组和第一时间想到presum，而数组元素之间关系也应该想到two sum  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>加0到presum中或者加0到sum_to_idx字典中，确保presum本身可以等于k     </li>
<li>数组含负数，也即是presum中可以含有多个相同的值，所以sum_to_idx要转成频数而不是下标。如[-1, 1, -1, 1], k=0结果为4，而不是3, 容易漏整个数组和     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># presum = [0, 1, 2, 3], target = presum[i] - k = presum[j]</span></span><br><span class="line"><span class="comment"># add 0 to presum so that presum[i] = k</span></span><br><span class="line"><span class="comment"># [0, -1, 0, -1, 0]</span></span><br><span class="line"><span class="comment"># [0, 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	presum, res = [<span class="number">0</span>], <span class="number">0</span> <span class="comment">#</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		presum.append(presum[<span class="number">-1</span>] + n) <span class="comment"># 0, 1, 2, 3</span></span><br><span class="line">	sum_to_idx = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(presum)): <span class="comment">#</span></span><br><span class="line">		<span class="keyword">if</span> presum[i] - k <span class="keyword">in</span> sum_to_idx: <span class="comment"># 1-1</span></span><br><span class="line">			res += sum_to_idx[presum[i] - k] <span class="comment">#4</span></span><br><span class="line">		sum_to_idx[presum[i]] += <span class="number">1</span> <span class="comment"># &#123;0:2, -1:2, 2:2&#125;</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 557 Reverse Words in a String III</title>
    <url>/2017/11/02/lee-557/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">LeetCode 557 Reverse Words in a String III</a></strong></p>
<p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<p><strong>Example 1:</strong></p>
<pre>Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
</pre>

<p><strong>Note:</strong>In the string, each word is separated by single space and there will not be any extra space in the string.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定字符串，将每个单词逐字符逆置，返回新字符串。注意：字符串中单词之间有且只有1个空格分开。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这里考到StringBuilder，对于字符串连接效率高。还有一个小技巧，就是往输入参数附加一个空格，这样for循环结束后不用特别处理边界情况。<br>第一种方法是以单词为扫描单位，把字符串分成单词字符串数组，然后把每个单词反转及一个空格加入到结果sb中。<br>第二种方法是以字符为扫描单位，遇到空格是，就把之前存入的word放入sb中，再进行下一轮word扫描。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用StringBuilder</li>
<li>末尾加入空格</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><p>第一种方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	String[] tokens = s.split(<span class="string">" "</span>);</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">for</span>(String token : tokens)</span><br><span class="line">		sb.append(<span class="keyword">new</span> StringBuilder(token).reverse().toString()+<span class="string">" "</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	s = s+<span class="string">" "</span>;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">		<span class="keyword">if</span>(c!=<span class="string">' '</span>)</span><br><span class="line">			word.append(c);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sb.append(word.reverse().toString()+<span class="string">" "</span>);</span><br><span class="line">			word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为字符串长度。第一种方法空间复杂度为<code>O(n)</code>，而第二种方法为<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 572 Subtree of Another Tree</title>
    <url>/2018/01/29/lee-572/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/subtree-of-another-tree" target="_blank" rel="noopener">LeetCode 572 Subtree of Another Tree</a></strong></p>
<p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p>
<p><strong>Example 1:</strong><br>Given tree s:</p>
<pre>     3
    / \
   4   5
  / \
 1   2
</pre>

<p>Given tree t:</p>
<pre>   4 
  / \
 1   2
</pre>

<p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p>
<p><strong>Example 2:</strong><br>Given tree s:</p>
<pre>     3
    / \
   4   5
  / \
 1   2
    /
   0
</pre>

<p>Given tree t:</p>
<pre>   4
  / \
 1   2
</pre>

<p>Return <strong>false</strong>.</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个非空二叉树s和t，判断t是否是s的子树。s的子树是指由s中某节点及该节点的所有子节点构成的二叉树。<br>特别的，s是其本身的子树。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是A公司的题目。DFS解题：</p>
<ol>
<li>s树的每一个节点与t树的根节点比较，若值相等进行下一步。</li>
<li>s树的某节点为根的子树和t树进行结构+值比较。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>s=null和t=null，是子树</li>
<li>s和t任一为空，另一个不为空，不是子树。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isSame(s, t))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> s!=<span class="keyword">null</span> &amp;&amp; (isSubtree(s.left, t) || isSubtree(s.right, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode root, TreeNode root2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> root.val==root2.val &amp;&amp; isSame(root.left,root2.left) &amp;&amp; isSame(root.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>，n和m分别为s数和t数大小。</p>
<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>如果s是BST，怎么改进算法？<br>二分法先找到s的节点值等于t根节点值的节点再比较。时间复杂度为<code>O(logn+m)</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(TreeNode t, TreeNode node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> result = t.compareTo(node.val);</span><br><span class="line">	<span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> contains(t, node.right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> contains(t, node.left);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若BST不是严格递增 (allow duplicates)，多比较几个相等节点即可。</p>
]]></content>
      <tags>
        <tag>Interviewer</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 588 Design In-Memory File System</title>
    <url>/2021/12/16/lee-588/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-in-memory-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a data structure that simulates an in-memory file system.<br><br>Implement the FileSystem class:<br><br><em>   <code>FileSystem()</code> Initializes the object of the system.
</em>   <code>List&lt;String&gt; ls(String path)</code><br>    <em>   If <code>path</code> is a file path, returns a list that only contains this file’s name.
    </em>   If <code>path</code> is a directory path, returns the list of file and directory names <strong>in this directory</strong>.The answer should in <strong>lexicographic order</strong>.<br><em>   <code>void mkdir(String path)</code> Makes a new directory according to the given <code>path</code>. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.
</em>   <code>void addContentToFile(String filePath, String content)</code><br>    <em>   If <code>filePath</code> does not exist, creates that file containing given <code>content</code>.
    </em>   If <code>filePath</code> already exists, appends the given <code>content</code> to original content.<br><em>   <code>String readContentFromFile(String filePath)</code> Returns the content in the file at <code>filePath</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/28/filesystem.png" alt=""><br><br><pre><strong>Input</strong><br>[“FileSystem”, “ls”, “mkdir”, “addContentToFile”, “ls”, “readContentFromFile”]<br>[[], [“/“], [“/a/b/c”], [“/a/b/c/d”, “hello”], [“/“], [“/a/b/c/d”]]<br><strong>Output</strong><br>[null, [], null, null, [“a”], “hello”]<br><br><strong>Explanation</strong><br>FileSystem fileSystem = new FileSystem();<br>fileSystem.ls(“/“);                         // return []<br>fileSystem.mkdir(“/a/b/c”);<br>fileSystem.addContentToFile(“/a/b/c/d”, “hello”);<br>fileSystem.ls(“/“);                         // return [“a”]<br>fileSystem.readContentFromFile(“/a/b/c/d”); // return “hello”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= path.length, filePath.length &lt;= 100</code><br><em>   <code>path</code> and <code>filePath</code> are absolute paths which begin with <code>&#39;/&#39;</code> and do not end with <code>&#39;/&#39;</code> except that the path is just <code>&quot;/&quot;</code>.
</em>   You can assume that all directory names and file names only contain lowercase letters, and the same names will not exist in the same directory.<br><em>   You can assume that all operations will be passed valid parameters, and users will not attempt to retrieve file content or list a directory or file that does not exist.
</em>   <code>1 &lt;= content.length &lt;= 50</code><br>*   At most <code>300</code> calls will be made to <code>ls</code>, <code>mkdir</code>, <code>addContentToFile</code>, and <code>readContentFromFile</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统 </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>如数据库系统的B+树一样，用Trie</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>TrieNode含children和files，都是dict，<strong>只能是目录节点</strong>。因为不知道最后一个路劲部分是文件还是目录，所以ls里面需要遍历直到倒数第二个节点，再判断是哪种情况。另一个种设计是采取is_file, content，既可以是目录节点也可以是文件节点，本文采取前者     </li>
<li>ls:题目要求目录可以含目录和文件。两种情况：若是文件，返回[文件]含在一个list中；若是目录，返回它下面的目录+文件  </li>
<li>ls:返回结果要排序  </li>
<li>ls:输入path可以是/或/a/b，所以/要特殊化处理，只能是目录，所以只有一种情况：目录和文件    </li>
<li>_dir而不是dir, path而不是filepath，注意变量要用同一个</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ls</span><span class="params">(self, path: str)</span> -&gt; List[str]:</span>  <span class="comment"># req remember /a not /a/</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(self.root.children.keys()) + list(self.root.files.keys())) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">        dirs = path[<span class="number">1</span>:].split(<span class="string">'/'</span>)</span><br><span class="line">        it = self._ls(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dirs[<span class="number">-1</span>] <span class="keyword">in</span> it.files:</span><br><span class="line">            <span class="keyword">return</span> [dirs[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># return files if no dir, no mixed types in same dir</span></span><br><span class="line">            <span class="keyword">return</span> sorted(list(it.children[dirs[<span class="number">-1</span>]].children.keys()) + list(it.children[dirs[<span class="number">-1</span>]].files.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(self, path: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        path = path[<span class="number">1</span>:]</span><br><span class="line">        dirs = path.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        self._mkdir(dirs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addContentToFile</span><span class="params">(self, filePath: str, content: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self._mkdir(dirs[:<span class="number">-1</span>])</span><br><span class="line">        filename = dirs[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">not</span> <span class="keyword">in</span> it.files:</span><br><span class="line">            it.files[filename] = <span class="string">''</span></span><br><span class="line">        it.files[filename] += content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readContentFromFile</span><span class="params">(self, filePath: str)</span> -&gt; str:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>)  <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self._ls(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> it.files[dirs[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ls</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> _dir <span class="keyword">in</span> dirs:</span><br><span class="line">            it = it.children[_dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_mkdir</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> _dir <span class="keyword">in</span> dirs:</span><br><span class="line">            it = it.children[_dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.files = collections.defaultdict(str) <span class="comment"># use dict coz filename can't be duplicate and faster for lookup</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>, n为路径长度  </p>
]]></content>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 658 Find K Closest Elements</title>
    <url>/2018/01/28/lee-658/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-k-closest-elements" target="_blank" rel="noopener">LeetCode 658 Find K Closest Elements</a></strong></p>
<p>Given a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p>
<p><strong>Example 1:</strong>  </p>
<pre><b>Input:</b> [1,2,3,4,5], k=4, x=3
<b>Output:</b> [1,2,3,4]
</pre>

<p><strong>Example 2:</strong>  </p>
<pre><b>Input:</b> [1,2,3,4,5], k=4, x=-1
<b>Output:</b> [1,2,3,4]
</pre>

<p><strong>Note:</strong>  </p>
<ol>
<li>The value k is positive and will always be smaller than the length of the sorted array.</li>
<li>Length of the given array is positive and will not exceed 10<sup>4</sup></li>
<li>Absolute value of elements in the array and x will not exceed 10<sup>4</sup></li>
</ol>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个排序数组，两个整数k和x，求数组中距离x最近的k个数字。结果应该有序，距离相同时优先选择较小的数字。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol>
<li>进阶二分法找出第一个大于等于key值的元素。</li>
<li>左右两指针搜索k个元素。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>指针不能越界</li>
<li>根据题意，与key距离一样时，取较小元素。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> upperIdx = firstEqualOrGreater(arr, x);</span><br><span class="line">	<span class="keyword">int</span> lowerIdx = upperIdx-<span class="number">1</span>;</span><br><span class="line">	List result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(lowerIdx&lt;<span class="number">0</span>)</span><br><span class="line">			result.add(arr[upperIdx++]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(upperIdx&gt;=arr.length)</span><br><span class="line">			result.add(arr[lowerIdx--]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x-arr[lowerIdx]&lt;=arr[upperIdx]-x)</span><br><span class="line">			result.add(arr[lowerIdx--]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			result.add(arr[upperIdx++]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Collections.sort(result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstEqualOrGreater</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lo = <span class="number">0</span>, hi = a.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid =  lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;key)</span><br><span class="line">			lo = mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			hi = mid-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn+k)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 678 Valid Parenthesis String</title>
    <url>/2021/12/08/lee-678/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> containing only three types of characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> and <code>&#39;*&#39;</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.<br><br>The following rules define a <strong>valid</strong> string:<br><br><em>   Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.
</em>   Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.<br><em>   Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.
</em>   <code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “()”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “(<em>)”<br><strong>Output:</strong> true<br></em></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “())”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 100</code>
</em>   <code>s[i]</code> is <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> or <code>&#39;*&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求给定字符串带星号是否合法括号配对。</p>
<h3 id="Stack算法思路-推荐-："><a href="#Stack算法思路-推荐-：" class="headerlink" title="Stack算法思路(推荐)："></a><strong>Stack算法思路(推荐)：</strong></h3><p>括号题优先考虑用Stack。如果不带星号，回忆合法括号题，有三种不合法情况，此题只需考虑两种，不需考虑多种括号类型<br>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空)<br>难点： </p>
<ol>
<li>在于要去想<strong>多一个栈来存星号</strong>，因为星号可以作为左括号备选去match右括号。右括号在两个栈中优先配对左括号，星号可以为空。如果两个栈均为空，处理了第一种不合法情况  </li>
<li>循环后，如果两栈有余，分4中情况讨论：<br>1) 左括号栈有余星号栈空，正是第二种不合法情况<br>2) 左括号栈空星号栈空，合法<br>3) 左括号栈空星号栈有余，合法，星号可为空<br>4) 都有余，这是难点二。星号可以作为右括号去配对左括号，前提条件是<strong>星号在左括号之后</strong>，考虑*(，这是不合法 </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>如果for循环出来后，两栈不为空，要比较先后顺序  </li>
<li>for loop后，L18 - Line 19记得pop，否则死循环  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	stack_left, stack_star = [], []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">			stack_left.append(i)</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'*'</span>:</span><br><span class="line">			stack_star.append(i)</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">if</span> stack_left:  <span class="comment"># match ( first rather than * because * can be empty</span></span><br><span class="line">				stack_left.pop()</span><br><span class="line">			<span class="keyword">elif</span> stack_star:</span><br><span class="line">				stack_star.pop()</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">while</span> stack_left <span class="keyword">and</span> stack_star:  <span class="comment"># use * to match (</span></span><br><span class="line">		<span class="keyword">if</span> stack_left[<span class="number">-1</span>] &gt; stack_star[<span class="number">-1</span>]:  <span class="comment"># consider *(</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		stack_left.pop()</span><br><span class="line">		stack_star.pop()</span><br><span class="line">	<span class="keyword">return</span> len(stack_left) == <span class="number">0</span>  <span class="comment"># stack_star can be non empty</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="统计算法II解题思路："><a href="#统计算法II解题思路：" class="headerlink" title="统计算法II解题思路："></a><strong>统计算法II解题思路：</strong></h3><p>括号题另一个常用思路是用统计左右括号数。此题较难想到是用一个<strong>左括号数量范围</strong>去验证。<br>lo为左括号的最少合法个数，hi为左括号的最大合法个数，有范围是因为星号可以变成左右括号或空。<br>遇到左括号，都加1，遇到右括号，都减1，遇到星号，假设星号为右括号，所以lo减1，hi加1.<br>如果hi小于0，表示最大左括号数小于右括号数，不满足此法的规则一，不合法  </p>
<p>难点在于<strong>lo设为非负</strong>。因为lo是最少且合法，合法意思是lo不是单纯地将所有星号变成右括号，而是当左括号不足时，用提高下限，将星号变成空，体现在令lo为非负。<br>for循环后，lo必须为0，运用了法则二，左右括号相等。  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	lo = hi = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			lo += <span class="number">1</span></span><br><span class="line">			hi += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'*'</span>:</span><br><span class="line">			<span class="keyword">if</span> lo &gt; <span class="number">0</span>:  <span class="comment"># treat * as empty space</span></span><br><span class="line">				lo -= <span class="number">1</span></span><br><span class="line">			hi += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">if</span> lo &gt; <span class="number">0</span>:  <span class="comment"># treat the previous * as empty space</span></span><br><span class="line">				lo -= <span class="number">1</span></span><br><span class="line">			hi -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> hi &lt; <span class="number">0</span>:  <span class="comment"># the num of right parenthesis &gt; left ones</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> lo == <span class="number">0</span>  <span class="comment"># the num of right parenthesis should equal to left ones</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="DP算法III解题思路："><a href="#DP算法III解题思路：" class="headerlink" title="DP算法III解题思路："></a><strong>DP算法III解题思路：</strong></h3><p>基本情况为s[i], s[j] 分别在(*, )* 就合法<br>如果用单边DP，并不能确定区间内那些合法，所以只能用区间型DP<br>dp[i][j] = s[i-1] == ‘*‘ and dp[i+1][j] 星号不匹配<br>         = s[i-1] in ‘(*‘ and dp[i+1][k-1] and s[k-1] in (‘)*‘) and dp[k+1][j] 星号匹配  </p>
<p>具体参考leetcode答案<br>DP基本情况比较难想出来且递归是复杂，实现易错，不推荐。不过可以多了解区间型DP的模式  </p>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^3)</code>，空间复杂度<code>O(n^2)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 680 Valid Palindrome II</title>
    <url>/2021/12/16/lee-680/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, return <code>true</code> <em>if the</em> <code>s</code> <em>can be palindrome after deleting <strong>at most one</strong> character from it</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aba”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abca”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You could delete the character ‘c’.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “abc”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s</code> consists of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>删除一个字符变成回文字符串 </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是O(n^2)，要优化到O(n)且这是关于元素之间的关系，考虑用Two pointers</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>当发现不相等的字符，不能简单认为s[i + 1] == s[j]就觉得应该删除左边字符，因为可能是刚好相等，如bddbd，第一个b和倒数第二个b相等，如果删除第一个b，就会得到False，所以应该<strong>删除左边字符和删除右边字符同时都要试</strong>    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; j:</span><br><span class="line">		<span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">			<span class="keyword">if</span> self.is_palindrome(s[i + <span class="number">1</span>:j + <span class="number">1</span>]) <span class="keyword">or</span> self.is_palindrome(s[i:j]):</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		j -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 692 Top K Frequent Words</title>
    <url>/2021/12/24/lee-692/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/top-k-frequent-words" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent strings</em>.<br><br>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“i”,”love”,”leetcode”,”i”,”love”,”coding”], k = 2<br><strong>Output:</strong> [“i”,”love”]<br><strong>Explanation:</strong> “i” and “love” are the two most frequent words.<br>Note that “i” comes before “love” due to a lower alphabetical order.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“the”,”day”,”is”,”sunny”,”the”,”the”,”the”,”sunny”,”is”,”is”], k = 4<br><strong>Output:</strong> [“the”,”is”,”sunny”,”day”]<br><strong>Explanation:</strong> “the”, “is”, “sunny” and “day” are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= words.length &lt;= 500</code>
</em>   <code>1 &lt;= words[i] &lt;= 10</code><br><em>   <code>words[i]</code> consists of lowercase English letters.
</em>   <code>k</code> is in the range <code>[1, The number of **unique** words[i]]</code><br><br><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求k个最高频率的单词</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若频率一样，就按字母顺序lexicographical. 所以用大小为k的heap做比较困难。直接用排序即可   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, words: List[str], k: int)</span> -&gt; List[str]:</span></span><br><span class="line">	freq_dict = collections.Counter(words)</span><br><span class="line">	li = [(freq, word) <span class="keyword">for</span> word, freq <span class="keyword">in</span> freq_dict.items()]</span><br><span class="line">	li.sort(key=<span class="keyword">lambda</span> x : (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">	<span class="keyword">return</span> [pair[<span class="number">1</span>] <span class="keyword">for</span> pair <span class="keyword">in</span> li[:k]]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 696 Count Binary Substrings</title>
    <url>/2021/12/05/lee-696/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-binary-substrings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Give a binary string <code>s</code>, return the number of non-empty substrings that have the same number of <code>0</code>‘s and <code>1</code>‘s, and all the <code>0</code>‘s and all the <code>1</code>‘s in these substrings are grouped consecutively.<br><br>Substrings that occur multiple times are counted the number of times they occur.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “00110011”<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”.<br>Notice that some of these substrings repeat and are counted the number of times they occur.<br>Also, “00110011” is not a valid substring because all the 0’s (and 1’s) are not grouped together.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “10101”<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> There are 4 substrings: “10”, “01”, “10”, “01” that have equal number of consecutive 1’s and 0’s.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>子串中，连续0和连续1的个数中间对称，求这样的子串的个数</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>这题至少medium，一开始考虑给定一个字符串怎么判断是否满足条件，统计个数和flag变化。然后是双重循环分别以a[0..n-1]为开头的子串判断，若不满足就跳出内循环，复杂度为O(n).<br>既然是连续，又是只有0和1，不妨考虑统计个数。如00110011,统计0和1的个数为count=[2,2,2,2]相邻的数代表不同种类，所以去min(count[i-1], count[i])，如2, 2可以是01/10, 0011/1100两种，具体以哪个数开始取决于数组本身。统计i=[1..n-1]即所求。复杂度为O(n).  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>累计思想，按0和1累计得到累计数组，然后求相邻最小个数的和。      </li>
<li>循环出来，处理最后一个部分。 </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	presum, count, res = [], <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)): <span class="comment">#</span></span><br><span class="line">		<span class="keyword">if</span> s[i - <span class="number">1</span>] == s[i]:</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			presum.append(count) <span class="comment">#[2, 2,2,2]</span></span><br><span class="line">			count = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">		presum.append(count)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(presum)):</span><br><span class="line">		res += min(presum[i - <span class="number">1</span>], presum[i])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Amazon</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 698 Partition to K Equal Sum Subsets</title>
    <url>/2018/01/28/lee-698/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets" target="_blank" rel="noopener">LeetCode 698 Partition to K Equal Sum Subsets</a></strong></p>
<p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, find whether it’s possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>
<p><strong>Example 1:</strong>  </p>
<pre><b>Input:</b> nums = [4, 3, 2, 3, 5, 2, 1], k = 4
<b>Output:</b> True
<b>Explanation:</b> It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>

<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code>.</li>
<li><code>0 &lt; nums[i] &lt; 10000</code>.</li>
</ul>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断数组nums是否可以划分为k个和相等的子数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题与416类似，所以一开始考虑用0-1背包问题思路，但是0-1背包问题得出的解为2,2,1，与答案不同。因为背包问题只能求出第一个解，并不能求出k个解。所以类似于排列组合，<br>需要DFS来一个个数来试。参数为visited数组为记录该数是否用了，curSum，k，若curSum等于target(sum/k)，找到第一个解，k–，curSum=0，找下一个解。这个方法是用k次排列组合法组成最终解。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组和为不能被k整除，无解</li>
<li>引入st，排列组合必须，用于for循环的起始点。</li>
<li>k=1立刻剪枝，因为前三个解都是等于sum/k,最后一个也一定是sum/k</li>
<li>当curSum==target时，进行k-1，curSum=0的下一轮dfs。</li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets0</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">		sum+=i;</span><br><span class="line">	<span class="keyword">if</span>(sum%k!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">	<span class="keyword">return</span> dfs0(nums, k, sum/k, <span class="number">0</span>, visited, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> curSum, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(curSum==target)</span><br><span class="line">		<span class="keyword">return</span> dfs0(nums, k-<span class="number">1</span>, target, <span class="number">0</span>, visited, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(curSum+nums[i]&lt;=target)&#123;</span><br><span class="line">			visited[i] = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(dfs0(nums, k, target, curSum+nums[i], visited, i+<span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			visited[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>这是NP问题。  </p>
<hr>
<p>另一个方法是，将k次排列组合法整合成一次，途径是开一个k大小数组，每一个数肯定属于其中一个。visited数组替换成ksum数组和idx控制遍历数组顺序。某一个数肯定是属于ksum数组的任一个，<br>所以所有可能性都考虑到，可以求得解。先对原数组排序方便从后往前遍历，贪心算法可以帮助剪枝，因为先填大的数，容易获得结果或排除结果。如[1….1, 4], target=4, k=2，从前往后的话，<br>多个1可以有非常多的可能。提高算法效率但若不排序的话会得到LTE。<br>这个方法比第一个方法的优势在于它用ksum数组取代visited和curSum参数，第一种方法要从头开始扫k遍数组，而此法只需扫一遍数组+每个元素试k次。   </p>
<ol>
<li>数组和为不能被k整除，无解</li>
<li>对数组排序</li>
<li>DFS四部曲，从后往前遍历数组加入ksum</li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>数组和为不能被k整除，无解</li>
<li>从后往前遍历数组</li>
</ol>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">		sum+=i;</span><br><span class="line">	<span class="keyword">if</span>(sum%k!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">	<span class="keyword">int</span>[] ksum = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">	<span class="keyword">return</span> dfs(nums, k, sum/k, ksum, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span>[] ksum, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(idx==-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : ksum)</span><br><span class="line">			<span class="keyword">if</span>(a!=target)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ksum[i]+nums[idx]&lt;=target)&#123;</span><br><span class="line">			ksum[i] += nums[idx];</span><br><span class="line">			<span class="keyword">if</span>(dfs(nums, k, target, ksum, idx-<span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			ksum[i] -= nums[idx];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>这是NP问题。</p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 718 Maximum Length of Repeated Subarray</title>
    <url>/2021/12/23/lee-718/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br><strong>Output:</strong> 5<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code>
</em>   <code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两数组的最长相等子数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于是两数组匹配，所以是匹配性DP<br>dp[i][j]为以nums1[i-1], nums2[j-1]为结尾的最长重复数组，答案为滚动最大值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1 if nums1[i-1] == nums2[j-1]</span><br><span class="line">         = 0                if nums1[i-1] != nums2[j-1]</span><br></pre></td></tr></table></figure></p>
<p>类似题目：<br>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j-1] + 1 if nums1[i-1] == nums2[j-1]</span></span><br><span class="line"><span class="comment">#          = 0                if nums1[i-1] != nums2[j-1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">	max_length = <span class="number">0</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums1) + <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">			max_length = max(max_length, dp[i][j])</span><br><span class="line">	<span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 729 My Calendar I</title>
    <url>/2021/12/05/lee-729/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/my-calendar-i/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>double booking</strong>.<br><br>A <strong>double booking</strong> happens when two events have some non-empty intersection (i.e., some moment is common to both events.).<br><br>The event can be represented as a pair of integers <code>start</code> and <code>end</code> that represents a booking on the half-open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.<br><br>Implement the <code>MyCalendar</code> class:<br><br><em>   <code>MyCalendar()</code> Initializes the calendar object.
</em>   <code>boolean book(int start, int end)</code> Returns <code>true</code> if the event can be added to the calendar successfully without causing a <strong>double booking</strong>. Otherwise, return <code>false</code> and do not add the event to the calendar.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MyCalendar”, “book”, “book”, “book”]<br>[[], [10, 20], [15, 25], [20, 30]]<br><strong>Output</strong><br>[null, true, false, true]<br><br><strong>Explanation</strong><br>MyCalendar myCalendar = new MyCalendar();<br>myCalendar.book(10, 20); // return True<br>myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.<br>myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= start &lt; end &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   At most <code>1000</code> calls will be made to <code>book</code>.<br><br></div>

<h3 id="暴力法算法思路-推荐-："><a href="#暴力法算法思路-推荐-：" class="headerlink" title="暴力法算法思路(推荐)："></a><strong>暴力法算法思路(推荐)：</strong></h3><p>存储所有区间</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>区间比较难写，用符合加入会议条件的相反来写，not (start &gt;= root.end or end &lt;= root.start)      </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendar = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> self.calendar:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (start &gt;= e <span class="keyword">or</span> end &lt;= s):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.calendar.append((start, end))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>, 空间复杂度<code>O(n)</code> </p>
<hr>
<h3 id="端点排序法解题思路II："><a href="#端点排序法解题思路II：" class="headerlink" title="端点排序法解题思路II："></a><strong>端点排序法解题思路II：</strong></h3><p>区间重合题考虑用heap或者端点排序法，输入是必须有序，所以此题可以令区间有序，而heap用于处理重合情况下的计算，此题不适用，所以用端点排序法。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>区间端点排序，(endpoint, 1/-1), 1表示始点，-1表示终点。用bisect搜索时，注意输入也要用两维(start, 1)    </li>
<li>难点在于比较结果决定返回Ture or False。两种情况返回False：好的情况是输入区间的搜索结果的下标应该相等表示可以插入到现有两区间之间，所以<strong>若不等</strong>，就不符合。第二种是若现有区间完全覆盖新区间，此时搜索结果下标也一样，所以此情况<strong>新区间终点的搜索结果(后一个节点)是终点</strong>。同时为保证搜索结果不处理越界，<strong>加入空端点</strong>  </li>
<li>若同一个端点同时存在始点和端点，不用合并，因为它们已经按-1, 1排序了。 </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendar = [(float(<span class="string">'-inf'</span>), <span class="number">-1</span>), (float(<span class="string">'inf'</span>), <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        index_start = bisect.bisect(self.calendar, (start, <span class="number">1</span>)) <span class="comment"># remember params</span></span><br><span class="line">        index_end = bisect.bisect(self.calendar, (end, <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">if</span> index_start != index_end <span class="keyword">or</span> self.calendar[index_end][<span class="number">1</span>] == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># no need to merge endpoints coz they are sorted in (a, -1), (a, 1) as expected</span></span><br><span class="line">        bisect.insort(self.calendar, (start, <span class="number">1</span>))</span><br><span class="line">        bisect.insort(self.calendar, (end, <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，由于insort是插入需要移动数组，所以是O(n), 空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="线段树算法III思路-不推荐-："><a href="#线段树算法III思路-不推荐-：" class="headerlink" title="线段树算法III思路(不推荐)："></a><strong>线段树算法III思路(不推荐)：</strong></h3><p>区间重合题考虑用heap类似meeting rooms，输入是必须有序，但这里新区间与已有区间不是有序且不能online处理，所以不能用heap。<br>考虑用start, end排序，二分法查找，只能处理单次，因为插入不方便。<br>要查找和插入都能低于O(n)，就只能用TreeMap。类似于线段树存储区间，此题每个Node存储一个区间。新区间的end，start分别与root的start和end比较，若不重合，就递归到左右子树。此树投影为离散且不重合的区间。   </p>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>考察二叉树插入算法，<strong>返回值需要是TreeNode</strong>，如root.left = self.dfs(root.left, start, end)。由于需要知道是否成功插入，所以返回值多加一个boolean  </li>
<li>区间比较难写，用符合加入会议条件的相反来写，not (start &gt;= root.end or end &lt;= root.start)      </li>
<li>is_left or is_right任意一个加入成功都可以，所以是or不是and  </li>
</ol>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        root, is_booked = self.dfs(self.head, start, end)</span><br><span class="line">        self.head = root</span><br><span class="line">        <span class="keyword">return</span> is_booked</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(start, end), <span class="keyword">True</span></span><br><span class="line">        <span class="comment">#if root.start &lt;= start &lt; root.end or root.start &lt; end &lt;= root.end: # remember</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (start &gt;= root.end <span class="keyword">or</span> end &lt;= root.start):</span><br><span class="line">            <span class="keyword">return</span> root, <span class="keyword">False</span></span><br><span class="line">        is_left = is_right = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> end &lt;= root.start:</span><br><span class="line">            root.left, is_left = self.dfs(root.left, start, end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right, is_right = self.dfs(root.right, start, end)</span><br><span class="line">        <span class="keyword">return</span> root, is_left <span class="keyword">or</span> is_right <span class="comment"># remember or</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，最差情况为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 731 My Calendar II</title>
    <url>/2021/12/05/lee-731/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/my-calendar-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>triple booking</strong>.<br><br>A <strong>triple booking</strong> happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).<br><br>The event can be represented as a pair of integers <code>start</code> and <code>end</code> that represents a booking on the half-open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.<br><br>Implement the <code>MyCalendarTwo</code> class:<br><br><em>   <code>MyCalendarTwo()</code> Initializes the calendar object.
</em>   <code>boolean book(int start, int end)</code> Returns <code>true</code> if the event can be added to the calendar successfully without causing a <strong>triple booking</strong>. Otherwise, return <code>false</code> and do not add the event to the calendar.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MyCalendarTwo”, “book”, “book”, “book”, “book”, “book”, “book”]<br>[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]<br><strong>Output</strong><br>[null, true, true, true, false, true, true]<br><br><strong>Explanation</strong><br>MyCalendarTwo myCalendarTwo = new MyCalendarTwo();<br>myCalendarTwo.book(10, 20); // return True, The event can be booked.<br>myCalendarTwo.book(50, 60); // return True, The event can be booked.<br>myCalendarTwo.book(10, 40); // return True, The event can be double booked.<br>myCalendarTwo.book(5, 15);  // return False, The event ca not be booked, because it would result in a triple booking.<br>myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.<br>myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= start &lt; end &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   At most <code>1000</code> calls will be made to <code>book</code>.<br><br></div>


<h3 id="暴力法算法思路-推荐-："><a href="#暴力法算法思路-推荐-：" class="headerlink" title="暴力法算法思路(推荐)："></a><strong>暴力法算法思路(推荐)：</strong></h3><p>存储所有区间和重合区间</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>区间比较难写，用符合加入会议条件的相反来写，not (start &gt;= root.end or end &lt;= root.start)      </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(TestCases)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendar = []</span><br><span class="line">        self.overlaps = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> self.overlaps:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (start &gt;= e <span class="keyword">or</span> end &lt;= s):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> self.calendar:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (start &gt;= e <span class="keyword">or</span> end &lt;= s):</span><br><span class="line">                self.overlaps.append((max(start, s), min(end, e)))</span><br><span class="line">        self.calendar.append((start, end))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>, 空间复杂度<code>O(n)</code> </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>有重复区间，考虑用meeting rooms的方法二。用一个map来存储endpoint包括start和end的频率，若遇到start，map[start]++, 若遇到end, map[end]–，插入一个区间后，遍历所有endpoints，若超过3就返回False<br>虽然复杂度稍差，系数更大。但此法更有推广性，如果允许重复会议更多，此法可扩展  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先插入有序区间，然后统计看是否有重复区间超过2. </li>
<li>若是False，用remove这个函数要删除刚插入的。  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(TestCases)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendar = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        bisect.insort(self.calendar, (start, <span class="number">1</span>))</span><br><span class="line">        bisect.insort(self.calendar, (end, <span class="number">-1</span>))</span><br><span class="line">        active_meeting = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> endpoint, _type <span class="keyword">in</span> self.calendar:</span><br><span class="line">            <span class="keyword">if</span> _type == <span class="number">1</span>:</span><br><span class="line">                active_meeting += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                active_meeting -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> active_meeting &gt;= <span class="number">3</span>:</span><br><span class="line">                self.calendar.remove((start, <span class="number">1</span>))</span><br><span class="line">                self.calendar.remove((end, <span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>, 空间复杂度<code>O(n)</code> </p>
]]></content>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 735 Asteroid Collision</title>
    <url>/2021/12/24/lee-735/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/asteroid-collision/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>We are given an array <code>asteroids</code> of integers representing asteroids in a row.<br><br>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.<br><br>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> asteroids = [5,10,-5]<br><strong>Output:</strong> [5,10]<br><strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> asteroids = [8,-8]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> The 8 and -8 collide exploding each other.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> asteroids = [10,2,-5]<br><strong>Output:</strong> [10]<br><strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= asteroids.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-1000 &lt;= asteroids[i] &lt;= 1000</code><br>*   <code>asteroids[i] != 0</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>星体向左向右同速运动，符号表示方向，数值表示星体大小。若相撞，同大小想消，否则较小的消失。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>保持原有顺序且相邻元素大小关系，考虑用Stack</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>两星体可以正负，所以有四种可能：同左，同右，向左向右，向右向左。<strong>只有最后一种向右向左才会相撞。</strong>所以出栈条件为栈顶为正，遍历元素为负。    </li>
<li>同大小要特别处理，记录到is_same_size变量中。入栈条件为<strong>出栈条件的非以及不是is_same_size</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">		is_same_size = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span> <span class="keyword">and</span> -asteroids[i] &gt;= stack[<span class="number">-1</span>]:</span><br><span class="line">			stack_top = stack.pop()</span><br><span class="line">			<span class="keyword">if</span> stack_top == -asteroids[i]:</span><br><span class="line">				is_same_size = <span class="keyword">True</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> (stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>) <span class="keyword">and</span> <span class="keyword">not</span> is_same_size:</span><br><span class="line">			stack.append(asteroids[i])</span><br><span class="line">	<span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<p>更简洁的写法，不要要掌握while, break, else语句，如果没有break，else永远执行，若break，else不执行。若不熟悉该语法，推荐用上法。  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision2</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> -asteroids[i] &lt; stack[<span class="number">-1</span>] <span class="keyword">or</span> stack.pop() == -asteroids[i]:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append(asteroids[i])</span><br><span class="line">	<span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 759 Employee Free Time</title>
    <url>/2021/12/26/lee-759/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/employee-free-time/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.<br><br>Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.<br><br>Return the list of finite intervals representing <strong>common, positive-length free time</strong> for <em>all</em> employees, also in sorted order.<br><br>(Even though we are representing <code>Intervals</code> in the form <code>[x, y]</code>, the objects inside are <code>Intervals</code>, not lists or arrays. For example, <code>schedule[0][0].start = 1</code>, <code>schedule[0][0].end = 2</code>, and <code>schedule[0][0][0]</code> is not defined).  Also, we wouldn’t include intervals like [5, 5] in our answer, as they have zero length.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]<br><strong>Output:</strong> [[3,4]]<br><strong>Explanation:</strong> There are a total of three employees, and all common<br>free time intervals would be [-inf, 1], [3, 4], [10, inf].<br>We discard any intervals that contain inf as they aren’t finite.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]<br><strong>Output:</strong> [[5,6],[7,9]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= schedule.length , schedule[i].length &lt;= 50</code>
</em>   <code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定员工的schedule，给所有员工的空余时间的区间</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑用Leetcode 056 merge intervals，然后求不能merge时的区间。后来想用Leetcode 253 meeting rooms II也是关于重合区间，只要active meetings为0时，就表示空余区间，此法更容易实现   </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Leetcode 253 meeting rooms II的排序解法  </li>
<li>注意输入是每一个员工的schedule如[Interval(1, 2), Interval(5, 6)]，然后是所有员工schedule的列表  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">	TestCases.compare(self, self.employeeFreeTime([[Interval(<span class="number">1</span>, <span class="number">2</span>), Interval(<span class="number">5</span>, <span class="number">6</span>)], [Interval(<span class="number">1</span>, <span class="number">3</span>)], [Interval(<span class="number">4</span>, <span class="number">10</span>)]]), [Interval(<span class="number">3</span>, <span class="number">4</span>)])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">employeeFreeTime</span><span class="params">(self, schedule: [[Interval]])</span> -&gt; [Interval]:</span></span><br><span class="line">	schedule_endpoints = []</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> schedule:</span><br><span class="line">		<span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">			schedule_endpoints.append((s.start, <span class="number">0</span>)) <span class="comment"># [(1, 0),(2,1),(5,0), (6,1)]</span></span><br><span class="line">			schedule_endpoints.append((s.end, <span class="number">1</span>))</span><br><span class="line">	schedule_endpoints.sort()</span><br><span class="line">	res, free_time, active_schedule = [], [], <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(schedule_endpoints)):</span><br><span class="line">		<span class="keyword">if</span> schedule_endpoints[i][<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">			active_schedule += <span class="number">1</span> <span class="comment"># 0</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			active_schedule -= <span class="number">1</span> <span class="comment">#</span></span><br><span class="line">		<span class="keyword">if</span> active_schedule == <span class="number">0</span>:</span><br><span class="line">			free_time.append(schedule_endpoints[i][<span class="number">0</span>]) <span class="comment">#[2,5]</span></span><br><span class="line">		<span class="keyword">if</span> active_schedule == <span class="number">1</span> <span class="keyword">and</span> len(free_time) == <span class="number">1</span>:</span><br><span class="line">			free_time.append(schedule_endpoints[i][<span class="number">0</span>])</span><br><span class="line">			free_interval = Interval(free_time[<span class="number">0</span>], free_time[<span class="number">1</span>])</span><br><span class="line">			res.append(free_interval)</span><br><span class="line">			free_time = []</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 787 Cheapest Flights Within K Stops</title>
    <url>/2022/01/03/lee-787/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt;, price&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is a flight from city <code>from&lt;sub&gt;i&lt;/sub&gt;</code> to city <code>to&lt;sub&gt;i&lt;/sub&gt;</code> with cost <code>price&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from</em> <code>src</code> <em>to</em> <code>dst</code> <em>with at most</em> <code>k</code> <em>stops.</em> If there is no such route, return<code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""><br><br><pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1<br><strong>Output:</strong> 200<br><strong>Explanation:</strong> The graph is shown.<br>The cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""><br><br><pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0<br><strong>Output:</strong> 500<br><strong>Explanation:</strong> The graph is shown.<br>The cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 100</code>
</em>   <code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code><br><em>   <code>flights[i].length == 3</code>
</em>   <code>0 &lt;= from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt; &lt; n</code><br><em>   <code>from&lt;sub&gt;i&lt;/sub&gt; != to&lt;sub&gt;i&lt;/sub&gt;</code>
</em>   <code>1 &lt;= price&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   There will not be any multiple flights between two cities.
</em>   <code>0 &lt;= src, dst, k &lt; n</code><br>*   <code>src != dst</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求只允许停k个站情况下，最便宜机票价格</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS + Heap<br>这是单源最短路径的典型应用。可以用Dijkstra，机票价格相当于单源最短路径问题中的路径大小。一开始我用BFS，但得到TLE，因为存在循环，导致节点被重复访问(同一路径)。但一个节点的确可以被用不同路径访问。所以引入visited[node] = dis </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>node需要被多次访问，所以跟模板不同，visited的检测要放在neighbor循环之外且用node且初始化为空。visited不再是set，它需要记录node离src的距离。一方面用于循环检测，因为如果存在循环，会出现dist &gt;= visited[node]。若该节点的当前距离小于之前的最小距离，此时也要加入到heap，因为贪婪法，虽然此路径费用较高，但它距离更近，当k限制比较小时，此路径可能满足要求。这就是为什么一个节点会被多次访问的原因。</li>
<li><strong>若路径不存在返回-1</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, k: int)</span> -&gt; int:</span></span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> pair <span class="keyword">in</span> flights:</span><br><span class="line">		graph[pair[<span class="number">0</span>]].append((pair[<span class="number">1</span>], pair[<span class="number">2</span>]))</span><br><span class="line">    heap = ([(<span class="number">0</span>, src, <span class="number">0</span>)]) <span class="comment"># price, node_id, distance</span></span><br><span class="line">	visited = &#123;&#125;</span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		p, node, dist = heapq.heappop(heap)</span><br><span class="line">		<span class="keyword">if</span> node == dst <span class="keyword">and</span> dist &lt;= k + <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> p</span><br><span class="line">		<span class="keyword">if</span> node <span class="keyword">in</span> visited <span class="keyword">and</span> dist &gt;= visited[node]:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		visited[node] = dist</span><br><span class="line">		<span class="keyword">for</span> neighbor, _price <span class="keyword">in</span> graph[node]:</span><br><span class="line">			heapq.heappush(heap, (p + _price, neighbor, dist + <span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(VlogV)</code>，空间复杂度<code>O(V)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Heap</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 811 Subdomain Visit Count</title>
    <url>/2021/12/15/lee-811/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/subdomain-visit-count/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A website domain <code>&quot;discuss.leetcode.com&quot;</code> consists of various subdomains. At the top level, we have <code>&quot;com&quot;</code>, at the next level, we have <code>&quot;leetcode.com&quot;</code> and at the lowest level, <code>&quot;discuss.leetcode.com&quot;</code>. When we visit a domain like <code>&quot;discuss.leetcode.com&quot;</code>, we will also visit the parent domains <code>&quot;leetcode.com&quot;</code> and <code>&quot;com&quot;</code> implicitly.<br><br>A <strong>count-paired domain</strong> is a domain that has one of the two formats <code>&quot;rep d1.d2.d3&quot;</code> or <code>&quot;rep d1.d2&quot;</code> where <code>rep</code> is the number of visits to the domain and <code>d1.d2.d3</code> is the domain itself.<br><br><em>   For example, <code>&quot;9001 discuss.leetcode.com&quot;</code> is a <strong>count-paired domain</strong> that indicates that <code>discuss.leetcode.com</code> was visited <code>9001</code> times.<br><br>Given an array of <strong>count-paired domains</strong> <code>cpdomains</code>, return <em>an array of the <strong>count-paired domains</strong> of each subdomain in the input</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> cpdomains = [“9001 discuss.leetcode.com”]<br><strong>Output:</strong> [“9001 leetcode.com”,”9001 discuss.leetcode.com”,”9001 com”]<br><strong>Explanation:</strong> We only have one website domain: “discuss.leetcode.com”.<br>As discussed above, the subdomain “leetcode.com” and “com” will also be visited. So they will all be visited 9001 times.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> cpdomains = [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]<br><strong>Output:</strong> [“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]<br><strong>Explanation:</strong> We will visit “google.mail.com” 900 times, “yahoo.com” 50 times, “intel.mail.com” once and “wiki.org” 5 times.<br>For the subdomains, we will visit “mail.com” 900 + 1 = 901 times, “com” 900 + 50 + 1 = 951 times, and “org” 5 times.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= cpdomain.length &lt;= 100</code><br><em>   <code>1 &lt;= cpdomain[i].length &lt;= 100</code>
</em>   <code>cpdomain[i]</code> follows either the <code>&quot;rep&lt;sub&gt;i&lt;/sub&gt; d1&lt;sub&gt;i&lt;/sub&gt;.d2&lt;sub&gt;i&lt;/sub&gt;.d3&lt;sub&gt;i&lt;/sub&gt;&quot;</code> format or the <code>&quot;rep&lt;sub&gt;i&lt;/sub&gt; d1&lt;sub&gt;i&lt;/sub&gt;.d2&lt;sub&gt;i&lt;/sub&gt;&quot;</code> format.<br><em>   <code>rep&lt;sub&gt;i&lt;/sub&gt;</code> is an integer in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.
</em>   <code>d1&lt;sub&gt;i&lt;/sub&gt;</code>, <code>d2&lt;sub&gt;i&lt;/sub&gt;</code>, and <code>d3&lt;sub&gt;i&lt;/sub&gt;</code> consist of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>统计所以domain和子域名个数  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>遍历每个domain，将domain和个数存入dict，再对domain按点号break，将每个sub-domain存入dict</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Line 64根据题意倒转统计，Line 65记得非空时候加点号   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">	domain_to_count = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> pair_str <span class="keyword">in</span> cpdomains:</span><br><span class="line">		pair = pair_str.split(<span class="string">' '</span>)</span><br><span class="line">		count = int(pair[<span class="number">0</span>])</span><br><span class="line">		domain = pair[<span class="number">1</span>]</span><br><span class="line">		subdomain = <span class="string">''</span></span><br><span class="line">		<span class="keyword">for</span> segment <span class="keyword">in</span> domain.split(<span class="string">'.'</span>)[::<span class="number">-1</span>]:</span><br><span class="line">			subdomain = segment + (<span class="string">'.'</span> + subdomain <span class="keyword">if</span> subdomain <span class="keyword">else</span> <span class="string">''</span>)</span><br><span class="line">			domain_to_count[subdomain] += count</span><br><span class="line">	<span class="keyword">return</span> [<span class="string">'&#123;&#125; &#123;&#125;'</span>.format(_count, _domain) <span class="keyword">for</span> _domain, _count <span class="keyword">in</span> domain_to_count.items()]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 809 Expressive Words</title>
    <url>/2021/12/18/lee-809/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/expressive-words/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Sometimes people repeat letters to represent extra feeling. For example:<br><br><em>   <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>
</em>   <code>&quot;hi&quot; -&gt; &quot;hiiii&quot;</code><br><br>In these strings like <code>&quot;heeellooo&quot;</code>, we have groups of adjacent letters that are all the same: <code>&quot;h&quot;</code>, <code>&quot;eee&quot;</code>, <code>&quot;ll&quot;</code>, <code>&quot;ooo&quot;</code>.<br><br>You are given a string <code>s</code> and an array of query strings <code>words</code>. A query word is <strong>stretchy</strong> if it can be made to be equal to <code>s</code> by any number of applications of the following extension operation: choose a group consisting of characters <code>c</code>, and add some number of characters <code>c</code> to the group so that the size of the group is <strong>three or more</strong>.<br><br><em>   For example, starting with <code>&quot;hello&quot;</code>, we could do an extension on the group <code>&quot;o&quot;</code> to get <code>&quot;hellooo&quot;</code>, but we cannot get <code>&quot;helloo&quot;</code> since the group <code>&quot;oo&quot;</code> has a size less than three. Also, we could do another extension like <code>&quot;ll&quot; -&gt; &quot;lllll&quot;</code> to get <code>&quot;helllllooo&quot;</code>. If <code>s = &quot;helllllooo&quot;</code>, then the query word <code>&quot;hello&quot;</code> would be <strong>stretchy</strong> because of these two extension operations: <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>.<br><br>Return <em>the number of query strings that are <strong>stretchy</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “heeellooo”, words = [“hello”, “hi”, “helo”]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>We can extend “e” and “o” in the word “hello” to get “heeellooo”.<br>We can’t extend “helo” to get “heeellooo” because the group “ll” is not size 3 or more.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “zzzzzyyyyy”, words = [“zzyy”,”zy”,”zyy”]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length, words.length &lt;= 100</code><br><em>   <code>1 &lt;= words[i].length &lt;= 100</code>
</em>   <code>s</code> and <code>words[i]</code> consist of lowercase letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Cisco常考题<br>定义了一种富于表现力的单词，就是说某个字母可以重复三次或以上，叫stretchy<br>找给定的单词列表中的单词可以成为stretchy单词的个数  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计每个字符的个数，然后比较对应每个字符个数 </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Line 13的条件，若个数不等，word的字符个数大于stretchy的字符个数(word不能删除字符)，或者stretchy的个数小于3，就不满足    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	s_count = self.get_consecutive_count(s)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">		char_count = self.get_consecutive_count(word)</span><br><span class="line">		<span class="keyword">if</span> len(char_count) != len(s_count):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s_count)):</span><br><span class="line">			char_s, count_s = s_count[i]</span><br><span class="line">			char_w, count_w = char_count[i]</span><br><span class="line">			<span class="keyword">if</span> char_w != char_s:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">if</span> count_s != count_w <span class="keyword">and</span> (count_w &gt; count_s <span class="keyword">or</span> count_s &lt; <span class="number">3</span>): <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">if</span> i == len(s_count) - <span class="number">1</span>:</span><br><span class="line">				res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_consecutive_count</span><span class="params">(self, s)</span>:</span></span><br><span class="line">	s += <span class="string">' '</span></span><br><span class="line">	s_count, count = [], <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] != s[i - <span class="number">1</span>]:</span><br><span class="line">			s_count.append((s[i - <span class="number">1</span>], count))</span><br><span class="line">			count = <span class="number">0</span></span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> s_count</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 815 Bus Routes</title>
    <url>/2021/12/19/lee-815/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/bus-routes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array <code>routes</code> representing bus routes where <code>routes[i]</code> is a bus route that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> bus repeats forever.<br><br><em>   For example, if <code>routes[0] = [1, 5, 7]</code>, this means that the <code>0&lt;sup&gt;th&lt;/sup&gt;</code> bus travels in the sequence <code>1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; ...</code> forever.<br><br>You will start at the bus stop <code>source</code> (You are not on any bus initially), and you want to go to the bus stop <code>target</code>. You can travel between bus stops by buses only.<br><br>Return <em>the least number of buses you must take to travel from</em> <code>source</code> <em>to</em> <code>target</code>. Return <code>-1</code> if it is not possible.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> routes = [[1,2,7],[3,6,7]], source = 1, target = 6<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= routes.length &lt;= 500</code>.<br><em>   <code>1 &lt;= routes[i].length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   All the values of <code>routes[i]</code> are <strong>unique</strong>.<br><em>   <code>sum(routes[i].length) &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= routes[i][j] &lt; 10&lt;sup&gt;6&lt;/sup&gt;</code><br>*   <code>0 &lt;= source, target &lt; 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求公交路线中最小换站次数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值题且涉及到图，容易想到BFS。但此题难点在于不能将每个站作为一个节点，这样代码复杂且TLE。优化的做法是将路线作为节点，因为同一路线换站次数是一样的。属于<strong>一组节点作为一层的BFS</strong>。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>将整条路线作为图的节点</strong>。这些节点都位于同一层，换乘不同路线才会换到下一层，路径+1    </li>
<li>source和target所在的路线可能是多个，所以要将target所在的所有路线放在set中  </li>
<li><strong>邻接表计算是用两条路线是否有交集</strong>，有交集才能换乘，才能进入下一层访问，Python用set(a) &amp; set(b)  </li>
<li>如果target和source相等，返回0 (<strong>相等test case</strong>)  </li>
<li>站点不存在或者不存在任何路线，就返回-1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination</span><span class="params">(self, routes: List[List[int]], source: int, target: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> target == source: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	graph = collections.defaultdict(list) <span class="comment"># both set or list are fine</span></span><br><span class="line">	queue, targets, visited, distance = collections.deque(), set(), set(), collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">		<span class="keyword">if</span> source <span class="keyword">in</span> set(routes[i]):</span><br><span class="line">			queue.append(i)</span><br><span class="line">			visited.add(i)</span><br><span class="line">			distance[i] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> target <span class="keyword">in</span> set(routes[i]):</span><br><span class="line">			targets.add(i)</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(routes)):</span><br><span class="line">			<span class="keyword">if</span> set(routes[i]) &amp; set(routes[j]):</span><br><span class="line">				graph[i].append(j)</span><br><span class="line">				graph[j].append(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node <span class="keyword">in</span> targets:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance[neighbor] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<p>TLE版本用station作为节点  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination2</span><span class="params">(self, routes: List[List[int]], source: int, target: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> target == source: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	graph, station_to_route = collections.defaultdict(list), collections.defaultdict(set)</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">		r = routes[j] + [routes[j][<span class="number">0</span>]]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(r)):</span><br><span class="line">			<span class="comment"># graph[r[i - 1]].append(r[i])</span></span><br><span class="line">			station_to_route[r[i]].add(j)</span><br><span class="line"></span><br><span class="line">	queue = collections.deque()</span><br><span class="line">	visited = set()</span><br><span class="line">	bus_num = collections.defaultdict(int)  <span class="comment"># remember collections.defaultdict(lambda: 1)</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> station_to_route[source]:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> routes[j]:</span><br><span class="line">			<span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(i)</span><br><span class="line">			visited.add(i)</span><br><span class="line">			bus_num[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == target:</span><br><span class="line">			<span class="keyword">return</span> bus_num[node]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> station_to_route[node]:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> routes[j]:</span><br><span class="line">				<span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				queue.append(i)</span><br><span class="line">				visited.add(i)</span><br><span class="line">				bus_num[i] = bus_num[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>, n = num of routes </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Breadth-first Search</tag>
        <tag>Uber</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 828 Count Unique Characters of All Substrings of a Given String</title>
    <url>/2021/12/26/lee-828/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Let’s define a function <code>countUniqueChars(s)</code> that returns the number of unique characters on <code>s</code>.<br><br><em>   For example if <code>s = &quot;LEETCODE&quot;</code> then <code>&quot;L&quot;</code>, <code>&quot;T&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;O&quot;</code>, <code>&quot;D&quot;</code> are the unique characters since they appear only once in <code>s</code>, therefore <code>countUniqueChars(s) = 5</code>.<br><br>Given a string <code>s</code>, return the sum of <code>countUniqueChars(t)</code> where <code>t</code> is a substring of s.<br><br>Notice that some substrings can be repeated so in this case you have to count the repeated ones too.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ABC”<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> All possible substrings are: “A”,”B”,”C”,”AB”,”BC” and “ABC”.<br>Evey substring is composed with only unique letters.<br>Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ABA”<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> The same as example 1, except <code>countUniqueChars</code>(“ABA”) = 1.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “LEETCODE”<br><strong>Output:</strong> 92<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length &lt;= 10</code><sup>5</sup><br>*   <code>s</code> consists of uppercase English letters only.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子串的唯一字符的个数的总和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是所有子串O(n^2)，统计唯一字符个数O(n), 复杂度为O(n^3). 尝试优化统计那一步，用presum map来详见可以O(1)求得，但内存过大，仍然TLE。<br>求个个数且是字符串题，考虑用DP。此题还有点似Leetcode 003 Longest Substring Without Repeating Characters。  </p>
<p>写几个找规律且从简单开始，也就是没有重复<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A: 1</span><br><span class="line">AB: 1                + 2 + 1 = 4, 1是dp[1], 2是以B结尾的2个子串有两个B，最后一个1表示AB串中有一个A  </span><br><span class="line">       B</span><br><span class="line">      AB        </span><br><span class="line">ABC： 4           + 3 + 2 + 1 = 10， 4是dp[2], 2是以C结尾的3个子串有三个C，2个B，1个A. Delta = 6  </span><br><span class="line">        C</span><br><span class="line">       BC</span><br><span class="line">      ABC  </span><br><span class="line">ABCB:10      + 2 + 3 + 0 + 1 = 16, 同理是上一个DP结果和从后往前每个字母在新子串中的唯一数。由于出现重复，B从4个变成2个，前一个B变成0个，其他加法项是不变的。Delta = 6 + 4 - 2 x 2 = 6 公式为Delta = Delta + 当前长度 - (i - 上一个重复元素下标) x 2    </span><br><span class="line">         B</span><br><span class="line">        CB</span><br><span class="line">       BCB</span><br><span class="line">      ABCB  </span><br><span class="line">ABCBA:16 + 4 + 2 + 3 + 0 + 0 = 25 = 16 + delta 验证公式delta = 6 + 5 - 1 x 2 = 9    </span><br><span class="line">          A </span><br><span class="line">         BA</span><br><span class="line">        CBA</span><br><span class="line">       BCBA</span><br><span class="line">      ABCBA </span><br><span class="line">ABCBAC:25 + 3 + 4 + 2 + 0 + 0 + 0 = 34 = 25 + delta 验证公式delta = 9 + 6 - (6 - 3) x 2 = 9    </span><br><span class="line">           C </span><br><span class="line">          AC </span><br><span class="line">         BAC</span><br><span class="line">        CBAC</span><br><span class="line">       BCBAC</span><br><span class="line">      ABCBAC </span><br><span class="line">ABCBACA:34 + 2 + 3 + 0 + 2 + 0 + 0 + 0 = 41 = 34 + delta 验证公式delta = 9 + 7 - (7 - 2) x 2 = 6不匹配，新A本来是7个变成2个，而次新A上一轮有4个最多减4个并不能减5个，所以x 2是不对的。      </span><br><span class="line">            A </span><br><span class="line">           CA </span><br><span class="line">          ACA </span><br><span class="line">         BACA</span><br><span class="line">        CBACA</span><br><span class="line">       BCBACA</span><br><span class="line">      ABCBACA</span><br></pre></td></tr></table></figure></p>
<p>公式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Delta = Delta + 当前下标 - 上一个重复元素下标 - (上一个重复元素下标 - 上个重复元素对应的下标)</span><br><span class="line">Res += Delta</span><br></pre></td></tr></table></figure></p>
<p>公式解释：<br>delta是每增加一个字符的增量。若每一个字符都不重复，Delta = Delta + 当前长度表示增加了最后一个字符的数量如AB -&gt; ABC<br>若有重复，就只增加遇到前一个重复前的个数，如ABCB -&gt; ABCBA的4个<br>若前面重复有2个，就还要减去在算前一个重复时的增量如上图ABCBACA中BACA和CBACA中在BA和CBA时候当时A没有重复，计算了2个</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>delta_sum为上一轮的增加的唯一元素个数<br>delta[i]为下标为i的元素的唯一个数的增量  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>公式中减去重复个数不能乘以2，因为上一个重复元素的增量可能不够减     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	res, delta_sum, delta, char_to_index = <span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>] * len(s), collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		cur_len = i + <span class="number">1</span></span><br><span class="line">		delta[i] = cur_len</span><br><span class="line">		<span class="keyword">if</span> s[i] <span class="keyword">in</span> char_to_index:</span><br><span class="line">			delta[i] -= char_to_index[s[i]] + <span class="number">1</span></span><br><span class="line">			delta_sum += delta[i] - delta[char_to_index[s[i]]]</span><br><span class="line">			delta[char_to_index[s[i]]] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			delta_sum += delta[i]</span><br><span class="line">		res += delta_sum</span><br><span class="line">		char_to_index[s[i]] = i</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="两个Map算法II解题思路-推荐-："><a href="#两个Map算法II解题思路-推荐-：" class="headerlink" title="两个Map算法II解题思路(推荐)："></a><strong>两个Map算法II解题思路(推荐)：</strong></h3><p>公式中上个重复元素对应的加法项也就是上个重复元素与上上个重复元素的距离，所以引入另一个map来记录，避免用delta[i]，算法更加简单。  </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	last_last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">	res, delta = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		delta += i - last_char_to_index[c] - (last_char_to_index[c] - last_last_char_to_index[c])</span><br><span class="line">		last_last_char_to_index[c] = last_char_to_index[c]</span><br><span class="line">		last_char_to_index[c] = i</span><br><span class="line">		res += delta</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Amazon</tag>
        <tag>Math</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 863 All Nodes Distance K in Binary Tree</title>
    <url>/2021/12/06/lee-863/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, the value of a target node <code>target</code>, and an integer <code>k</code>, return <em>an array of the values of all nodes that have a distance</em> <code>k</code> <em>from the target node.</em><br><br>You can return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2<br><strong>Output:</strong> [7,4,1]<br>Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 1, k = 3<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 500]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 500</code><br><em>   All the values <code>Node.val</code> are <strong>unique</strong>.
</em>   <code>target</code> is the value of one of the nodes in the tree.<br>*   <code>0 &lt;= k &lt;= 1000</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>有三种情况，都容易忽略： 1. 儿子节点 2. 所有父节点路劲上 3. 兄弟节点路径上。而第三种情况要搜另一边的儿子节点（左右不确定）要用visited记录，而且不一定是父亲的兄弟节点，可能爷爷的非父亲的儿子节点。<br>既然不是单向搜索，不妨转换为图，然后用计算距离BFS模板，只要用map来记录某节点的父亲节点或者增加一个域。BFS中for neighbor in [node.left, node, right, node.parent]  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>root的parent是None，所以从root去赋值parent，而不是从parent root给儿子赋parent  </li>
<li>Line 13 node.left, node.right, node.parent都可能为None，所以Line14要加not neighbor      </li>
<li>BFS从target开始而不是root</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root: TreeNode, target: TreeNode, k: int)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	self.dfs(root, <span class="keyword">None</span>)</span><br><span class="line">	queue, visited, distance_to_tgt,  = collections.deque([target]), set([target]), collections.defaultdict(int)</span><br><span class="line">	distance_to_tgt[target], res = <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> distance_to_tgt[node] == k:</span><br><span class="line">			res.append(node.val)</span><br><span class="line">		<span class="keyword">if</span> distance_to_tgt[node] &gt; k:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> [node.left, node.right, node.parent]:</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> neighbor <span class="keyword">or</span> neighbor <span class="keyword">in</span> visited:  <span class="comment"># remember not neighbor</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">			distance_to_tgt[neighbor] = distance_to_tgt[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, parent)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	root.parent = parent</span><br><span class="line">	<span class="string">'''if root.left:</span></span><br><span class="line"><span class="string">		root.left.parent = root</span></span><br><span class="line"><span class="string">	if root.right:</span></span><br><span class="line"><span class="string">		root.right.parent = root'''</span></span><br><span class="line">	self.dfs(root.left, root)  <span class="comment"># remember to pass parent</span></span><br><span class="line">	self.dfs(root.right, root)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 829 Consecutive Numbers Sum</title>
    <url>/2021/12/16/lee-829/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>n</code>, return <em>the number of ways you can write</em> <code>n</code> <em>as the sum of consecutive positive integers.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> 5 = 2 + 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 9<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 9 = 4 + 5 = 2 + 3 + 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 15<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续整数的和等于N的个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>只有Fintech考，数学题。思路见注释  </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x, x+1, ... , x+k-1</span></span><br><span class="line"><span class="comment"># (x + x+k-1) * k / 2 = 2x+k-1) = n, x = [n - k(k-1)/2]/k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(<span class="number">2</span> * n) + <span class="number">1</span>)):</span><br><span class="line">		<span class="keyword">if</span> (n - i * (i - <span class="number">1</span>) / <span class="number">2</span>) % i == <span class="number">0</span>:</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 871 Minimum Number of Refueling Stops</title>
    <url>/2021/12/28/lee-871/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.<br><br>There are gas stations along the way. The gas stations are represented as an array <code>stations</code> where <code>stations[i] = [position&lt;sub&gt;i&lt;/sub&gt;, fuel&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> gas station is <code>position&lt;sub&gt;i&lt;/sub&gt;</code> miles east of the starting position and has <code>fuel&lt;sub&gt;i&lt;/sub&gt;</code> liters of gas.<br><br>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.<br><br>Return <em>the minimum number of refueling stops the car must make in order to reach its destination</em>. If it cannot reach the destination, return <code>-1</code>.<br><br>Note that if the car reaches a gas station with <code>0</code> fuel left, the car can still refuel there. If the car reaches the destination with <code>0</code> fuel left, it is still considered to have arrived.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 1, startFuel = 1, stations = []<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> We can reach the target without refueling.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 1, stations = [[10,100]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We can not reach the target (or even the first gas station).<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We start with 10 liters of fuel.<br>We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.<br>Then, we drive from position 10 to position 60 (expending 50 liters of fuel),<br>and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.<br>We made 2 refueling stops along the way, so we return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target, startFuel &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>0 &lt;= stations.length &lt;= 500</code><br><em>   <code>0 &lt;= position&lt;sub&gt;i&lt;/sub&gt; &lt;= position&lt;sub&gt;i+1&lt;/sub&gt; &lt; target</code>
</em>   <code>1 &lt;= fuel&lt;sub&gt;i&lt;/sub&gt; &lt; 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>其最小加油次数使得能到达目标  </p>
<h3 id="Heap解题思路-推荐-："><a href="#Heap解题思路-推荐-：" class="headerlink" title="Heap解题思路(推荐)："></a><strong>Heap解题思路(推荐)：</strong></h3><p>由于是重叠区间题且贪婪法加找最大油加油站，考虑用heap。求最小值，所以用最大堆。heap存的油数。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>每到一个加油站，先将油预存到heap中。startFuel为到达某个站后的剩余油数，若startFuel为负，从heap中取油，且累计加油次数。  </li>
<li>用heap模板，遍历数组也就是加油站。  </li>
<li>若加完油后，仍为负数，返回-1。</li>
<li>因为要计算target是否能达到，所以不妨<strong>将target加入到stations</strong>中，这样startFuel的计算可以包括target     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	heap, res, prev_pos = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	stations.append([target, <span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> pos, fuel <span class="keyword">in</span> stations:</span><br><span class="line">		startFuel -= pos - prev_pos</span><br><span class="line">		<span class="keyword">while</span> heap <span class="keyword">and</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line">			startFuel += -heapq.heappop(heap)</span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		heapq.heappush(heap, -fuel)</span><br><span class="line">		prev_pos = pos</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code> </p>
<hr>
<h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>一开始考虑用jump game，但此题可以在同一层加多次油。比如start fuel有100 mi，而加油站有3个，所以同一层可以加3次油。所以层数和加油次数不是一个概念。<br>既然是最值考虑另一种方法DP。这题有两个难点:<br>第一个难点是DP式： dp不采用题目的最小加油次数，考虑jump game的分析，转化成dp[i]为停i个站加油能达到的最远距离。或者这样思考，若定义走到第n个站需要最小加油次数，这个n颗粒度不够细，可以换成miles，不如将下标和数值互换。<br>第二个难点是递归式。首先知道假设dp[2]能到达的范围内有一个加油站，加油后dp[3] = dp[2] + 该油站的油数。递归式为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span><br></pre></td></tr></table></figure>
<p>有个前提条件是dp[2]必须能达到当前的加油站。比如要更新dp[3]从任意两个加油站dp[2] + 加油站[i]可能获得。还可能是从dp[2] + 加油站[i+1]获得，如此类推，要试完stations[i..n]。<br><strong>dp值从后往前更新</strong>，因为当前加油站在后方。   </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp定义和递归式     </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [startFuel] + [<span class="number">0</span>] * len(stations)</span><br><span class="line">	<span class="keyword">for</span> i, (pos, fuel) <span class="keyword">in</span> enumerate(stations):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">if</span> dp[j] &gt;= pos:</span><br><span class="line">				dp[j + <span class="number">1</span>] = max(dp[j + <span class="number">1</span>], dp[j] + fuel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, miles <span class="keyword">in</span> enumerate(dp):</span><br><span class="line">		<span class="keyword">if</span> miles &gt;= target:</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 907 Sum of Subarray Minimums</title>
    <url>/2021/12/12/lee-907/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sum-of-subarray-minimums/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><p>Given an array of integers arr, find the sum of <code>min(b)</code>, where <code>b</code> ranges over every (contiguous) subarray of <code>arr</code>. Since the answer may be large, return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p><br><br><p>&nbsp;</p><br><p><strong>Example 1:</strong></p><br><br><pre><strong>Input:</strong> arr = [3,1,2,4]<br><strong>Output:</strong> 17<br><strong>Explanation:</strong><br>Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].<br>Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.<br>Sum is 17.<br></pre><br><br><p><strong>Example 2:</strong></p><br><br><pre><strong>Input:</strong> arr = [11,81,94,43,3]<br><strong>Output:</strong> 444<br></pre><br><br><p>&nbsp;</p><br><p><strong>Constraints:</strong></p><br><br><ul><br>    <li><code>1 &lt;= arr.length &lt;= 3 <em> 10<sup>4</sup></em></code></li><br>    <li><code>1 &lt;= arr[i] &lt;= 3  10<sup>4</sup></code></li><br></ul><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子数组的最小值的和</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>求区间最值用Stack，因为是最小值，所以用<strong>递增栈</strong><br>一开始考虑用类似DP，因为若知道[3, 2, 6]栈为[2, 6], 8入栈，8与每一个栈内元素计算最小值，优化是用栈内的累计和，如2和6对应的累计和而不用每个元素计算。<br>参考了网上算法，<strong>栈内每个元素向左向右区间内（包括自己）均是最小值</strong>，所以出栈时候进行计算即可。<br>如[3, 2, 8, 7, 6, 9, 10, 4]栈是[2, 6, 9, 10]对应的下标，现在4入栈，9和10出栈后，6准备出栈。<br>prev_idx为6的下标4， i是7，6是[8, 7, 6], [7, 6], [6]三个区间的最小值prev_idx - stack[-1] = 3个区间，<br>而这些区间的最小值的和还要再乘以后面的大于它的数，如[7, 6]这个区间可以和这些区间合并[7, 6], [7, 6, 9], [7, 6, 9, 10], 所以(i - prev_idx) = 3<br>这就是arr[prev_idx] * (prev_idx - stack[-1]) * (i - prev_idx)的精髓  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>头尾加入最小值，加入头部因为公式需要栈内的前元素，这样可以处理只有一个元素出栈的情况。尾部加入最小值因为确保所有元素都出栈。     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">	arr.insert(<span class="number">0</span>, -sys.maxsize)</span><br><span class="line">	arr.append(-sys.maxsize)</span><br><span class="line">	stack, res = [], <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">		<span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &lt; arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">			prev_idx = stack.pop()</span><br><span class="line">			res += arr[prev_idx] * (prev_idx - stack[<span class="number">-1</span>]) * (i - prev_idx)</span><br><span class="line">			res = res % (pow(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>)</span><br><span class="line">		stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 909 Snakes and Ladders</title>
    <url>/2021/12/27/lee-909/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n&lt;sup&gt;2&lt;/sup&gt;</code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank" rel="noopener"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.<br><br>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:<br><br><em>   Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n&lt;sup&gt;2&lt;/sup&gt;)]</code>.
    </em>   This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.<br><em>   If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.
</em>   The game ends when you reach the square <code>n&lt;sup&gt;2&lt;/sup&gt;</code>.<br><br>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have a snake or ladder.<br><br>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent snake or ladder.<br><br><em>   For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.<br><br>Return <em>the least number of moves required to reach the square</em> <code>n&lt;sup&gt;2&lt;/sup&gt;</code><em>. If it is not possible to reach the square, return</em> <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt=""><br><br><pre><strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>In the beginning, you start at square 1 (at row 5, column 0).<br>You decide to move to square 2 and must take the ladder to square 15.<br>You then decide to move to square 17 and must take the snake to square 13.<br>You then decide to move to square 14 and must take the ladder to square 35.<br>You then decide to move to square 36, ending the game.<br>This is the lowest possible number of moves to reach the last square, so return 4.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> board = [[-1,-1],[-1,3]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>n == board.length == board[i].length</code><br><em>   <code>2 &lt;= n &lt;= 20</code>
</em>   <code>grid[i][j]</code> is either <code>-1</code> or in the range <code>[1, n&lt;sup&gt;2&lt;/sup&gt;]</code>.<br>*   The squares labeled <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have any ladders or snakes.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二维版上每格label从1到n^2, 从左到右或从右到左(梅花间竹)，从下到上。每次走1-6步，格上可能有梯子和蛇，梯子是快进，蛇是回退直接到达目标格。求从1到n^2所需要步数。始点和目标不含梯子和蛇。</p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>求最值两个方法：DP和BFS。一开始考虑用DP，但状态很复杂，因为存在回退，这样回退后要重新计算回退之后的DP值。<br>由于此题没有方向性而且似jump game，所以考虑用DP。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题意：对于梯子和蛇，它不能停留在梯子和蛇的起点，只能够停在终点，所以梯子和蛇的起点到1的距离为无穷大。其实可以留在起点，比如一个格同时是蛇的终点和梯子的起点。题意表明不能在同一步中两次用梯子或蛇。   </li>
<li>根据上述题意，程序中对应是<strong>如碰到儿子中有梯子和蛇的起点，完全忽略它，立刻转换成终点，也就是不入列，不入visited，不计算距离，完全当其透明</strong>。开始犯的错误是将其入列，出列才计算梯子终点。此算法仍然可以满足上述题意，此时梯子的起点会被加入到visited和distance，queue中，因为它确实停在那里了。  </li>
<li>visited在计算完梯子和蛇的终点后才处理，而不是进入for loop后  </li>
<li>neighbor不能超过n，达不到目标返回-1  </li>
<li>另一个难点在label转成坐标从而查找是否有梯子和蛇</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited: <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			queue.append(next_step)</span><br><span class="line">			visited.add(next_step)</span><br><span class="line">			distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
<p>另一种优化是只入最远的节点和蛇梯子的终点，类似于jump两种，类似于jump game。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(board) * len(board)</span><br><span class="line">	queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">	visited = set([<span class="number">1</span>])</span><br><span class="line">	distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == n:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		max_non_jump = node</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">			dest_label = board[board_x][board_y]</span><br><span class="line">			next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> next_step <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">				queue.append(next_step)</span><br><span class="line">				visited.add(next_step)</span><br><span class="line">				distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				max_non_jump = next_step</span><br><span class="line">		<span class="keyword">if</span> max_non_jump <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		queue.append(max_non_jump)</span><br><span class="line">		visited.add(max_non_jump)</span><br><span class="line">		distance[max_non_jump] = distance[node] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">	label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">	row_id = label // n <span class="comment"># 0</span></span><br><span class="line">	col_id = label % n</span><br><span class="line">	<span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>/6)</code>，空间复杂度<code>O(n<sup>2</sup>/6)</code>  </p>
<hr>
<h3 id="DP算法II解题思路-不推荐-："><a href="#DP算法II解题思路-不推荐-：" class="headerlink" title="DP算法II解题思路(不推荐)："></a><strong>DP算法II解题思路(不推荐)：</strong></h3><p>非常容易错，且效率更低，需要回退重新计算dp值。 dp[i] + 1 &lt; dp[dest_label]保证不会在无限回退，i = dest_label - 1要在break前做，而不是更前，否二影响dp[dest_label]计算</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders_dp</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	N = len(board) * len(board) + <span class="number">1</span></span><br><span class="line">	dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="comment"># i is label id</span></span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">	<span class="comment"># for i in range(2, N):</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; N:</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">			<span class="keyword">if</span> i + k &lt; N:</span><br><span class="line">				board_x, board_y = self.get_board_cell(len(board), i + k)</span><br><span class="line">				dest_label = board[board_x][board_y]</span><br><span class="line">				next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> i + k</span><br><span class="line">				<span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">					<span class="keyword">if</span> dest_label &lt; i <span class="keyword">and</span> dp[i] + <span class="number">1</span> &lt; dp[dest_label]: <span class="comment"># remember </span></span><br><span class="line">						dp[dest_label] = min(dp[dest_label], dp[i] + <span class="number">1</span>)</span><br><span class="line">						i = dest_label - <span class="number">1</span> <span class="comment"># remember to assign at the end</span></span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">				dp[next_step] = min(dp[next_step], dp[i] + <span class="number">1</span>) <span class="comment"># remember + 1 inside min</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 926 Flip String to Monotone Increasing</title>
    <url>/2021/12/26/lee-926/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A binary string is monotone increasing if it consists of some number of <code>0</code>‘s (possibly none), followed by some number of <code>1</code>‘s (also possibly none).<br><br>You are given a binary string <code>s</code>. You can flip <code>s[i]</code> changing it from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.<br><br>Return <em>the minimum number of flips to make</em> <code>s</code> <em>monotone increasing</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “00110”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> We flip the last digit to get 00111.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “010110”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We flip to get 011111, or alternatively 000111.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “00011000”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We flip to get 00000000.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>01字符串中Flip其中一些将它变成00111,0和1的个数是任意。  </p>
<h3 id="DP解题思路-推荐-："><a href="#DP解题思路-推荐-：" class="headerlink" title="DP解题思路(推荐)："></a><strong>DP解题思路(推荐)：</strong></h3><p>求最小值考虑用BFS或者DP。BFS的复杂度可能比较大，DP定义为以s[i]为结尾的最小flip数，但由于不知道具体排列(末状态)是什么或者结尾是什么，所以比较难从子问题推导出来。<br>不妨用两个dp来计算，<br>dp为以0为结尾的最小flip数<br>dp2为以1为结尾的最小flip数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp = dp     if s[i] = &apos;0&apos;</span><br><span class="line">   = dp + 1 if s[i] = &apos;1&apos;</span><br><span class="line">   </span><br><span class="line">dp2 = min(dp2 + 1, dp + 1)     if s[i] = &apos;0&apos;</span><br><span class="line">    = min(dp2, dp)             if s[i] = &apos;1&apos;</span><br></pre></td></tr></table></figure></p>
<p>公式不是对称，因为题意是先0再1。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用Python的dp和dp2同时由前状态赋值，这样避免用临时变量     </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	dp, dp2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">			dp, dp2 = dp, min(dp, dp2) + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			dp, dp2 = dp + <span class="number">1</span>, min(dp2, dp)</span><br><span class="line">	<span class="keyword">return</span> min(dp, dp2)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
<hr>
<h3 id="presum算法II解题思路："><a href="#presum算法II解题思路：" class="headerlink" title="presum算法II解题思路："></a><strong>presum算法II解题思路：</strong></h3><p>统计1的个数，若是0同时统计从0 flip到1的个数，取两者较小为新flip数。较难理解，不推荐    </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	ones, flips = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> c == <span class="string">'1'</span>:</span><br><span class="line">			ones += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			flips += <span class="number">1</span></span><br><span class="line">		flips = min(ones, flips)</span><br><span class="line">	<span class="keyword">return</span> flips</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 937 Reorder Data in Log Files</title>
    <url>/2021/12/25/lee-937/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reorder-data-in-log-files/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of <code>logs</code>. Each log is a space-delimited string of words, where the first word is the <strong>identifier</strong>.<br><br>There are two types of logs:<br><br><em>   <strong>Letter-logs</strong>: All words (except the identifier) consist of lowercase English letters.
</em>   <strong>Digit-logs</strong>: All words (except the identifier) consist of digits.<br><br>Reorder these logs so that:<br><br>1.  The <strong>letter-logs</strong> come before all <strong>digit-logs</strong>.<br>2.  The <strong>letter-logs</strong> are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.<br>3.  The <strong>digit-logs</strong> maintain their relative ordering.<br><br>Return <em>the final order of the logs</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> logs = [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br><strong>Output:</strong> [“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]<br><strong>Explanation:</strong><br>The letter-log contents are all different, so their ordering is “art can”, “art zero”, “own kit dig”.<br>The digit-logs have a relative order of “dig1 8 1 5 1”, “dig2 3 6”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> logs = [“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]<br><strong>Output:</strong> [“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= logs.length &lt;= 100</code>
</em>   <code>3 &lt;= logs[i].length &lt;= 100</code><br><em>   All the tokens of <code>logs[i]</code> are separated by a <strong>single</strong> space.
</em>   <code>logs[i]</code> is guaranteed to have an identifier and at least one word after the identifier.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排序log file，以下顺序：字母log (内容，id), 数字log</p>
<h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>排序的multi key实现(0, content_str, li[0]) if is_alpha else (1, ). (1, )表示按数组顺序    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(x)</span>:</span></span><br><span class="line">		li = x.split(<span class="string">' '</span>)</span><br><span class="line">		content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">		is_alpha = <span class="number">1</span> <span class="keyword">if</span> content_str[<span class="number">0</span>].isalpha() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>, content_str, li[<span class="number">0</span>]) <span class="keyword">if</span> is_alpha <span class="keyword">else</span> (<span class="number">1</span>, )</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted(logs, key=get_key)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmlogn)</code>，空间复杂度<code>O(mn)</code>, n为log数量，m为每个log的最长长度。如mergesort中merge复杂度为nm, 每个key比较是O(m)复杂度  </p>
<hr>
<h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>我的解法。本质上和上法一致，较繁琐  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>字母log排序不能按content_str + ‘ ‘ + li[0], 而是(content_str, li[0])作多key排序  </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles2</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">	letter_logs, digit_logs = [], []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(logs)):</span><br><span class="line">		<span class="keyword">if</span> logs[i][<span class="number">-1</span>].isdigit():</span><br><span class="line">			digit_logs.append(logs[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			li = logs[i].split(<span class="string">' '</span>)</span><br><span class="line">			content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">			letter_logs.append((content_str, li[<span class="number">0</span>], i))</span><br><span class="line">	letter_logs.sort()</span><br><span class="line">	res = [logs[pair[<span class="number">2</span>]] <span class="keyword">for</span> pair <span class="keyword">in</span> letter_logs]</span><br><span class="line">	res += digit_logs</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 973 K Closest Points to Origin</title>
    <url>/2021/12/05/lee-973/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <code>points</code> where <code>points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.<br><br>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code>√(x&lt;sub&gt;1&lt;/sub&gt; - x&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt; + (y&lt;sub&gt;1&lt;/sub&gt; - y&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;</code>).<br><br>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg" alt=""><br><br><pre><strong>Input:</strong> points = [[1,3],[-2,2]], k = 1<br><strong>Output:</strong> [[-2,2]]<br><strong>Explanation:</strong><br>The distance between (1, 3) and the origin is sqrt(10).<br>The distance between (-2, 2) and the origin is sqrt(8).<br>Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br>We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> points = [[3,3],[5,-1],[-2,4]], k = 2<br><strong>Output:</strong> [[3,3],[-2,4]]<br><strong>Explanation:</strong> The answer [[-2,4],[3,3]] would also be accepted.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= k &lt;= points.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt; x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt; &lt; 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最大堆    </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>求最小距离用最大堆，距离的相反数入堆   </li>
<li>与堆顶比较，跟模板一样仍然是大于号       </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> points <span class="keyword">or</span> <span class="keyword">not</span> points[<span class="number">0</span>]:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	heap, res = [], []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):</span><br><span class="line">		x, y = points[i][<span class="number">0</span>], points[i][<span class="number">1</span>] <span class="comment"># x=-2, y=2</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; k: <span class="comment"># i=1, k=1</span></span><br><span class="line">			heapq.heappush(heap, (-(x * x + y * y), x, y)) <span class="comment"># -10, 1, 3</span></span><br><span class="line">		<span class="keyword">elif</span> -(x * x + y * y) &gt; heap[<span class="number">0</span>][<span class="number">0</span>]: <span class="comment"># -8 &gt; -10</span></span><br><span class="line">			heapq.heapreplace(heap, (-(x * x + y * y), x, y)) <span class="comment"># -8, -2, -2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		(dis, x, y) = heapq.heappop(heap) <span class="comment"># -8, -2, -2</span></span><br><span class="line">		res.append([x, y])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">	PriorityQueue&lt;Point&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Point&gt;(K,</span><br><span class="line">			<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> distance(o2, o1); <span class="comment">// descending</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">		Point p = <span class="keyword">new</span> Point(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(maxHeap.size() &lt; K)</span><br><span class="line">			maxHeap.offer(p);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(distance(p, maxHeap.peek()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			maxHeap.poll();</span><br><span class="line">			maxHeap.offer(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!maxHeap.isEmpty()) &#123;</span><br><span class="line">		Point p = maxHeap.poll();</span><br><span class="line">		res[j][<span class="number">0</span>] = p.x;</span><br><span class="line">		res[j][<span class="number">1</span>] = p.y;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (o1.x * o1.x + o1.y * o1.y) - (o2.x * o2.x + o2.y * o2.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> x;</span><br><span class="line">	 <span class="keyword">int</span> y;</span><br><span class="line">	 Point() &#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">	 Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x = a; y = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(k)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 981 Time Based Key-Value Store</title>
    <url>/2021/12/25/lee-981/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/time-based-key-value-store/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp.<br><br>Implement the <code>TimeMap</code> class:<br><br><em>   <code>TimeMap()</code> Initializes the object of the data structure.
</em>   <code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value</code> at the given time <code>timestamp</code>.<br><em>   <code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“TimeMap”, “set”, “get”, “get”, “set”, “get”, “get”]<br>[[], [“foo”, “bar”, 1], [“foo”, 1], [“foo”, 3], [“foo”, “bar2”, 4], [“foo”, 4], [“foo”, 5]]<br><strong>Output</strong><br>[null, null, “bar”, “bar”, null, “bar2”, “bar2”]<br><br><strong>Explanation</strong><br>TimeMap timeMap = new TimeMap();<br>timeMap.set(“foo”, “bar”, 1);  // store the key “foo” and value “bar” along with timestamp = 1.<br>timeMap.get(“foo”, 1);         // return “bar”<br>timeMap.get(“foo”, 3);         // return “bar”, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is “bar”.<br>timeMap.set(“foo”, “bar2”, 4); // store the key “foo” and value “bar2” along with timestamp = 4.<br>timeMap.get(“foo”, 4);         // return “bar2”<br>timeMap.get(“foo”, 5);         // return “bar2”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= key.length, value.length &lt;= 100</code><br><em>   <code>key</code> and <code>value</code> consist of lowercase English letters and digits.
</em>   <code>1 &lt;= timestamp &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code><br><em>   All the timestamps <code>timestamp</code> of <code>set</code> are strictly increasing.
</em>   At most <code>2 * 10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>set</code> and <code>get</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现带历史记录的HashMap。也就是同一个key记录所有赋过值的value</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Map to list的思路，list含两个，包括value和timestamp，用binary search搜索timestamp的下标，然后返回对应的value   </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.key_to_val = collections.defaultdict(list)</span><br><span class="line">        self.key_to_timestamp = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key: str, value: str, timestamp: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.key_to_val[key].append(value)</span><br><span class="line">        self.key_to_timestamp[key].append(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: str, timestamp: int)</span> -&gt; str:</span></span><br><span class="line">        index = bisect.bisect(self.key_to_timestamp[key], timestamp) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key_to_val[key][index]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>get时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Index Page</title>
    <url>/2017/11/02/lee/</url>
    <content><![CDATA[<p><strong>LeetCode 目录</strong></p>
<table>
<thead>
<tr>
<th>#</th>
<th style="text-align:left">Title</th>
<th style="text-align:left">Difficulty</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">Two Sum</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">Add Two Numbers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">Longest Substring Without Repeating Characters</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">Median of Two Sorted Arrays</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">Longest Palindromic Substring</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">ZigZag Conversion</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left">Reverse Integer</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:left">String to Integer (atoi)</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:left">Palindrome Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:left">Regular Expression Matching</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:left">Container With Most Water</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:left">Integer to Roman</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:left">Roman to Integer</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:left">Longest Common Prefix</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>15</td>
<td style="text-align:left">3Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>16</td>
<td style="text-align:left">3Sum Closest</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>17</td>
<td style="text-align:left">Letter Combinations of a Phone Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>18</td>
<td style="text-align:left">4Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>19</td>
<td style="text-align:left">Remove Nth Node From End of List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>20</td>
<td style="text-align:left">Valid Parentheses</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>21</td>
<td style="text-align:left">Merge Two Sorted Lists</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:left">Generate Parentheses</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>23</td>
<td style="text-align:left">Merge k Sorted Lists</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>24</td>
<td style="text-align:left">Swap Nodes in Pairs</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>25</td>
<td style="text-align:left">Reverse Nodes in k-Group</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>26</td>
<td style="text-align:left">Remove Duplicates from Sorted Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>27</td>
<td style="text-align:left">Remove Element</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>28</td>
<td style="text-align:left">Implement strStr()</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>29</td>
<td style="text-align:left">Divide Two Integers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>30</td>
<td style="text-align:left">Substring with Concatenation of All Words</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>31</td>
<td style="text-align:left">Next Permutation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>32</td>
<td style="text-align:left">Longest Valid Parentheses</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>33</td>
<td style="text-align:left">Search in Rotated Sorted Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>34</td>
<td style="text-align:left">Search for a Range</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>35</td>
<td style="text-align:left">Search Insert Position</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>36</td>
<td style="text-align:left">Valid Sudoku</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>37</td>
<td style="text-align:left">Sudoku Solver</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>38</td>
<td style="text-align:left">Count and Say</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>39</td>
<td style="text-align:left">Combination Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>40</td>
<td style="text-align:left">Combination Sum II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>41</td>
<td style="text-align:left">First Missing Positive</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>42</td>
<td style="text-align:left">Trapping Rain Water</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>43</td>
<td style="text-align:left">Multiply Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>44</td>
<td style="text-align:left">Wildcard Matching</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>45</td>
<td style="text-align:left">Jump Game II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>46</td>
<td style="text-align:left">Permutations</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>47</td>
<td style="text-align:left">Permutations II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>48</td>
<td style="text-align:left">Rotate Image</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>49</td>
<td style="text-align:left">Group Anagrams</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>50</td>
<td style="text-align:left">Pow(x, n)</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>51</td>
<td style="text-align:left">N-Queens</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>52</td>
<td style="text-align:left">N-Queens II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>53</td>
<td style="text-align:left">Maximum Subarray</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>54</td>
<td style="text-align:left">Spiral Matrix</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>55</td>
<td style="text-align:left">Jump Game</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>56</td>
<td style="text-align:left">Merge Intervals</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>57</td>
<td style="text-align:left">Insert Interval</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>58</td>
<td style="text-align:left">Length of Last Word</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>59</td>
<td style="text-align:left">Spiral Matrix II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>60</td>
<td style="text-align:left">Permutation Sequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>61</td>
<td style="text-align:left">Rotate List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>62</td>
<td style="text-align:left">Unique Paths</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>63</td>
<td style="text-align:left">Unique Paths II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>64</td>
<td style="text-align:left">Minimum Path Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>65</td>
<td style="text-align:left">Valid Number</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>66</td>
<td style="text-align:left">Plus One</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>67</td>
<td style="text-align:left">Add Binary</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>68</td>
<td style="text-align:left">Text Justification</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>69</td>
<td style="text-align:left">Sqrt(x)</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>70</td>
<td style="text-align:left">Climbing Stairs</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>71</td>
<td style="text-align:left">Simplify Path</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>72</td>
<td style="text-align:left">Edit Distance</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>73</td>
<td style="text-align:left">Set Matrix Zeroes</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>74</td>
<td style="text-align:left">Search a 2D Matrix</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>75</td>
<td style="text-align:left">Sort Colors</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>76</td>
<td style="text-align:left">Minimum Window Substring</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>77</td>
<td style="text-align:left">Combinations</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>78</td>
<td style="text-align:left">Subsets</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>79</td>
<td style="text-align:left">Word Search</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>80</td>
<td style="text-align:left">Remove Duplicates from Sorted Array II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>81</td>
<td style="text-align:left">Search in Rotated Sorted Array II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>82</td>
<td style="text-align:left">Remove Duplicates from Sorted List II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>83</td>
<td style="text-align:left">Remove Duplicates from Sorted List</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>84</td>
<td style="text-align:left">Largest Rectangle in Histogram</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>85</td>
<td style="text-align:left">Maximal Rectangle</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>86</td>
<td style="text-align:left">Partition List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>87</td>
<td style="text-align:left">Scramble String</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>88</td>
<td style="text-align:left">Merge Sorted Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>89</td>
<td style="text-align:left">Gray Code</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>90</td>
<td style="text-align:left">Subsets II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>91</td>
<td style="text-align:left">Decode Ways</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>92</td>
<td style="text-align:left">Reverse Linked List II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>93</td>
<td style="text-align:left">Restore IP Addresses</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>94</td>
<td style="text-align:left">Binary Tree Inorder Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>95</td>
<td style="text-align:left">Unique Binary Search Trees II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>96</td>
<td style="text-align:left">Unique Binary Search Trees</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>97</td>
<td style="text-align:left">Interleaving String</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>98</td>
<td style="text-align:left">Validate Binary Search Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>99</td>
<td style="text-align:left">Recover Binary Search Tree</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>100</td>
<td style="text-align:left">Same Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>101</td>
<td style="text-align:left">Symmetric Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>102</td>
<td style="text-align:left">Binary Tree Level Order Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>103</td>
<td style="text-align:left">Binary Tree Zigzag Level Order Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>104</td>
<td style="text-align:left">Maximum Depth of Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>105</td>
<td style="text-align:left">Construct Binary Tree from Preorder and Inorder Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>106</td>
<td style="text-align:left">Construct Binary Tree from Inorder and Postorder Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>107</td>
<td style="text-align:left">Binary Tree Level Order Traversal II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>108</td>
<td style="text-align:left">Convert Sorted Array to Binary Search Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>109</td>
<td style="text-align:left">Convert Sorted List to Binary Search Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>110</td>
<td style="text-align:left">Balanced Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>111</td>
<td style="text-align:left">Minimum Depth of Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>112</td>
<td style="text-align:left">[Path Sum]</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>113</td>
<td style="text-align:left">Path Sum II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>114</td>
<td style="text-align:left">Flatten Binary Tree to Linked List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>115</td>
<td style="text-align:left">Distinct Subsequences</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>116</td>
<td style="text-align:left">Populating Next Right Pointers in Each Node</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>117</td>
<td style="text-align:left">Populating Next Right Pointers in Each Node II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>118</td>
<td style="text-align:left">Pascal’s Triangle</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>119</td>
<td style="text-align:left">Pascal’s Triangle II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>120</td>
<td style="text-align:left">Triangle</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>121</td>
<td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>122</td>
<td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>123</td>
<td style="text-align:left">[Best Time to Buy and Sell Stock III]</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>124</td>
<td style="text-align:left">Binary Tree Maximum Path Sum</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>125</td>
<td style="text-align:left">Valid Palindrome</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>126</td>
<td style="text-align:left">Word Ladder II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>127</td>
<td style="text-align:left">Word Ladder</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>128</td>
<td style="text-align:left">Longest Consecutive Sequence</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>129</td>
<td style="text-align:left">Sum Root to Leaf Numbers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>130</td>
<td style="text-align:left">Surrounded Regions</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>131</td>
<td style="text-align:left">Palindrome Partitioning</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>132</td>
<td style="text-align:left">Palindrome Partitioning II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>133</td>
<td style="text-align:left">Clone Graph</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>134</td>
<td style="text-align:left">Gas Station</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>135</td>
<td style="text-align:left">Candy</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>136</td>
<td style="text-align:left">Single Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>137</td>
<td style="text-align:left">Single Number II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>138</td>
<td style="text-align:left">Copy List with Random Pointer</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>139</td>
<td style="text-align:left">Word Break</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>140</td>
<td style="text-align:left">Word Break II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>141</td>
<td style="text-align:left">Linked List Cycle</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>142</td>
<td style="text-align:left">Linked List Cycle II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>143</td>
<td style="text-align:left">Reorder List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>144</td>
<td style="text-align:left">Binary Tree Preorder Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>145</td>
<td style="text-align:left">Binary Tree Postorder Traversal</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>146</td>
<td style="text-align:left">LRU Cache</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>147</td>
<td style="text-align:left">Insertion Sort List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>148</td>
<td style="text-align:left">Sort List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>149</td>
<td style="text-align:left">Max Points on a Line</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>150</td>
<td style="text-align:left">Evaluate Reverse Polish Notation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>151</td>
<td style="text-align:left">Reverse Words in a String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>152</td>
<td style="text-align:left">Maximum Product Subarray</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>153</td>
<td style="text-align:left">Find Minimum in Rotated Sorted Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>154</td>
<td style="text-align:left">Find Minimum in Rotated Sorted Array II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>155</td>
<td style="text-align:left">Min Stack</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>156</td>
<td style="text-align:left">Binary Tree Upside Down</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>157</td>
<td style="text-align:left">Read N Characters Given Read4</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>158</td>
<td style="text-align:left">Read N Characters Given Read4 II - Call multiple times</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>159</td>
<td style="text-align:left">Longest Substring with At Most Two Distinct Characters</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>160</td>
<td style="text-align:left">Intersection of Two Linked Lists</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>161</td>
<td style="text-align:left">One Edit Distance</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>162</td>
<td style="text-align:left">Find Peak Element</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>163</td>
<td style="text-align:left">Missing Ranges</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>164</td>
<td style="text-align:left">Maximum Gap</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>165</td>
<td style="text-align:left">Compare Version Numbers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>166</td>
<td style="text-align:left">Fraction to Recurring Decimal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>167</td>
<td style="text-align:left">Two Sum II - Input array is sorted</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>168</td>
<td style="text-align:left">Excel Sheet Column Title</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>169</td>
<td style="text-align:left">Majority Element</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>170</td>
<td style="text-align:left">Two Sum III - Data structure design</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>171</td>
<td style="text-align:left">Excel Sheet Column Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>172</td>
<td style="text-align:left">Factorial Trailing Zeroes</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>173</td>
<td style="text-align:left">Binary Search Tree Iterator</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>174</td>
<td style="text-align:left">Dungeon Game</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>175</td>
<td style="text-align:left">Combine Two Tables</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>176</td>
<td style="text-align:left">Second Highest Salary</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>177</td>
<td style="text-align:left">Nth Highest Salary</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>178</td>
<td style="text-align:left">Rank Scores</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>179</td>
<td style="text-align:left">Largest Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>180</td>
<td style="text-align:left">Consecutive Numbers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>181</td>
<td style="text-align:left">Employees Earning More Than Their Managers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>182</td>
<td style="text-align:left">Duplicate Emails</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>183</td>
<td style="text-align:left">Customers Who Never Order</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>184</td>
<td style="text-align:left">Department Highest Salary</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>185</td>
<td style="text-align:left">Department Top Three Salaries</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>186</td>
<td style="text-align:left">Reverse Words in a String II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>187</td>
<td style="text-align:left">Repeated DNA Sequences</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>188</td>
<td style="text-align:left">Best Time to Buy and Sell Stock IV</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>189</td>
<td style="text-align:left">Rotate Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>190</td>
<td style="text-align:left">Reverse Bits</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>191</td>
<td style="text-align:left">Number of 1 Bits</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>192</td>
<td style="text-align:left">Word Frequency</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>193</td>
<td style="text-align:left">Valid Phone Numbers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>194</td>
<td style="text-align:left">Transpose File</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>195</td>
<td style="text-align:left">Tenth Line</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>196</td>
<td style="text-align:left">Delete Duplicate Emails</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>197</td>
<td style="text-align:left">Rising Temperature</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>198</td>
<td style="text-align:left">House Robber</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>199</td>
<td style="text-align:left">Binary Tree Right Side View</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>200</td>
<td style="text-align:left">[Number of Islands]</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>201</td>
<td style="text-align:left">Bitwise AND of Numbers Range</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>202</td>
<td style="text-align:left">Happy Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>203</td>
<td style="text-align:left">Remove Linked List Elements</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>204</td>
<td style="text-align:left">Count Primes</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>205</td>
<td style="text-align:left">Isomorphic Strings</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>206</td>
<td style="text-align:left">Reverse Linked List</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>207</td>
<td style="text-align:left">Course Schedule</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>208</td>
<td style="text-align:left">Implement Trie (Prefix Tree)</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>209</td>
<td style="text-align:left">Minimum Size Subarray Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>210</td>
<td style="text-align:left">Course Schedule II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>211</td>
<td style="text-align:left">Add and Search Word - Data structure design</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>212</td>
<td style="text-align:left">Word Search II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>213</td>
<td style="text-align:left">House Robber II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>214</td>
<td style="text-align:left">Shortest Palindrome</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>215</td>
<td style="text-align:left">Kth Largest Element in an Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>216</td>
<td style="text-align:left">Combination Sum III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>217</td>
<td style="text-align:left">Contains Duplicate</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>218</td>
<td style="text-align:left">The Skyline Problem</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>219</td>
<td style="text-align:left">Contains Duplicate II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>220</td>
<td style="text-align:left">Contains Duplicate III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>221</td>
<td style="text-align:left">Maximal Square</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>222</td>
<td style="text-align:left">Count Complete Tree Nodes</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>223</td>
<td style="text-align:left">Rectangle Area</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>224</td>
<td style="text-align:left">Basic Calculator</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>225</td>
<td style="text-align:left">Implement Stack using Queues</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>226</td>
<td style="text-align:left">Invert Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>227</td>
<td style="text-align:left">Basic Calculator II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>228</td>
<td style="text-align:left">Summary Ranges</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>229</td>
<td style="text-align:left">Majority Element II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>230</td>
<td style="text-align:left">Kth Smallest Element in a BST</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>231</td>
<td style="text-align:left">Power of Two</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>232</td>
<td style="text-align:left">Implement Queue using Stacks</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>233</td>
<td style="text-align:left">Number of Digit One</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>234</td>
<td style="text-align:left">Palindrome Linked List</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>235</td>
<td style="text-align:left">Lowest Common Ancestor of a Binary Search Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>236</td>
<td style="text-align:left">Lowest Common Ancestor of a Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>237</td>
<td style="text-align:left">Delete Node in a Linked List</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>238</td>
<td style="text-align:left">Product of Array Except Self</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>239</td>
<td style="text-align:left">Sliding Window Maximum</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>240</td>
<td style="text-align:left">Search a 2D Matrix II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>241</td>
<td style="text-align:left">Different Ways to Add Parentheses</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>242</td>
<td style="text-align:left">Valid Anagram</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>243</td>
<td style="text-align:left">Shortest Word Distance</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>244</td>
<td style="text-align:left">Shortest Word Distance II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>245</td>
<td style="text-align:left">Shortest Word Distance III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>246</td>
<td style="text-align:left">Strobogrammatic Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>247</td>
<td style="text-align:left">Strobogrammatic Number II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>248</td>
<td style="text-align:left">Strobogrammatic Number III</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>249</td>
<td style="text-align:left">Group Shifted Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>250</td>
<td style="text-align:left">Count Univalue Subtrees</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>251</td>
<td style="text-align:left">Flatten 2D Vector</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>252</td>
<td style="text-align:left">Meeting Rooms</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>253</td>
<td style="text-align:left">Meeting Rooms II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>254</td>
<td style="text-align:left">Factor Combinations</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>255</td>
<td style="text-align:left">Verify Preorder Sequence in Binary Search Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>256</td>
<td style="text-align:left">Paint House</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>257</td>
<td style="text-align:left">Binary Tree Paths</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>258</td>
<td style="text-align:left">Add Digits</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>259</td>
<td style="text-align:left">3Sum Smaller</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>260</td>
<td style="text-align:left">Single Number III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>261</td>
<td style="text-align:left">Graph Valid Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>262</td>
<td style="text-align:left">Trips and Users</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>263</td>
<td style="text-align:left">Ugly Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>264</td>
<td style="text-align:left">Ugly Number II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>265</td>
<td style="text-align:left">Paint House II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>266</td>
<td style="text-align:left">Palindrome Permutation</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>267</td>
<td style="text-align:left">Palindrome Permutation II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>268</td>
<td style="text-align:left">Missing Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>269</td>
<td style="text-align:left">Alien Dictionary</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>270</td>
<td style="text-align:left">Closest Binary Search Tree Value</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>271</td>
<td style="text-align:left">Encode and Decode Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>272</td>
<td style="text-align:left">Closest Binary Search Tree Value II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>273</td>
<td style="text-align:left">Integer to English Words</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>274</td>
<td style="text-align:left">H-Index</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>275</td>
<td style="text-align:left">H-Index II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>276</td>
<td style="text-align:left">Paint Fence</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>277</td>
<td style="text-align:left">Find the Celebrity</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>278</td>
<td style="text-align:left">First Bad Version</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>279</td>
<td style="text-align:left">Perfect Squares</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>280</td>
<td style="text-align:left">Wiggle Sort</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>281</td>
<td style="text-align:left">Zigzag Iterator</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>282</td>
<td style="text-align:left">Expression Add Operators</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>283</td>
<td style="text-align:left">Move Zeroes</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>284</td>
<td style="text-align:left">Peeking Iterator</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>285</td>
<td style="text-align:left">Inorder Successor in BST</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>286</td>
<td style="text-align:left">Walls and Gates</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>287</td>
<td style="text-align:left">Find the Duplicate Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>288</td>
<td style="text-align:left">Unique Word Abbreviation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>289</td>
<td style="text-align:left">Game of Life</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>290</td>
<td style="text-align:left">Word Pattern</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>291</td>
<td style="text-align:left">Word Pattern II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>292</td>
<td style="text-align:left">Nim Game</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>293</td>
<td style="text-align:left">Flip Game</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>294</td>
<td style="text-align:left">Flip Game II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>295</td>
<td style="text-align:left">Find Median from Data Stream</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>296</td>
<td style="text-align:left">Best Meeting Point</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>297</td>
<td style="text-align:left">Serialize and Deserialize Binary Tree</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>298</td>
<td style="text-align:left">Binary Tree Longest Consecutive Sequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>299</td>
<td style="text-align:left">Bulls and Cows</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>300</td>
<td style="text-align:left">Longest Increasing Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>301</td>
<td style="text-align:left">Remove Invalid Parentheses</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>302</td>
<td style="text-align:left">Smallest Rectangle Enclosing Black Pixels</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>303</td>
<td style="text-align:left">Range Sum Query - Immutable</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>304</td>
<td style="text-align:left">Range Sum Query 2D - Immutable</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>305</td>
<td style="text-align:left">Number of Islands II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>306</td>
<td style="text-align:left">Additive Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>307</td>
<td style="text-align:left">Range Sum Query - Mutable</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>308</td>
<td style="text-align:left">Range Sum Query 2D - Mutable</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>309</td>
<td style="text-align:left">[Best Time to Buy and Sell Stock with Cooldown]</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>310</td>
<td style="text-align:left">[Minimum Height Trees]</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>311</td>
<td style="text-align:left">Sparse Matrix Multiplication</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>312</td>
<td style="text-align:left">[Burst Balloons]</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>313</td>
<td style="text-align:left">Super Ugly Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>314</td>
<td style="text-align:left">Binary Tree Vertical Order Traversal</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>315</td>
<td style="text-align:left">Count of Smaller Numbers After Self</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>316</td>
<td style="text-align:left">[Remove Duplicate Letters]</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>317</td>
<td style="text-align:left">Shortest Distance from All Buildings</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>318</td>
<td style="text-align:left">Maximum Product of Word Lengths</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>319</td>
<td style="text-align:left">Bulb Switcher</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>320</td>
<td style="text-align:left">Generalized Abbreviation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>321</td>
<td style="text-align:left">Create Maximum Number</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>322</td>
<td style="text-align:left">Coin Change</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>323</td>
<td style="text-align:left">Number of Connected Components in an Undirected Graph</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>324</td>
<td style="text-align:left">Wiggle Sort II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>325</td>
<td style="text-align:left">Maximum Size Subarray Sum Equals k</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>326</td>
<td style="text-align:left">Power of Three</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>327</td>
<td style="text-align:left">Count of Range Sum</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>328</td>
<td style="text-align:left">Odd Even Linked List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>329</td>
<td style="text-align:left">Longest Increasing Path in a Matrix</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>330</td>
<td style="text-align:left">Patching Array</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>331</td>
<td style="text-align:left">Verify Preorder Serialization of a Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>332</td>
<td style="text-align:left">Reconstruct Itinerary</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>333</td>
<td style="text-align:left">Largest BST Subtree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>334</td>
<td style="text-align:left">Increasing Triplet Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>335</td>
<td style="text-align:left">Self Crossing</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>336</td>
<td style="text-align:left">Palindrome Pairs</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>337</td>
<td style="text-align:left">House Robber III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>338</td>
<td style="text-align:left">Counting Bits</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>339</td>
<td style="text-align:left">Nested List Weight Sum</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>340</td>
<td style="text-align:left">Longest Substring with At Most K Distinct Characters</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>341</td>
<td style="text-align:left">Flatten Nested List Iterator</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>342</td>
<td style="text-align:left">Power of Four</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>343</td>
<td style="text-align:left">Integer Break</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>344</td>
<td style="text-align:left">Reverse String</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>345</td>
<td style="text-align:left">Reverse Vowels of a String</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>346</td>
<td style="text-align:left">Moving Average from Data Stream</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>347</td>
<td style="text-align:left">Top K Frequent Elements</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>348</td>
<td style="text-align:left">Design Tic-Tac-Toe</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>349</td>
<td style="text-align:left">Intersection of Two Arrays</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>350</td>
<td style="text-align:left">Intersection of Two Arrays II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>351</td>
<td style="text-align:left">Android Unlock Patterns</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>352</td>
<td style="text-align:left">Data Stream as Disjoint Intervals</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>353</td>
<td style="text-align:left">Design Snake Game</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>354</td>
<td style="text-align:left">Russian Doll Envelopes</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>355</td>
<td style="text-align:left">Design Twitter</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>356</td>
<td style="text-align:left">Line Reflection</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>357</td>
<td style="text-align:left">Count Numbers with Unique Digits</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>358</td>
<td style="text-align:left">Rearrange String k Distance Apart</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>359</td>
<td style="text-align:left">Logger Rate Limiter</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>360</td>
<td style="text-align:left">Sort Transformed Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>361</td>
<td style="text-align:left">Bomb Enemy</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>362</td>
<td style="text-align:left">Design Hit Counter</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>363</td>
<td style="text-align:left">Max Sum of Rectangle No Larger Than K</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>364</td>
<td style="text-align:left">Nested List Weight Sum II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>365</td>
<td style="text-align:left">Water and Jug Problem</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>366</td>
<td style="text-align:left">Find Leaves of Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>367</td>
<td style="text-align:left">Valid Perfect Square</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>368</td>
<td style="text-align:left">Largest Divisible Subset</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>369</td>
<td style="text-align:left">Plus One Linked List</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>370</td>
<td style="text-align:left">Range Addition</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>371</td>
<td style="text-align:left">Sum of Two Integers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>372</td>
<td style="text-align:left">Super Pow</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>373</td>
<td style="text-align:left">Find K Pairs with Smallest Sums</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>374</td>
<td style="text-align:left">Guess Number Higher or Lower</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>375</td>
<td style="text-align:left">Guess Number Higher or Lower II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>376</td>
<td style="text-align:left">Wiggle Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>377</td>
<td style="text-align:left">Combination Sum IV</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>378</td>
<td style="text-align:left">Kth Smallest Element in a Sorted Matrix</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>379</td>
<td style="text-align:left">Design Phone Directory</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>380</td>
<td style="text-align:left">Insert Delete GetRandom O(1)</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>381</td>
<td style="text-align:left">Insert Delete GetRandom O(1) - Duplicates allowed</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>382</td>
<td style="text-align:left">Linked List Random Node</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>383</td>
<td style="text-align:left">Ransom Note</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>384</td>
<td style="text-align:left">Shuffle an Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>385</td>
<td style="text-align:left">Mini Parser</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>386</td>
<td style="text-align:left">Lexicographical Numbers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>387</td>
<td style="text-align:left">First Unique Character in a String</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>388</td>
<td style="text-align:left">Longest Absolute File Path</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>389</td>
<td style="text-align:left">Find the Difference</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>390</td>
<td style="text-align:left">Elimination Game</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>391</td>
<td style="text-align:left">Perfect Rectangle</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>392</td>
<td style="text-align:left">Is Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>393</td>
<td style="text-align:left">UTF-8 Validation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>394</td>
<td style="text-align:left">Decode String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>395</td>
<td style="text-align:left">Longest Substring with At Least K Repeating Characters</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>396</td>
<td style="text-align:left">Rotate Function</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>397</td>
<td style="text-align:left">Integer Replacement</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>398</td>
<td style="text-align:left">Random Pick Index</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>399</td>
<td style="text-align:left">Evaluate Division</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>400</td>
<td style="text-align:left">Nth Digit</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>401</td>
<td style="text-align:left">Binary Watch</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>402</td>
<td style="text-align:left">Remove K Digits</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>403</td>
<td style="text-align:left">Frog Jump</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>404</td>
<td style="text-align:left">Sum of Left Leaves</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>405</td>
<td style="text-align:left">Convert a Number to Hexadecimal</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>406</td>
<td style="text-align:left">Queue Reconstruction by Height</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>407</td>
<td style="text-align:left">Trapping Rain Water II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>408</td>
<td style="text-align:left">Valid Word Abbreviation</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>409</td>
<td style="text-align:left">Longest Palindrome</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>410</td>
<td style="text-align:left">Split Array Largest Sum</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>411</td>
<td style="text-align:left">Minimum Unique Word Abbreviation</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>412</td>
<td style="text-align:left">Fizz Buzz</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>413</td>
<td style="text-align:left">Arithmetic Slices</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>414</td>
<td style="text-align:left">Third Maximum Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>415</td>
<td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/02/lee-415/" target="_blank" rel="noopener">Add Strings</a></td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>416</td>
<td style="text-align:left">Partition Equal Subset Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>417</td>
<td style="text-align:left">Pacific Atlantic Water Flow</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>418</td>
<td style="text-align:left">Sentence Screen Fitting</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>419</td>
<td style="text-align:left">Battleships in a Board</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>420</td>
<td style="text-align:left">Strong Password Checker</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>421</td>
<td style="text-align:left">Maximum XOR of Two Numbers in an Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>422</td>
<td style="text-align:left">Valid Word Square</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>423</td>
<td style="text-align:left">Reconstruct Original Digits from English</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>424</td>
<td style="text-align:left">Longest Repeating Character Replacement</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>425</td>
<td style="text-align:left">Word Squares</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>432</td>
<td style="text-align:left">All O`one Data Structure</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>433</td>
<td style="text-align:left">Minimum Genetic Mutation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>434</td>
<td style="text-align:left">Number of Segments in a String</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>435</td>
<td style="text-align:left">Non-overlapping Intervals</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>436</td>
<td style="text-align:left">Find Right Interval</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>437</td>
<td style="text-align:left">Path Sum III</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>438</td>
<td style="text-align:left">Find All Anagrams in a String</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>439</td>
<td style="text-align:left">Ternary Expression Parser</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>440</td>
<td style="text-align:left">K-th Smallest in Lexicographical Order</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>441</td>
<td style="text-align:left">Arranging Coins</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>442</td>
<td style="text-align:left">Find All Duplicates in an Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>443</td>
<td style="text-align:left">String Compression</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>444</td>
<td style="text-align:left">Sequence Reconstruction</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>445</td>
<td style="text-align:left">Add Two Numbers II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>446</td>
<td style="text-align:left">Arithmetic Slices II - Subsequence</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>447</td>
<td style="text-align:left">Number of Boomerangs</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>448</td>
<td style="text-align:left">Find All Numbers Disappeared in an Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>449</td>
<td style="text-align:left">Serialize and Deserialize BST</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>450</td>
<td style="text-align:left">Delete Node in a BST</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>451</td>
<td style="text-align:left">Sort Characters By Frequency</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>452</td>
<td style="text-align:left">Minimum Number of Arrows to Burst Balloons</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>453</td>
<td style="text-align:left">Minimum Moves to Equal Array Elements</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>454</td>
<td style="text-align:left">4Sum II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>455</td>
<td style="text-align:left">Assign Cookies</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>456</td>
<td style="text-align:left">132 Pattern</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>457</td>
<td style="text-align:left">Circular Array Loop</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>458</td>
<td style="text-align:left">Poor Pigs</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>459</td>
<td style="text-align:left">Repeated Substring Pattern</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>460</td>
<td style="text-align:left">LFU Cache</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>461</td>
<td style="text-align:left">Hamming Distance</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>462</td>
<td style="text-align:left">Minimum Moves to Equal Array Elements II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>463</td>
<td style="text-align:left">Island Perimeter</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>464</td>
<td style="text-align:left">Can I Win</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>465</td>
<td style="text-align:left">Optimal Account Balancing</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>466</td>
<td style="text-align:left">Count The Repetitions</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>467</td>
<td style="text-align:left">Unique Substrings in Wraparound String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>468</td>
<td style="text-align:left">Validate IP Address</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>469</td>
<td style="text-align:left">Convex Polygon</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>471</td>
<td style="text-align:left">Encode String with Shortest Length</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>472</td>
<td style="text-align:left">Concatenated Words</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>473</td>
<td style="text-align:left">Matchsticks to Square</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>474</td>
<td style="text-align:left">Ones and Zeroes</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>475</td>
<td style="text-align:left">Heaters</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>476</td>
<td style="text-align:left">Number Complement</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>477</td>
<td style="text-align:left">Total Hamming Distance</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>479</td>
<td style="text-align:left">Largest Palindrome Product</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>480</td>
<td style="text-align:left">Sliding Window Median</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>481</td>
<td style="text-align:left">Magical String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>482</td>
<td style="text-align:left">License Key Formatting</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>483</td>
<td style="text-align:left">Smallest Good Base</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>484</td>
<td style="text-align:left">Find Permutation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>485</td>
<td style="text-align:left">Max Consecutive Ones</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>486</td>
<td style="text-align:left">Predict the Winner</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>487</td>
<td style="text-align:left">Max Consecutive Ones II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>488</td>
<td style="text-align:left">Zuma Game</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>490</td>
<td style="text-align:left">The Maze</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>491</td>
<td style="text-align:left">Increasing Subsequences</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>492</td>
<td style="text-align:left">Construct the Rectangle</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>493</td>
<td style="text-align:left">Reverse Pairs</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>494</td>
<td style="text-align:left">Target Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>495</td>
<td style="text-align:left">Teemo Attacking</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>496</td>
<td style="text-align:left">Next Greater Element I</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>498</td>
<td style="text-align:left">Diagonal Traverse</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>499</td>
<td style="text-align:left">The Maze III</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>500</td>
<td style="text-align:left">Keyboard Row</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>501</td>
<td style="text-align:left">Find Mode in Binary Search Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>502</td>
<td style="text-align:left">IPO</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>503</td>
<td style="text-align:left">Next Greater Element II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>504</td>
<td style="text-align:left">Base 7</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>505</td>
<td style="text-align:left">The Maze II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>506</td>
<td style="text-align:left">Relative Ranks</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>507</td>
<td style="text-align:left">Perfect Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>508</td>
<td style="text-align:left">Most Frequent Subtree Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>513</td>
<td style="text-align:left">Find Bottom Left Tree Value</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>514</td>
<td style="text-align:left">Freedom Trail</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>515</td>
<td style="text-align:left">Find Largest Value in Each Tree Row</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>516</td>
<td style="text-align:left">Longest Palindromic Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>517</td>
<td style="text-align:left">Super Washing Machines</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>518</td>
<td style="text-align:left">Coin Change 2</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>520</td>
<td style="text-align:left">Detect Capital</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>521</td>
<td style="text-align:left">Longest Uncommon Subsequence IÊ</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>522</td>
<td style="text-align:left">Longest Uncommon Subsequence II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>523</td>
<td style="text-align:left">Continuous Subarray Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>524</td>
<td style="text-align:left">Longest Word in Dictionary through Deleting</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>525</td>
<td style="text-align:left">Contiguous Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>526</td>
<td style="text-align:left">Beautiful Arrangement</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>527</td>
<td style="text-align:left">Word Abbreviation</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>529</td>
<td style="text-align:left">Minesweeper</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>530</td>
<td style="text-align:left">Minimum Absolute Difference in BST</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>531</td>
<td style="text-align:left">Lonely Pixel I</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>532</td>
<td style="text-align:left">K-diff Pairs in an Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>533</td>
<td style="text-align:left">Lonely Pixel II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>534</td>
<td style="text-align:left">Design TinyURL</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>535</td>
<td style="text-align:left">Encode and Decode TinyURL</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>536</td>
<td style="text-align:left">Construct Binary Tree from String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>537</td>
<td style="text-align:left">Complex Number Multiplication</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>538</td>
<td style="text-align:left">Convert BST to Greater Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>539</td>
<td style="text-align:left">Minimum Time Difference</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>540</td>
<td style="text-align:left">Single Element in a Sorted Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>541</td>
<td style="text-align:left">Reverse String II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>542</td>
<td style="text-align:left">01 Matrix</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>543</td>
<td style="text-align:left">Diameter of Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>544</td>
<td style="text-align:left">Output Contest Matches</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>545</td>
<td style="text-align:left">Boundary of Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>546</td>
<td style="text-align:left">Remove Boxes</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>547</td>
<td style="text-align:left">Friend Circles</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>548</td>
<td style="text-align:left">Split Array with Equal Sum</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>549</td>
<td style="text-align:left">Binary Tree Longest Consecutive Sequence II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>551</td>
<td style="text-align:left">Student Attendance Record I</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>552</td>
<td style="text-align:left">Student Attendance Record II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>553</td>
<td style="text-align:left">Optimal Division</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>554</td>
<td style="text-align:left">Brick Wall</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>555</td>
<td style="text-align:left">Split Concatenated Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>556</td>
<td style="text-align:left">Next Greater Element III</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>557</td>
<td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/02/lee-557/" target="_blank" rel="noopener">Reverse Words in a String III</a></td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>560</td>
<td style="text-align:left">Subarray Sum Equals K</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>561</td>
<td style="text-align:left">Array Partition I</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>562</td>
<td style="text-align:left">Longest Line of Consecutive One in Matrix</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>563</td>
<td style="text-align:left">Binary Tree Tilt</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>564</td>
<td style="text-align:left">Find the Closest Palindrome</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>565</td>
<td style="text-align:left">Array Nesting</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>566</td>
<td style="text-align:left">Reshape the Matrix</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>567</td>
<td style="text-align:left">Permutation in String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>568</td>
<td style="text-align:left">Maximum Vacation Days</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>569</td>
<td style="text-align:left">Median Employee Salary</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>570</td>
<td style="text-align:left">Managers with at Least 5 Direct Reports</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>571</td>
<td style="text-align:left">Find Median Given Frequency of Numbers</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>572</td>
<td style="text-align:left">Subtree of Another Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>573</td>
<td style="text-align:left">Squirrel Simulation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>574</td>
<td style="text-align:left">Winning Candidate</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>575</td>
<td style="text-align:left">Distribute Candies</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>576</td>
<td style="text-align:left">Out of Boundary Paths</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>577</td>
<td style="text-align:left">Employee Bonus</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>578</td>
<td style="text-align:left">Get Highest Answer Rate Question</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>579</td>
<td style="text-align:left">Find Cumulative Salary of an Employee</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>580</td>
<td style="text-align:left">Count Student Number in Departments</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>581</td>
<td style="text-align:left">Shortest Unsorted Continuous Subarray</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>582</td>
<td style="text-align:left">Kill Process</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>583</td>
<td style="text-align:left">Delete Operation for Two Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>584</td>
<td style="text-align:left">Find Customer Referee</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>585</td>
<td style="text-align:left">Investments in 2016</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>586</td>
<td style="text-align:left">Customer Placing the Largest Number of Orders</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>587</td>
<td style="text-align:left">Erect the Fence</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>588</td>
<td style="text-align:left">Design In-Memory File System</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>591</td>
<td style="text-align:left">Tag Validator</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>592</td>
<td style="text-align:left">Fraction Addition and Subtraction</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>593</td>
<td style="text-align:left">Valid Square</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>594</td>
<td style="text-align:left">Longest Harmonious Subsequence</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>595</td>
<td style="text-align:left">Big Countries</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>596</td>
<td style="text-align:left">Classes More Than 5 Students</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>597</td>
<td style="text-align:left">Friend Requests I: Overall Acceptance Rate</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>598</td>
<td style="text-align:left">Range Addition II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>599</td>
<td style="text-align:left">Minimum Index Sum of Two Lists</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>600</td>
<td style="text-align:left">Non-negative Integers without Consecutive Ones</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>601</td>
<td style="text-align:left">Human Traffic of Stadium</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>602</td>
<td style="text-align:left">Friend Requests II: Who Has the Most Friends</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>603</td>
<td style="text-align:left">Consecutive Available Seats</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>604</td>
<td style="text-align:left">Design Compressed String Iterator</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>605</td>
<td style="text-align:left">Can Place Flowers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>606</td>
<td style="text-align:left">Construct String from Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>607</td>
<td style="text-align:left">Sales Person</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>608</td>
<td style="text-align:left">Tree Node</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>609</td>
<td style="text-align:left">Find Duplicate File in System</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>610</td>
<td style="text-align:left">Triangle Judgement</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>611</td>
<td style="text-align:left">Valid Triangle Number</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>612</td>
<td style="text-align:left">Shortest Distance in a Plane</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>613</td>
<td style="text-align:left">Shortest Distance in a Line</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>614</td>
<td style="text-align:left">Second Degree Follower</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>615</td>
<td style="text-align:left">Average Salary: Departments VS Company</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>616</td>
<td style="text-align:left">Add Bold Tag in String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>617</td>
<td style="text-align:left">Merge Two Binary Trees</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>618</td>
<td style="text-align:left">Students Report By Geography</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>619</td>
<td style="text-align:left">Biggest Single Number</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>620</td>
<td style="text-align:left">Not Boring Movies</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>621</td>
<td style="text-align:left">Task Scheduler</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>623</td>
<td style="text-align:left">Add One Row to Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>624</td>
<td style="text-align:left">Maximum Distance in Arrays</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>625</td>
<td style="text-align:left">Minimum Factorization</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>626</td>
<td style="text-align:left">Exchange Seats</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>627</td>
<td style="text-align:left">Swap Salary</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>628</td>
<td style="text-align:left">Maximum Product of Three Numbers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>629</td>
<td style="text-align:left">K Inverse Pairs Array</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>630</td>
<td style="text-align:left">Course Schedule III</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>631</td>
<td style="text-align:left">Design Excel Sum Formula</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>632</td>
<td style="text-align:left">Smallest Range</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>633</td>
<td style="text-align:left">Sum of Square Numbers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>634</td>
<td style="text-align:left">Find the Derangement of An Array</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>635</td>
<td style="text-align:left">Design Log Storage System</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>636</td>
<td style="text-align:left">Exclusive Time of Functions</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>637</td>
<td style="text-align:left">Average of Levels in Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>638</td>
<td style="text-align:left">Shopping Offers</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>639</td>
<td style="text-align:left">Decode Ways II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>640</td>
<td style="text-align:left">Solve the Equation</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>642</td>
<td style="text-align:left">Design Search Autocomplete System</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>643</td>
<td style="text-align:left">Maximum Average Subarray I</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>644</td>
<td style="text-align:left">Maximum Average Subarray II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>645</td>
<td style="text-align:left">Set Mismatch</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>646</td>
<td style="text-align:left">Maximum Length of Pair Chain</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>647</td>
<td style="text-align:left">Palindromic Substrings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>648</td>
<td style="text-align:left">Replace Words</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>649</td>
<td style="text-align:left">Dota2 Senate</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>650</td>
<td style="text-align:left">2 Keys Keyboard</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>651</td>
<td style="text-align:left">4 Keys Keyboard</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>652</td>
<td style="text-align:left">Find Duplicate Subtrees</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>653</td>
<td style="text-align:left">Two Sum IV - Input is a BST</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>654</td>
<td style="text-align:left">Maximum Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>655</td>
<td style="text-align:left">Print Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>656</td>
<td style="text-align:left">Coin Path</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>657</td>
<td style="text-align:left">Judge Route Circle</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>658</td>
<td style="text-align:left">Find K Closest Elements</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>659</td>
<td style="text-align:left">Split Array into Consecutive Subsequences</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>660</td>
<td style="text-align:left">Remove 9</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>661</td>
<td style="text-align:left">Image Smoother</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>662</td>
<td style="text-align:left">Maximum Width of Binary Tree</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>663</td>
<td style="text-align:left">Equal Tree Partition</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>664</td>
<td style="text-align:left">Strange Printer</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>665</td>
<td style="text-align:left">Non-decreasing Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>666</td>
<td style="text-align:left">Path Sum IV</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>667</td>
<td style="text-align:left">Beautiful Arrangement II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>668</td>
<td style="text-align:left">Kth Smallest Number in Multiplication Table</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>669</td>
<td style="text-align:left">Trim a Binary Search Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>670</td>
<td style="text-align:left">Maximum Swap</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>671</td>
<td style="text-align:left">Second Minimum Node In a Binary Tree</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>672</td>
<td style="text-align:left">Bulb Switcher II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>673</td>
<td style="text-align:left">Number of Longest Increasing Subsequence</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>674</td>
<td style="text-align:left">Longest Continuous Increasing Subsequence</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>675</td>
<td style="text-align:left">Cut Off Trees for Golf Event</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>676</td>
<td style="text-align:left">Implement Magic Dictionary</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>677</td>
<td style="text-align:left">Map Sum Pairs</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>678</td>
<td style="text-align:left">Valid Parenthesis String</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>679</td>
<td style="text-align:left">24 Game</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>680</td>
<td style="text-align:left">Valid Palindrome II</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>681</td>
<td style="text-align:left">Next Closest Time</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>682</td>
<td style="text-align:left">Baseball Game</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>683</td>
<td style="text-align:left">K Empty Slots</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>684</td>
<td style="text-align:left">Redundant Connection</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>685</td>
<td style="text-align:left">Redundant Connection II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>686</td>
<td style="text-align:left">Repeated String Match</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>687</td>
<td style="text-align:left">Longest Univalue Path</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>688</td>
<td style="text-align:left">Knight Probability in Chessboard</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>689</td>
<td style="text-align:left">Maximum Sum of 3 Non-Overlapping Subarrays</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>690</td>
<td style="text-align:left">Employee Importance</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>691</td>
<td style="text-align:left">Stickers to Spell Word</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>692</td>
<td style="text-align:left">Top K Frequent Words</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>693</td>
<td style="text-align:left">Binary Number with Alternating Bits</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>694</td>
<td style="text-align:left">Number of Distinct Islands</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>695</td>
<td style="text-align:left">Max Area of Island</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>696</td>
<td style="text-align:left">Count Binary Substrings</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>697</td>
<td style="text-align:left">Degree of an Array</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>698</td>
<td style="text-align:left">Partition to K Equal Sum Subsets</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>699</td>
<td style="text-align:left">Falling Squares</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>711</td>
<td style="text-align:left">Number of Distinct Islands II</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>712</td>
<td style="text-align:left">Minimum ASCII Delete Sum for Two Strings</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>713</td>
<td style="text-align:left">Subarray Product Less Than K</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>714</td>
<td style="text-align:left">Best Time to Buy and Sell Stock with Transaction Fee</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>715</td>
<td style="text-align:left">Range Module</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>716</td>
<td style="text-align:left">Max Stack</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>717</td>
<td style="text-align:left">1-bit and 2-bit Characters</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>718</td>
<td style="text-align:left">Maximum Length of Repeated Subarray</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>719</td>
<td style="text-align:left">Find K-th Smallest Pair Distance</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>720</td>
<td style="text-align:left">Longest Word in Dictionary</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>721</td>
<td style="text-align:left">Accounts Merge</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>722</td>
<td style="text-align:left">Remove Comments</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>723</td>
<td style="text-align:left">Candy Crush</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>724</td>
<td style="text-align:left">Find Pivot Index</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>725</td>
<td style="text-align:left">Split Linked List in Parts</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>726</td>
<td style="text-align:left">Number of Atoms</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>727</td>
<td style="text-align:left">Minimum Window Subsequence</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>728</td>
<td style="text-align:left">Self Dividing Numbers</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>729</td>
<td style="text-align:left">My Calendar I</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>730</td>
<td style="text-align:left">Count Different Palindromic Subsequences</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>731</td>
<td style="text-align:left">My Calendar II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>732</td>
<td style="text-align:left">My Calendar III</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>733</td>
<td style="text-align:left">Flood Fill</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>734</td>
<td style="text-align:left">Sentence Similarity</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>735</td>
<td style="text-align:left">Asteroid Collision</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>736</td>
<td style="text-align:left">Parse Lisp Expression</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>737</td>
<td style="text-align:left">Sentence Similarity II</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>738</td>
<td style="text-align:left">Monotone Increasing Digits</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>739</td>
<td style="text-align:left">Daily Temperatures</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>740</td>
<td style="text-align:left">Delete and Earn</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>741</td>
<td style="text-align:left">Cherry Pickup</td>
<td style="text-align:left">Hard</td>
</tr>
<tr>
<td>742</td>
<td style="text-align:left">Closest Leaf in a Binary TreeNew</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>743</td>
<td style="text-align:left">Network Delay TimeNew</td>
<td style="text-align:left">Medium</td>
</tr>
<tr>
<td>744</td>
<td style="text-align:left">Find Smallest Letter Greater Than TargetNew</td>
<td style="text-align:left">Easy</td>
</tr>
<tr>
<td>745</td>
<td style="text-align:left">Prefix and Suffix SearchNew</td>
<td style="text-align:left">Hard</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 987 Vertical Order Traversal of a Binary Tree</title>
    <url>/2021/12/27/lee-987/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.<br><br>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.<br><br>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.<br><br>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br><strong>Explanation:</strong><br>Column -1: Only node 9 is in this column.<br>Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.<br>Column 1: Only node 20 is in this column.<br>Column 2: Only node 7 is in this column.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5,6,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>Column -2: Only node 4 is in this column.<br>Column -1: Only node 2 is in this column.<br>Column 0: Nodes 1, 5, and 6 are in this column.<br>          1 is at the top, so it comes first.<br>          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.<br>Column 1: Only node 3 is in this column.<br>Column 2: Only node 7 is in this column.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,6,5,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>This case is the exact same as example 2, but with nodes 5 and 6 swapped.<br>Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 1000]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序打印二叉树，若列号同，同一行的节点按值排序 </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>与<a href="https://shineboy2013.github.io/2021/12/24/lee-314/" target="_blank" rel="noopener">LeetCode 314 Binary Tree Vertical Order Traversal</a>类似，用BFS</p>
<p>LeetCode 314 Binary Tree Vertical Order Traversal 同一列，从上到下，从左到右排序<br>LeetCode 987 Vertical Order Traversal of a Binary Tree 同一列，从上到下，同一行值从小到大排序</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>与LeetCode 314实现的区别</p>
<ol>
<li>一开始以为同一列的同一行的节点在queue是一个紧接一个出列。但同一行节点可能先出列col=3, col=4， col=3。而且同一列同一行的节点有多个，不止两个。所以<strong>将row_id也加入到queue节点和map中</strong>  </li>
<li>遍历结果时，map中的value排序**, value是先row_id再node.val，所以直接可以排序，最后直接取出第二维度</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	col_to_node_list = collections.defaultdict(list)</span><br><span class="line">	min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">	queue = collections.deque([(root, <span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node, row_id, col_id = queue.popleft()</span><br><span class="line">		col_to_node_list[col_id].append((row_id, node.val))</span><br><span class="line">		min_col, max_col = min(min_col, col_id), max(max_col, col_id)</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			queue.append((node.left, row_id + <span class="number">1</span>, col_id - <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			queue.append((node.right, row_id + <span class="number">1</span>, col_id + <span class="number">1</span>))</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">		col_to_node_list[i].sort()</span><br><span class="line">		res.append([_[<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> col_to_node_list[i]])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，稍大于O(n), 因为同一列同一行节点要排序    </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Binary Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2021/12/13/leetcode-000/</url>
    <content><![CDATA[<p><strong><a href="">LeetCode</a></strong></p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 706 Design HashMap</title>
    <url>/2022/03/15/leetcode-0706-design-hashmap/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-hashmap/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a HashMap without using any built-in hash table libraries.<br><br>Implement the <code>MyHashMap</code> class:<br><br><em>   <code>MyHashMap()</code> initializes the object with an empty map.
</em>   <code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.<br><em>   <code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.
</em>   <code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MyHashMap”, “put”, “put”, “get”, “get”, “put”, “get”, “remove”, “get”]<br>[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]<br><strong>Output</strong><br>[null, null, null, 1, -1, null, 1, null, -1]<br><br><strong>Explanation</strong><br>MyHashMap myHashMap = new MyHashMap();<br>myHashMap.put(1, 1); // The map is now [[1,1]]<br>myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]<br>myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]<br>myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]<br>myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)<br>myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]<br>myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]<br>myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= key, value &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code>
</em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计HashMap</p>
<h3 id="LL解题思路-推荐-："><a href="#LL解题思路-推荐-：" class="headerlink" title="LL解题思路(推荐)："></a><strong>LL解题思路(推荐)：</strong></h3><p>大学学到的方法，用Array实现，将key mod prime num找到index插入。难点在于冲突处理，这里用chaining方法，也就是LL</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>迭代LL时候，每种方法put, get, remove都不同。put只能迭代到最后一个不能到None，因为要从尾部加入。<br>get正常一个个迭代。remove要从parent也就是it.next迭代因为要删除节点。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.key_space = <span class="number">997</span></span><br><span class="line">        self.buckets = [ListNode(<span class="number">-1</span>, <span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.key_space)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        it = self.buckets[index]</span><br><span class="line">        <span class="keyword">while</span> it:</span><br><span class="line">            <span class="keyword">if</span> it.key == key:</span><br><span class="line">                it.val = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> it.next:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            it = it.next</span><br><span class="line">        it.next = ListNode(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        it = self.buckets[index]</span><br><span class="line">        <span class="keyword">while</span> it:</span><br><span class="line">            <span class="keyword">if</span> it.key == key:</span><br><span class="line">                <span class="keyword">return</span> it.val</span><br><span class="line">            it = it.next</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        it = self.buckets[index]</span><br><span class="line">        <span class="keyword">while</span> it.next:</span><br><span class="line">            <span class="keyword">if</span> it.next.key == key:</span><br><span class="line">                tmp = it.next</span><br><span class="line">                it.next, tmp.next = it.next.next, <span class="keyword">None</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            it = it.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k)</code>，空间复杂度<code>O(n)</code>, k为冲突数</p>
<hr>
<h3 id="数组算法II解题思路："><a href="#数组算法II解题思路：" class="headerlink" title="数组算法II解题思路："></a><strong>数组算法II解题思路：</strong></h3><p>较容易实现，remove复杂度稍差，但是最差情况也是同上</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.key_space = <span class="number">997</span></span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.key_space)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        <span class="keyword">for</span> i, [_key, _val] <span class="keyword">in</span> enumerate(self.buckets[index]):</span><br><span class="line">            <span class="keyword">if</span> _key == key:</span><br><span class="line">                self.buckets[index][i] = [key, value]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        self.buckets[index].append([key, value])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        <span class="keyword">for</span> _key, _val <span class="keyword">in</span> self.buckets[index]:</span><br><span class="line">            <span class="keyword">if</span> _key == key:</span><br><span class="line">                <span class="keyword">return</span> _val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.key_space</span><br><span class="line">        <span class="keyword">for</span> i, [_key, _val] <span class="keyword">in</span> enumerate(self.buckets[index]):</span><br><span class="line">            <span class="keyword">if</span> _key == key:</span><br><span class="line">                self.buckets[index].pop(i)</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k)</code>，空间复杂度<code>O(n)</code>, k为冲突数</p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 095 Unique Binary Search Trees II</title>
    <url>/2022/01/18/leetcode-095-unique-binary-search-trees-ii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST’</strong>s (binary search trees), which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt=""><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 8</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求所有val为1-n的BST的所有可能性</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS中比较难的catalan类型。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>root = TreeNode(i)要在最内层for循环中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt; end:</span><br><span class="line">		<span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line">	<span class="keyword">if</span> start == end:</span><br><span class="line">		<span class="keyword">return</span> [TreeNode(start)]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">		left_nodes = self.dfs(start, i - <span class="number">1</span>)</span><br><span class="line">		right_nodes = self.dfs(i + <span class="number">1</span>, end)</span><br><span class="line">		<span class="keyword">for</span> _l <span class="keyword">in</span> left_nodes:</span><br><span class="line">			<span class="keyword">for</span> _r <span class="keyword">in</span> right_nodes:</span><br><span class="line">				root = TreeNode(i)</span><br><span class="line">				root.left = _l</span><br><span class="line">				root.right = _r</span><br><span class="line">				res.append(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Backtracking</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1143 Longest Common Subsequence</title>
    <url>/2022/01/29/leetcode-1143-longest-common-subsequence/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code>0</code>.<br><br>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.<br><br><em>   For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.<br><br>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> text1 = “abcde”, text2 = “ace”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest common subsequence is “ace” and its length is 3.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> text1 = “abc”, text2 = “abc”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest common subsequence is “abc” and its length is 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> text1 = “abc”, text2 = “def”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There is no such common subsequence, so the result is 0.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br>*   <code>text1</code> and <code>text2</code> consist of only lowercase English characters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两字符串的最大公共字符序列，不一定需要连续</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两字符串最值问题用DP<br>dp[i][j]为最大公共字符序列，最后一位不需要相等。递归式为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = max(dp[i - 1][j], dp[i][j - 1])</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DP五点注意事项</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不相等时候不需要dp[i - 1][j - 1]，因为已经包含在dp[i - 1][j]或dp[i][j - 1]中, <strong>DP属于累计DP</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) <span class="comment"># no dp[i - 1][j - 1] but no impact</span></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>打印路径</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">longest, res = dp[<span class="number">-1</span>][<span class="number">-1</span>], <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> m &gt;= <span class="number">0</span> <span class="keyword">and</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">if</span> dp[m - <span class="number">1</span>][n] == longest:</span><br><span class="line">		m -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">elif</span> dp[m][n - <span class="number">1</span>] == longest:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		res += text1[m - <span class="number">1</span>]</span><br><span class="line">		longest -= <span class="number">1</span></span><br><span class="line">		m -= <span class="number">1</span></span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1146 Snapshot Array</title>
    <url>/2022/02/16/leetcode-1146-snapshot-array/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/snapshot-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement a SnapshotArray that supports the following interface:<br><br><em>   <code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length.  <strong>Initially, each element equals 0</strong>.
</em>   <code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.<br><em>   <code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.
</em>   <code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> [“SnapshotArray”,”set”,”snap”,”set”,”get”]<br>[[3],[0,5],[],[0,6],[0,0]]<br><strong>Output:</strong> [null,null,0,null,5]<br><strong>Explanation:</strong><br>SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3<br>snapshotArr.set(0,5);  // Set array[0] = 5<br>snapshotArr.snap();  // Take a snapshot, return snap_id = 0<br>snapshotArr.set(0,6);<br>snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= length &lt;= 50000</code>
</em>   At most <code>50000</code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.<br><em>   <code>0 &lt;= index &lt; length</code>
</em>   <code>0 &lt;= snap_id &lt;</code>(the total number of times we call <code>snap()</code>)<br>*   <code>0 &lt;= val &lt;= 10^9</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个数据结构支持数组的快照</p>
<h3 id="Binary-Search解题思路-推荐-："><a href="#Binary-Search解题思路-推荐-：" class="headerlink" title="Binary Search解题思路(推荐)："></a><strong>Binary Search解题思路(推荐)：</strong></h3><p>暴力法是每次快照时候，将当时的数组的所有值存入dict中，key为(snap_id, index), value为数组值，得到MLE<br>后来考虑用二分法优化snap，将数值跟前值不同才存入历史记录，但得到TLE，应该是因为snap时间太长，因为要遍历整个数组<br>所以应该将存入历史这一步放在set中，每次值改变才存入历史记录，虽然一个snap_id可能会存入多值，大部分是不需要，因为同一个snap_id应该取最新值，但这样设计费了空间，省了时间。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>历史记录为3d数组，第一维为数组index, 第二维为所有历史记录，第三维为每一个记录为[snap_id, value]。由于数组初始值为0，所以初始历史记录为[-1, 0]</li>
<li>snap_id和题目要求的id差1，比如第一次call snap为0，但是之前的snap应该为-1</li>
<li>最容易错的在于二分法，要先将snap_id + 1，比如[-1, 0], [0, 5], [0, 6], [0, 2], [1, 1], [1, 4]…找snap_id = 0的值也就是要找最后的，所以先加1，找到[1, 1]再下标减1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">        self.snap_id = <span class="number">0</span></span><br><span class="line">        self.history = [[[<span class="number">-1</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.history[index].append([self.snap_id, val])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        self.snap_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.snap_id - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line">        last_snap_id = bisect.bisect(self.history[index], [snap_id + <span class="number">1</span>]) - <span class="number">1</span> <span class="comment"># remember snap + 1</span></span><br><span class="line">        <span class="keyword">return</span> self.history[index][last_snap_id][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>get时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>, 数组某值n更改次数  </p>
<hr>
<h3 id="暴力法算法II解题思路-不推荐-："><a href="#暴力法算法II解题思路-不推荐-：" class="headerlink" title="暴力法算法II解题思路(不推荐)："></a><strong>暴力法算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">	self.ary = [<span class="number">0</span>] * length</span><br><span class="line">	self.snap_id = <span class="number">-1</span></span><br><span class="line">	self.idx_snap_to_val = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	self.ary[index] = val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">	self.snap_id += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(self.ary):</span><br><span class="line">		self.idx_snap_to_val[(i, self.snap_id)] = self.ary[i]</span><br><span class="line">	<span class="keyword">return</span> self.snap_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> self.idx_snap_to_val[(index, snap_id)]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1166 Design File System</title>
    <url>/2022/02/15/leetcode-1166-design-file-system/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are asked to design a file system that allows you to create new paths and associate them with different values.<br><br>The format of a path is one or more concatenated strings of the form: <code>/</code> followed by one or more lowercase English letters. For example, “<code>/leetcode&quot;</code> and “<code>/leetcode/problems&quot;</code> are valid paths while an empty string <code>&quot;&quot;</code> and <code>&quot;/&quot;</code> are not.<br><br>Implement the <code>FileSystem</code> class:<br><br><em>   <code>bool createPath(string path, int value)</code> Creates a new <code>path</code> and associates a <code>value</code> to it if possible and returns <code>true</code>. Returns <code>false</code> if the path <strong>already exists</strong> or its parent path <strong>doesn’t exist</strong>.
</em>   <code>int get(string path)</code> Returns the value associated with <code>path</code> or returns <code>-1</code> if the path doesn’t exist.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”get”]<br>[[],[“/a”,1],[“/a”]]<br><strong>Output:</strong><br>[null,true,1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/a”, 1); // return true<br>fileSystem.get(“/a”); // return 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”createPath”,”get”,”createPath”,”get”]<br>[[],[“/leet”,1],[“/leet/code”,2],[“/leet/code”],[“/c/d”,1],[“/c”]]<br><strong>Output:</strong><br>[null,true,true,2,false,-1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/leet”, 1); // return true<br>fileSystem.createPath(“/leet/code”, 2); // return true<br>fileSystem.get(“/leet/code”); // return 2<br>fileSystem.createPath(“/c/d”, 1); // return false because the parent path “/c” doesn’t exist.<br>fileSystem.get(“/c”); // return -1 because this path doesn’t exist.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of calls to the two functions is less than or equal to <code>10&lt;sup&gt;4&lt;/sup&gt;</code> in total.
</em>   <code>2 &lt;= path.length &lt;= 100</code><br>*   <code>1 &lt;= value &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统，支持创建路径，路径含key, value</p>
<h3 id="Trie解题思路："><a href="#Trie解题思路：" class="headerlink" title="Trie解题思路："></a><strong>Trie解题思路：</strong></h3><p>用Trie, is_end变成key, value</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>遍历用1开始，因为首个/前面是空字符串</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">if</span> i == len(segments) - <span class="number">1</span>: <span class="comment"># match all the previous segments</span></span><br><span class="line">                    it.children[segment] = TrieNode(segment)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">if</span> it.value != <span class="number">-1</span>: <span class="comment"># exists</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">return</span> it.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.value = <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="算法II-HashMap解题思路："><a href="#算法II-HashMap解题思路：" class="headerlink" title="算法II HashMap解题思路："></a><strong>算法II HashMap解题思路：</strong></h3><p>用前缀法</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem2</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.path_to_val = defaultdict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">"/"</span> <span class="keyword">or</span> len(path) == <span class="number">0</span> <span class="keyword">or</span> path <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search from the right</span></span><br><span class="line">        parent = path[:path.rfind(<span class="string">'/'</span>)]</span><br><span class="line">        <span class="keyword">if</span> len(parent) &gt; <span class="number">1</span> <span class="keyword">and</span> parent <span class="keyword">not</span> <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        self.path_to_val[path] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.path_to_val.get(path, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 129 Sum Root to Leaf Numbers</title>
    <url>/2022/01/16/leetcode-129-sum-root-to-leaf-numbers/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.<br><br>Each root-to-leaf path in the tree represents a number.<br><br><em>   For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.<br><br>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.<br><br>A <strong>leaf</strong> node is a node with no children.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 25<br><strong>Explanation:</strong><br>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.<br>Therefore, sum = 12 + 13 = <code>25</code>.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,9,0,5,1]<br><strong>Output:</strong> 1026<br><strong>Explanation:</strong><br>The root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.<br>The root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.<br>The root-to-leaf path <code>4-&gt;0</code> represents the number 40.<br>Therefore, sum = 495 + 491 + 40 = <code>1026</code>.<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the tree is in the range <code>[1, 1000]</code>.<br><em>   <code>0 &lt;= Node.val &lt;= 9</code>
</em>   The depth of the tree will not exceed <code>10</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>由root到叶子节点的数字组成多位数的数，求这些数的总和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>题目提到叶子节点，所以DFS中要含叶子节点的情况</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题目提到叶子节点，所以DFS中要含叶子节点的情况。当然还要有root为空的情况，这样root.left和root.right不用非空检查，代码更简洁</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	current = path * <span class="number">10</span> + root.val</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">		<span class="keyword">return</span> current</span><br><span class="line">	<span class="comment">#if root.left #if root.right:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(root.left, current) + self.dfs(root.right, current)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1293 Shortest Path in a Grid with Obstacles Elimination</title>
    <url>/2022/02/16/leetcode-1293-shortest-path-in-a-grid-with-obstacles-elimination/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.<br><br>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner</em> <code>(0, 0)</code> <em>to the lower right corner</em> <code>(m - 1, n - 1)</code> <em>given that you can eliminate <strong>at most</strong></em> <code>k</code> <em>obstacles</em>. If it is not possible to find such walk return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1<br><strong>Output:</strong> 6<br><strong>Explanation:</strong><br>The shortest path without eliminating any obstacle is 10.<br>The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 40</code>
</em>   <code>1 &lt;= k &lt;= m * n</code><br><em>   <code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.
</em>   <code>grid[0][0] == grid[m - 1][n - 1] == 0</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵从左上走到右下，但含障碍，现在可以移除k个，使得路径最短，求最短路径</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最短路径用BFS，但此题难点在于distance跟路径有关，比如某一格可能属于不同的路径，此时它的distance会不同，所以distance不能global，必须作为state传到下一个迭代<br>同样的情况也在visited中存在，visited跟路径相关，而这一格跟k相关，这一格可以被属于不同的k的路径访问，所以visited应该加入k</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>visited是(x, y, k), queue是(x, y, k, dis)</li>
<li>(x, y, k - 1)跟visited比较，而不是(x, y, k)。下一个节点的条件为eleminatios &gt;= 0</li>
<li>若k过多会LTE, 因为广度会过大。这是用曼哈顿距离来剪枝。左上到右下距离为m - n + 2这肯定是最短距离，若k大于等于这个数，也就是可以移除曼哈顿路径上的所有障碍。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, grid: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">	m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> k &gt;= m + n - <span class="number">2</span>: <span class="comment"># TLE</span></span><br><span class="line">		<span class="keyword">return</span> m + n - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	queue = collections.deque([(<span class="number">0</span>, <span class="number">0</span>, k, <span class="number">0</span>)]) <span class="comment"># x, y, k, distance</span></span><br><span class="line">	visited = set([(<span class="number">0</span>, <span class="number">0</span>, k)]) <span class="comment"># include k</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		_x, _y, _k, _dis = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> _x == m - <span class="number">1</span> <span class="keyword">and</span> _y == n - <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> _dis</span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">			x, y = _x + _dx, _y + _dy</span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			eliminations = _k - <span class="number">1</span> <span class="keyword">if</span> grid[x][y] == <span class="number">1</span> <span class="keyword">else</span> _k</span><br><span class="line">			<span class="keyword">if</span> (x, y, eliminations) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> eliminations &gt;= <span class="number">0</span>:</span><br><span class="line">				queue.append((x, y, eliminations, _dis + <span class="number">1</span>))</span><br><span class="line">				visited.add((x, y, eliminations))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmk)</code>，空间复杂度<code>O(mnk)</code>, 某个cell都可能被访问k次，因为最多有k条路径  </p>
]]></content>
      <tags>
        <tag>Matrix</tag>
        <tag>Breadth-first Search</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1347 Minimum Number of Steps to Make Two Strings Anagram</title>
    <url>/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.<br><br>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.<br><br>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bab”, t = “aba”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Replace the first ‘a’ in t with b, t = “bba” which is anagram of s.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, t = “practice”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Replace ‘p’, ‘r’, ‘a’, ‘i’ and ‘c’ from t with proper characters to make t anagram of s.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “mangaar”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “anagram” and “mangaar” are anagrams.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s.length == t.length<code>*</code>s<code>and</code>t` consist of lowercase English letters only.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过替换字母使得两字符为同位词Anagram</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计某一个词的词频，遍历另一个单词，减去词频，若不够减(小于0)，就加步数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">	char_to_count_t = collections.Counter(t)</span><br><span class="line">	steps = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> char_to_count_t <span class="keyword">and</span> char_to_count_t[char] &gt; <span class="number">0</span>:</span><br><span class="line">			char_to_count_t[char] -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			steps += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 136 Single Number</title>
    <url>/2022/01/16/leetcode-136-single-number/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.<br><br>You must implement a solution with a linear runtime complexity and use only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,2,1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [4,1,2,1,2]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>-3 <em> 10<sup>4</sup> &lt;= nums[i] &lt;= 3 </em> 10<sup>4</sup>`<br>*   Each element in the array appears twice except for one element which appears only once.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数列中，所有数都出现两次除了一个数，求这一个数</p>
<h3 id="异或解题思路-推荐-："><a href="#异或解题思路-推荐-：" class="headerlink" title="异或解题思路(推荐)："></a><strong>异或解题思路(推荐)：</strong></h3><p>Easy题</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		res ^= n</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="HashMap算法II解题思路："><a href="#HashMap算法II解题思路：" class="headerlink" title="HashMap算法II解题思路："></a><strong>HashMap算法II解题思路：</strong></h3><p>记录频数，最直观解法</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	num_to_count = collections.Counter(nums)</span><br><span class="line">	<span class="keyword">return</span> [n <span class="keyword">for</span> n, count <span class="keyword">in</span> num_to_count.items() <span class="keyword">if</span> count == <span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="Math算法III解题思路："><a href="#Math算法III解题思路：" class="headerlink" title="Math算法III解题思路："></a><strong>Math算法III解题思路：</strong></h3><p>用set求单一元素和乘以2减去原数组的和</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * sum(set(nums)) - sum(nums)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1405 Longest Happy String</title>
    <url>/2022/02/07/leetcode-1405-longest-happy-string/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-happy-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A string <code>s</code> is called <strong>happy</strong> if it satisfies the following conditions:<br><br><em>   <code>s</code> only contains the letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.
</em>   <code>s</code> does not contain any of <code>&quot;aaa&quot;</code>, <code>&quot;bbb&quot;</code>, or <code>&quot;ccc&quot;</code> as a substring.<br><em>   <code>s</code> contains <strong>at most</strong> <code>a</code> occurrences of the letter <code>&#39;a&#39;</code>.
</em>   <code>s</code> contains <strong>at most</strong> <code>b</code> occurrences of the letter <code>&#39;b&#39;</code>.<br><em>   <code>s</code> contains <strong>at most</strong> <code>c</code> occurrences of the letter <code>&#39;c&#39;</code>.<br><br>Given three integers <code>a</code>, <code>b</code>, and <code>c</code>, return <em>the <strong>longest possible happy</strong> string</em>. If there are multiple longest happy strings, return <em>any of them</em>. If there is no such string, return <em>the empty string</em> <code>&quot;&quot;</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within a string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 1, c = 7<br><strong>Output:</strong> “ccaccbcc”<br><strong>Explanation:</strong> “ccbccacc” would also be a correct answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 7, b = 1, c = 0<br><strong>Output:</strong> “aabaa”<br><strong>Explanation:</strong> It is the only correct answer in this case.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= a, b, c &lt;= 100</code><br>*   <code>a + b + c &gt; 0</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定三个整数代表abc的个数，生成一个字符串，字符串abc频数不能超过这3个数，不能有连续的aaa, bbb, ccc, 求此种字符串的最大长度</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由第一个例子看出，先尽量用频数最多的字符，直到连续3个为止，然后再用次多的，如此反复做。这里用到最多和次多，所以考虑用Heap</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>每次选频数最高的字符，但若此字符已连续3次，选次高的，用heap。 </li>
<li>大于0的频数才加入到heap Line 4和Line 17</li>
<li>heapreplace等于heappop次高的和heappush最高的。<strong>既然要有次高，heap就不能为空</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	heap = []</span><br><span class="line">	<span class="keyword">if</span> a &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">		heapq.heappush(heap, (-a, <span class="string">'a'</span>))</span><br><span class="line">	<span class="keyword">if</span> b &gt; <span class="number">0</span>:</span><br><span class="line">		heapq.heappush(heap, (-b, <span class="string">'b'</span>))</span><br><span class="line">	<span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">		heapq.heappush(heap, (-c, <span class="string">'c'</span>))</span><br><span class="line">	<span class="keyword">while</span> heap:</span><br><span class="line">		count, char = heapq.heappop(heap)</span><br><span class="line">		<span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == char:</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			count, char = heapq.heapreplace(heap, (count, char))</span><br><span class="line">		res += char</span><br><span class="line">		<span class="keyword">if</span> count + <span class="number">1</span>:</span><br><span class="line">			heapq.heappush(heap, (count + <span class="number">1</span>, char))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Heap</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 141 Linked List Cycle</title>
    <url>/2022/01/16/leetcode-141-linked-list-cycle/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.<br><br>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.<br><br>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""><br><br><pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""><br><br><pre><strong>Input:</strong> head = [1,2], pos = 0<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""><br><br><pre><strong>Input:</strong> head = [1], pos = -1<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no cycle in the linked list.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of the nodes in the list is in the range <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.
</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.<br><br><em>*Follow up:</em></em> Can you solve it using <code>O(1)</code> (i.e. constant) memory?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求LL是否存在循环</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>快慢指针。若存在循环就一定会相遇，这是显然的。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>不涉及删除，所以不需要哟用到fake_node</strong>，但循环中先走再判断。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">	fast, slow= head, head</span><br><span class="line">	<span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">		fast, slow = fast.next.next, slow.next</span><br><span class="line">		<span class="keyword">if</span> fast == slow: <span class="comment"># meets again</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 142 Linked List Cycle II</title>
    <url>/2022/01/16/leetcode-142-linked-list-cycle-ii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.<br><br>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.<br><br><strong>Do not modify</strong> the linked list.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""><br><br><pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1<br><strong>Output:</strong> tail connects to node index 1<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""><br><br><pre><strong>Input:</strong> head = [1,2], pos = 0<br><strong>Output:</strong> tail connects to node index 0<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""><br><br><pre><strong>Input:</strong> head = [1], pos = -1<br><strong>Output:</strong> no cycle<br><strong>Explanation:</strong> There is no cycle in the linked list.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of the nodes in the list is in the range <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.
</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.<br><br><em>*Follow up:</em></em> Can you solve it using <code>O(1)</code> (i.e. constant) memory?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求LL是否存在循环，若存在返回循环起点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先用快慢指针找到相遇点，然后将slow指针移回fake_head起点，同速度移动直到相遇即为所求</p>
<p>证明：<br><img src="/images/L142.png" alt=""><br>A为起点，B为快慢指针相遇点，假设长度分别为z, y, x<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fast在相遇时走过的距离为: z + x + y + y, 比slow多走一圈  </span><br><span class="line">slow在相遇时走过的距离为: z + y  </span><br><span class="line">由于fast速度是slow的两倍，所以相遇时，同一时间内，走过的距离也是两倍。</span><br><span class="line">z + x + y + y = 2 * (z + y)</span><br><span class="line">x = z得证</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>不涉及删除，所以不需要哟用到fake_node</strong>，但循环中先走再判断。</li>
<li>循环可能不存在，此时返回None</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	fast, slow= head, head</span><br><span class="line">	<span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">		fast, slow = fast.next.next, slow.next</span><br><span class="line">		<span class="keyword">if</span> fast == slow: <span class="comment"># meets again</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span> <span class="comment"># remember</span></span><br><span class="line">	slow = head</span><br><span class="line">	<span class="keyword">while</span> fast != slow:</span><br><span class="line">		fast, slow = fast.next, slow.next</span><br><span class="line">	<span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1304 Find N Unique Integers Sum up to Zero</title>
    <url>/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong> integers such that they add up to <code>0</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> [-7,-1,1,3,4]<br><strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [-1,0,1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求n个数的数组使得数组和为0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，只要将相反数放入数组即可</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		res.append(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</span><br><span class="line">		res.append(i + <span class="number">1</span>)</span><br><span class="line">		res.append(-i - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1448 Count Good Nodes in Binary Tree</title>
    <url>/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named <strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.<br><br>Return the number of <strong>good</strong> nodes in the binary tree.<br><br><strong>Example 1:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.<br>Root Node (3) is always a good node.<br>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.<br>Node 5 -&gt; (3,4,5) is the maximum value in the path<br>Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,3,null,4,2]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because “3” is higher than it.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.
</em>   Each node’s value is between <code>[-10^4, 10^4]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个节点是good表示该节点从root到自己的路径上，所有节点都小于等于自己。求二叉树的good节点个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计左右子树的good节点个数，最重要是引入类似于min, max验证BST，<strong>引入path_max来记录路径上的最大值</strong>，只要该节点值大于path_max就是good节点。DFS返回good节点个数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>引入path_max来记录路径上的最大值</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(root, float(<span class="string">'-inf'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path_max)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	left = self.dfs(root.left, max(root.val, path_max))</span><br><span class="line">	right = self.dfs(root.right, max(root.val, path_max))</span><br><span class="line">	res = left + right</span><br><span class="line">	<span class="keyword">if</span> path_max &lt;= root.val:</span><br><span class="line">		res += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 150 Evaluate Reverse Polish Notation</title>
    <url>/2022/01/17/leetcode-150-evaluate-reverse-polish-notation/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.<br><br>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.<br><br><strong>Note</strong> that division between two integers should truncate toward zero.<br><br>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> tokens = [“2”,”1”,”+”,”3”,”<em>“]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong> ((2 + 1) </em> 3) = 9<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> tokens = [“4”,”13”,”5”,”/“,”+”]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> (4 + (13 / 5)) = 6<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”/“,”</em>“,”17”,”+”,”5”,”+”]<br><strong>Output:</strong> 22<br><strong>Explanation:</strong> ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= tokens.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求逆波兰式计算结果</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>逆波兰式用Stack</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>左右操作数</strong>是有区别的，所以stack先出栈的为右操作数，后出栈的为左操作数</li>
<li>最容易错的是向下取整, 题目返回要求整数。所以<strong>要除法后取整int(prev / num)</strong>。这点和LeetCode 227 Basic Calculator II一样。也是和Java一致，用类型转化来实现，而//是比它小的整数如-2.8就是-3，只在负数是有区别</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">		<span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			operand_right = stack.pop() <span class="comment"># remember</span></span><br><span class="line">			operand_left = stack.pop()</span><br><span class="line">			<span class="keyword">if</span> token == <span class="string">'+'</span>:</span><br><span class="line">				stack.append(operand_left + operand_right)</span><br><span class="line">			<span class="keyword">elif</span> token == <span class="string">'-'</span>:</span><br><span class="line">				stack.append(operand_left - operand_right)</span><br><span class="line">			<span class="keyword">elif</span> token == <span class="string">'*'</span>:</span><br><span class="line">				stack.append(operand_left * operand_right)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				stack.append(int(operand_left / operand_right)) <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			stack.append(int(token))</span><br><span class="line">	<span class="keyword">return</span> stack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Stack</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 149 Max Points on a Line</title>
    <url>/2022/01/17/leetcode-149-max-points-on-a-line/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <code>points</code> where <code>points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt=""><br><br><pre><strong>Input:</strong> points = [[1,1],[2,2],[3,3]]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt=""><br><br><pre><strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= points.length &lt;= 300</code>
</em>   <code>points[i].length == 2</code><br><em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   All the <code>points</code> are <strong>unique</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求在同一直线上的点的最大个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>固定一个点，求其与其他点的斜率是否相同，记录在map中。通过同一个点，若斜率相同，肯定在同一直线上。这是几何题。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>两重循环，外循环为每个点，内循环为该点和其他的点的斜率。<strong>斜率可以为无穷大</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):</span><br><span class="line">		slope_to_count = collections.defaultdict(int)</span><br><span class="line">		max_p = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(points)):</span><br><span class="line">			slope = (points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]) / (points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]) \</span><br><span class="line">				<span class="keyword">if</span> points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">else</span> float(<span class="string">'inf'</span>) <span class="comment"># remember line is y-axis</span></span><br><span class="line">			slope_to_count[slope] += <span class="number">1</span></span><br><span class="line">			max_p = max(max_p, slope_to_count[slope])</span><br><span class="line">		res = max(res, max_p + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 151 Reverse Words in a String</title>
    <url>/2022/01/17/leetcode-151-reverse-words-in-a-stringsolution/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.<br><br>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.<br><br>Return <em>a string of the words in reverse order concatenated by a single space.</em><br><br><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “the sky is blue”<br><strong>Output:</strong> “blue is sky the”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “  hello world  “<br><strong>Output:</strong> “world hello”<br><strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “a good   example”<br><strong>Output:</strong> “example good a”<br><strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.<br><em>   There is <strong>at least one</strong> word in <code>s</code>.<br><br><strong>Follow-up: </strong>If the string data type is mutable in your language, can you solve it <em>*in-place</em></em> with <code>O(1)</code> extra space?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>反转字符串中的单词顺序</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>word不能为空，单词之间可能含多个空格</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">	words = s.split(<span class="string">' '</span>)</span><br><span class="line">	words_without_space = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> word]</span><br><span class="line">	<span class="keyword">return</span> <span class="string">' '</span>.join(words_without_space[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 152 Maximum Product Subarray</title>
    <url>/2022/01/17/leetcode-152-maximum-product-subarray/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, find a contiguous non-empty subarray within the array that has the largest product, and return <em>the product</em>.<br><br>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.<br><br>A <strong>subarray</strong> is a contiguous subsequence of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,-2,4]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> [2,3] has the largest product 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-2,0,-1]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 2 </em> 10<sup>4</sup><code>*</code>-10 &lt;= nums[i] &lt;= 10<code>*   The product of any prefix or suffix of</code>nums` is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子数组最大积</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 053 Maximum Subarray求子数组最大和，用DP。</p>
<p>递归式； dp为以某个数为结尾的最大子数组积，dp2为以某个数为结尾的最小子数组积<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(num[i], dp[i-1] * num[i], dp2[i-1] * num[i])</span><br><span class="line">dp2[i] = min(num[i], dp[i-1] * num[i], dp2[i-1] * num[i])</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于负负得正，所以是多状态DP。需要同时赋值</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max(num[i], dp[i-1] * num[i], dp2[i-1] * num[i])</span></span><br><span class="line"><span class="comment"># dp2[i] = min(num[i], dp[i-1] * num[i], dp2[i-1] * num[i])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	max_p, min_p, res = <span class="number">1</span>, <span class="number">1</span>, float(<span class="string">'-inf'</span>)</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">		<span class="comment"># remember assign same time</span></span><br><span class="line">		max_p, min_p = max(n, max_p * n, min_p * n), min(n, max_p * n, min_p * n) <span class="comment"># 4, -48 | 4, -8, -48</span></span><br><span class="line">		res = max(res, max_p) <span class="comment"># 6</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1522 Diameter of N-Ary Tree</title>
    <url>/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-n-ary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>root</code> of an <a href="https://leetcode.com/articles/introduction-to-n-ary-trees/" target="_blank" rel="noopener">N-ary tree</a>, you need to compute the length of the diameter of the tree.<br><br>The diameter of an N-ary tree is the length of the <strong>longest</strong> path between any two nodes in the tree. This path may or may not pass through the root.<br><br>(<em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Diameter is shown in red color.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [1,null,2,null,3,4,null,5,null,6]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br><strong>Output:</strong> 7<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The depth of the n-ary tree is less than or equal to <code>1000</code>.
</em>   The total number of nodes is between <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 543 Diameter of Binary Tree，但此题为N叉树</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DFS</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>求数组中最大的两数和，用去掉最大值的方法得到次大值。还要注意初始值加入[1, 1]，避免没有儿子节点或只有一个的情况</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		path_len = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">		<span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">			path_len.append(dfs(child) + <span class="number">1</span>)</span><br><span class="line">		largest = max(path_len)</span><br><span class="line">		path_len.remove(largest)</span><br><span class="line">		second_largest = max(path_len)</span><br><span class="line">		total = largest + second_largest - <span class="number">1</span></span><br><span class="line">		max_len = max(total, max_len)</span><br><span class="line">		<span class="keyword">return</span> largest</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 157 Read N Characters Given Read4</title>
    <url>/2022/02/13/leetcode-157-read-n-characters-given-read4/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method to read <code>n</code> characters.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;
char[] buf4 = new char[4]; // Create buffer with enough space to store characters
read4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;
read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of file
read4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.
</em>   The <code>read</code> function will only be called once for each test case.<br><em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, n = 4<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>Note that “abc” is the file’s content, not buf. buf is the destination buffer that you will have to write the results to.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abcde”, n = 5<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcde”. We read a total of 5 characters from the file, so return 5.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> file = “abcdABCD1234”, n = 12<br><strong>Output:</strong> 12<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcdABCD1234”. We read a total of 12 characters from the file, so return 12.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.
</em>   <code>1 &lt;= n &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Karat题，有一个函数read4,如此调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf4 = [&apos; &apos;] * 4</span><br><span class="line">count = read4(buf4)</span><br></pre></td></tr></table></figure>
<p>buf4是填充后的结果，是一个大小为4的char list<br>count是buf4的有数据的实际大小(4或更小，取决于是否文件最后一段是否不够4)</p>
<p>现在要实现这个函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def read(self, buf, n)</span><br></pre></td></tr></table></figure></p>
<p>buf是字符列表，n是想要读取文件的大小，返回值为n或者更小，取决于是否文件大小是否小于n</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>若count为0，跳出循环</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; n:</span><br><span class="line">		buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">		count = read4(buf4)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		count = min(count, n - i)</span><br><span class="line">		buf[i:] = buf4</span><br><span class="line">		i += count</span><br><span class="line">	<span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 163 Missing Ranges</title>
    <url>/2022/01/17/leetcode-163-missing-ranges/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/missing-ranges/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an inclusive range <code>[lower, upper]</code> and a <strong>sorted unique</strong> integer array <code>nums</code>, where all elements are in the inclusive range.<br><br>A number <code>x</code> is considered <strong>missing</strong> if <code>x</code> is in the range <code>[lower, upper]</code> and <code>x</code> is not in <code>nums</code>.<br><br>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover every missing number exactly</strong></em>. That is, no element of <code>nums</code> is in any of the ranges, and each missing number is in one of the ranges.<br><br>Each range <code>[a,b]</code> in the list should be output as:<br><br><em>   <code>&quot;a-&gt;b&quot;</code> if <code>a != b</code>
</em>   <code>&quot;a&quot;</code> if <code>a == b</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,3,50,75], lower = 0, upper = 99<br><strong>Output:</strong> [“2”,”4-&gt;49”,”51-&gt;74”,”76-&gt;99”]<br><strong>Explanation:</strong> The ranges are:<br>[2,2] –&gt; “2”<br>[4,49] –&gt; “4-&gt;49”<br>[51,74] –&gt; “51-&gt;74”<br>[76,99] –&gt; “76-&gt;99”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1], lower = -1, upper = -1<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no missing ranges since there are no missing numbers.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= lower &lt;= upper &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   <code>0 &lt;= nums.length &lt;= 100</code><br><em>   <code>lower &lt;= nums[i] &lt;= upper</code>
</em>   All the values of <code>nums</code> are <strong>unique</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个范围[lower, upper]和数组表示这个范围有的数，求缺失数范围</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。也是数学题<br>公式为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nums[i-1] + 1, nums[i] - 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>缺失数范围公式为[nums[i-1] + 1, nums[i] - 1], 需要一个函数来处理若范围内仅含一个数或多个数的情况</li>
<li>题目条件lower, upper在数组范围之外，所以不妨<strong>将lower, upper加到数组中</strong>，同一处理，但是由于lower和upper表示缺失数，而数组表示含有数。所以将lower - 1和upper + 1加到数组</li>
<li><strong>数组可能为空</strong>，要特别处理Line 3</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMissingRanges</span><span class="params">(self, nums: List[int], lower: int, upper: int)</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> [self.get_missing_str(lower, upper)]</span><br><span class="line">	res = []</span><br><span class="line">	nums.insert(<span class="number">0</span>, lower - <span class="number">1</span>)</span><br><span class="line">	nums.append(upper + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">		<span class="comment"># [nums[i-1] + 1, n - 1]</span></span><br><span class="line">		<span class="keyword">if</span> nums[i - <span class="number">1</span>] + <span class="number">1</span> &lt;= nums[i] - <span class="number">1</span>:</span><br><span class="line">			res.append(self.get_missing_str(nums[i - <span class="number">1</span>] + <span class="number">1</span>, nums[i] - <span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_missing_str</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start == end:</span><br><span class="line">		<span class="keyword">return</span> str(start)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> str(start) + <span class="string">'-&gt;'</span> + str(end)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 158 Read N Characters Given read4 II - Call Multiple Times</title>
    <url>/2022/02/13/leetcode-158-read-n-characters-given-read4/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method <code>read</code> to read <code>n</code> characters. Your method <code>read</code> may be <strong>called multiple times</strong>.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;
char[] buf4 = new char[4]; // Create buffer with enough space to store characters
read4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;
read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of file
read4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.
</em>   The read function may be <strong>called multiple times</strong>.<br><em>   Please remember to <strong>RESET</strong> your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/" target="_blank" rel="noopener">here</a> for more details.
</em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><em>   It is guaranteed that in a given test case the same buffer <code>buf</code> is called by <code>read</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [1,2,1]<br><strong>Output:</strong> [1,2,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 1); // After calling your read method, buf should contain “a”. We read a total of 1 character from the file, so return 1.<br>sol.read(buf, 2); // Now buf should contain “bc”. We read a total of 2 characters from the file, so return 2.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br>Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [4,1]<br><strong>Output:</strong> [3,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 4); // After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.
</em>   <code>1 &lt;= queries.length &lt;= 10</code><br>*   <code>1 &lt;= queries[i] &lt;= 500</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>题意类似于LeetCode 157 Read N Characters Given Read4，但此题唯一的区别是这个新的API: def read(self, buf, n)会被调用多次</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为read调用多次，所以调用read4多读了几个字符在n以外的，需要保留下来让下一次read返回到结果中，所以用queue来保存中间结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>先将read4的结果保存在self.queue中，然后再填充到buf中，这里用到了quicksort里面partition的方法，while中只有当填充buf时i才移动，而read4时候不移动</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">	self.queue = collections.deque()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; n:</span><br><span class="line">		<span class="keyword">if</span> self.queue:</span><br><span class="line">			buf[i] = self.queue.popleft()</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">			count = read4(buf4)</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			self.queue.extend(buf4[:count])</span><br><span class="line">	<span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160 Intersection of Two Linked Lists</title>
    <url>/2022/01/17/leetcode-160-intersection-of-two-linked-lists/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.<br><br>For example, the following two linked lists begin to intersect at node <code>c1</code>:<br><br><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt=""><br><br>The test cases are generated such that there are no cycles anywhere in the entire linked structure.<br><br><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.<br><br><strong>Custom Judge:</strong><br><br>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):<br><br><em>   <code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.
</em>   <code>listA</code> - The first linked list.<br><em>   <code>listB</code> - The second linked list.
</em>   <code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.<br><em>   <code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.<br><br>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt=""><br><br><pre><strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<br><strong>Output:</strong> Intersected at ‘8’<br><strong>Explanation:</strong> The intersected node’s value is 8 (note that this must not be 0 if the two lists intersect).<br>From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt=""><br><br><pre><strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br><strong>Output:</strong> Intersected at ‘2’<br><strong>Explanation:</strong> The intersected node’s value is 2 (note that this must not be 0 if the two lists intersect).<br>From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt=""><br><br><pre><strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br><strong>Output:</strong> No intersection<br><strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.<br>Explanation: The two lists do not intersect, so return null.<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes of <code>listA</code> is in the <code>m</code>.<br><em>   The number of nodes of <code>listB</code> is in the <code>n</code>.
</em>   <code>1 &lt;= m, n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>1 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= skipA &lt; m</code><br><em>   <code>0 &lt;= skipB &lt; n</code>
</em>   <code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.<br><em>   <code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.<br><br><em>*Follow up:</em></em> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两LL的相交点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于<a href="https://shineboy2013.github.io/2021/12/28/lee-1650/" target="_blank" rel="noopener">LeetCode 1650 Lowest Common Ancestor of a Binary Tree III</a>.</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	a_set = set()</span><br><span class="line">	it = headA</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		a_set.add(it)</span><br><span class="line">		it = it.next</span><br><span class="line">	it = headB</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		<span class="keyword">if</span> it <span class="keyword">in</span> a_set:</span><br><span class="line">			<span class="keyword">return</span> it</span><br><span class="line">		it = it.next</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1647 Minimum Deletions to Make Character Frequencies Unique</title>
    <url>/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.<br><br>Given a string <code>s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>s</code> <em><strong>good</strong>.</em><br><br>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>&quot;aab&quot;</code>, the <strong>frequency</strong> of <code>&#39;a&#39;</code> is <code>2</code>, while the <strong>frequency</strong> of <code>&#39;b&#39;</code> is <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> <code>s</code> is already good.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aaabbbcc”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete two ‘b’s resulting in the good string “aaabcc”.<br>Another way it to delete one ‘b’ and one ‘c’ resulting in the good string “aaabbc”.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ceabaacb”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete both ‘c’s resulting in the good string “eabaab”.<br>Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>s</code> contains only lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串，求最小删除次数使得字符串的每一种字符频率不同</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解，若遇到频率相同的字符，就将其减一，也就是删除一个字符，使得它不再与其他字符频率相同直到0. 关键在用一个unique_count的set来记录频数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用一个unique_count的set来记录频数</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDeletions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	unique_count = set()</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char, count <span class="keyword">in</span> char_to_count.items():</span><br><span class="line">		cur_count = count</span><br><span class="line">		<span class="keyword">while</span> cur_count <span class="keyword">in</span> unique_count:</span><br><span class="line">			cur_count -= <span class="number">1</span></span><br><span class="line">			res += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> cur_count &gt; <span class="number">0</span>:</span><br><span class="line">			unique_count.add(cur_count)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Greedy</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169 Majority Element</title>
    <url>/2022/01/17/leetcode-169-majority-element/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.<br><br>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,3]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= n &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><em>*Follow-up:</em></em> Could you solve the problem in linear time and in <code>O(1)</code> space?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组中的众数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>编程之美的水王法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	candidate, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">			candidate = nums[i]</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] == candidate:</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			count -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1761 Minimum Degree of a Connected Trio in a Graph</title>
    <url>/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an undirected graph. You are given an integer <code>n</code> which is the number of nodes in the graph and an array <code>edges</code>, where each <code>edges[i] = [u&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is an undirected edge between <code>u&lt;sub&gt;i&lt;/sub&gt;</code> and <code>v&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>A <strong>connected trio</strong> is a set of <strong>three</strong> nodes where there is an edge between <strong>every</strong> pair of them.<br><br>The <strong>degree of a connected trio</strong> is the number of edges where one endpoint is in the trio, and the other is not.<br><br>Return <em>the <strong>minimum</strong> degree of a connected trio in the graph, or</em> <code>-1</code> <em>if the graph has no connected trios.</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios1.png" alt=""><br><br><pre><strong>Input:</strong> n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios2.png" alt=""><br><br><pre><strong>Input:</strong> n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There are exactly three trios:<br>1) [1,4,3] with degree 0.<br>2) [2,5,6] with degree 2.<br>3) [5,6,7] with degree 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 400</code>
</em>   <code>edges[i].length == 2</code><br><em>   `1 &lt;= edges.length &lt;= n </em> (n-1) / 2<code>*</code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n<code>*</code>u<sub>i</sub> != v<sub>i</sub>`<br>*   There are no repeated edges.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个图，trio是三个节点直接互相相连，而度数表示连着trio的边的个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>根据定义，找出所有三个节点的组合，判断是否trio，然后根据trio的每个节点的度数总和 - 6即为所求<br>遍历所有三个节点组合时，会重复了两次。所以一个优化是，先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环。因为这个最小度数的节点已经大于等于3，trio里其他两个度数比它大的节点的度数更加会大于最小度数除以3，这样总度数肯定大于此时的最小度数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>根据定义，找出所有三个节点的组合u -&gt; v, v -&gt; w, w是否在u中，判断是否trio。先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环</li>
<li>邻接图用set，因为Line 13查找w是否在u中可以提高效率</li>
<li>min_degree / 3不是// 3</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTrioDegree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	graph = collections.defaultdict(set) <span class="comment"># use set coz if w in graph[u]</span></span><br><span class="line">	<span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">		graph[u].add(v)</span><br><span class="line">		graph[v].add(u)</span><br><span class="line"></span><br><span class="line">	min_degree = float(<span class="string">'inf'</span>)</span><br><span class="line">	<span class="keyword">for</span> u <span class="keyword">in</span> sorted(range(<span class="number">1</span>, n + <span class="number">1</span>), key=<span class="keyword">lambda</span> x: len(graph[x])):</span><br><span class="line">		<span class="keyword">if</span> len(graph[u]) &gt;= min_degree / <span class="number">3</span>: <span class="comment"># remember / 3 not // 3</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">			<span class="keyword">for</span> w <span class="keyword">in</span> graph[v]:</span><br><span class="line">				<span class="keyword">if</span> w <span class="keyword">in</span> graph[u]:</span><br><span class="line">					min_degree = min(min_degree, len(graph[u]) + len(graph[v]) + len(graph[w]))</span><br><span class="line">	<span class="keyword">return</span> min_degree - <span class="number">6</span> <span class="keyword">if</span> min_degree != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</title>
    <url>/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given two integers, <code>x</code> and <code>y</code>, which represent your current location on a Cartesian grid: <code>(x, y)</code>. You are also given an array <code>points</code> where each <code>points[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> represents that a point exists at <code>(a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;)</code>. A point is <strong>valid</strong> if it shares the same x-coordinate or the same y-coordinate as your location.<br><br>Return <em>the index <strong>(0-indexed)</strong> of the <strong>valid</strong> point with the smallest <strong>Manhattan distance</strong> from your current location</em>. If there are multiple, return <em>the valid point with the <strong>smallest</strong> index</em>. If there are no valid points, return <code>-1</code>.<br><br>The <strong>Manhattan distance</strong> between two points <code>(x&lt;sub&gt;1&lt;/sub&gt;, y&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(x&lt;sub&gt;2&lt;/sub&gt;, y&lt;sub&gt;2&lt;/sub&gt;)</code> is <code>abs(x&lt;sub&gt;1&lt;/sub&gt; - x&lt;sub&gt;2&lt;/sub&gt;) + abs(y&lt;sub&gt;1&lt;/sub&gt; - y&lt;sub&gt;2&lt;/sub&gt;)</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[3,4]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The answer is allowed to be on the same location as your current location.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[2,3]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There are no valid points.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= points.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>points[i].length == 2</code><br>*   <code>1 &lt;= x, y, a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个坐标和一堆坐标，这个坐标与某个点在同一条y轴或x轴上叫合法点，求它到这些点的最小曼哈顿距离对应的点的下标，若有多个结果，返回最小的数组下标。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，根据题意求</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearestValidPoint</span><span class="params">(self, x: int, y: int, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	min_dis = float(<span class="string">'inf'</span>)</span><br><span class="line">	res = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i, (_x, _y) <span class="keyword">in</span> enumerate(points):</span><br><span class="line">		<span class="keyword">if</span> x == _x <span class="keyword">or</span> y == _y:</span><br><span class="line">			<span class="keyword">if</span> abs(x - _x) + abs(y - _y) &lt; min_dis:</span><br><span class="line">				min_dis = abs(x - _x) + abs(y - _y)</span><br><span class="line">				res = i</span><br><span class="line">			<span class="keyword">elif</span> abs(x - _x) + abs(y - _y) == min_dis <span class="keyword">and</span> i &lt; res:</span><br><span class="line">				res = i</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 189 Rotate Array</title>
    <url>/2022/01/17/leetcode-189-rotate-array/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3<br><strong>Output:</strong> [5,6,7,1,2,3,4]<br><strong>Explanation:</strong><br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-100,3,99], k = 2<br><strong>Output:</strong> [3,99,-1,-100]<br><strong>Explanation:</strong><br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><em>   <code>0 &lt;= k &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br><strong>Follow up:</strong>

</em>   Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.<br>*   Could you do it in-place with <code>O(1)</code> extra space?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组原地向右旋转k位</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p><img src="/images/L189.png" alt=""><br>证明如上图，比如[1,2,3,4,5,6,7]中，A = [1,2,3,4], B = [5,6,7]先整体reverse再分别reverse。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>k会大于数组大小，所以取mod</li>
<li>Python中reverse一个sublist，方法先取sublist再倒转</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	k = k % len(nums) <span class="comment"># remember</span></span><br><span class="line">	nums[:] = nums[::<span class="number">-1</span>]</span><br><span class="line">	nums[:k] = nums[:k][::<span class="number">-1</span>] <span class="comment"># remember how to reverse sublist</span></span><br><span class="line">	nums[k:] = nums[k:][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 191 Number of 1 Bits</title>
    <url>/2022/01/17/leetcode-191-number-of-1-bits/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).<br><br><strong>Note:</strong><br><br><em>   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.
</em>   In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 00000000000000000000000000001011<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The input binary string <strong>00000000000000000000000000001011</strong> has a total of three ‘1’ bits.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 00000000000000000000000010000000<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The input binary string <strong>00000000000000000000000010000000</strong> has a total of one ‘1’ bit.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 11111111111111111111111111111101<br><strong>Output:</strong> 31<br><strong>Explanation:</strong> The input binary string <strong>11111111111111111111111111111101</strong> has a total of thirty one ‘1’ bits.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The input must be a <strong>binary string</strong> of length <code>32</code>.<br><br><em>*Follow up:</em></em> If this function is called many times, how would you optimize it?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求二进制上1的个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用n &amp; n - 1来去掉最左的1</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>用n &amp; n - 1来去掉最左的1</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> n:</span><br><span class="line">		n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1937 Maximum Number of Points with Cost</title>
    <url>/2022/02/16/leetcode-1937-maximum-number-of-points-with-cost/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-number-of-points-with-cost/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> integer matrix <code>points</code> (<strong>0-indexed</strong>). Starting with <code>0</code> points, you want to <strong>maximize</strong> the number of points you can get from the matrix.<br><br>To gain points, you must pick one cell in <strong>each row</strong>. Picking the cell at coordinates <code>(r, c)</code> will <strong>add</strong> <code>points[r][c]</code> to your score.<br><br>However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows <code>r</code> and <code>r + 1</code> (where <code>0 &lt;= r &lt; m - 1</code>), picking cells at coordinates <code>(r, c&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(r + 1, c&lt;sub&gt;2&lt;/sub&gt;)</code> will <strong>subtract</strong> <code>abs(c&lt;sub&gt;1&lt;/sub&gt; - c&lt;sub&gt;2&lt;/sub&gt;)</code> from your score.<br><br>Return <em>the <strong>maximum</strong> number of points you can achieve</em>.<br><br><code>abs(x)</code> is defined as:<br><br><em>   <code>x</code> for <code>x &gt;= 0</code>.
</em>   <code>-x</code> for <code>x &lt; 0</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,2,3],[1,5,1],[3,1,1]]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).<br>You add 3 + 5 + 3 = 11 to your score.<br>However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.<br>Your final score is 11 - 2 = 9.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,5],[2,3],[4,2]]<br><strong>Output:</strong> 11<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).<br>You add 5 + 3 + 4 = 12 to your score.<br>However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.<br>Your final score is 12 - 1 = 11.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == points.length</code>
</em>   <code>n == points[r].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= points[r][c] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中含点数，每行取一个cell上的点数，但若两行之间的cell的列不同，要扣去列下标差，求最大点数</p>
<h3 id="优化DP解题思路-推荐-："><a href="#优化DP解题思路-推荐-：" class="headerlink" title="优化DP解题思路(推荐)："></a><strong>优化DP解题思路(推荐)：</strong></h3><p>求数值的最大值，容易想到用DP，dp[i][j]定义为每个cell的累计最大点数，递归式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][k] - abs(j - k)) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p>
<p>复杂度为n立方。</p>
<p>如果没有扣除的规则，其实就是找上一行的最大值，但要考虑下标，考虑怎么移除这个限制，若将上一个某个cell搬到跟目前列，就是dp[i - 1][k] - (j - k), 所以可以提前计算，<br>而且有绝对值，所以类似于LeetCode 042 Trapping Rain Water拆分为向左向右最大值：<br>left[i]是该行第i个cell，上一行在该列左边的cell的累计最大点数(已扣除)，同理<br>right[i]是该行第i个cell，上一行在该列右边的cell的累计最大点数(已扣除)</p>
<p>最后，上一行的最大值只能在左边或右边<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(left[j], right[j]) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>left[j], right[j]的引入</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	m, n = len(points), len(points[<span class="number">0</span>])</span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">		dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">		left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">		left[<span class="number">0</span>], right[<span class="number">-1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">			left[j] = max(dp[i - <span class="number">1</span>][j], left[j - <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			right[j] = max(dp[i - <span class="number">1</span>][j], right[j + <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">			dp[i][j] = points[i][j] + max(left[j], right[j])</span><br><span class="line">	<span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
<hr>
<h3 id="暴力DP算法II解题思路-不推荐-："><a href="#暴力DP算法II解题思路-不推荐-：" class="headerlink" title="暴力DP算法II解题思路(不推荐)："></a><strong>暴力DP算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints2</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points))]</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">		dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">				dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][k] + points[i][j] - abs(j - k))</span><br><span class="line">	<span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 199 Binary Tree Right Side View</title>
    <url>/2022/01/17/leetcode-199-binary-tree-right-side-view/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,null,5,null,4]<br><strong>Output:</strong> [1,3,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1,null,3]<br><strong>Output:</strong> [1,3]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 100]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树从右看的节点列表。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS按层访问的最后一个</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>需要知道最后一个，所以引入i，不能用enumerate，只能用len</li>
<li>deque([root])不是deque(root)</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	res = []</span><br><span class="line">	queue = collections.deque([root])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		i, len_q = <span class="number">0</span>, len(queue) <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len_q):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">if</span> i == len_q - <span class="number">1</span>:</span><br><span class="line">				res.append(node.val)</span><br><span class="line">			<span class="keyword">if</span> node.left:</span><br><span class="line">				queue.append(node.left)</span><br><span class="line">			<span class="keyword">if</span> node.right:</span><br><span class="line">				queue.append(node.right)</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2007 Find Original Array From Doubled Array</title>
    <url>/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-original-array-from-doubled-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>An integer array <code>original</code> is transformed into a <strong>doubled</strong> array <code>changed</code> by appending <strong>twice the value</strong> of every element in <code>original</code>, and then randomly <strong>shuffling</strong> the resulting array.<br><br>Given an array <code>changed</code>, return <code>original</code> <em>if</em> <code>changed</code> <em>is a <strong>doubled</strong> array. If</em> <code>changed</code> <em>is not a <strong>doubled</strong> array, return an empty array. The elements in</em> <code>original</code> <em>may be returned in <strong>any</strong> order</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> changed = [1,3,4,2,6,8]<br><strong>Output:</strong> [1,3,4]<br><strong>Explanation:</strong> One possible original array could be [1,3,4]:<br>- Twice the value of 1 is 1 <em> 2 = 2.<br>- Twice the value of 3 is 3 </em> 2 = 6.<br>- Twice the value of 4 is 4 <em> 2 = 8.<br>Other original arrays could be [4,3,1] or [3,1,4].<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> changed = [6,3,0,1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> changed = [1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= changed.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= changed[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，求这个数组是否可以分成两部分，后一部分的每个元素是否前一部分某元素的两倍</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由最大值容易确定它的一半是否在数组中。所以排序后由大到小遍历。注意数组元素可能相等，所以不能用visited set来记录已用过的数，val_to_index也不支持重复，只有val_to_count支持</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用val_to_count，注意遍历时候就要减去，不要进入if才减去</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOriginalArray</span><span class="params">(self, changed: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> len(changed) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	changed.sort()</span><br><span class="line">	res = []</span><br><span class="line">	val_to_count = collections.Counter(changed)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(changed))):</span><br><span class="line">		<span class="keyword">if</span> val_to_count[changed[i]] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		val_to_count[changed[i]] -= <span class="number">1</span> <span class="comment"># not in  if statement</span></span><br><span class="line">		<span class="keyword">if</span> changed[i] / <span class="number">2</span> <span class="keyword">in</span> val_to_count <span class="keyword">and</span> val_to_count[changed[i] / <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">			val_to_count[changed[i] / <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">			res.append(int(changed[i] / <span class="number">2</span>))</span><br><span class="line">	<span class="keyword">return</span> [] <span class="keyword">if</span> len(res) * <span class="number">2</span> != len(changed) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Greedy</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 204 Count Primes</title>
    <url>/2022/01/17/leetcode-204-count-primes/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 10<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `0 &lt;= n &lt;= 5 </em> 10<sup>6</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求n内的素数个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>排除法：知道一个素数后删除它的倍数，剩下的就是下一个素数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>开一个prime大小数组，初始值为True表示是素数。</li>
<li>题目要求素数小于n，所以不含n</li>
<li>提高效率：i遍历到n开方+1，删除的数不能超过n(一开始写没有break导致TLE), 最后用sum统计比for循环效率高点</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	primes = [<span class="keyword">True</span>] * n <span class="comment"># remember less than n</span></span><br><span class="line">	primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> primes[i]:</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i * <span class="number">2</span>, n, i): <span class="comment"># starting from i rather than 2</span></span><br><span class="line">				primes[j] = <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2034 Stock Price Fluctuation</title>
    <url>/2022/02/16/leetcode-2034-stock-price-fluctuation/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/stock-price-fluctuation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a stream of <strong>records</strong> about a particular stock. Each record contains a <strong>timestamp</strong> and the corresponding <strong>price</strong> of the stock at that timestamp.<br><br>Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream <strong>correcting</strong> the price of the previous wrong record.<br><br>Design an algorithm that:<br><br><em>   <strong>Updates</strong> the price of the stock at a particular timestamp, <strong>correcting</strong> the price from any previous records at the timestamp.
</em>   Finds the <strong>latest price</strong> of the stock based on the current records. The <strong>latest price</strong> is the price at the latest timestamp recorded.<br><em>   Finds the <strong>maximum price</strong> the stock has been based on the current records.
</em>   Finds the <strong>minimum price</strong> the stock has been based on the current records.<br><br>Implement the <code>StockPrice</code> class:<br><br><em>   <code>StockPrice()</code> Initializes the object with no price records.
</em>   <code>void update(int timestamp, int price)</code> Updates the <code>price</code> of the stock at the given <code>timestamp</code>.<br><em>   <code>int current()</code> Returns the <strong>latest price</strong> of the stock.
</em>   <code>int maximum()</code> Returns the <strong>maximum price</strong> of the stock.<br><em>   <code>int minimum()</code> Returns the <strong>minimum price</strong> of the stock.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“StockPrice”, “update”, “update”, “current”, “maximum”, “update”, “maximum”, “update”, “minimum”]<br>[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]<br><strong>Output</strong><br>[null, null, null, 5, 10, null, 5, null, 2]<br><br><strong>Explanation</strong><br>StockPrice stockPrice = new StockPrice();<br>stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].<br>stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].<br>stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.<br>stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.<br>stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.<br>                          // Timestamps are [1,2] with corresponding prices [3,5].<br>stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.<br>stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].<br>stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= timestamp, price &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made <strong>in total</strong> to <code>update</code>, <code>current</code>, <code>maximum</code>, and <code>minimum</code>.
</em>   <code>current</code>, <code>maximum</code>, and <code>minimum</code> will be called <strong>only after</strong> <code>update</code> has been called <strong>at least once</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现一个关于股票的数据结构，可以更新时间点对应的股价，最大最小值，最新价格</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最大最小值容易想到用heap，但heap不支持更新，难点是怎么支持更新股价。<br>仍然(price, timestamp)加入到heap中，在出堆时验证</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>验证堆顶： 若股价和时间不匹配(用time_to_price验证)，表示这是stale股价，不断去掉，直到验证成功为止，最后加入到堆中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.time_to_price = &#123;&#125;</span><br><span class="line">        self.cur_time = <span class="number">0</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, timestamp: int, price: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.time_to_price[timestamp] = price</span><br><span class="line">        self.cur_time = max(self.cur_time, timestamp)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        heapq.heappush(self.max_heap, (-price, timestamp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.time_to_price[self.cur_time]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        <span class="keyword">while</span> -price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.max_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> -price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        <span class="keyword">while</span> price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> price</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>update时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206 Reverse Linked List</title>
    <url>/2022/01/17/leetcode-206-reverse-linked-list/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,3,4,5]<br><strong>Output:</strong> [5,4,3,2,1]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2]<br><strong>Output:</strong> [2,1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> head = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is the range <code>[0, 5000]</code>.
</em>   <code>-5000 &lt;= Node.val &lt;= 5000</code><br><br><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>反转LL</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题，但是经典题。循环体为，左方一个单独节点，右方为一个LL，将LL的首节点指向单独节点</p>
<p>LeetCode 206 Reverse Linked List 反转整个LL<br>LeetCode 092 Reverse Linked List II 反转部分LL，此题更加一般化</p>
<p>模板：<br>不断将end<strong>直接</strong>后面的节点加到start<strong>直接</strong>后面<br>start(group n) -&gt; NodeA （新状态） -&gt; … -&gt; end(group n+1)  -&gt; NodeA （前状态） -&gt; …  </p>
<ol>
<li>找出start和end，start为反转部分的前一个，end为反转部分的首个节点</li>
<li>循环删除end<strong>直接</strong>后，再加入到start<strong>直接</strong>后<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start, end = fake_head, head</span><br><span class="line"><span class="keyword">while</span> &lt;反转链表长度&gt;:</span><br><span class="line">	<span class="comment"># delete the node</span></span><br><span class="line">	moved_node, end.next = end.next, end.next.next</span><br><span class="line">	<span class="comment"># insert the moved_node</span></span><br><span class="line">	start.next, moved_node.next = moved_node, start.next</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>利用模板，由于首节点会变，所以引入fake_node</li>
<li>空节点的处理</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">	fake_head.next = head</span><br><span class="line">	start, end = fake_head, head</span><br><span class="line">	<span class="keyword">while</span> end.next:</span><br><span class="line">		<span class="comment"># delete the node</span></span><br><span class="line">		moved_node, end.next = end.next, end.next.next</span><br><span class="line">		<span class="comment"># insert the moved_node</span></span><br><span class="line">		start.next, moved_node.next = moved_node, start.next</span><br><span class="line">	<span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 207 Course Schedule</title>
    <url>/2022/01/17/leetcode-207-course-schedule/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that you <strong>must</strong> take course <code>b&lt;sub&gt;i&lt;/sub&gt;</code> first if you want to take course <code>a&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br><em>   For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.<br><br>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are a total of 2 courses to take.<br>To take course 1 you should have finished course 0. So it is possible.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There are a total of 2 courses to take.<br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= numCourses &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>0 &lt;= prerequisites.length &lt;= 5000</code>
</em>   <code>prerequisites[i].length == 2</code><br><em>   <code>0 &lt;= a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt; &lt; numCourses</code>
</em>   All the pairs prerequisites[i] are <strong>unique</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>课程有先修课要求，求是否可以完成所有课程</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>跟LeetCode 210 Course Schedule II几乎一样，此题求可否完成，那题求课程顺序。区别在于return那一句返回bool还是res</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	in_degree = [<span class="number">0</span>] * numCourses</span><br><span class="line">	graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> prerequisites:</span><br><span class="line">		in_degree[li[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">		graph[li[<span class="number">1</span>]].append(li[<span class="number">0</span>])</span><br><span class="line">	queue = collections.deque([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(in_degree)) <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>])</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> in_degree[neighbor] == <span class="number">0</span>:</span><br><span class="line">				queue.append(neighbor)</span><br><span class="line">	<span class="keyword">return</span> numCourses == len(res)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Amazon</tag>
        <tag>Graph</tag>
        <tag>Topological Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 211 Design Add and Search Words Data Structure</title>
    <url>/2022/01/17/leetcode-211-design-add-and-search-words-data-structure/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a data structure that supports adding new words and finding if a string matches any previously added string.<br><br>Implement the <code>WordDictionary</code> class:<br><br><em>   <code>WordDictionary()</code> Initializes the object.
</em>   <code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.<br><em>   <code>bool search(word)</code> Returns <code>true</code> if there is any string in the data structure that matches <code>word</code> or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.<br><br><strong>Example:</strong><br><br><pre><strong>Input</strong><br>[“WordDictionary”,”addWord”,”addWord”,”addWord”,”search”,”search”,”search”,”search”]<br>[[],[“bad”],[“dad”],[“mad”],[“pad”],[“bad”],[“.ad”],[“b..”]]<br><strong>Output</strong><br>[null,null,null,null,false,true,true,true]<br><br><strong>Explanation</strong><br>WordDictionary wordDictionary = new WordDictionary();<br>wordDictionary.addWord(“bad”);<br>wordDictionary.addWord(“dad”);<br>wordDictionary.addWord(“mad”);<br>wordDictionary.search(“pad”); // return False<br>wordDictionary.search(“bad”); // return True<br>wordDictionary.search(“.ad”); // return True<br>wordDictionary.search(“b..”); // return True<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= word.length &lt;= 500</code><br><em>   <code>word</code> in <code>addWord</code> consists lower-case English letters.
</em>   <code>word</code> in <code>search</code> consist of  <code>&#39;.&#39;</code> or lower-case English letters.<br>*   At most <code>50000</code> calls will be made to <code>addWord</code> and <code>search</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个数据结构支持加单词和查找单词。查找单词支持dot查询，表示配对任意字符</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>第一时间想到Trie，但难点在如果支持dot。一般Trie实现只支持单一单词查询，但是此题需要搜索所有可能节点。所以要将search加入TrieNode参数且转成DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>search加入TrieNode参数且转成DFS</li>
<li>终止条件第二个用TrieNode为空而不是用is_end</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.search_one_node(word, self.head)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_one_node</span><span class="params">(self, word, trie_node)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word <span class="keyword">and</span> trie_node.is_end:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word <span class="keyword">or</span> <span class="keyword">not</span> trie_node: <span class="comment"># remember not trie_node</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">'.'</span>:</span><br><span class="line">            <span class="keyword">for</span> child_node <span class="keyword">in</span> trie_node.children.values():</span><br><span class="line">                <span class="keyword">if</span> self.search_one_node(word[<span class="number">1</span>:], child_node):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.search_one_node(word[<span class="number">1</span>:], trie_node.children[word[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>search中不含dot时间复杂度为<code>O(n)</code>, 含dot时间复杂度为<code>O(26<sup>n</sup>)</code>，空间复杂度<code>O(1)</code>, n为搜索单词长度.   </p>
]]></content>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2128 Remove All Ones With Row and Column Flips</title>
    <url>/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> binary matrix <code>grid</code>.<br><br>In one operation, you can choose <strong>any</strong> row or column and flip each value in that row or column (i.e., changing all <code>0</code>‘s to <code>1</code>‘s, and all <code>1</code>‘s to <code>0</code>‘s).<br><br>Return <code>true</code> <em>if it is possible to remove all</em> <code>1</code><em>‘s from</em> <code>grid</code> using <strong>any</strong> number of operations or <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103191300-1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way to remove all 1’s from grid is to:<br>- Flip the middle row<br>- Flip the middle column<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181204-7.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,0],[0,0,0],[0,0,0]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> It is impossible to remove all 1’s from grid.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181224-8.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are no 1’s in grid.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code>
</em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个矩阵，每次可以flip一行或一列，求是否可以令矩阵变成全0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从例子找规律，<br>010和010属于一种类型<br>010和101也是同一种，每一行必须符合任何一种类型才是解</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	row_patten, row_pattern_invert = grid[<span class="number">0</span>], [<span class="number">1</span> - n <span class="keyword">for</span> n <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line">		<span class="keyword">if</span> grid[i] != row_patten <span class="keyword">and</span> grid[i] != row_pattern_invert:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 218 The Skyline Problem</title>
    <url>/2022/01/18/leetcode-218-the-skyline-problem/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A city’s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.<br><br>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left&lt;sub&gt;i&lt;/sub&gt;, right&lt;sub&gt;i&lt;/sub&gt;, height&lt;sub&gt;i&lt;/sub&gt;]</code>:<br><br><em>   <code>left&lt;sub&gt;i&lt;/sub&gt;</code> is the x coordinate of the left edge of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.
</em>   <code>right&lt;sub&gt;i&lt;/sub&gt;</code> is the x coordinate of the right edge of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.<br><em>   <code>height&lt;sub&gt;i&lt;/sub&gt;</code> is the height of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.<br><br>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.<br><br>The <strong>skyline</strong> should be represented as a list of “key points” <strong>sorted by their x-coordinate</strong> in the form <code>[[x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;],[x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.<br><br><strong>Note:</strong> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt=""><br><br><pre><strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]<br><strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]<br><strong>Explanation:</strong><br>Figure A shows the buildings of the input.<br>Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]<br><strong>Output:</strong> [[0,3],[5,0]]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= buildings.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= left&lt;sub&gt;i&lt;/sub&gt; &lt; right&lt;sub&gt;i&lt;/sub&gt; &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code>
</em>   <code>1 &lt;= height&lt;sub&gt;i&lt;/sub&gt; &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br>*   <code>buildings</code> is sorted by <code>left&lt;sub&gt;i&lt;/sub&gt;</code> in non-decreasing order.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p><strong>Heap(高度最大堆) + 端点排序法(先端点再高度逆序)</strong><br>不是高频题，但思路值得学习<br>Heap(高度最大堆): LeetCode 253 Meeting Rooms II方法一，终点的最小堆<br>端点排序法(先端点再高度逆序)： LeetCode 253 Meeting Rooms II方法二<br>meeting room是新线段的start逼栈顶终点出堆，此题也是同样，但用<strong>高度的最大堆</strong>维护当前最高大厦，这与题意符合。</p>
<ul>
<li><p>为什么要加入结束点?<br><img src="/images/L218.png" alt=""><br>两种情况，第一种情况没有问题，但第二种情况就会漏掉第一栋大厦的结束点。原因是出堆的点没有被处理，但出堆的点可能有多个而且若没有新大厦它不能出堆，所以结束点逼它出堆。</p>
</li>
<li><p>为什么高度逆序?<br><img src="/images/L218-2.png" alt=""><br>第一种情况在坐标2这个位置有两节点(2, 0, 0)第一栋大厦结束点, (2, 5, 3)第二栋大厦开始点，若不按高度排序，第一栋结束点会逼第一栋开始点出堆，产生天际线。若按高度逆序，后者先入堆，第一栋开始点出堆也不会产生天际线。类似于heapq.heapreplace先加入再删除或者LeetCode 354 Russian Doll Envelopes的排序方式</p>
</li>
</ul>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>先顺序排序端点再逆序高度</strong>，因为当结束点和始点重合时，让高度大的先入堆可以确保不会产生矮的天际线，否则这些矮的天际线实际被包含在高的大厦里。</li>
<li><strong>结束点也要加入循环但不入堆</strong>。这样产生两点：<br>1) start &gt;= heap[0][1]要取等号，否则不能让这栋大厦结束点出堆。<br>2) 结束点不入堆，因为它只用于产生结束点从而加入到结果集，它不产生高度，只有产生高度的点才会被加入到堆</li>
<li>与前高度不同，也就是高度发生变化就入堆</li>
<li>确保res[-1][1] != -heap[0][0]。用只有一栋大厦作为test case。<br>1) 因为用到了res[-1][1]，所以res初始化加入[-float(‘inf’), 0]，第一个值不会用到所以无所谓不妨去负无穷，高度为0；<br>2) 最后结果要排除这个点，取res[1:]<br>3) 因为要用到heap[0][0]，也就是heap要永远有节点。初始化加入[0, float(‘inf’)]，高度为0，用于产生在地平线的点的高度，结束点为无穷大，确保不会被逼出堆。<br>总结加入res中的为起始点，加入heap中的为结束点，它们高度均为0，但端点对称分别为负正无穷。</li>
</ol>
<p>大厦题，<strong>首尾加入节点</strong>：<br>LeetCode 084 Largest Rectangle in Histogram<br>LeetCode 218 The Skyline Problem</p>
<p>实现上有点似：<br>LeetCode 239 Sliding Window Maximum 模板，计算，排除<br>LeetCode 218 The Skyline Problem 模板，加入，计算</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSkyline</span><span class="params">(self, buildings: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	events = sorted(buildings + [[end, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _, end, _ <span class="keyword">in</span> buildings], key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">2</span>]))</span><br><span class="line">	heap, res = [(<span class="number">0</span>, float(<span class="string">'inf'</span>))], [[-float(<span class="string">'inf'</span>), <span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">for</span> start, end, height <span class="keyword">in</span> events:</span><br><span class="line">		<span class="keyword">while</span> heap <span class="keyword">and</span> start &gt;= heap[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">			heapq.heappop(heap)</span><br><span class="line">		<span class="keyword">if</span> height &gt; <span class="number">0</span>: <span class="comment"># don't push ends into the heap</span></span><br><span class="line">			heapq.heappush(heap, (-height, end))</span><br><span class="line">		<span class="keyword">if</span> res[<span class="number">-1</span>][<span class="number">1</span>] != -heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">			res.append([start, -heap[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(k)</code>, k为重合天际线个数，此复杂度跟Meeting Rooms II一致  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 221 Maximal Square</title>
    <url>/2022/01/18/leetcode-221-maximal-square/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>‘s and <code>1</code>‘s, <em>find the largest square containing only</em> <code>1</code>‘s <em>and return its area</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[“0”,”1”],[“1”,”0”]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> matrix = [[“0”]]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code>
</em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code>
</em>   <code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子正方形矩阵全是1的最大面积</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最值且是矩阵考虑用DP，但公式比较难写。<br>dp[i][j]为以(i-1, j-1)为右下端点的正方形的边长<br>递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125; + 1 if matrix[i][j] == 1</span><br><span class="line">         = 0                                             otherwise</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>严格遵守DP的5点注意事项</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>严格遵守DP的5点注意事项。初始值是0，表示<strong>第一行或第一列的点的边长最多只能为1</strong>.  </li>
<li>输入是字符，所以比较是否1时候用字符比较</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125; + 1 if matrix[i][j] == 1</span></span><br><span class="line"><span class="comment">#          = 0                                             otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)] <span class="comment"># remember 0 not 1 or float(inf)</span></span><br><span class="line">	<span class="comment"># dp[0][0] = 0</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">			dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span> <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># remember '1' not 1</span></span><br><span class="line">			res = max(res, dp[i][j])</span><br><span class="line">	<span class="keyword">return</span> res * res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code> </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 234 Palindrome Linked List</title>
    <url>/2022/01/18/leetcode-234-palindrome-linked-list/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,2,1]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is in the range <code>[1, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 9</code><br><br><strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一个LL是否回文</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>快慢指针 + Stack</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>快慢指针找到中点，找的同时，慢指针所有节点入栈。慢指针继续走，比较stack节点和慢指针节点。</li>
<li><strong>不涉及删除，所以不需要哟用到fake_node</strong></li>
<li><strong>中位数可能有1-2个</strong>。奇偶问题，若fast指向节点(另一情况是None), 表明是奇数个，slow在第二个循环前多走一步，跳过最中间的节点</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">	fast, slow = head, head</span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">		stack.append(slow)</span><br><span class="line">		slow = slow.next</span><br><span class="line">		fast = fast.next.next</span><br><span class="line">	<span class="keyword">if</span> fast:</span><br><span class="line">		slow = slow.next</span><br><span class="line">	<span class="keyword">while</span> slow:</span><br><span class="line">		<span class="keyword">if</span> stack.pop().val != slow.val:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		slow = slow.next</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 240 Search a 2D Matrix II</title>
    <url>/2022/01/18/leetcode-240-search-a-2d-matrix-ii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Write an efficient algorithm that searches for a <code>target</code> value in an <code>m x n</code> integer <code>matrix</code>. The <code>matrix</code> has the following properties:<br><br><em>   Integers in each row are sorted in ascending from left to right.
</em>   Integers in each column are sorted in ascending from top to bottom.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code>
</em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= n, m &lt;= 300</code>
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All the integers in each row are <strong>sorted</strong> in ascending order.
</em>   All the integers in each column are <strong>sorted</strong> in ascending order.<br>*   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵按行按列有序，求是否存在target</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>矩阵有序题有3道：<br>LeetCode 074 Search a 2D Matrix 每一行有序，下一行的首元素大于上一行的尾元素 + 找target<br>LeetCode 240 Search a 2D Matrix II 按行按列有序 + 找target<br>LeetCode 378 Kth Smallest Element in a Sorted Matrix 按行按列有序 + 找第k大<br>矩阵结构方面，第一道每一行都是独立，所以可以独立地按行按列做二分法<br>后两道，矩阵二维连续，所以解法都是类BFS，从某个点开始，然后比较它相邻的两个点。出发点不同，第二道在近似矩阵中点(右上角或左下角)，第三道在左上角出发。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>从右上角出发，比较左和下节点。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">	i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">if</span> target &lt; matrix[i][j]:</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 235 Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/2022/01/18/leetcode-235-lowest-common-ancestor-of-a-binary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br><br>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [2,1], p = 2, q = 1<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.
</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.
</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> will exist in the BST.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>BST中求给定的两节点的最低共同父亲节点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况，也是用DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>pq一定存在，所以有**三种情况： 1) p或q是root，另一是其子孙。 2) p，q分列root两边。 3) p，q在root的一边。跟LeetCode 236 Lowest Common Ancestor of a Binary Tree不同的是，<br>第二种情况，不用递归即知道，因为这是BST。第一和第三种情况同</li>
<li>第二种情况由于要比较p, q, root顺序，所以要令p, q有序，Line 4-5</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">if</span> p.val &gt; q.val: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> self.lowestCommonAncestor(root, q, p)</span><br><span class="line">	<span class="keyword">if</span> p.val &lt;= root.val &lt;= q.val <span class="keyword">or</span> p == root <span class="keyword">or</span> q == root: <span class="comment"># remember root is p or q</span></span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	<span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">		<span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 241 Different Ways to Add Parentheses</title>
    <url>/2022/01/18/leetcode-241-different-ways-to-add-parentheses/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “2-1-1”<br><strong>Output:</strong> [0,2]<br><strong>Explanation:</strong><br>((2-1)-1) = 0<br>(2-(1-1)) = 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “2<em>3-4</em>5”<br><strong>Output:</strong> [-34,-14,-10,-10,10]<br><strong>Explanation:</strong><br>(2<em>(3-(4</em>5))) = -34<br>((2<em>3)-(4</em>5)) = -14<br>((2<em>(3-4))</em>5) = -10<br>(2<em>((3-4)</em>5)) = -10<br>(((2<em>3)-4)</em>5) = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= expression.length &lt;= 20</code>
</em>   <code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.<br>*   All the integer values in the input expression are in the range <code>[0, 99]</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串含数字和加减乘除，求所有加括号方法得到的结果</p>
<h3 id="Catalan解题思路-推荐-："><a href="#Catalan解题思路-推荐-：" class="headerlink" title="Catalan解题思路(推荐)："></a><strong>Catalan解题思路(推荐)：</strong></h3><p>求所有结果，用DFS，由于需要左右递归，双边递归，所以用Catalan法模板</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>终止条件返回是一个list</strong></li>
<li>Python中用eval来计算字符串运算结果返回值为整数，所以归纳左右递归结果要用str转为字符串</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, expression: str)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> expression.isdigit():</span><br><span class="line">		<span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		left_res = self.diffWaysToCompute(expression[:i])</span><br><span class="line">		right_res = self.diffWaysToCompute(expression[i + <span class="number">1</span>:])</span><br><span class="line">		res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code></p>
<hr>
<h3 id="记忆性搜索算法II解题思路："><a href="#记忆性搜索算法II解题思路：" class="headerlink" title="记忆性搜索算法II解题思路："></a><strong>记忆性搜索算法II解题思路：</strong></h3><p>大致同上，只不过加入记忆性搜索算法，但优化不算大</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute2</span><span class="params">(self, expression)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(expression, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, expression: str, cache)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> expression.isdigit():</span><br><span class="line">		<span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line">	<span class="keyword">if</span> expression <span class="keyword">in</span> cache:</span><br><span class="line">		<span class="keyword">return</span> cache[expression]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		left_res = self.dfs(expression[:i], cache)</span><br><span class="line">		right_res = self.dfs(expression[i + <span class="number">1</span>:], cache)</span><br><span class="line">		res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line">	cache[expression] = res</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 242 Valid Anagram</title>
    <url>/2022/01/18/leetcode-242-valid-anagram/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “nagaram”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “rat”, t = “car”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, t.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s<code>and</code>t` consist of lowercase English letters.<br><br><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>验证变位词</p>
<h3 id="频率法解题思路-推荐-："><a href="#频率法解题思路-推荐-：" class="headerlink" title="频率法解题思路(推荐)："></a><strong>频率法解题思路(推荐)：</strong></h3><p>简单题</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="排序法算法II解题思路："><a href="#排序法算法II解题思路：" class="headerlink" title="排序法算法II解题思路："></a><strong>排序法算法II解题思路：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 243 Shortest Word Distance</title>
    <url>/2022/01/18/leetcode-243-shortest-word-distance/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-word-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of strings <code>wordsDict</code> and two different strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between these two words in the list</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “coding”, word2 = “practice”<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “makes”, word2 = “coding”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= wordsDict.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>1 &lt;= wordsDict[i].length &lt;= 10<code>*</code>wordsDict[i]<code>consists of lowercase English letters.
*</code>word1<code>and</code>word2<code>are in</code>wordsDict<code>.
*</code>word1 != word2`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求单词列表中给定的两个单词的最短下标距离</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同向双指针</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>同向双指针，分别指向两单词，计算结果时必须是找到才比较</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, wordsDict: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">	p1 = p2 = <span class="number">-1</span></span><br><span class="line">	res = float(<span class="string">'inf'</span>)</span><br><span class="line">	<span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(wordsDict):</span><br><span class="line">		<span class="keyword">if</span> word == word1:</span><br><span class="line">			p1 = i</span><br><span class="line">		<span class="keyword">if</span> word == word2:</span><br><span class="line">			p2 = i</span><br><span class="line">		<span class="keyword">if</span> p1 != <span class="number">-1</span> <span class="keyword">and</span> p2 != <span class="number">-1</span>:</span><br><span class="line">			res = min(res, abs(p1 - p2))</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 249 Group Shifted Strings</title>
    <url>/2022/01/18/leetcode-249-group-shifted-strings/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/group-shifted-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>We can shift a string by shifting each of its letters to its successive letter.<br><br><em>   For example, <code>&quot;abc&quot;</code> can be shifted to be <code>&quot;bcd&quot;</code>.<br><br>We can keep shifting the string to form a sequence.

</em>   For example, we can keep shifting <code>&quot;abc&quot;</code> to form the sequence: <code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code>.<br><br>Given an array of strings <code>strings</code>, group all <code>strings[i]</code> that belong to the same shifting sequence. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strings = [“abc”,”bcd”,”acef”,”xyz”,”az”,”ba”,”a”,”z”]<br><strong>Output:</strong> [[“acef”],[“a”,”z”],[“abc”,”bcd”,”xyz”],[“az”,”ba”]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strings = [“a”]<br><strong>Output:</strong> [[“a”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strings.length &lt;= 200</code>
</em>   <code>1 &lt;= strings[i].length &lt;= 50</code><br>*   <code>strings[i]</code> consists of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将单词按等偏移量分组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>单词分组题，设计一个id。组内的每个单词里字母之间的差值是一致的，如abd, wxz, 差值分别为1和2，这是同一组。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>求每个单词每个字母之间的差值，用下滑线连接作为id。注意差值可能为负数，所以要取mod变正</li>
<li>单一字母单词，不存在偏移量，id为空，所以代码不需要特殊处理</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span><span class="params">(self, strings: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">	res = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">		_id = <span class="string">''</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">			_id += str((ord(s[j]) - ord(s[j - <span class="number">1</span>])) % <span class="number">26</span>) + <span class="string">'_'</span></span><br><span class="line">		res[_id].append(s)</span><br><span class="line">	<span class="keyword">return</span> list(res.values())</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>, n为单词个数, m为单词最长长度。  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 256 Paint House</title>
    <url>/2022/01/19/leetcode-256-paint-house/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is a row of <code>n</code> houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br><br>The cost of painting each house with a certain color is represented by an <code>n x 3</code> cost matrix <code>costs</code>.<br><br><em>   For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with the color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on…<br><br>Return <em>the minimum cost to paint all houses</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> costs = [[17,2,17],[16,16,5],[14,3,19]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>Minimum cost: 2 + 5 + 3 = 10.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> costs = [[7,6,2]]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>costs.length == n</code><br><em>   <code>costs[i].length == 3</code>
</em>   <code>1 &lt;= n &lt;= 100</code><br>*   <code>1 &lt;= costs[i][j] &lt;= 20</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排屋相邻不同色地涂色(3色)的最低成本</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>低频题。最值且涉及数值考虑用DP。由于相邻不能同色，所以是多状态DP，有3个状态，不妨多用一维表示，第二维只有3值。<br>dp[i][j]定义为第i间屋涂上第j色的最低总费用，递归式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>递归5步曲，多1，初始，多1，少1，答案。记得第一步初始化数组多1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dp = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(costs) + <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">			dp[i][j] = min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j])</span><br><span class="line">	<span class="keyword">return</span> min(dp[<span class="number">-1</span>][<span class="number">0</span>], dp[<span class="number">-1</span>][<span class="number">1</span>], dp[<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 259 3Sum Smaller</title>
    <url>/2022/01/29/leetcode-259-3sum-smaller/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of <code>n</code> integers <code>nums</code> and an integer <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-2,0,1,3], target = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Because there are two triplets which sums are less than 2:<br>[-2,0,1]<br>[-2,0,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [0], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>0 &lt;= n &lt;= 3500</code><br><em>   <code>-100 &lt;= nums[i] &lt;= 100</code>
</em>   <code>-100 &lt;= target &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找三数和小于target的组合个数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于三数和等于target，但当小于target时，直接求个数，类似于LeetCode 315 Count of Smaller Numbers After Self。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>res不是+1而是right - left</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">		left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; right:</span><br><span class="line">			<span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">				res += right - left <span class="comment"># remember</span></span><br><span class="line">				left += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				right -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
        <tag>Citadel</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 266 Palindrome Permutation</title>
    <url>/2022/01/19/leetcode-266-palindrome-permutation/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code>, return <code>true</code> if a permutation of the string could form a palindrome.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “code”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “carerac”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 5000</code>
</em>   <code>s</code> consists of only lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串的任一全排列是否存在回文字符串</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，也就是统计字符频率，奇数频率的字符最多有1个</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>统计字符频率，奇数频率的字符最多有1个</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 268 Missing Number</title>
    <url>/2022/01/19/leetcode-268-missing-number/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code>
</em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= nums[i] &lt;= n</code>
</em>   All the numbers of <code>nums</code> are <strong>unique</strong>.<br><br><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组缺失一个数，所有数应该在[0, n]内，求缺失数</p>
<h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="异或法解题思路II："><a href="#异或法解题思路II：" class="headerlink" title="异或法解题思路II："></a><strong>异或法解题思路II：</strong></h3><p>高斯原理</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	res = len(nums) <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">		res ^= i ^ n</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>
<hr>
<h3 id="数学法解题思路III："><a href="#数学法解题思路III：" class="headerlink" title="数学法解题思路III："></a><strong>数学法解题思路III：</strong></h3><p>高斯原理</p>
<h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	n = len(nums)</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span> + n) * (n + <span class="number">1</span>) // <span class="number">2</span> - sum(nums)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 270 Closest Binary Search Tree Value</title>
    <url>/2022/01/19/leetcode-270-closest-binary-search-tree-value/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div>Given the <code>root</code> of a binary search tree and a <code>target</code> value, return <em>the value in the BST that is closest to the</em> <code>target</code>. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 4.428571<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>. </em> <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code> * <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求BST中最接近target的值</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>接近target的值在BST搜索路径上，越后搜索到的(越后入栈的)越接近，但最接近的可能大于或小于target(predecessors or successors)，只能逐一比较.<br>类似于LeetCode 272 Closest Binary Search Tree Value II</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>循环中用it，不能用root，注意检查</li>
<li>接近target的值在BST搜索路径上，逐一比较</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root: TreeNode, target: float)</span> -&gt; int:</span></span><br><span class="line">	closest_vals = []</span><br><span class="line">	it = root</span><br><span class="line">	<span class="keyword">while</span> it:</span><br><span class="line">		closest_vals.append(it.val)</span><br><span class="line">		<span class="keyword">if</span> target &lt; it.val:</span><br><span class="line">			it = it.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			it = it.right</span><br><span class="line">	min_val, res = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> closest_vals:</span><br><span class="line">		<span class="keyword">if</span> abs(target - n) &lt; min_val:</span><br><span class="line">			min_val = abs(target - n)</span><br><span class="line">			res = n</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(h)</code>，空间复杂度<code>O(h)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 277 Find the Celebrity</title>
    <url>/2022/01/19/leetcode-277-find-the-celebrity/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.<br><br>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is ask questions like: “Hi, A. Do you know B?” to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).<br><br>You are given a helper function <code>bool knows(a, b)</code> that tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.<br><br>Return <em>the celebrity’s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There is no celebrity.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == graph.length</code>
</em>   <code>n == graph[i].length</code><br><em>   <code>2 &lt;= n &lt;= 100</code>
</em>   <code>graph[i][j]</code> is <code>0</code> or <code>1</code>.<br><em>   <code>graph[i][i] == 1</code><br><br><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is `3 </em> n`, could you find a solution without exceeding the maximum number of calls?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过调用a是否认识b函数，找出名人。名人是除自己的所有人都认识他，他不认识其他所有人</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 169 Majority Element，用水王法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>找出可能名人，通过查看是否i后面的每一个人都认识i，若不是将candidate换成当前下标</li>
<li>按定义验证第一步的结果是否名人，两步验证</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>按照定义，若i不认识candiate才换candidate，用not。因为edge case是没有边或者图存在循环</li>
<li>验证时候，第二步验证candidate若认识任意人就不是名人，排除candidate认识自己。题目条件candidate认识自己。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="comment"># find potential candidate</span></span><br><span class="line">	candidate = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">			candidate = i</span><br><span class="line">	<span class="comment"># validate</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		<span class="keyword">if</span> candidate != i <span class="keyword">and</span> knows(candidate, i):</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 282 Expression Add Operators</title>
    <url>/2022/01/19/leetcode-282-expression-add-operators/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/expression-add-operators" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators</em> <code>&#39;+&#39;</code><em>,</em> <code>&#39;-&#39;</code><em>, and/or</em> <code>&#39;*&#39;</code> <em>between the digits of</em> <code>num</code> <em>so that the resultant expression evaluates to the</em> <code>target</code> <em>value</em>.<br><br>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = “123”, target = 6<br><strong>Output:</strong> [“1<em>2</em>3”,”1+2+3”]<br><strong>Explanation:</strong> Both “1<em>2</em>3” and “1+2+3” evaluate to 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = “232”, target = 8<br><strong>Output:</strong> [“2<em>3+2”,”2+3</em>2”]<br><strong>Explanation:</strong> Both “2<em>3+2” and “2+3</em>2” evaluate to 8.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = “3456237490”, target = 9191<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no expressions that can be created from “3456237490” to evaluate to 9191.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num.length &lt;= 10</code>
</em>   <code>num</code> consists of only digits.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= target &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一串数字加入加减乘能得到target的所有可能性</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有可能用DFS。属于分割型DFS，在数位之间加符号，数位可以是1个到多个。<br>一轮递归分割出符号 + 数字<br>另一种选择是数字 + 符号，但需要额外变量sign，因为不能立刻计算到结果。也不符合正常逻辑。所以选择前者。</p>
<p>由于运算都是二元，也就是用上述分割法，第一个数要特别处理。所以DFS中要特别处理第一个数。这样可以开始写加减。引入prev_res作为DFS参数，这样只要prev_res 加减 该轮数字即可得到该轮结果。用DFS模板5个标准参数外加prev_res：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_res, path, res):</span><br></pre></td></tr></table></figure></p>
<p>这样只处理加减的DFS比较容易实现  </p>
<p>最大难点在于乘法，参考LeetCode 227 Basic Calculator II，加减和乘除属于两层计算需要分别处理，所以引入<strong>新参数prev_multi_res，用于保存乘法结果，而刚才的命名为prev_add_res保存加减乘的全部结果</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_add_res, prev_multi_res, path, res):</span><br></pre></td></tr></table></figure></p>
<p>举例2+3*4，按照原来的逻辑会计算到2+3=5，但此时如果遇到乘号，就要重新计算加法结果，先减去乘法结果，退回到2，再计算3*4=12这是乘法结果，再加回2得到新加法结果。进一步理解prev_multi_res，如果该轮是加减法，仍要将该轮的数作为prev_multi_res传到下轮DFS，因为如果下一轮是乘法，它就是第一个乘法的数。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>先实现加减法</li>
<li>再实现乘法</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>分割型DFS，选择每轮递归分割符号 + 数字。由于运算都是二元，<strong>特别处理第一个数</strong></li>
<li>引入参数prev_add_res, prev_multi_res. <strong>prev_multi_res若是加减，用(+/-)cur_num, 否则用乘法结果prev_multi_res * cur_num</strong>。注意若是减法cur_num用负号</li>
<li>分割时数字不能有前缀0</li>
<li>prev_res不用恢复状态因为是标量</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span><span class="params">(self, num: str, target: int)</span> -&gt; List[str]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(num, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, st, target, prev_add_res, prev_multi_res, path, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> st == len(num):</span><br><span class="line">		<span class="keyword">if</span> target == prev_add_res:</span><br><span class="line">			res.append(path)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(num)):</span><br><span class="line">		<span class="keyword">if</span> i &gt; st <span class="keyword">and</span> num[st] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		cur_num = int(num[st:i + <span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> path: <span class="comment"># remember</span></span><br><span class="line">		    <span class="comment"># first number, same as + case</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, str(cur_num), res)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, path + <span class="string">'+'</span> + str(cur_num), res) <span class="comment"># use cur_num rather than cur</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, prev_add_res - cur_num, -cur_num, path + <span class="string">'-'</span> + str(cur_num), res) <span class="comment"># -cur_num rather than cur_num</span></span><br><span class="line">			self.dfs(num, i + <span class="number">1</span>, target, (prev_add_res - prev_multi_res) + prev_multi_res * cur_num, prev_multi_res * cur_num, path + <span class="string">'*'</span> + str(cur_num), res) <span class="comment"># prev_multi_res * cur_num not cur_num</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(4<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>, 因为每个字符之间都有不加操作符，加3个操作符，所以是4，有n-1个间隔  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Math</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 283 Move Zeroes</title>
    <url>/2022/01/20/leetcode-283-move-zeroes/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.<br><br><strong>Note</strong> that you must do this in-place without making a copy of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,12]<br><strong>Output:</strong> [1,3,12,0,0]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you minimize the total number of operations done?</div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将数组的0全部移到数组末</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。Quicksort的partition的应用</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	non_zero_idx = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">			nums[i], nums[non_zero_idx] = nums[non_zero_idx], nums[i]</span><br><span class="line">			non_zero_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 286 Walls and Gates</title>
    <url>/2022/01/20/leetcode-286-walls-and-gates/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values.<br><br><em>   <code>-1</code> A wall or an obstacle.
</em>   <code>0</code> A gate.<br><em>   <code>INF</code> Infinity means an empty room. We use the value <code>2&lt;sup&gt;31&lt;/sup&gt; - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.<br><br>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt=""><br><br><pre><strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br><strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> rooms = [[-1]]<br><strong>Output:</strong> [[-1]]<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == rooms.length</code><br><em>   <code>n == rooms[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 250</code><br>*   <code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有房间到门的最短距离</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>属于多始点BFS类型</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>门的距离不更新，所以出列后要判断该点是否为门，不是用距离来判断</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSET = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        gates = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rooms)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(rooms[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    gates.append((i, j, <span class="number">0</span>))</span><br><span class="line">        queue = collections.deque(gates)</span><br><span class="line">        visited = set(gates)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, distance = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> rooms[x][y] != <span class="number">0</span>: <span class="comment"># not distance != 0</span></span><br><span class="line">                rooms[x][y] = distance</span><br><span class="line">            <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">                _x, _y = x + _dx, y + _dy</span><br><span class="line">                <span class="keyword">if</span> _x &lt; <span class="number">0</span> <span class="keyword">or</span> _x &gt;= len(rooms) <span class="keyword">or</span> _y &lt; <span class="number">0</span> <span class="keyword">or</span> _y &gt;= len(rooms[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        rooms[_x][_y] == <span class="number">-1</span> <span class="keyword">or</span> (_x, _y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((_x, _y, distance + <span class="number">1</span>))</span><br><span class="line">                visited.add((_x, _y))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(mn)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Matrix</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <url>/2022/01/20/leetcode-287-find-the-duplicate-number/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br><br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br><br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,4,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,1,3,4,2]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>nums.length == n + 1</code><br><em>   <code>1 &lt;= nums[i] &lt;= n</code>
</em>   All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.<br><br><strong>Follow up:</strong><br><br><em>   How can we prove that at least one duplicate number must exist in <code>nums</code>?
</em>   Can you solve the problem in linear runtime complexity?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数值二分法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li>
<li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line">	<span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">		mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">		count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line">		<span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">			start = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid</span><br><span class="line">	<span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 296 Best Meeting Point</title>
    <url>/2022/01/18/leetcode-296-best-meeting-point/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> binary grid <code>grid</code> where each <code>1</code> marks the home of one friend, return <em>the minimal <strong>total travel distance</strong></em>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/meetingpoint-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> Given three friends living at (0,0), (0,4), and (2,2).<br>The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.<br>So return 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,1]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code>
</em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><em>   There will be <em>*at least two</em></em> friends in the <code>grid</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中1表示朋友的位置，求最佳见面位置，所有朋友到这个位置曼哈顿距离最短。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是数学题也是非高频题。如果是一维，求最佳位置，是所有朋友位置的中点，也就是左边朋友和右边朋友的数量是一样。求距离也就是用相向双指针，求每对点的距离。<br>推广到二维，同理，x和y坐标是独立的。分别求距离即可。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用相向双指针，求每对点的距离</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTotalDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	x_coordinates, y_coordinates = [], []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">				x_coordinates.append(i)</span><br><span class="line">				y_coordinates.append(j)</span><br><span class="line">	x_coordinates.sort()</span><br><span class="line">	y_coordinates.sort()</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	left, right = <span class="number">0</span>, len(y_coordinates) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		res += y_coordinates[right] - y_coordinates[left]</span><br><span class="line">		left += <span class="number">1</span></span><br><span class="line">		right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	left, right = <span class="number">0</span>, len(x_coordinates) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		res += x_coordinates[right] - x_coordinates[left]</span><br><span class="line">		left += <span class="number">1</span></span><br><span class="line">		right -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>, n为矩阵的长边大小  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 298 Binary Tree Longest Consecutive Sequence</title>
    <url>/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive sequence path</em>.<br><br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,null,3,2,null,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range `[1, 3 </em> 10<sup>4</sup>]<code>.
*</code>-3 <em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 </em> 10<sup>4</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求从父到子的最长连续数列的长度(由小到大)</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p>
<p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>题意是从父到儿子的有小到大数列，而不是儿子到父亲</li>
<li>以root为起点的最长数列，若root不符合条件，不加入left或right的长度</li>
<li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有三种情况：自己，自己+左，自己+右</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		left = dfs(root.left)</span><br><span class="line">		right = dfs(root.right)</span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:  <span class="comment"># remember not ==</span></span><br><span class="line">			lpath += left</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right</span><br><span class="line">		res = max(lpath, rpath)</span><br><span class="line">		max_len = max(res, max_len)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 304 Range Sum Query 2D - Immutable</title>
    <url>/2022/01/21/leetcode-304-range-sum-query-2d-immutable/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:<br><br><em>   Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br>Implement the NumMatrix class:

</em>   <code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.<br><em>   <code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt=""><br><br><pre><strong>Input</strong><br>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<br><strong>Output</strong><br>[null, 8, 11, 12]<br><br><strong>Explanation</strong><br>NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == matrix.length</code><br><em>   <code>n == matrix[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= row1 &lt;= row2 &lt; m</code><br><em>   <code>0 &lt;= col1 &lt;= col2 &lt; n</code>
</em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>sumRegion</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子矩阵和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>计算presum公式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j] - dp[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>计算子矩阵公式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dp有左上边界，计算子矩阵注意dp和输入差1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp[<span class="number">0</span>])):</span><br><span class="line">                self.dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + self.dp[i - <span class="number">1</span>][j] + self.dp[i][j - <span class="number">1</span>] - self.dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 315 Count of Smaller Numbers After Self</title>
    <url>/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [5,2,6,1]<br><strong>Output:</strong> [2,1,1,0]<br><strong>Explanation:</strong><br>To the right of 5 there are <strong>2</strong> smaller elements (2 and 1).<br>To the right of 2 there is only <strong>1</strong> smaller element (1).<br>To the right of 6 there is <strong>1</strong> smaller element (1).<br>To the right of 1 there is <strong>0</strong> smaller element.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-1]<br><strong>Output:</strong> [0,0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组中，统计每一位比自己小的数。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑用递减栈。但不可行, 因为这是统计题，而不是求比自己大的一个数LeetCode 503 Next Greater Element II。类似于merge sort，考虑统计逆序数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>由于mergesort会改变数组顺序，所以统计数组count也要对应的数也会变，所以将原数组变成(数值, 下标)对，count就可以统计原数组</li>
<li>计算逆序对时候，放在nums[i][0] &lt;= nums[j][0]中，核心在count[nums[i][1]] += j - mid - 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	count = [<span class="number">0</span>] * len(nums)</span><br><span class="line">	num_with_idx = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">	self.merge_sort(num_with_idx, <span class="number">0</span>, len(nums) - <span class="number">1</span>, count)</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums, start, end, count)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">	self.merge_sort(nums, start, mid, count)</span><br><span class="line">	self.merge_sort(nums, mid + <span class="number">1</span>, end, count)</span><br><span class="line">	self.merge(nums, start, mid, end, count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, start, mid, end, count)</span>:</span></span><br><span class="line">	i, j = start, mid + <span class="number">1</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">		<span class="keyword">if</span> nums[i][<span class="number">0</span>] &lt;= nums[j][<span class="number">0</span>]:</span><br><span class="line">			res.append(nums[i])</span><br><span class="line">			count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(nums[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">		res.append(nums[i])</span><br><span class="line">		count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= end:</span><br><span class="line">		res.append(nums[j])</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Merge Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 325 Maximum Size Subarray Sum Equals k</title>
    <url>/2022/01/23/leetcode-325-maximum-size-subarray-sum-equals-k/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the maximum length of a subarray that sums to</em> <code>k</code>. If there is not one, return <code>0</code> instead.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,-1,5,-2,3], k = 3<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The subarray [1, -1, 5, -2] sums to 3 and is the longest.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-2,-1,2,1], k = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The subarray [-1, 2] sums to 1 and is the longest.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 2 </em> 10<sup>5</sup><code>*</code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup><code>*</code>-10<sup>9</sup> &lt;= k &lt;= 10<sup>9</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长子数组和等于k，求长度</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始以为类似于LeetCode 209 Minimum Size Subarray Sum用同向双指针。但这题不是连续，因为此题含负数，不会连续大于等于target。考虑用presum的two sum法。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>加入presum[0] = 0</strong>，因为这样才可以得到以首元素开始的子数组和</li>
<li>若presum已经在hashmap中了，不要加入，因为要保证最长数组，如 [-1, 1], target = 0, index可以为0, 2</li>
<li>max_len答案只要初始化为0，不用最小值，因为最大长度必为非负</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># presum[i] - presum[j] = k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArrayLen</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	max_len, presum = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># not float('-inf')</span></span><br><span class="line">	sum_to_idx = collections.defaultdict(int)</span><br><span class="line">	sum_to_idx[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		presum += nums[i]</span><br><span class="line">		<span class="keyword">if</span> presum - k <span class="keyword">in</span> sum_to_idx:</span><br><span class="line">			max_len = max(max_len, i - sum_to_idx[presum - k] + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> presum <span class="keyword">not</span> <span class="keyword">in</span> sum_to_idx: <span class="comment"># remember</span></span><br><span class="line">			sum_to_idx[presum] = i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 317 Shortest Distance from All Buildings</title>
    <url>/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> grid <code>grid</code> of values <code>0</code>, <code>1</code>, or <code>2</code>, where:<br><br><em>   each <code>0</code> marks <strong>an empty land</strong> that you can pass by freely,
</em>   each <code>1</code> marks <strong>a building</strong> that you cannot pass through, and<br><em>   each <code>2</code> marks <strong>an obstacle</strong> that you cannot pass through.<br><br>You want to build a house on an empty land that reaches all buildings in the <strong>shortest total travel</strong> distance. You can only move up, down, left, and right.<br><br>Return <em>the <strong>shortest travel distance</strong> for such a house</em>. If it is not possible to build such a house according to the above rules, return <code>-1</code>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).<br>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.<br>So return 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,0]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> grid = [[1]]<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>m == grid.length</code><br><em>   <code>n == grid[i].length</code>
</em>   <code>1 &lt;= m, n &lt;= 50</code><br><em>   <code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.
</em>   There will be <strong>at least one</strong> building in the <code>grid</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找到所有大厦最短距离的点，这个点不能是大厦也不能是障碍</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始觉得类似于LeetCode 296 Best Meeting Point，但由于有障碍，所以不能用贪婪法。最值考虑用BFS。属于对所有节点BFS。类似于LeetCode 200 Number of Islands，<br>从每一栋大厦开始做BFS，计算每个点到此大厦距离。然后对累计到这个点的总距离矩阵dis中。最后求距离矩阵的最小值。 </p>
<p>此题难点在于-1的情况，也就是一个点不能到达其中一个building或者是这个building不能到达的点。所以要再用一个矩阵house_count来记录每一个点能到达的大厦数。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>-1的情况，用一个矩阵house_count来记录每一个点能到达的大厦数。  </li>
<li>用常数记录矩阵长和宽，不用x &gt;= len(grid) or y &gt;= len(grid[0]), 否则会TLE</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">	dis = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	house_count = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	total_houses = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">				self.bfs(grid, i, j, dis, house_count)</span><br><span class="line">				total_houses += <span class="number">1</span></span><br><span class="line">	min_dis = float(<span class="string">'inf'</span>) <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dis)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(dis[<span class="number">0</span>])):</span><br><span class="line">			<span class="keyword">if</span> dis[i][j] &gt; <span class="number">0</span> <span class="keyword">and</span> house_count[i][j] == total_houses:</span><br><span class="line">				min_dis = min(min_dis, dis[i][j])</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> min_dis == float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_dis <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, start_x, start_y, dis, house_count)</span>:</span></span><br><span class="line">	h = len(grid)</span><br><span class="line">	w = len(grid[<span class="number">0</span>]) <span class="comment"># remember otherwise TLE</span></span><br><span class="line">	queue = collections.deque([(start_x, start_y, <span class="number">0</span>)])</span><br><span class="line">	visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">	visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">			x, y = node[<span class="number">0</span>] + _dx, node[<span class="number">1</span>] + _dy</span><br><span class="line">			<span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= h <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= w <span class="keyword">or</span> grid[x][y] != <span class="number">0</span> <span class="keyword">or</span> visited[x][y]:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((x, y, node[<span class="number">2</span>] + <span class="number">1</span>))</span><br><span class="line">			visited[x][y] = <span class="keyword">True</span></span><br><span class="line">			dis[x][y] += node[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">			house_count[x][y] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm * nm)</code>，空间复杂度<code>O(nm)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Matrix</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 328 Odd Even Linked List</title>
    <url>/2022/01/23/leetcode-328-odd-even-linked-list/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.<br><br>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.<br><br>Note that the relative order inside both the even and odd groups should remain as it was in the input.<br><br>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,3,4,5]<br><strong>Output:</strong> [1,3,5,2,4]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [2,1,3,5,6,4,7]<br><strong>Output:</strong> [2,3,6,7,1,5,4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n ==</code>number of nodes in the linked list
</em>   <code>0 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>重排LL， 先偶位再奇位</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>LL四点注意事项： 删除节点.next = None</li>
<li>空输入特别处理</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> head: <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	odd_head = ListNode(<span class="number">0</span>)</span><br><span class="line">	it, it_odd = head, odd_head</span><br><span class="line">	<span class="keyword">while</span> it.next:</span><br><span class="line">		it_odd.next = it.next</span><br><span class="line">		it.next = it.next.next</span><br><span class="line">		<span class="keyword">if</span> it.next:</span><br><span class="line">			it = it.next</span><br><span class="line">		it_odd = it_odd.next</span><br><span class="line">		it_odd.next = <span class="keyword">None</span> <span class="comment"># remember</span></span><br><span class="line">	it.next = odd_head.next</span><br><span class="line">	<span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 340 Longest Substring with At Most K Distinct Characters</title>
    <url>/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>that contains at most</em> <code>k</code> <em><strong>distinct</strong> characters</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “eceba”, k = 2<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The substring is “ece” with length 3.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aa”, k = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The substring is “aa” with length 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>0 &lt;= k &lt;= 50`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最长子串，它含有最多k种字符</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同向双指针，属于最长串类型</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>while条件中，反计算char_to_count，还要pop key</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">	char_to_count, left, max_len = collections.defaultdict(int), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		char_to_count[char] += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> len(char_to_count) &gt; k:</span><br><span class="line">			char_to_count[s[left]] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> char_to_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">				char_to_count.pop(s[left])</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		max_len = max(max_len, i - left + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 337 House Robber III</title>
    <url>/2022/01/24/leetcode-337-house-robber-iii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.<br><br>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.<br><br>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,2,3,null,3,null,1]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,4,5,1,3,null,1]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.
</em>   <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树，相隔一层投，求最大值</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>多状态DP。返回值为，第一个是以root为结尾的最大值，第二个为儿子层总和的最大值。</p>
<p>与LeetCode 309 Best Time to Buy and Sell Stock with Cooldown相似</p>
<h3 id="DFS解题步骤："><a href="#DFS解题步骤：" class="headerlink" title="DFS解题步骤："></a><strong>DFS解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>以儿子层的前n最大值 = max(left) + max(right)</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	res = self.dfs2(root)</span><br><span class="line">	<span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	left = self.dfs2(root.left)</span><br><span class="line">	right = self.dfs2(root.right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>], max(left) + max(right)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="记忆法搜索算法II解题思路："><a href="#记忆法搜索算法II解题思路：" class="headerlink" title="记忆法搜索算法II解题思路："></a><strong>记忆法搜索算法II解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) = root.val + g(root.left) + g(root.right)  </span><br><span class="line">g(n) = max(f(root.left), g(root.left)) + max(f(root.right), g(root.right))</span><br></pre></td></tr></table></figure></p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	f, g = &#123;&#125;, &#123;&#125;</span><br><span class="line">	res = self.dfs(root, f, g)</span><br><span class="line">	<span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, f, g)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">		f[root.left], g[root.left] = self.dfs(root.left, f, g)</span><br><span class="line">	<span class="keyword">if</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">		f[root.right], g[root.right] = self.dfs(root.right, f, g)</span><br><span class="line">	f[root] = root.val + g[root.left] + g[root.right]</span><br><span class="line">	g[root] = max(f[root.left], g[root.left]) + max(f[root.right], g[root.right])</span><br><span class="line">	<span class="keyword">return</span> f[root], g[root]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 346 Moving Average from Data Stream</title>
    <url>/2022/01/24/leetcode-346-moving-average-from-data-stream/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/moving-average-from-data-stream/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.<br><br>Implement the <code>MovingAverage</code> class:<br><br><em>   <code>MovingAverage(int size)</code> Initializes the object with the size of the window <code>size</code>.
</em>   <code>double next(int val)</code> Returns the moving average of the last <code>size</code> values of the stream.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MovingAverage”, “next”, “next”, “next”, “next”]<br>[[3], [1], [10], [3], [5]]<br><strong>Output</strong><br>[null, 1.0, 5.5, 4.66667, 6.0]<br><br><strong>Explanation</strong><br>MovingAverage movingAverage = new MovingAverage(3);<br>movingAverage.next(1); // return 1.0 = 1 / 1<br>movingAverage.next(10); // return 5.5 = (1 + 10) / 2<br>movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3<br>movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= size &lt;= 1000</code>
</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>next</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求data stream特定窗口的平均数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>结构上跟LRU cache类似</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用queue</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size: int)</span>:</span></span><br><span class="line">	self.queue = collections.deque()</span><br><span class="line">	self.size = size</span><br><span class="line">	self.sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, val: int)</span> -&gt; float:</span></span><br><span class="line">	<span class="keyword">if</span> len(self.queue) &lt; self.size:</span><br><span class="line">		self.queue.append(val)</span><br><span class="line">		self.sum += val</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		n = self.queue.popleft()</span><br><span class="line">		self.sum -= n</span><br><span class="line">		self.queue.append(val)</span><br><span class="line">		self.sum += val</span><br><span class="line">	<span class="keyword">return</span> self.sum / len(self.queue)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 348 Design Tic-Tac-Toe</title>
    <url>/2022/01/23/leetcode-348-design-tic-tac-toe/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-tic-tac-toe/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Assume the following rules are for the tic-tac-toe game on an <code>n x n</code> board between two players:<br><br>1.  A move is guaranteed to be valid and is placed on an empty block.<br>2.  Once a winning condition is reached, no more moves are allowed.<br>3.  A player who succeeds in placing <code>n</code> of their marks in a horizontal, vertical, or diagonal row wins the game.<br><br>Implement the <code>TicTacToe</code> class:<br><br><em>   <code>TicTacToe(int n)</code> Initializes the object the size of the board <code>n</code>.
</em>   <code>int move(int row, int col, int player)</code> Indicates that the player with id <code>player</code> plays at the cell <code>(row, col)</code> of the board. The move is guaranteed to be a valid move.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“TicTacToe”, “move”, “move”, “move”, “move”, “move”, “move”, “move”]<br>[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]<br><strong>Output</strong><br>[null, 0, 0, 0, 0, 0, 0, 1]<br><br><strong>Explanation</strong><br>TicTacToe ticTacToe = new TicTacToe(3);<br>Assume that player 1 is “X” and player 2 is “O” in the board.<br>ticTacToe.move(0, 0, 1); // return 0 (no one wins)<br>|X| | |<br>| | | |    // Player 1 makes a move at (0, 0).<br>| | | |<br><br>ticTacToe.move(0, 2, 2); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 2 makes a move at (0, 2).<br>| | | |<br><br>ticTacToe.move(2, 2, 1); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 1 makes a move at (2, 2).<br>| | |X|<br><br>ticTacToe.move(1, 1, 2); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 2 makes a move at (1, 1).<br>| | |X|<br><br>ticTacToe.move(2, 0, 1); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 1 makes a move at (2, 0).<br>|X| |X|<br><br>ticTacToe.move(1, 0, 2); // return 0 (no one wins)<br>|X| |O|<br>|O|O| |    // Player 2 makes a move at (1, 0).<br>|X| |X|<br><br>ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)<br>|X| |O|<br>|O|O| |    // Player 1 makes a move at (2, 1).<br>|X|X|X|<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 100</code>
</em>   player is <code>1</code> or <code>2</code>.<br><em>   <code>0 &lt;= row, col &lt; n</code>
</em>   <code>(row, col)</code> are <strong>unique</strong> for each different call to <code>move</code>.<br><em>   At most <code>n&lt;sup&gt;2&lt;/sup&gt;</code> calls will be made to <code>move</code>.<br><br><em>*Follow-up:</em></em> Could you do better than <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> per <code>move()</code> operation?<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计井字过三关</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>游戏题。最重要是是数据结构，类似于LeetCode 051 N-Queens和LeetCode 037 Sudoku Solver用matrix记录每行，每列，对角线和反对角线的和。这样验证时候只需要O(1). </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>对角线和反对角线只有一条，所以要先判断move的这个点是否在对角线上。</li>
<li>由于用-1来代表某一个player，所以判断和时候，用abs</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.board_len = n</span><br><span class="line">        self.row = [<span class="number">0</span>] * n</span><br><span class="line">        self.col = [<span class="number">0</span>] * n</span><br><span class="line">        self.diag = <span class="number">0</span></span><br><span class="line">        self.anti_diag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, row: int, col: int, player: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> player == <span class="number">2</span>:</span><br><span class="line">            player = <span class="number">-1</span></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="keyword">if</span> row == col: <span class="comment"># remember</span></span><br><span class="line">            self.diag += player</span><br><span class="line">        <span class="keyword">if</span> row == self.board_len - <span class="number">1</span> - col:</span><br><span class="line">            self.anti_diag += player</span><br><span class="line">        does_win = abs(self.row[row]) == self.board_len <span class="keyword">or</span> abs(self.col[col]) == self.board_len <span class="keyword">or</span> \</span><br><span class="line">                abs(self.diag) == self.board_len <span class="keyword">or</span> abs(self.anti_diag) == self.board_len <span class="comment"># remember abs</span></span><br><span class="line">        <span class="keyword">if</span> does_win:</span><br><span class="line">            <span class="keyword">if</span> player == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> player</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>move时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 351 Android Unlock Patterns</title>
    <url>/2022/02/13/leetcode-351-android-unlock-patterns/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/android-unlock-patterns" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Android devices have a special lock screen with a <code>3 x 3</code> grid of dots. Users can set an “unlock pattern” by connecting the dots in a specific sequence, forming a series of joined line segments where each segment’s endpoints are two consecutive dots in the sequence. A sequence of <code>k</code> dots is a <strong>valid</strong> unlock pattern if both of the following are true:<br><br><em>   All the dots in the sequence are <strong>distinct</strong>.
</em>   If the line segment connecting two consecutive dots in the sequence passes through the <strong>center</strong> of any other dot, the other dot <strong>must have previously appeared</strong> in the sequence. No jumps through the center non-selected dots are allowed.<br>    <em>   For example, connecting dots <code>2</code> and <code>9</code> without dots <code>5</code> or <code>6</code> appearing beforehand is valid because the line from dot <code>2</code> to dot <code>9</code> does not pass through the center of either dot <code>5</code> or <code>6</code>.
    </em>   However, connecting dots <code>1</code> and <code>3</code> without dot <code>2</code> appearing beforehand is invalid because the line from dot <code>1</code> to dot <code>3</code> passes through the center of dot <code>2</code>.<br><br>Here are some example valid and invalid unlock patterns:<br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png" alt=""><br><br><em>   The 1st pattern <code>[4,1,3,6]</code> is invalid because the line connecting dots <code>1</code> and <code>3</code> pass through dot <code>2</code>, but dot <code>2</code> did not previously appear in the sequence.
</em>   The 2nd pattern <code>[4,1,9,2]</code> is invalid because the line connecting dots <code>1</code> and <code>9</code> pass through dot <code>5</code>, but dot <code>5</code> did not previously appear in the sequence.<br><em>   The 3rd pattern <code>[2,4,1,3,6]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>3</code> meets the condition because dot <code>2</code> previously appeared in the sequence.
</em>   The 4th pattern <code>[6,5,4,1,9,2]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>9</code> meets the condition because dot <code>5</code> previously appeared in the sequence.<br><br>Given two integers <code>m</code> and <code>n</code>, return <em>the <strong>number of unique and valid unlock patterns</strong> of the Android grid lock screen that consist of <strong>at least</strong></em> <code>m</code> <em>keys and <strong>at most</strong></em> <code>n</code> <em>keys.</em><br><br>Two unlock patterns are considered <strong>unique</strong> if there is a dot in one sequence that is not in the other, or the order of the dots is different.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 1<br><strong>Output:</strong> 9<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 2<br><strong>Output:</strong> 65<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= m, n &lt;= 9</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>安卓开屏密码解锁种数。给定m, n是安卓的密码长度范围，求这个范围内的解码种数。1可以跳到2和4, 5, 6, 8(斜线没有通过其他数字)，但不能跳到3, 7, 9因为前提条件是这条线通过的数如2, 4, 5必须已经用过了。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题属于填位法，带条件的，条件在于map中，类似于LeetCode 248 Strobogrammatic Number III<br>难点是理解jump keys，有16种<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip[1][3] = skip[3][1] = 2;</span><br><span class="line">skip[1][7] = skip[7][1] = 4;</span><br><span class="line">skip[3][9] = skip[9][3] = 6;</span><br><span class="line">skip[7][9] = skip[9][7] = 8;</span><br><span class="line">skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>用DFS模板: def dfs(self, graph, start, visited, res), start = num</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>Line 9有return，所以要去掉刚加入的visited的num</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JUMP_KEYS = &#123;(<span class="number">1</span>,<span class="number">3</span>):<span class="number">2</span>, (<span class="number">1</span>,<span class="number">7</span>):<span class="number">4</span>, (<span class="number">1</span>,<span class="number">9</span>):<span class="number">5</span>, (<span class="number">2</span>,<span class="number">8</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">7</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">1</span>):<span class="number">2</span>, (<span class="number">3</span>,<span class="number">9</span>):<span class="number">6</span>, (<span class="number">4</span>,<span class="number">6</span>):<span class="number">5</span>, (<span class="number">6</span>,<span class="number">4</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">1</span>):<span class="number">4</span>, (<span class="number">7</span>,<span class="number">3</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">9</span>):<span class="number">8</span>, (<span class="number">8</span>,<span class="number">2</span>):<span class="number">5</span>, (<span class="number">9</span>,<span class="number">7</span>):<span class="number">8</span>, (<span class="number">9</span>,<span class="number">3</span>):<span class="number">6</span>, (<span class="number">9</span>,<span class="number">1</span>):<span class="number">5</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, m, n, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited.add(num)</span><br><span class="line">        <span class="keyword">if</span> len(visited) == n:</span><br><span class="line">            visited.remove(num) <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) &gt;= m:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> next_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> (num, next_num) <span class="keyword">in</span> JUMP_KEYS <span class="keyword">and</span> JUMP_KEYS[(num, next_num)] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += self.dfs(next_num, m, n, visited)</span><br><span class="line">        visited.remove(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 因为最多是9乘以8乘以7…  </p>
]]></content>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 359 Logger Rate Limiter</title>
    <url>/2022/01/25/leetcode-359-logger-rate-limiter/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/logger-rate-limiter/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a logger system that receives a stream of messages along with their timestamps. Each <strong>unique</strong> message should only be printed <strong>at most every 10 seconds</strong> (i.e. a message printed at timestamp <code>t</code> will prevent other identical messages from being printed until timestamp <code>t + 10</code>).<br><br>All messages will come in chronological order. Several messages may arrive at the same timestamp.<br><br>Implement the <code>Logger</code> class:<br><br><em>   <code>Logger()</code> Initializes the <code>logger</code> object.
</em>   <code>bool shouldPrintMessage(int timestamp, string message)</code> Returns <code>true</code> if the <code>message</code> should be printed in the given <code>timestamp</code>, otherwise returns <code>false</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Logger”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”]<br>[[], [1, “foo”], [2, “bar”], [3, “foo”], [8, “bar”], [10, “foo”], [11, “foo”]]<br><strong>Output</strong><br>[null, true, true, false, false, false, true]<br><br><strong>Explanation</strong><br>Logger logger = new Logger();<br>logger.shouldPrintMessage(1, “foo”);  // return true, next allowed timestamp for “foo” is 1 + 10 = 11<br>logger.shouldPrintMessage(2, “bar”);  // return true, next allowed timestamp for “bar” is 2 + 10 = 12<br>logger.shouldPrintMessage(3, “foo”);  // 3 &lt; 11, return false<br>logger.shouldPrintMessage(8, “bar”);  // 8 &lt; 12, return false<br>logger.shouldPrintMessage(10, “foo”); // 10 &lt; 11, return false<br>logger.shouldPrintMessage(11, “foo”); // 11 &gt;= 11, return true, next allowed timestamp for “foo” is 11 + 10 = 21<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= timestamp &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code>
</em>   Every <code>timestamp</code> will be passed in non-decreasing order (chronological order).<br><em>   <code>1 &lt;= message.length &lt;= 30</code>
</em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>shouldPrintMessage</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现Logger打印的rate limiter</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>题不难，但有实际意义</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>shouldPrintMessage只有返回True时候才记录时间点。否则不记录。这属于<strong>元素相等的test case</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.throttle_interval = <span class="number">10</span></span><br><span class="line">        self.msg_to_timestamp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldPrintMessage</span><span class="params">(self, timestamp: int, message: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">in</span> self.msg_to_timestamp <span class="keyword">and</span> timestamp - self.msg_to_timestamp[message] &lt; self.throttle_interval:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.msg_to_timestamp[message] = timestamp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Hash Table</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 364 Nested List Weight Sum II</title>
    <url>/2022/01/26/leetcode-364-nested-list-weight-sum-ii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.<br><br>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer’s value set to its <strong>depth</strong>. Let <code>maxDepth</code> be the <strong>maximum depth</strong> of any integer.<br><br>The <strong>weight</strong> of an integer is <code>maxDepth - (the depth of the integer) + 1</code>.<br><br>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>weight</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex1.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> Four 1’s with a weight of 1, one 2 with a weight of 2.<br>1<em>1 + 1</em>1 + 2<em>2 + 1</em>1 + 1<em>1 = 8<br></em></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex2.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [1,[4,[6]]]<br><strong>Output:</strong> 17<br><strong>Explanation:</strong> One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.<br>13 + 4<em>2 + 6</em>1 = 17<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nestedList.length &lt;= 50</code>
</em>   The values of the integers in the nested list is in the range <code>[-100, 100]</code>.<br><em>   The maximum <em>*depth</em></em> of any integer is less than or equal to <code>50</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求NestedInteger的和。越浅，权重越高</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS按层遍历。此题类似于LeetCode 339 Nested List Weight Sum。归纳成更一般的方法：因为权重只与第几层有关。所以先求每一层的和，存到sums里面，再按照题目要求每个和乘以相应的权重求和。</p>
<p>Nested List题目：<br>LeetCode 341 Flatten Nested List Iterator Iterator - Stack<br>LeetCode 339 Nested List Weight Sum - BFS<br>LeetCode 364 Nested List Weight Sum II - BFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>queue.extend(node.getList())将节点的儿子节点即node.getList()放入queue</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSumInverse</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">	queue = collections.deque(nestedList)</span><br><span class="line">	sums, max_depth, res = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		layer_sum = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">			node = queue.popleft()</span><br><span class="line">			<span class="keyword">if</span> node.isInteger():</span><br><span class="line">				layer_sum += node.getInteger()</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line">		sums.append(layer_sum)</span><br><span class="line">		max_depth += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(sums):</span><br><span class="line">		res += n * (max_depth - i)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>, k为每层最多节点数 + 最大层数  </p>
]]></content>
      <tags>
        <tag>LinkedIn</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 370 Range Addition</title>
    <url>/2022/01/27/leetcode-370-range-addition/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-addition/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer <code>length</code> and an array <code>updates</code> where <code>updates[i] = [startIdx&lt;sub&gt;i&lt;/sub&gt;, endIdx&lt;sub&gt;i&lt;/sub&gt;, inc&lt;sub&gt;i&lt;/sub&gt;]</code>.<br><br>You have an array <code>arr</code> of length <code>length</code> with all zeros, and you have some operation to apply on <code>arr</code>. In the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> operation, you should increment all the elements <code>arr[startIdx&lt;sub&gt;i&lt;/sub&gt;], arr[startIdx&lt;sub&gt;i&lt;/sub&gt; + 1], ..., arr[endIdx&lt;sub&gt;i&lt;/sub&gt;]</code> by <code>inc&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>Return <code>arr</code> <em>after applying all the</em> <code>updates</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/27/rangeadd-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]<br><strong>Output:</strong> [-2,0,3,5,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]<br><strong>Output:</strong> [0,-4,2,2,2,4,4,-4,-4,-4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code>
</em>   <code>0 &lt;= updates.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= startIdx&lt;sub&gt;i&lt;/sub&gt; &lt;= endIdx&lt;sub&gt;i&lt;/sub&gt; &lt; length</code>
</em>   <code>-1000 &lt;= inc&lt;sub&gt;i&lt;/sub&gt; &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>统一加一个数到子数组中，如此有好几个操作，求最后数组结果</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>差分数组，<strong>数加到首节点，数减在末节点 + 1，最后累加</strong></p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>数加到首节点，数减在末节点 + 1，最后累加</strong></li>
<li>端点需要累加res[li[0]] += li[2], 而不是res[li[0]] = li[2]</li>
<li>len(res)而不是len(li)</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getModifiedArray</span><span class="params">(self, length: int, updates: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">	res = [<span class="number">0</span>] * length</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> updates:</span><br><span class="line">		res[li[<span class="number">0</span>]] += li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line">		<span class="keyword">if</span> li[<span class="number">1</span>] + <span class="number">1</span> &lt; len(res): <span class="comment"># remember not len(li)</span></span><br><span class="line">			res[li[<span class="number">1</span>] + <span class="number">1</span>] += -li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">		res[i] += res[i - <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>, n, m分别为数组长度和update个数  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Citadel</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 366 Find Leaves of Binary Tree</title>
    <url>/2022/01/26/leetcode-366-find-leaves-of-binary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-leaves-of-binary-tree" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, collect a tree’s nodes as if you were doing this:<br><br><em>   Collect all the leaf nodes.
</em>   Remove all the leaf nodes.<br><em>   Repeat until the tree is empty.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5]<br><strong>Output:</strong> [[4,5,3],[2],[1]]<br>Explanation:<br>[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the tree is in the range <code>[1, 100]</code>.<br>*   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求逐层叶子剥离的所有叶子节点，按剥离顺序放入结果</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>考虑BFS从上到下，但深度不对，因为是从叶子节点开始计算的，如例子所示，根节点1的高度取决于儿子的最大深度。所以应该从底到上计算，也就是DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>从底到上计算高度，取左右树的最大高度</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">	res = []</span><br><span class="line">	self.dfs(root, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">		<span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">			res.append([root.val])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res[<span class="number">0</span>].append(root.val)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	left_depth = self.dfs(root.left, res)</span><br><span class="line">	right_depth = self.dfs(root.right, res)</span><br><span class="line">	depth = max(left_depth, right_depth) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> depth - <span class="number">1</span> &lt; len(res):</span><br><span class="line">		res[depth - <span class="number">1</span>].append(root.val)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		res.append([root.val])</span><br><span class="line">	<span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 384 Shuffle an Array</title>
    <url>/2022/01/27/leetcode-384-shuffle-an-array/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.<br><br>Implement the <code>Solution</code> class:<br><br><em>   <code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.
</em>   <code>int[] reset()</code> Resets the array to its original configuration and returns it.<br><em>   <code>int[] shuffle()</code> Returns a random shuffling of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Solution”, “shuffle”, “reset”, “shuffle”]<br>[[[1, 2, 3]], [], [], []]<br><strong>Output</strong><br>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1, 2, 3]);<br>solution.shuffle();    // Shuffle the array [1,2,3] and return its result.<br>                       // Any permutation of [1,2,3] must be equally likely to be returned.<br>                       // Example: return [3, 1, 2]<br>solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]<br>solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]<br><br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= nums.length &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code>
</em>   All the elements of <code>nums</code> are <strong>unique</strong>.<br><em>   At most `5 </em> 10<sup>4</sup><code>calls **in total** will be made to</code>reset<code>and</code>shuffle`.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>随机重排数组</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>水塘抽样法</p>
<p>先看算法，再理解，第i个元素会被交换的概率：<br>某一个元素保留概率为(n - i) / (n - i + 1)<br>某一个元素交换概率为1 / (n - i)<br>所以从左到右遍历到第i个元素时，它被交换到后面的概率为 所有前面都保留 乘以 第i轮循环时被交换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n - 1) / n * (n - 2) / (n - 1) ... (n - i) / (n - i + 1) * 1 / (n - i)</span><br></pre></td></tr></table></figure></p>
<p>前面都约了，最后等于1 / n </p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>死记算法，跟后面的元素互换</li>
<li>复制原数组以防被改</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">	self.original = list(nums)</span><br><span class="line">	self.nums = nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">return</span> list(self.original)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">		swap_idx = random.randrange(i, len(self.nums))</span><br><span class="line">		self.nums[i], self.nums[swap_idx] = self.nums[swap_idx], self.nums[i]</span><br><span class="line">	<span class="keyword">return</span> self.nums</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 408 Valid Word Abbreviation</title>
    <url>/2022/03/19/leetcode-408-valid-word-abbreviation/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-word-abbreviation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A string can be <strong>abbreviated</strong> by replacing any number of <strong>non-adjacent</strong>, <strong>non-empty</strong> substrings with their lengths. The lengths <strong>should not</strong> have leading zeros.<br><br>For example, a string such as <code>&quot;substitution&quot;</code> could be abbreviated as (but not limited to):<br><br><em>   <code>&quot;s10n&quot;</code> (<code>&quot;s &lt;u&gt;ubstitutio&lt;/u&gt; n&quot;</code>)
</em>   <code>&quot;sub4u4&quot;</code> (<code>&quot;sub &lt;u&gt;stit&lt;/u&gt; u &lt;u&gt;tion&lt;/u&gt;&quot;</code>)<br><em>   <code>&quot;12&quot;</code> (<code>&quot;&lt;u&gt;substitution&lt;/u&gt;&quot;</code>)
</em>   <code>&quot;su3i1u2on&quot;</code> (<code>&quot;su &lt;u&gt;bst&lt;/u&gt; i &lt;u&gt;t&lt;/u&gt; u &lt;u&gt;ti&lt;/u&gt; on&quot;</code>)<br><em>   <code>&quot;substitution&quot;</code> (no substrings replaced)<br><br>The following are <strong>not valid</strong> abbreviations:

</em>   <code>&quot;s55n&quot;</code> (<code>&quot;s &lt;u&gt;ubsti&lt;/u&gt; &lt;u&gt;tutio&lt;/u&gt; n&quot;</code>, the replaced substrings are adjacent)<br><em>   <code>&quot;s010n&quot;</code> (has leading zeros)
</em>   <code>&quot;s0ubstitution&quot;</code> (replaces an empty substring)<br><br>Given a string <code>word</code> and an abbreviation <code>abbr</code>, return <em>whether the string <strong>matches</strong> the given abbreviation</em>.<br><br>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> word = “internationalization”, abbr = “i12iz4n”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The word “internationalization” can be abbreviated as “i12iz4n” (“i <u>nternational</u> iz <u>atio</u> n”).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> word = “apple”, abbr = “a2e”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The word “apple” cannot be abbreviated as “a2e”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= word.length &lt;= 20</code>
</em>   <code>word</code> consists of only lowercase English letters.<br><em>   <code>1 &lt;= abbr.length &lt;= 10</code>
</em>   <code>abbr</code> consists of lowercase English letters and digits.<br>*   All the integers in <code>abbr</code> will fit in a 32-bit integer.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>验证第二字符串是否第一字符串的一个种简写形式，用数字代替字符串部分长度</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用内外while循环如quicksort的不推荐的算法，<strong>内循环的条件一定要复制外循环的条件</strong>j &lt; len(abbr)</li>
<li>题目条件不能含前缀0，包括0本身，若数字第一位为0，就返回False</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validWordAbbreviation</span><span class="params">(self, word: str, abbr: str)</span> -&gt; bool:</span></span><br><span class="line">	i, j, num = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(word) <span class="keyword">and</span> j &lt; len(abbr):</span><br><span class="line">		num_str = <span class="string">''</span></span><br><span class="line">		<span class="keyword">while</span> j &lt; len(abbr) <span class="keyword">and</span> abbr[j].isdigit(): <span class="comment"># remember j &lt; len(abbr)</span></span><br><span class="line">			num_str += abbr[j]</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> num_str:</span><br><span class="line">			<span class="keyword">if</span> num_str[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			i += int(num_str)</span><br><span class="line">		<span class="keyword">elif</span> word[i] != abbr[j]:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> i != len(word) <span class="keyword">or</span> j != len(abbr) <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 399 Evaluate Division</title>
    <url>/2022/01/27/leetcode-399-evaluate-division/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;]</code> and <code>values[i]</code> represent the equation <code>A&lt;sub&gt;i&lt;/sub&gt; / B&lt;sub&gt;i&lt;/sub&gt; = values[i]</code>. Each <code>A&lt;sub&gt;i&lt;/sub&gt;</code> or <code>B&lt;sub&gt;i&lt;/sub&gt;</code> is a string that represents a single variable.<br><br>You are also given some <code>queries</code>, where <code>queries[j] = [C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;]</code> represents the <code>j&lt;sup&gt;th&lt;/sup&gt;</code> query where you must find the answer for <code>C&lt;sub&gt;j&lt;/sub&gt; / D&lt;sub&gt;j&lt;/sub&gt; = ?</code>.<br><br>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.<br><br><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br><strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]<br><strong>Explanation:</strong><br>Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em><br>queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em><br>return: [6.0, 0.5, -1.0, 1.0, -1.0 ]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br><strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br><strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= equations.length &lt;= 20</code>
</em>   <code>equations[i].length == 2</code><br><em>   <code>1 &lt;= A&lt;sub&gt;i&lt;/sub&gt;.length, B&lt;sub&gt;i&lt;/sub&gt;.length &lt;= 5</code>
</em>   <code>values.length == equations.length</code><br><em>   <code>0.0 &lt; values[i] &lt;= 20.0</code>
</em>   <code>1 &lt;= queries.length &lt;= 20</code><br><em>   <code>queries[i].length == 2</code>
</em>   <code>1 &lt;= C&lt;sub&gt;j&lt;/sub&gt;.length, D&lt;sub&gt;j&lt;/sub&gt;.length &lt;= 5</code><br>*   <code>A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;, C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;</code> consist of lower case English letters and digits.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据已知除法结果求其他除法表达式</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是G家的面试题。图问题，因为每个除法式相乘可以得到query所要的，所以属于图问题。可以用BFS来遍历图，如已知a/b = 2, b/c = 3, 需要知道a/c, 就是2 x 3，所以只要从a开始， c为BFS的target，迭代时不断相乘</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>核心思想： BFS来遍历图，迭代时不断相乘。<strong>无向图</strong>，因为a/c也可以c/a.</li>
<li>BFS的注意事项后两个：BFS无解时候不存在的时候返回-1</li>
<li>两种edge cases： 若query中任意元素不在图中，返回-1(题目要求), 若元素相等，返回1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(equations):</span><br><span class="line">		graph[li[<span class="number">0</span>]].append((li[<span class="number">1</span>], values[i]))</span><br><span class="line">		graph[li[<span class="number">1</span>]].append((li[<span class="number">0</span>], <span class="number">1</span> / values[i])) <span class="comment"># remember it is an undirected graph</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">		<span class="keyword">if</span> query[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph <span class="keyword">or</span> query[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">			res.append(<span class="number">-1.0</span>)</span><br><span class="line">		<span class="keyword">elif</span> query[<span class="number">0</span>] <span class="keyword">in</span> graph <span class="keyword">and</span> query[<span class="number">0</span>] == query[<span class="number">1</span>]:</span><br><span class="line">			res.append(<span class="number">1.0</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			val = self.bfs(graph, query)</span><br><span class="line">			res.append(val)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, query)</span>:</span></span><br><span class="line">	queue = collections.deque([(query[<span class="number">0</span>], <span class="number">1</span>)])</span><br><span class="line">	visited = set([queue[<span class="number">0</span>]])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node, parent_val = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == query[<span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">return</span> parent_val</span><br><span class="line">		<span class="keyword">for</span> neighbor, val <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append((neighbor, parent_val * val))</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(（V + E) * m)</code>，空间复杂度<code>O(E)</code>, m为query数  </p>
]]></content>
      <tags>
        <tag>Breadth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 426 Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <url>/2022/03/19/leetcode-426-convert-binary-search-tree-to-sorted-doubly-linked-list/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Convert a <strong>Binary Search Tree</strong> to a sorted <strong>Circular Doubly-Linked List</strong> in place.<br><br>You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br><br>We want to do the transformation <strong>in place</strong>. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt=""><br><br><pre><strong>Input:</strong> root = [4,2,5,1,3]<br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt=""><br><strong>Output:</strong> [1,2,3,4,5]<br><br><strong>Explanation:</strong> The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png" alt=""><br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> [1,2,3]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 2000]</code>.
</em>   <code>-1000 &lt;= Node.val &lt;= 1000</code><br><em>   All the values of the tree are <em>*unique</em></em>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将二叉树变成双向链表，left为父节点，right为儿子节点</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 114 Flatten Binary Tree to Linked List，先假设左右儿子，已经是双向LL，下面就是将root这个节点插入到两个LL之间其将它们首尾相连</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>要将左右儿子节点的LL，首尾相连。首尾节点获得要在if语句前，因为右儿子的left会连到root，就找不到它的尾部。首尾相连要发生在最后。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">		root.left, root.right = root, root</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	left_head = self.treeToDoublyList(root.left)</span><br><span class="line">	right_head = self.treeToDoublyList(root.right)</span><br><span class="line">	<span class="comment"># remember this part and order, can't be placed after ifs</span></span><br><span class="line">	new_head = left_head <span class="keyword">if</span> left_head <span class="keyword">else</span> root</span><br><span class="line">	new_tail = right_head.left <span class="keyword">if</span> right_head <span class="keyword">else</span> root</span><br><span class="line">	<span class="keyword">if</span> left_head:</span><br><span class="line">		left_head.left.right, root.left = root, left_head.left</span><br><span class="line">	<span class="keyword">if</span> right_head:</span><br><span class="line">		root.right, right_head.left = right_head, root</span><br><span class="line">	new_head.left, new_tail.right = new_tail, new_head</span><br><span class="line">	<span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 432 All O one Data Structure</title>
    <url>/2022/02/24/leetcode-432-all-oone-data-structure/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a data structure to store the strings’ count with the ability to return the strings with minimum and maximum counts.<br><br>Implement the <code>AllOne</code> class:<br><br><em>   <code>AllOne()</code> Initializes the object of the data structure.
</em>   <code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.<br><em>   <code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.
</em>   <code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><em>   <code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“AllOne”, “inc”, “inc”, “getMaxKey”, “getMinKey”, “inc”, “getMaxKey”, “getMinKey”]<br>[[], [“hello”], [“hello”], [], [], [“leet”], [], []]<br><strong>Output</strong><br>[null, null, null, “hello”, “hello”, null, “hello”, “leet”]<br><br><strong>Explanation</strong><br>AllOne allOne = new AllOne();<br>allOne.inc(“hello”);<br>allOne.inc(“hello”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “hello”<br>allOne.inc(“leet”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “leet”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= key.length &lt;= 10</code><br><em>   <code>key</code> consists of lowercase English letters.
</em>   It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.<br><em>   At most `5 </em> 10<sup>4</sup><code>calls will be made to</code>inc<code>,</code>dec<code>,</code>getMaxKey<code>, and</code>getMinKey`.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构，使其支持增加或减少一个单词的频数，最大或最小单词的频数。注意最小频数不能为0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这个频数有点似LRU的分层思路，加入self.max_freq, 其他操作都可以实现，但是dec操作不能达到O(1), 因为若某个最小频数单词从1变成0，需要检索频率到下一个有节点的层。<br>改进就是要将频率的的值连起来，所以参考LRU，map的key是频率，value是node，node中含有freq，形成一个环。而node含有该频率对应的单词set，inc/dec就是将单词移动另一个node中</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>与LRU区别: map的key是频率，node含有频率和单词set，数据结构加入key_to_count。LL是从最大频率到最小频率</li>
<li>inc操作将节点从原频率node移到下一个频率node，若新node不存在，调用append_before. 然后从原频率node的单词set中删除该单词，若set为空，删除此node以及map中的entry</li>
<li>dec与inc类似，但要注意频率变成0的情况：不移到新的node，且从key_to_count中删除该单词</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.freq_to_node = &#123;&#125;</span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line">        self.key_to_count = collections.defaultdict(int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.tail</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">            self.freq_to_node[count] = self.append_before(old_node)</span><br><span class="line">        new_node = self.freq_to_node[count]</span><br><span class="line">        new_node.key_set.add(key)</span><br><span class="line">        self.key_to_count[key] = count</span><br><span class="line"></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.head</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">                self.freq_to_node[count] = self.append_after(old_node)</span><br><span class="line">            new_node = self.freq_to_node[count]</span><br><span class="line">            new_node.key_set.add(key)</span><br><span class="line">            self.key_to_count[key] = count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.key_to_count.pop(key)</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.tail <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.head <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_before</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq + <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node.prev, node</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_after</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq - <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node, node.next</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, freq=<span class="number">0</span>, next=None, prev=None)</span>:</span></span><br><span class="line">        self.key_set = set()</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Linked List</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 438 Find All Anagrams in a String</title>
    <url>/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of</em> <code>p</code><em>‘s anagrams in</em> <code>s</code>. You may return the answer in <strong>any order</strong>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “cbaebabacd”, p = “abc”<br><strong>Output:</strong> [0,6]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abab”, p = “ab”<br><strong>Output:</strong> [0,1,2]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, p.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>s<code>and</code>p` consist of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s中含p的anagram的所有初始下标</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求某子串的频率统计，第一时间想到滑动窗口。此题较特殊，属于固定大小窗口的滑动窗口，因为p的大小是固定的，窗口大小必须和p长度一样。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">	char_to_count_p = collections.Counter(p)</span><br><span class="line">	substr_win = collections.defaultdict(int)</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">		substr_win[s[i]] += <span class="number">1</span></span><br><span class="line">		<span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= len(p):</span><br><span class="line">			substr_win[s[i - len(p)]] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> substr_win[s[i - len(p)]] == <span class="number">0</span>:</span><br><span class="line">				substr_win.pop(s[i - len(p)])</span><br><span class="line">		<span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line">			res.append(i - len(p) + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 498 Diagonal Traverse</title>
    <url>/2022/02/12/leetcode-498-diagonal-traverse/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]<br><strong>Output:</strong> [1,2,4,7,5,3,6,8,9]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> mat = [[1,2],[3,4]]<br><strong>Output:</strong> [1,2,3,4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == mat.length</code>
</em>   <code>n == mat[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= mat[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按类对角线梅花间竹地遍历每个元素，输出最后结果</p>
<h3 id="找规律解题思路："><a href="#找规律解题思路：" class="headerlink" title="找规律解题思路："></a><strong>找规律解题思路：</strong></h3><p>边界条件很难找，而且每一层的结束点也和矩阵的长度或宽度有关。先找规律，可以看出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每层的所有元素下标和相等</span><br></pre></td></tr></table></figure></p>
<p>正常从左到右从上到下遍历矩阵，用一个dict来每层的每一个数，可以看出这些数的顺序都是按题目要求的，只不过是正序或逆序，所以最后按照奇偶决定是否正序或逆序加入到结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>从左到右从上到下遍历矩阵，dict[i + j]来加入每层的每一个数</li>
<li>dict的key的范围容易得知，按照奇偶决定是否正序或逆序加入到结果</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>dict[i + j]来加入每层的每一个数</li>
<li>dict的key的最大值为len(mat) + len(mat[0]) - 1</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, mat: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">	groups = collections.defaultdict(list)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(mat[<span class="number">0</span>])):</span><br><span class="line">			groups[i + j].append(mat[i][j])</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat) + len(mat[<span class="number">0</span>]) - <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">			res.extend(groups[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.extend(groups[i][::<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>
<hr>
<h3 id="按题意II解题思路："><a href="#按题意II解题思路：" class="headerlink" title="按题意II解题思路："></a><strong>按题意II解题思路：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_diagnals</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    is_reversed = <span class="keyword">True</span></span><br><span class="line">    <span class="comment"># all diagnal starting from top row</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">        diag_row, diag_col = <span class="number">0</span>, col</span><br><span class="line">        one_print = []</span><br><span class="line">        <span class="keyword">while</span> diag_row &lt; len(matrix) <span class="keyword">and</span> diag_col &gt;= <span class="number">0</span>:</span><br><span class="line">            one_print.append(matrix[diag_row][diag_col])</span><br><span class="line">            diag_row += <span class="number">1</span></span><br><span class="line">            diag_col -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_reversed:</span><br><span class="line">            res.extend(one_print[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.extend(one_print)</span><br><span class="line">        is_reversed = <span class="keyword">not</span> is_reversed</span><br><span class="line">    <span class="comment"># diagnal start rightmost columns</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">        diag_row, diag_col = row, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        one_print = []</span><br><span class="line">        <span class="keyword">while</span> diag_row &lt; len(matrix) <span class="keyword">and</span> diag_col &gt;= <span class="number">0</span>:</span><br><span class="line">            one_print.append(matrix[diag_row][diag_col])</span><br><span class="line">            diag_row += <span class="number">1</span></span><br><span class="line">            diag_col -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_reversed:</span><br><span class="line">            res.extend(one_print[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.extend(one_print)</span><br><span class="line">        is_reversed = <span class="keyword">not</span> is_reversed</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 518 Coin Change 2</title>
    <url>/2022/01/30/leetcode-518-coin-change-2/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br><br>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.<br><br>You may assume that you have an infinite number of each kind of coin.<br><br>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> amount = 5, coins = [1,2,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> amount = 3, coins = [2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> amount = 10, coins = [10]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= coins.length &lt;= 300</code>
</em>   <code>1 &lt;= coins[i] &lt;= 5000</code><br><em>   All the values of <code>coins</code> are <strong>unique</strong>.
</em>   <code>0 &lt;= amount &lt;= 5000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求兑换硬币的种数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 322 Coin Change，那题求最小个数，此题求总数，也是用DP。<br>递归式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = sum(dp[j]), i = j + coins[i]</span><br></pre></td></tr></table></figure></p>
<p>LeetCode 377 Combination Sum IV 题目基本一样，唯一区别是结果元素有序，属于排列<br>LeetCode 518 Coin Change 2 题目基本一样，唯一区别是结果元素无序，属于组合</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>递归5部曲</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>for循环顺序不能错，先coin再dp</strong>，否则会有重复计算，如dp[3] = 2 + 1和1 + 2. 字面上理解也是可以知道重复。但如果coin先的话，就只能用1的硬币，第二轮是只能用2的硬币，如此类推，显然不会重复，dp[3] = dp[2] + 1(只用硬币1), dp[1] + 2(只用硬币2) </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[j], i = j + coins[i]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">	dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)): <span class="comment"># [0, 0]</span></span><br><span class="line">			<span class="keyword">if</span> i + coin &lt;= amount:</span><br><span class="line">				dp[i + coin] += dp[i]</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*amount)</code>，空间复杂度<code>O(amount)</code>  </p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
        <tag>Citadel</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 549 Binary Tree Longest Consecutive Sequence II</title>
    <url>/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive path in the tree</em>.<br><br>A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.<br><br><em>   For example, <code>[1,2,3,4]</code> and <code>[4,3,2,1]</code> are both considered valid, but the path <code>[1,2,4,3]</code> is not valid.<br><br>On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The longest consecutive path is [1, 2] or [2, 1].<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest consecutive path is [1, 2, 3] or [3, 2, 1].<br></pre><br><br><strong>Constraints:</strong>

</em>   The number of nodes in the tree is in the range <code>[1, 3 * 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><em>   `-3 </em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup>`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求任意节点到另一个节点的最长连续数列的长度(由小到大)</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 298 Binary Tree Longest Consecutive Sequence，不过由于父亲到儿子可能递增或递减，所以DFS返回值也返回递增和递减的长度</p>
<p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p>
<p>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>DFS返回值也返回递增和递减的长度</li>
<li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># (increasing, decreasing) from root</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		inc = desc = <span class="number">1</span></span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		left = dfs(root.left)</span><br><span class="line">		right = dfs(root.right)</span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:</span><br><span class="line">			lpath += left[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right[<span class="number">0</span>]</span><br><span class="line">		inc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">		lpath = rpath = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> root.left <span class="keyword">and</span> root.val - <span class="number">1</span> == root.left.val:</span><br><span class="line">			lpath += left[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> root.right <span class="keyword">and</span> root.val - <span class="number">1</span> == root.right.val:</span><br><span class="line">			rpath += right[<span class="number">1</span>]</span><br><span class="line">		desc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">		total = inc + desc - <span class="number">1</span></span><br><span class="line">		max_len = max(inc, desc, total, max_len)</span><br><span class="line">		<span class="keyword">return</span> inc, desc</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 543 Diameter of Binary Tree</title>
    <url>/2022/02/07/leetcode-543-diameter-of-binary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.<br><br>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.<br><br>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1,2]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.
</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三种情况：自己+左，自己+右，左+右，不要漏掉最后一种</li>
<li>用nonlocal就不用定义self.max_len的全局变量</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">nonlocal</span> max_len</span><br><span class="line">		left = dfs(root.left) + <span class="number">1</span></span><br><span class="line">		right = dfs(root.right) + <span class="number">1</span></span><br><span class="line">		res = max(left, right)</span><br><span class="line">		total = left + right - <span class="number">1</span></span><br><span class="line">		max_len = max(res, total, max_len)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 567 Permutation in String</title>
    <url>/2022/02/15/leetcode-567-permutation-in-string/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> <em>if</em> <code>s2</code> <em>contains a permutation of</em> <code>s1</code><em>, or</em> <code>false</code> <em>otherwise</em>.<br><br>In other words, return <code>true</code> if one of <code>s1</code>‘s permutations is the substring of <code>s2</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidbaooo”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> s2 contains one permutation of s1 (“ba”).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidboaoo”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length, s2.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s1</code> and <code>s2</code> consist of lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s2中是否含s1的anagram</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 438 Find All Anagrams in a String, 唯一区别是substr_win == char_to_count_p时返回而不是加入到res</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">	char_to_count_p = collections.Counter(s1)</span><br><span class="line">	substr_win = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s2):</span><br><span class="line">		substr_win[s2[i]] += <span class="number">1</span></span><br><span class="line">		<span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= len(s1):</span><br><span class="line">			substr_win[s2[i - len(s1)]] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> substr_win[s2[i - len(s1)]] == <span class="number">0</span>:</span><br><span class="line">				substr_win.pop(s2[i - len(s1)])</span><br><span class="line">		<span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 628 Maximum Product of Three Numbers</title>
    <url>/2022/01/29/leetcode-628-maximum-product-of-three-numbers/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an integer array <code>nums</code>, <em>find three numbers whose product is maximum and return the maximum product</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4]<br><strong>Output:</strong> 24<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-2,-3]<br><strong>Output:</strong> -6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>3 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>-1000 &lt;= nums[i] &lt;= 1000</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组任意三个数的最大乘积</p>
<h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>数学题，正负数分开，最大只可以是排序后最大的三个数(全正，全负)或最大整数乘以最小两个负数(正负均有)</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	nums.sort()</span><br><span class="line">	<span class="keyword">return</span> max(nums[<span class="number">-1</span>] * nums[<span class="number">-2</span>] * nums[<span class="number">-3</span>], nums[<span class="number">-1</span>] * nums[<span class="number">0</span>] * nums[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="Heap算法II解题思路："><a href="#Heap算法II解题思路：" class="headerlink" title="Heap算法II解题思路："></a><strong>Heap算法II解题思路：</strong></h3><p>由上述思路进一步优化，不需要全部排序，只需要知道最大的3个数和最小的两个数即可</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line">	smallest = heapq.nsmallest(<span class="number">2</span>, nums)</span><br><span class="line">	<span class="keyword">return</span> max(largest[<span class="number">0</span>] * largest[<span class="number">1</span>] * largest[<span class="number">2</span>], largest[<span class="number">0</span>] * smallest[<span class="number">0</span>] * smallest[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 670 Maximum Swap</title>
    <url>/2022/02/15/leetcode-670-maximum-swap/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-swap/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an integer <code>num</code>. You can swap two digits at most once to get the maximum valued number.<br><br>Return <em>the maximum valued number you can get</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = 2736<br><strong>Output:</strong> 7236<br><strong>Explanation:</strong> Swap the number 2 and the number 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = 9973<br><strong>Output:</strong> 9973<br><strong>Explanation:</strong> No swap.<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>0 &lt;= num &lt;= 10&lt;sup&gt;8&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数，最多交换一位，使得这个数尽可能最大</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 854 K-Similar Strings, 如2736， 求2后面最大的数为7，和7交换即为所求。这里有两个问题：</p>
<ol>
<li>第一位可能已经是最大的数位，这样需要遍历每个数位，找到能交换的数位，若这个位在倒序排序后位置一样，表明此位不能交换。所以排序法的算法复杂度为n平方</li>
<li>若要优化就要采用bucket sort，因为数位是有限的。若后续数位有一个数比自己大，表示可交换。所以只要记录每个数位的位置，贪心法从9(最大)遍历到自己，若该位位置在自己之后，可交换</li>
<li>若不同数位上数值相同，应该记录其最后的位置，因为交换时候将小的尽量往后交换，越好越不重要，如2949, 2和最后的9交换得到最大的数</li>
</ol>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>内循环从9遍历到该位数值(不包括)</li>
<li>buckets的key为字符串，注意整数和字符串互换，如buckets[str(j)], int(digits[i])</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">	digits, buckets = str(num), collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i, digit <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">		buckets[digit] = i <span class="comment"># use last position for same char</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>, int(digits[i]), <span class="number">-1</span>): <span class="comment"># remember to use int(digits[i]) not i</span></span><br><span class="line">			<span class="keyword">if</span> buckets[str(j)] &gt; i: <span class="comment"># 2736, i = (2), j = (7) # remember to use str j</span></span><br><span class="line">				<span class="keyword">return</span> int(digits[:i] + digits[buckets[str(j)]] + digits[i + <span class="number">1</span>:buckets[str(j)]] + digits[i] + digits[buckets[str(j)] + <span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(9n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 721 Accounts Merge</title>
    <url>/2022/01/20/leetcode-721-accounts-mergesolution/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> accounts = [[“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],[“John”,”johnsmith@mail.com”,”john00@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Output:</strong> [[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Explanation:</strong><br>The first and second John’s are the same person as they have the common email “johnsmith@mail.com”.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’],<br>[‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> accounts = [[“Gabe”,”Gabe0@m.co”,”Gabe3@m.co”,”Gabe1@m.co”],[“Kevin”,”Kevin3@m.co”,”Kevin5@m.co”,”Kevin0@m.co”],[“Ethan”,”Ethan5@m.co”,”Ethan4@m.co”,”Ethan0@m.co”],[“Hanzo”,”Hanzo3@m.co”,”Hanzo1@m.co”,”Hanzo0@m.co”],[“Fern”,”Fern5@m.co”,”Fern1@m.co”,”Fern0@m.co”]]<br><strong>Output:</strong> [[“Ethan”,”Ethan0@m.co”,”Ethan4@m.co”,”Ethan5@m.co”],[“Gabe”,”Gabe0@m.co”,”Gabe1@m.co”,”Gabe3@m.co”],[“Hanzo”,”Hanzo0@m.co”,”Hanzo1@m.co”,”Hanzo3@m.co”],[“Kevin”,”Kevin0@m.co”,”Kevin3@m.co”,”Kevin5@m.co”],[“Fern”,”Fern0@m.co”,”Fern1@m.co”,”Fern5@m.co”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= accounts.length &lt;= 1000</code>
</em>   <code>2 &lt;= accounts[i].length &lt;= 10</code><br><em>   <code>1 &lt;= accounts[i][j] &lt;= 30</code>
</em>   <code>accounts[i][0]</code> consists of English letters.<br>*   <code>accounts[i][j] (for j &gt; 0)</code> is a valid email.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p>
<h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li>
<li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li>
<li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		li[:] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">	graph = collections.defaultdict(list)</span><br><span class="line">	name_dict = collections.defaultdict(str)</span><br><span class="line">	<span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">		name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">			graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">			graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">			graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">	res, visited = [], set()</span><br><span class="line">	<span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">		sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line">		<span class="keyword">if</span> sub_res:</span><br><span class="line">			res.append(sub_res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	res, name = [], <span class="string">''</span></span><br><span class="line">	queue = collections.deque([start])</span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		res.append(node)</span><br><span class="line">		<span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">			name = name_dict[node]</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			visited.add(neighbor)</span><br><span class="line">	res.sort()</span><br><span class="line">	res.insert(<span class="number">0</span>, name)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p>
<hr>
<h3 id="UnionFind算法II解题思路-不推荐-："><a href="#UnionFind算法II解题思路-不推荐-：" class="headerlink" title="UnionFind算法II解题思路(不推荐)："></a><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li>
<li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li>
<li>处理名字</li>
<li>有重复邮件</li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 770 Basic Calculator IV</title>
    <url>/2022/02/06/leetcode-770-basic-calculator-iv/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-iv/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code><br><br><em>   An expression alternates chunks and symbols, with a space separating each chunk and symbol.
</em>   A chunk is either an expression in parentheses, a variable, or a non-negative integer.<br><em>   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.<br><br>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.

</em>   For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.<br><br>The format of the output is as follows:<br><br><em>   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
    </em>   For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.<br><em>   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
    </em>   For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.<br><em>   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
</em>   An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.<br><em>   Terms (including constant terms) with coefficient <code>0</code> are not included.
    </em>   For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “e + 8 - a + 5”, evalvars = [“e”], evalints = [1]<br><strong>Output:</strong> [“-1<em>a”,”14”]<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “e - 8 + temperature - pressure”, evalvars = [“e”, “temperature”], evalints = [1, 12]<br><strong>Output:</strong> [“-1pressure”,”5”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> expression = “(e + 8) <em> (e - 8)”, evalvars = [], evalints = []<br><strong>Output:</strong> [“1</em>e<em>e”,”-64”]<br></em></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= expression.length &lt;= 250</code><br><em>   <code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, `’</em>‘<code>,</code>‘(‘<code>,</code>‘)’<code>,</code>‘ ‘<code>.
*</code>expression<code>does not contain any leading or trailing spaces.
*   All the tokens in</code>expression<code>are separated by a single space.
*</code>0 &lt;= evalvars.length &lt;= 100<code>*</code>1 &lt;= evalvars[i].length &lt;= 20<code>*</code>evalvars[i]<code>consists of lowercase English letters.
*</code>evalints.length == evalvars.length<code>*</code>-100 &lt;= evalints[i] &lt;= 100`<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>表达式含有若干变量evalvars及其对应值evalints，且含加减乘和括号，求结果。若变量不在evalvars就简化表达式</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题<strong>不需要掌握</strong>，若考到就认命好了。之前的LeetCode 224 Basic Calculator含有括号和加法已经是Hard，此题不但有括号和加减乘，还有变量，难度不止提高一个数量级。不过不可以用eval函数的条件去掉了。所以就是考察eval。<br>如果不含变量，直接调用eval即可求解  </p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="keyword">return</span> eval(expression)</span><br></pre></td></tr></table></figure>
<p>含变量且变量有值，就调用字典将变量替代掉，这里考到了regex替代函数re.sub</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s.group()</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'\w+'</span>, f, expression)</span><br><span class="line">	res = eval(converted_expr)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>由于变量可能没有值，所以核心思路是用dict进行计算，如x + 2，用集合求和{(x,): 1} + {(): 2}得到{(‘x’,): 1, (): -2}，用dict来计算及保存结果</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol>
<li>regex替代变量</li>
<li>将表达式用f包装，如(f(“x”) + f(“8”)) * (f(“x”) - f(“8”))</li>
<li>实现dict的加减乘</li>
<li>dict的计算结果转成题目所求</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span><span class="params">(Counter)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.update(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			self.subtract(other)</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">			product = MyCounter()</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">				<span class="keyword">for</span> y <span class="keyword">in</span> other:</span><br><span class="line">					xy = tuple(sorted(x + y))</span><br><span class="line">					product[xy] += self[x] * other[y]</span><br><span class="line">			<span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">	var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">		token = s</span><br><span class="line">		s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line">		<span class="keyword">return</span> MyCounter(&#123;(s, ): <span class="number">1</span>&#125;) <span class="keyword">if</span> s.isalpha() <span class="keyword">else</span> MyCounter(&#123;(): int(s)&#125;)</span><br><span class="line"></span><br><span class="line">	converted_expr = re.sub(<span class="string">r'(\w+)'</span>, <span class="string">r'f("\1")'</span>, expression)</span><br><span class="line">	<span class="comment"># (f("x") + f("8")) * (f("x") - f("8"))</span></span><br><span class="line">	res = eval(converted_expr) <span class="comment">#</span></span><br><span class="line">	<span class="comment"># C(&#123;('x', 'x'): 1, ('x',): 0, (): -64&#125;)</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">'*'</span>.join((str(res[x]), ) + x)</span><br><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> sorted(res, key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line">			<span class="keyword">if</span> res[x]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Karat</tag>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 785 Is Graph Bipartite?</title>
    <url>/2022/02/06/leetcode-785-is-graph-bipartite/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:<br><br><em>   There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).
</em>   There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).<br><em>   If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).
</em>   The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.<br><br>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.<br><br>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>graph.length == n</code>
</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= graph[u].length &lt; n</code>
</em>   <code>0 &lt;= graph[u][i] &lt;= n - 1</code><br><em>   <code>graph[u]</code> does not contain <code>u</code>.
</em>   All the values of <code>graph[u]</code> are <strong>unique</strong>.<br>*   If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>无向图中是否存在一个划分，将节点分为两集合，任何一条边都连接着两个集合，也就是不存在一条边在单一集合内。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</li>
<li>题意表示，图可能是有几个连通图，所以要从每个节点做BFS，除非节点已访问过， Line 4. node_to_color作为visited的功能</li>
<li>return True在两个函数中要写，否则返回None</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	node_to_color = collections.defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> node_to_color: <span class="comment"># disconnected nodes</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		node_to_color[i] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, i, node_to_color):</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, n, node_to_color)</span>:</span></span><br><span class="line">	queue = collections.deque([n])</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color <span class="keyword">and</span> node_to_color[neighbor] != <span class="number">1</span> - node_to_color[node]:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">			<span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(neighbor)</span><br><span class="line">			node_to_color[neighbor] = <span class="number">1</span> - node_to_color[node]</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>
]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 772 Basic Calculator III</title>
    <url>/2022/03/01/leetcode-772-basic-calculator-iii/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement a basic calculator to evaluate a simple expression string.<br><br>The expression string contains only non-negative integers, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code> operators, and open <code>&#39;(&#39;</code> and closing parentheses <code>&#39;)&#39;</code>. The integer division should <strong>truncate toward zero</strong>.<br><br>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>.<br><br><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “1+1”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “6-4/2”<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “2<em>(5+5</em>2)/3+(6/2+8)”<br><strong>Output:</strong> 21<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.<br><em>   <code>s</code> is a <em>*valid</em></em> expression.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除且有括号。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 227求加减乘除，这里多了括号，括号内含加减乘除，所以每对括号是一轮DFS。遇到左括号，就进入递归，遇到右括号就返回递归值</p>
<p><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a> 括号加减法, 同一层括号内求和遇括号入栈<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a> 加减乘除, 和的每一项入栈，方便出栈计乘除<br><a href="https://shineboy2013.github.io/2022/03/01/leetcode-772-basic-calculator-iii/" target="_blank" rel="noopener">LeetCode 772 Basic Calculator III</a> 加减乘除括号, L227的递归版</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不同于L227, 类似于填位法将i作为DFS参数传入，返回括号内的值以及i。i放入while循环， i += 1要加入到空格情况和循环最后</li>
<li>最后位加入加号要移除DFS中，放入主函数</li>
<li><strong>注意处理括号情况的顺序，左括号在空格后，右括号在最后</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	s += <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, i)</span>:</span></span><br><span class="line">	res, num, stack, op = <span class="number">0</span>, <span class="number">0</span>, [], <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">		char = s[i]</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			num, i = self.dfs(s, i + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">			stack.append(-num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">			stack.append(num) <span class="comment"># [4+2*1]</span></span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(prev * num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(int(prev / num))  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">			op = char</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">return</span> sum(stack), i</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 791 Custom Sort String</title>
    <url>/2022/03/19/leetcode-791-custom-sort-string/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/custom-sort-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given two strings order and s. All the words of <code>order</code> are <strong>unique</strong> and were sorted in some custom order previously.<br><br>Permute the characters of <code>s</code> so that they match the order that <code>order</code> was sorted. More specifically, if a character <code>x</code> occurs before a character <code>y</code> in <code>order</code>, then <code>x</code> should occur before <code>y</code> in the permuted string.<br><br>Return <em>any permutation of</em> <code>s</code> <em>that satisfies this property</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> order = “cba”, s = “abcd”<br><strong>Output:</strong> “cbad”<br><strong>Explanation:</strong><br>“a”, “b”, “c” appear in order, so the order of “a”, “b”, “c” should be “c”, “b”, and “a”.<br>Since “d” does not appear in order, it can be at any position in the returned string. “dcba”, “cdba”, “cbda” are also valid outputs.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> order = “cbafg”, s = “abcd”<br><strong>Output:</strong> “cbad”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= order.length &lt;= 26</code>
</em>   <code>1 &lt;= s.length &lt;= 200</code><br><em>   <code>order</code> and <code>s</code> consist of lowercase English letters.
</em>   All the characters of <code>order</code> are <strong>unique</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给一个字符串，求这个字符串的一个排列，使得字母顺序按照另一个给定字符串order的顺序。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由限制条件知道，order字母是唯一的，order字母可以重复。所以只要统计s频率，然后按照字母顺序开始重写</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customSortString</span><span class="params">(self, order: str, s: str)</span> -&gt; str:</span></span><br><span class="line">	char_to_count = collections.Counter(s)</span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> order:</span><br><span class="line">		<span class="keyword">if</span> c <span class="keyword">in</span> char_to_count:</span><br><span class="line">			res += c * char_to_count[c]</span><br><span class="line">			char_to_count.pop(c)</span><br><span class="line">	<span class="keyword">for</span> c, count <span class="keyword">in</span> char_to_count.items():</span><br><span class="line">		res += c * count</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 839 Similar String Groups</title>
    <url>/2022/02/15/leetcode-839-similar-string-groups/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/similar-string-groups/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>. Also two strings <code>X</code> and <code>Y</code> are similar if they are equal.<br><br>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.<br><br>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.<br><br>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“tars”,”rats”,”arts”,”star”]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“omv”,”ovm”]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 300</code>
</em>   <code>1 &lt;= strs[i].length &lt;= 300</code><br><em>   <code>strs[i]</code> consists of lowercase letters only.
</em>   All words in <code>strs</code> have the same length and are anagrams of each other.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>单词列表中，可以分成多少组，每组里面的单词互相之间至少有一对可以通过交换一个位置变成另一个单词</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>典型求连通集个数，类似于Num of island，用BFS。难点在于怎么找到neighbor，用遍历每一个单词的方式</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>难点在于怎么找到neighbor，用遍历每一个单词的方式，判断是否buddyStrings Leetcode 0859</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, strs: List[str])</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	visited, groups, word_set = set(), <span class="number">0</span>, set(strs)</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">		<span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		self.bfs(word_set, s, visited)</span><br><span class="line">		groups += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> groups</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word_set, start, visited)</span>:</span></span><br><span class="line">	queue = collections.deque([start])</span><br><span class="line">	visited.add(start)</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">for</span> s <span class="keyword">in</span> word_set:</span><br><span class="line">			<span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">if</span> node == s <span class="keyword">or</span> <span class="keyword">not</span> self.buddyStrings(node, s):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			queue.append(s)</span><br><span class="line">			visited.add(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal):  <span class="comment"># any dups</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 833 Find And Replace in String</title>
    <url>/2022/02/16/leetcode-833-find-and-replace-in-string/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a <strong>0-indexed</strong> string <code>s</code> that you must perform <code>k</code> replacement operations on. The replacement operations are given as three <strong>0-indexed</strong> parallel arrays, <code>indices</code>, <code>sources</code>, and <code>targets</code>, all of length <code>k</code>.<br><br>To complete the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> replacement operation:<br><br>1.  Check if the <strong>substring</strong> <code>sources[i]</code> occurs at index <code>indices[i]</code> in the <strong>original string</strong> <code>s</code>.<br>2.  If it does not occur, <strong>do nothing</strong>.<br>3.  Otherwise if it does occur, <strong>replace</strong> that substring with <code>targets[i]</code>.<br><br>For example, if <code>s = &quot;&lt;u&gt;ab&lt;/u&gt;cd&quot;</code>, <code>indices[i] = 0</code>, <code>sources[i] = &quot;ab&quot;</code>, and <code>targets[i] = &quot;eee&quot;</code>, then the result of this replacement will be <code>&quot;&lt;u&gt;eee&lt;/u&gt;cd&quot;</code>.<br><br>All replacement operations must occur <strong>simultaneously</strong>, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will <strong>not overlap</strong>.<br><br><em>   For example, a testcase with <code>s = &quot;abc&quot;</code>, <code>indices = [0, 1]</code>, and <code>sources = [&quot;ab&quot;,&quot;bc&quot;]</code> will not be generated because the <code>&quot;ab&quot;</code> and <code>&quot;bc&quot;</code> replacements overlap.<br><br>Return <em>the <strong>resulting string</strong> after performing all replacement operations on</em> <code>s</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters in a string.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“a”, “cd”], targets = [“eee”, “ffff”]<br><strong>Output:</strong> “eeebffff”<br><strong>Explanation:</strong><br>“a” occurs at index 0 in s, so we replace it with “eee”.<br>“cd” occurs at index 2 in s, so we replace it with “ffff”.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“ab”,”ec”], targets = [“eee”,”ffff”]<br><strong>Output:</strong> “eeecd”<br><strong>Explanation:</strong><br>“ab” occurs at index 0 in s, so we replace it with “eee”.<br>“ec” does not occur at index 2 in s, so we do nothing.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length &lt;= 1000</code><br><em>   <code>k == indices.length == sources.length == targets.length</code>
</em>   <code>1 &lt;= k &lt;= 100</code><br><em>   <code>0 &lt;= indexes[i] &lt; s.length</code>
</em>   <code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code><br><em>   <code>s</code> consists of only lowercase English letters.
</em>   <code>sources[i]</code> and <code>targets[i]</code> consist of only lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>整洁题。找到位置，然后验证，最后替换</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>i是循环外的变量，所以poplate index_dict注意不能重名</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, s: str, indices: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	index_dict = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _i, _n <span class="keyword">in</span> enumerate(indices):</span><br><span class="line">		index_dict[_n] = _i <span class="comment"># 0 -&gt; 0, 2 -&gt; 1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> index_dict <span class="keyword">and</span> s[i:i + len(sources[index_dict[i]])] == sources[index_dict[i]]:</span><br><span class="line">			res += targets[index_dict[i]]</span><br><span class="line">			i += len(sources[index_dict[i]])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res += s[i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 843 Guess the Word</title>
    <url>/2022/02/16/leetcode-843-guess-the-word/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>This is an <strong><em>interactive problem</em></strong>.<br><br>You are given an array of <strong>unique</strong> strings <code>wordlist</code> where <code>wordlist[i]</code> is <code>6</code> letters long, and one word in this list is chosen as <code>secret</code>.<br><br>You may call <code>Master.guess(word)</code> to guess a word. The guessed word should have type <code>string</code> and must be from the original list with <code>6</code> lowercase letters.<br><br>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <code>secret</code> word. Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.<br><br>For each test case, you have exactly <code>10</code> guesses to guess the word. At the end of any number of calls, if you have made <code>10</code> or fewer calls to <code>Master.guess</code> and at least one of these guesses was <code>secret</code>, then you pass the test case.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br><strong>Explanation:</strong><br>master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>We made 5 calls to master.guess and one of them was the secret, so we pass the test case.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> secret = “hamada”, wordlist = [“hamada”,”khaled”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= wordlist.length &lt;= 100</code>
</em>   <code>wordlist[i].length == 6</code><br><em>   <code>wordlist[i]</code> consist of lowercase English letters.
</em>   All the strings of <code>wordlist</code> are <strong>unique</strong>.<br><em>   <code>secret</code> exists in <code>wordlist</code>.
</em>   <code>numguesses == 10</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定单词列表，每个单词长度为6， 其中一个为答案，每次猜一个单词。给一个API会告诉你猜的单词有多少位命中(位置,数值), 求是否可以10次内猜对</p>
<h3 id="暴力法解题思路："><a href="#暴力法解题思路：" class="headerlink" title="暴力法解题思路："></a><strong>暴力法解题思路：</strong></h3><p>较直观的解法是抽第一个单词出来，然后call API, 然后再filter wordlist使得新的单词列表里的单词的命中位数也是一样的。每轮缩少范围。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord2</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		guess = wordlist[<span class="number">0</span>]</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="统计频率算法II解题思路-推荐-："><a href="#统计频率算法II解题思路-推荐-：" class="headerlink" title="统计频率算法II解题思路(推荐)："></a><strong>统计频率算法II解题思路(推荐)：</strong></h3><p>上述方法跟单词个数有关，如果很多的话，就会超过10次。考虑单词长度为6，而可以猜10次。考虑用26字母存储法，也就是统计频率。统计每位的频率，然后将频率作为这一位的分数，求每个单词的总分。<br>一定要选择单词列表中的某个单词去猜，如果不在列表中返回为-1，这个信息没有任何作用。<br>选择总分最高的去猜，原理是它最具代表性，这样可以快速排除很多单词，有点类似于二分法。反之，若用频率低的单词，也就只能排除一个单词。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		char_to_count = [collections.Counter(w[i] <span class="keyword">for</span> w <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">		guess = max(wordlist, key=<span class="keyword">lambda</span> w: sum(char_to_count[i][char] <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(w)))</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Google</tag>
        <tag>Interactive</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 854 K-Similar Strings</title>
    <url>/2022/02/15/leetcode-854-k-similar-strings/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/k-similar-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Strings <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong> (for some non-negative integer <code>k</code>) if we can swap the positions of two letters in <code>s1</code> exactly <code>k</code> times so that the resulting string equals <code>s2</code>.<br><br>Given two anagrams <code>s1</code> and <code>s2</code>, return the smallest <code>k</code> for which <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “ba”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “abc”, s2 = “bca”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length &lt;= 20</code>
</em>   <code>s2.length == s1.length</code><br><em>   <code>s1</code> and <code>s2</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>.
</em>   <code>s2</code> is an anagram of <code>s1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两字符，交换两个位置，使得他们相等，求最小交换次数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值考虑用BFS，难点在于生成neighbor，见注意事项</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用例子写程序node = abc s2 = cba, 先找到第一个不同位i，然后找下一个不同位j，这个不同位node[j]需要与目标s2[i]相同，贪心法</li>
<li>倒数第二行要break，否则TLE，因为只要找到一位可以交换这一层的BFS算是结束</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class="line">	queue = collections.deque([s1])</span><br><span class="line">	visited = set([s1])</span><br><span class="line">	distance = &#123;s1: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		node = queue.popleft()</span><br><span class="line">		<span class="keyword">if</span> node == s2:</span><br><span class="line">			<span class="keyword">return</span> distance[node]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)): <span class="comment"># abc, cba</span></span><br><span class="line">			<span class="keyword">if</span> node[i] == s2[i]:</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(node)):</span><br><span class="line">				<span class="keyword">if</span> node[j] == s2[j]:</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">if</span> node[j] == s2[i]:</span><br><span class="line">					ss = node[:i] + node[j] + node[i + <span class="number">1</span>:j] + node[i] + node[j + <span class="number">1</span>:]</span><br><span class="line">					<span class="keyword">if</span> ss <span class="keyword">in</span> visited:</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					queue.append(ss)</span><br><span class="line">					visited.add(ss)</span><br><span class="line">					distance[ss] = distance[node] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span> <span class="comment"># remember</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 938 Range Sum of BST</title>
    <url>/2022/03/16/leetcode-938-range-sum-of-bst/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given the <code>root</code> node of a binary search tree and two integers <code>low</code> and <code>high</code>, return <em>the sum of values of all nodes with a value in the <strong>inclusive</strong> range</em> <code>[low, high]</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [10,5,15,3,7,null,18], low = 7, high = 15<br><strong>Output:</strong> 32<br><strong>Explanation:</strong> Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10<br><strong>Output:</strong> 23<br><strong>Explanation:</strong> Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range `[1, 2 </em> 10<sup>4</sup>]<code>.
*</code>1 &lt;= Node.val &lt;= 10<sup>5</sup><code>*</code>1 &lt;= low &lt;= high &lt;= 10<sup>5</sup><code>*   All</code>Node.val` are <strong>unique</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定[low, high]和BST，求满足条件的BST的节点和</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，DFS，条件比较容易错</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>两个条件，若root.val在范围内，加入和。若low小于root.val(这里不取等号，因为所有节点是唯一，不存在相等节点)，<br>表示范围适用于左节点，同理右节点。</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root: TreeNode, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> low &lt;= root.val &lt;= high:</span><br><span class="line">		res += root.val</span><br><span class="line">	<span class="keyword">if</span> low &lt; root.val:</span><br><span class="line">		res += self.rangeSumBST(root.left, low, high)</span><br><span class="line">	<span class="keyword">if</span> root.val &lt; high:</span><br><span class="line">		res += self.rangeSumBST(root.right, low, high)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 921 Minimum Add to Make Parentheses Valid</title>
    <url>/2022/03/16/leetcode-921-minimum-add-to-make-parentheses-valid/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>A parentheses string is valid if and only if:<br><br><em>   It is the empty string,
</em>   It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or<br><em>   It can be written as <code>(A)</code>, where <code>A</code> is a valid string.<br><br>You are given a parentheses string <code>s</code>. In one move, you can insert a parenthesis at any position of the string.

</em>   For example, if <code>s = &quot;()))&quot;</code>, you can insert an opening parenthesis to be <code>&quot;(**(**)))&quot;</code> or a closing parenthesis to be <code>&quot;())**)**)&quot;</code>.<br><br>Return <em>the minimum number of moves required to make</em> <code>s</code> <em>valid</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “())”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “(((“<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 1000</code>
</em>   <code>s[i]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最小加括号数使得配对</p>
<h3 id="Stack解题思路-推荐-："><a href="#Stack解题思路-推荐-：" class="headerlink" title="Stack解题思路(推荐)："></a><strong>Stack解题思路(推荐)：</strong></h3><p>跟Leetcode 1249一样。括号题优先考虑用Stack。此题将下标存于stack中，stack留下的是不合法括号下标，也就是需要删除的 </p>
<p>LeetCode 1249 Minimum Remove to Make Valid Parentheses 求一个最优解 Medium, Stack<br>LeetCode 921 Minimum Add to Make Parentheses Valid 求一个最优解 Medium, Stack<br>LeetCode 301 Remove Invalid Parentheses 求所有最优解 Hard，此题 答案包含上题, BFS</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	stack, res = [], <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">		<span class="keyword">elif</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span> <span class="keyword">and</span> s[i] == <span class="string">')'</span>:  <span class="comment"># remember</span></span><br><span class="line">			stack.pop()</span><br><span class="line">		<span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">			stack.append(i)</span><br><span class="line">	<span class="keyword">return</span> len(stack)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>
<hr>
<h3 id="统计算法II解题思路："><a href="#统计算法II解题思路：" class="headerlink" title="统计算法II解题思路："></a><strong>统计算法II解题思路：</strong></h3><p>类似于Leetcode 032 Longest Valid Parentheses的统计算法。用这两种情况来写即可： ()), )(. 若左括号数left出现负数，根据第一个规律，重设left，计入res</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	left, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			left -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> left &lt; <span class="number">0</span>:</span><br><span class="line">				res += <span class="number">1</span></span><br><span class="line">				left = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> res + abs(left)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>Facebook</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Buddy Strings</title>
    <url>/2022/02/15/leetcode-859-buddy-strings/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/buddy-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> <em>if you can swap two letters in</em> <code>s</code> <em>so the result is equal to</em> <code>goal</code><em>, otherwise, return</em> <code>false</code><em>.</em><br><br>Swapping letters is defined as taking two indices <code>i</code> and <code>j</code> (0-indexed) such that <code>i != j</code> and swapping the characters at <code>s[i]</code> and <code>s[j]</code>.<br><br><em>   For example, swapping at indices <code>0</code> and <code>2</code> in <code>&quot;abcd&quot;</code> results in <code>&quot;cbad&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ba”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘b’ to get “ba”, which is equal to goal.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ab”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The only letters you can swap are s[0] = ‘a’ and s[1] = ‘b’, which results in “ba” != goal.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aa”, goal = “aa”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘a’ to get “aa”, which is equal to goal.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length, goal.length &lt;= 2 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> and <code>goal</code> consist of lowercase letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两字符串，交换一次使得他们相等</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况： 长度不等，完全相等（若至少有一个重复，即满足题意），两次不同</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>三种情况： 长度不等，完全相等，两次不同</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line">	<span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal): <span class="comment"># any dups</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 984 String Without AAA or BBB</title>
    <url>/2022/02/07/leetcode-984-string-without-aaa-or-bbb/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Given two integers <code>a</code> and <code>b</code>, return <strong>any</strong> string <code>s</code> such that:<br><br><em>   <code>s</code> has length <code>a + b</code> and contains exactly <code>a</code> <code>&#39;a&#39;</code> letters, and exactly <code>b</code> <code>&#39;b&#39;</code> letters,
</em>   The substring <code>&#39;aaa&#39;</code> does not occur in <code>s</code>, and<br><em>   The substring <code>&#39;bbb&#39;</code> does not occur in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 2<br><strong>Output:</strong> “abb”<br><strong>Explanation:</strong> “abb”, “bab” and “bba” are all correct answers.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 4, b = 1<br><strong>Output:</strong> “aabaa”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>0 &lt;= a, b &lt;= 100</code><br>*   It is guaranteed such an <code>s</code> exists for the given <code>a</code> and <code>b</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个整数代表ab的个数，生成一个字符串，字符串ab频数不能超过这2个数，不能有连续的aaa, bbb, 求此种字符串的最大长度</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>参考LeetCode 1405 Longest Happy String, 此题不用heap因为只有两种字符</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不能连续的处理</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span><span class="params">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	<span class="keyword">while</span> a &gt; <span class="number">0</span> <span class="keyword">or</span> b &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> a &gt; b:</span><br><span class="line">			<span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'a'</span>:</span><br><span class="line">				res += <span class="string">'b'</span></span><br><span class="line">				b -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				res += <span class="string">'a'</span></span><br><span class="line">				a -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">				res += <span class="string">'a'</span></span><br><span class="line">				a -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				res += <span class="string">'b'</span></span><br><span class="line">				b -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 979 Distribute Coins in Binary Tree</title>
    <url>/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/</url>
    <content><![CDATA[<p><strong><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given the <code>root</code> of a binary tree with <code>n</code> nodes where each <code>node</code> in the tree has <code>node.val</code> coins. There are <code>n</code> coins in total throughout the whole tree.<br><br>In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.<br><br>Return <em>the <strong>minimum</strong> number of moves required to make every node have <strong>exactly</strong> one coin</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,0,0]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> From the root of the tree, we move one coin to its left child, and one coin to its right child.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" alt=""><br><br><pre><strong>Input:</strong> root = [0,3,0]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is <code>n</code>.
</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= Node.val &lt;= n</code>
</em>   The sum of all <code>Node.val</code> is <code>n</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树某些节点含有硬币，求将这些硬币推向其他节点，使得所有节点都有一个硬币，求总移动次数</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先思考，若硬币都在root，也就是求所有节点的路径和。可以用每个节点的路径和求和，也可以定义dfs返回节点数，用全局变量加左右数，每轮递归都加一次，所以每个节点被加了其路径长度的次数。本算法采用后者<br>下面思考若硬币不在root，由于硬币可以从儿子给父亲，这是双向的，所以<strong>dfs定义为儿子给父亲的硬币数</strong>，若节点没有硬币，返回值会是负数，也就是父亲给儿子硬币，此时这个负数正是以此节点为root的数的总的节点数，所以与上述定义一致。<br>所以返回root.val + left + right - 1，left和right都是负数，left + right - 1是树的大小的负数，此结果为剩余硬币推给父亲的硬币数<br>res += abs(left) + abs(right)左子树和右子树所有节点一起走一条边的路径和</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>dfs定义为儿子给父亲的硬币数(若有硬币)，同时是子树的节点数的负数(若无硬币)</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">nonlocal</span> res</span><br><span class="line">		left = dfs(root.left)</span><br><span class="line">		right = dfs(root.right)</span><br><span class="line">		res += abs(left) + abs(right)</span><br><span class="line">		<span class="keyword">return</span> root.val + left + right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>Tree</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode 683 Word Break III</title>
    <url>/2020/05/09/lin-683/</url>
    <content><![CDATA[<p><strong><a href="https://www.lintcode.com/problem/word-break-iii/" target="_blank" rel="noopener">LintCode 683 Word Break III</a></strong></p>
<div><br><br>Give a dictionary of words and a sentence with all whitespace removed, return the number of sentences you can form by inserting whitespaces to the sentence so that each word can be found in the dictionary.<br><br><strong>Example 1:</strong><br><br><pre><br>Input:<br>“CatMat”<br>[“Cat”, “Mat”, “Ca”, “tM”, “at”, “C”, “Dog”, “og”, “Do”]<br>Output: 3<br>Explanation:<br>we can form 3 sentences, as follows:<br>“CatMat” = “Cat” + “Mat”<br>“CatMat” = “Ca” + “tM” + “at”<br>“CatMat” = “C” + “at” + “Mat”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><br>Input:<br>“a”<br>[]<br>Output: 0<br></pre><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，被“字典集合”（wordDict）中的单词拼接而成的可能性种数。  </p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。如果知道s[0:n-1)很容易知道s[0:n)是否有解，既然和子问题有关，就用DP。  </p>
<ol>
<li>定义dp[i]为字符串s[0,i)是合法分解种数。</li>
<li>判断一个字符串是否可以合法分解，方案是尝试在每一位进行分解，若其中一个可分解，即有解，加入到dp[i]中。<br>递归式为dp[i] += dp[k] * isWord(s[k:i)), 0 &lt;= k &lt; i. </li>
<li>方向为从左到右i=0..n, 初始值为dp[0] = 1. </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>将两个输入都转换成小写。 </li>
<li>dp[n+1]而不是dp[n]，而for循环从1开始。  </li>
<li>递归中dp[i]用+操作符。  </li>
</ol>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak3</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	Set&lt;String&gt; lowerDict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(String c : dict)</span><br><span class="line">		lowerDict.add(c.toLowerCase());</span><br><span class="line">	dict = lowerDict;</span><br><span class="line">	s = s.toLowerCase();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// dp[i][j] = sum(dp[i][k] * isWord(s[k,j])), i=0..n-1, j=i..n-1</span></span><br><span class="line">	<span class="comment">// dp[0][n-1] = sum(dp[0][k] * isWord(s[k,n-1]))</span></span><br><span class="line">	<span class="comment">// dp[n] = sum(dp[k] * isWord(s[k,n]))</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">			dp[i] += dp[k] * (dict.contains(s.substring(k, i)) ? <span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。  </p>
<p>这道题一开始走过一些弯路，首先我觉得类似于Catalan算法，左右半部都是子问题，但其实这属于单边问题。所以写了以下算法：  </p>
<h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak3_wrong</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// dp[i][j] = sum(dp[i][k] * dp[k][j])</span></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// use "ab" as an example</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= s.length(); len++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + len; j++) &#123;</span><br><span class="line">				<span class="comment">//"a","b"</span></span><br><span class="line">				dp[i][i+len] += dp[i][j] * dp[j][i+len];    		</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//"ab"</span></span><br><span class="line">			<span class="keyword">if</span>(dict.contains(s.substring(i, i+len)))</span><br><span class="line">				dp[i][i+len]++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个方法会有重复解，比如<br>“abc”, “a”,”b”,”c”<br>-&gt; <code>dp[&quot;ab&quot;] * dp[&quot;c&quot;] = 1</code><br>-&gt; <code>dp[&quot;a&quot;] * dp[&quot;bc&quot;] = 1</code><br>所以解重复，因为这问题是单边子问题而不是Catalan问题。<br>更改版本为单边子问题，一开始用dp[n]导致初始化稍复杂，其实初始化可以并入到递归式，只要用dp[n+1]即可。  </p>
<h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak32</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">		dp[i] = dict.contains(s.substring(<span class="number">0</span>, i + <span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">			dp[i] += dp[k] * (dict.contains(s.substring(k + <span class="number">1</span>, i + <span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Classic</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆性搜索</title>
    <url>/2020/05/09/memoization/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS将子问题的解存于结果中。cache[st] = result. st是子问题边界。  </p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><p>用于求所有可能性，且这些可能性有重复，记忆性搜索可以用于剪枝。  </p>
<ol>
<li>Leetcode 139</li>
<li>Leetcode 140</li>
</ol>
<p>与DP的界线：  </p>
<ol>
<li>状态转移特别麻烦如有循环依赖, 不是顺序性。如棋盘，上下左右四个方向如1197 Minimum Knight Moves和word ladder  </li>
<li>初始化状态不是特别容易找到</li>
</ol>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol>
<li>key为子问题索引st，value为子问题的解。不含path和res因为类似于Catalan，用子问题返回结果来组成此轮结果。f(input, st, endIndex, cache) -&gt; List    </li>
<li>紧跟终结条件，若在cache中，返回子问题的解。  </li>
<li>循环结束，将子问题的结果存于cache。  </li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>cache是一个解的集合，所以<strong>终止条件返回也需要是一个list</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, input, cache)</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> &lt;终止条件&gt;:</span><br><span class="line">		<span class="keyword">return</span> [] <span class="comment"># remember to use list</span></span><br><span class="line">	<span class="keyword">if</span> input <span class="keyword">in</span> cache:</span><br><span class="line">		<span class="keyword">return</span> cache[input]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(input)):</span><br><span class="line">		anwser = self.dfs(input[:i], cache)</span><br><span class="line">		res.append(anwser)</span><br><span class="line">	cache[input] = res</span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>.</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
        <tag>Memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>合并排序</title>
    <url>/2021/11/15/merge-sort/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>递归分前半和后半排序然后合并。  </p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>排序</li>
<li>求逆序数</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>merge函数中更改输入nums。  </li>
<li>line 15的等号决定是否stable sort。  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">	self.m_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m_sort</span><span class="params">(self, nums: List[int], start: int, end: int)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">	self.m_sort(nums, start, mid)</span><br><span class="line">	self.m_sort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">	self.merge(nums, start, mid, end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums: List[int], start: int, mid: int, end: int)</span>:</span></span><br><span class="line">	i, j, res = start, mid + <span class="number">1</span>, []</span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:  <span class="comment"># = decides if it is stable sort</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">			res.append(nums[i])</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res.append(nums[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">		res.append(nums[i])</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt;= end:</span><br><span class="line">		res.append(nums[j])</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock 001 Count changes for two N-trees</title>
    <url>/2022/02/15/mock-001/</url>
    <content><![CDATA[<p>A change for two N-children tree contains:</p>
<ol>
<li>key is different</li>
<li>value is different</li>
<li>delete a node</li>
<li>add a node</li>
</ol>
<p>Problem: how many changes to convert tree A to tree B</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>DD的面经题，多少个改动可以使得existingTree变成newTree</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS, 比较children，三种情况。若其中一方没有节点，就是计算节点数</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>比较children，三种情况。若其中一方没有节点，就是计算节点数</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeNodes</span><span class="params">(self, existingTree, newTree)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">and</span> <span class="keyword">not</span> newTree:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">or</span> <span class="keyword">not</span> newTree:</span><br><span class="line">		<span class="keyword">return</span> self.count(existingTree) + self.count(newTree)</span><br><span class="line">	res = <span class="number">0</span> <span class="keyword">if</span> existingTree.key == newTree.key <span class="keyword">and</span> existingTree.val == newTree.val <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">	existing_children_dict = self.get_children_dict(existingTree.children)</span><br><span class="line">	new_tree_children_dict = self.get_children_dict(newTree.children)</span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() &amp; new_tree_children_dict.keys(): <span class="comment"># in both</span></span><br><span class="line">		res += self.changeNodes(existing_children_dict[key], new_tree_children_dict[key])</span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() - new_tree_children_dict.keys(): <span class="comment"># in existing tree not in new tree</span></span><br><span class="line">		res += self.count(existing_children_dict[key])</span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> new_tree_children_dict.keys() - existing_children_dict.keys():  <span class="comment"># in new tree not in existing tree</span></span><br><span class="line">		res += self.count(new_tree_children_dict[key])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, root)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">		res += self.count(child)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_children_dict</span><span class="params">(self, children)</span>:</span></span><br><span class="line">	key_to_node = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">		key_to_node[child.key] = child</span><br><span class="line">	<span class="keyword">return</span> key_to_node</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock 002 Print 5-min intervals</title>
    <url>/2022/03/07/mock-002/</url>
    <content><![CDATA[<p>Input - (“mon 10:00 am”, mon 11:00 am)<br>Output - [11005, 11010, 11015…11100]<br>Output starts with 1 if the day is monday, 2 if tuesday and so on till 7 for sunday<br>Append 5 min interval times to that till the end time<br>So here it is 10:05 as first case, so its written as 11005<br>2nd is 10:10 so its written as 11010</p>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>DD的面经题，给定开始时间和结束时间，求5分钟的间隔时间，注意要round to 5min</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于非10进制，所以开一个类来计算进制</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>实现lt函数</li>
<li>12am, 12pm要mod 12</li>
<li>(0 if parts[2] == ‘am’ else 12)加括号</li>
<li>开始时间到到5分钟端点，结束时间加1分钟，由于只实现了lt</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DAY_DICT = &#123;<span class="string">'mon'</span>: <span class="number">1</span>, <span class="string">'tue'</span>: <span class="number">2</span>, <span class="string">'wed'</span>: <span class="number">3</span>, <span class="string">'thu'</span>: <span class="number">4</span>, <span class="string">'fri'</span>: <span class="number">5</span>, <span class="string">'sat'</span>: <span class="number">6</span>, <span class="string">'sun'</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_intervals</span><span class="params">(self, start, end)</span> -&gt; List:</span></span><br><span class="line">        start_time = Time(start)</span><br><span class="line">        end_time = Time(end)</span><br><span class="line">        <span class="keyword">if</span> start_time.min % <span class="number">5</span> &gt; <span class="number">0</span>:</span><br><span class="line">            start_time.add(<span class="number">5</span> - start_time.min % <span class="number">5</span>)</span><br><span class="line">        end_time.add(<span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> start_time &lt; end_time:</span><br><span class="line">            res.append(start_time.get_numeric())</span><br><span class="line">            start_time.add(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, time)</span>:</span></span><br><span class="line">        parts = time.split(<span class="string">' '</span>)</span><br><span class="line">        day = DAY_DICT[parts[<span class="number">0</span>]]</span><br><span class="line">        time_parts = parts[<span class="number">1</span>].split(<span class="string">':'</span>)</span><br><span class="line">        hour = int(time_parts[<span class="number">0</span>]) % <span class="number">12</span> + (<span class="number">0</span> <span class="keyword">if</span> parts[<span class="number">2</span>] == <span class="string">'am'</span> <span class="keyword">else</span> <span class="number">12</span>) <span class="comment"># remember paren (0 ...12), and % 12</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.hour = hour</span><br><span class="line">        self.min = int(time_parts[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.day &lt; other.day <span class="keyword">or</span> (self.day == other.day <span class="keyword">and</span> self.hour &lt; other.hour) <span class="keyword">or</span> \</span><br><span class="line">                (self.day == other.day <span class="keyword">and</span> self.hour == other.hour <span class="keyword">and</span> self.min &lt; other.min):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_numeric</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.day * <span class="number">10000</span> + self.hour * <span class="number">100</span> + self.min</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, mins)</span>:</span></span><br><span class="line">        self.min += mins</span><br><span class="line">        <span class="keyword">if</span> self.min == <span class="number">60</span>:</span><br><span class="line">            self.min = <span class="number">0</span></span><br><span class="line">            self.hour += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.hour == <span class="number">24</span>:</span><br><span class="line">            self.hour = <span class="number">0</span></span><br><span class="line">            self.day += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.day == <span class="number">7</span>:</span><br><span class="line">            self.day = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
]]></content>
      <tags>
        <tag>DoorDash</tag>
      </tags>
  </entry>
  <entry>
    <title>排列</title>
    <url>/2020/05/03/permutation/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 046的题目。这里作为知识点归纳。  </p>
<ol>
<li>类似于组合题，但用到了visited数组且递归中从i=0开始。  </li>
</ol>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>找所有可能性</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>每一种排列加入到结果集时要复制path。 </li>
</ol>
<p><a href="https://leetcode.com/problems/permutations" target="_blank" rel="noopener">Leetcode 046 Permutations</a>    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> [[]]</span><br><span class="line">	path, result, visited = [], [], set()</span><br><span class="line">	self.dfs(nums, path, result, visited)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path, result, visited)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">		result.append(list(path))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		path.append(nums[i])</span><br><span class="line">		visited.add(i)</span><br><span class="line">		self.dfs(nums, path, result, visited)</span><br><span class="line">		visited.remove(i)</span><br><span class="line">		path.pop()</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(nums, <span class="keyword">new</span> HashSet&lt;&gt;(), path, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, Set&lt;Integer&gt; visited, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">		res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(visited.contains(i))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		visited.add(i);</span><br><span class="line">		path.add(nums[i]);</span><br><span class="line">		dfs(nums, visited, path, res);</span><br><span class="line">		visited.remove(i);</span><br><span class="line">		path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>括号题或者字符串运算题</title>
    <url>/2021/12/07/parenthesis/</url>
    <content><![CDATA[<h2 id="括号题"><a href="#括号题" class="headerlink" title="括号题"></a>括号题</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol>
<li><strong>优先考虑用Stack</strong>。Stack可以将字符压入比较或者<strong>字符的下标</strong>压入比较，<em>后者信息量更大</em><br>三种情况不合法： ‘[‘ (stack有余，for后发生), ‘]’ (要匹配的时候stack为空，for中发生), ‘{]’ (不匹配，for中发生)  </li>
<li>DP  </li>
<li>1) 左括号的数量在每一位都大于等于右括号数量<br>2) 右括号的总和要等于右括号总和<br>以上两个条件都满足的话，左右括号匹配，但此法只能用于<strong>单种括号</strong>  </li>
</ol>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>括号题</li>
<li>字符串运算题如, 3+4, (3+4)*5</li>
</ol>
<h2 id="括号运算题"><a href="#括号运算题" class="headerlink" title="括号运算题"></a>括号运算题</h2><p>res是作为同一层的临时计算结果，若遇到左括号，res保留在stack中且reset，若遇到右括号，stack的结果还原到res<br>num也是临时变量负责储存整数   </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>char.isdigit()的计算  </li>
<li>左括号：入栈和reset res和num。    </li>
<li>右括号:出栈和还原res = tmp + f(res)。    </li>
</ol>
<h3 id="括号运算题模板："><a href="#括号运算题模板：" class="headerlink" title="括号运算题模板："></a><strong>括号运算题模板：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parenthesis</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    (Optional) s边界处理如s += <span class="string">'+'</span> </span><br><span class="line">	res, num, stack = <span class="string">''</span>, <span class="number">0</span>, []</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char.isdigit(): </span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">if</span> char.isalpha():</span><br><span class="line">			res += char</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'+'</span> <span class="comment"># 或其他操作符</span></span><br><span class="line">			res = 同层计算</span><br><span class="line">			num = <span class="number">0</span>  <span class="comment"># reset 不能reset res，因为res是这一层的临时结果</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'['</span>:</span><br><span class="line">			多个入栈(res) </span><br><span class="line">			res = <span class="string">''</span> <span class="comment"># reset</span></span><br><span class="line">			num = <span class="number">0</span>  <span class="comment"># reset </span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">']'</span>:</span><br><span class="line">			(Optional) res = 同层计算, 这两步同+运算符</span><br><span class="line">			tmp = 多个出栈</span><br><span class="line">			res = tmp + f(res) <span class="comment"># 还原上层结果</span></span><br><span class="line">			(Optional) num = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>.</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/04/26/quick-sort/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol>
<li>递归找pivot，然后按小于pivot和大于等于pivot分成两组。每轮递归，pivot肯定在正确（最终）位置上</li>
<li>partition方法类似于Leetcode75的sort colors一样用两个指针i和noSmallerIdx。i是循环指针，而<br>noSmallerIdx是第二组大于等于pivot的首元素，或者理解为比pivot小的元素（指针i指着）将要被交换<br>的位置（比pivot大的元素）=比pivot小的元素的最后一个+1.  </li>
<li>循环结束后，将pivot交换到正确的位置上。  </li>
</ol>
<p><img src="/images/quicksort.png" alt=""><br>i指向4，因为4小于pivot，所以要换到前面去，跟6置换，noSmallerIdx向后移。  </p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>排序</li>
<li>快速选择quick select</li>
<li>partition，如Leetcode 75</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	self.q_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_sort</span><span class="params">(self, nums: List[int], start: int, end: int)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt;= end:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	pivot = self.partition(nums, start, end)</span><br><span class="line">	self.q_sort(nums, start, pivot - <span class="number">1</span>)</span><br><span class="line">	self.q_sort(nums, pivot + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums: List[int], start: int, end: int)</span>:</span></span><br><span class="line">	no_smaller_index, pivot = start, end</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt; nums[pivot]:</span><br><span class="line">			nums[no_smaller_index], nums[i] = nums[i], nums[no_smaller_index]</span><br><span class="line">			no_smaller_index += <span class="number">1</span></span><br><span class="line">	nums[no_smaller_index], nums[end] = nums[end], nums[no_smaller_index]</span><br><span class="line">	<span class="keyword">return</span> no_smaller_index</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="Quick-Select"><a href="#Quick-Select" class="headerlink" title="Quick Select"></a>Quick Select</h2><p>选择第k小的数(下标从0开始)  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>left &gt; right不再是等于，因为几个数相等的情况，排序的时候不用再移动，但第k小里面需要继续递归。  </li>
<li>binary select是单边递归，而不是双边。要判断pivot是否等于k。  </li>
<li>递归调用仍用k，而不是跟pivot_pos相关，因为k是下标位置  </li>
<li>partition中range用[start, end)而不是len </li>
</ol>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_select</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">return</span> self.q_select(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_select</span><span class="params">(self, nums: List[int], start: int, end: int, k: int)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> start &gt; end:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	pivot = self.partition(nums, start, end)</span><br><span class="line">	<span class="keyword">if</span> k == pivot:</span><br><span class="line">		<span class="keyword">return</span> nums[pivot]</span><br><span class="line">	<span class="keyword">if</span> k &lt; pivot:</span><br><span class="line">		<span class="keyword">return</span> self.q_select(nums, start, pivot - <span class="number">1</span>, k)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> self.q_select(nums, pivot + <span class="number">1</span>, end, k)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>用于原位排序，将相应的元素放入该放的位置直到不满足条件为止  </p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><strong>i不一定会移动</strong>，放在else里面    </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">		<span class="keyword">if</span> &lt;condition&gt;</span><br><span class="line">			self.swap(nums, i, j)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">	nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">	quickSort(arr, left, pivotPos - <span class="number">1</span>);</span><br><span class="line">	quickSort(arr, pivotPos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> noSmallerIdx = left;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt; pivot) </span><br><span class="line">			swap(arr, noSmallerIdx++, i);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr, noSmallerIdx, right);</span><br><span class="line">	<span class="keyword">return</span> noSmallerIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">	arr[i] = arr[j];</span><br><span class="line">	arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/2021/10/30/stack/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>定义： 栈里元素维持由栈底到栈顶从大到小的顺序叫递减栈。跟最小堆一样，递减栈的<strong>栈首元素最小</strong>。<br><img src="/images/stack.png" alt="">  </p>
<p>反之是递增栈，不过此法因为用递减栈比较多，所以统称递减栈。通常是将下标而不是值放入到栈中，这样还可以知道元素间的距离。  </p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>数组不能打乱顺序且求极值</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>跟最小堆一样，当元素大于栈顶元素的时候才倒逼栈内元素出栈。    </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</span><br><span class="line">	<span class="keyword">while</span> stack <span class="keyword">and</span> li[i] &gt; li[stack[<span class="number">-1</span>]]:</span><br><span class="line">		index = stack.pop()</span><br><span class="line"></span><br><span class="line">	stack.append(i)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2017/12/03/topological/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>对于拓扑排序来说， 我们的中心思想是要我们可以找到一个顺序，每一次我们可以进行的工序是现在没有先序依赖的工序，<br>按照这个顺序可以流畅的完成我们的任务。<br>思路基于BFS的队列实现。区别在于统计每个节点的入度数。此法也可用于无向图。</p>
<ol>
<li>根据边统计每个节点的入度数记入in[i]，<strong>其他节点（含无边节点）入度数为0</strong></li>
<li>找出度数为0的节点加入到Queue</li>
<li>取出队首节点，把此节点邻接的节点度数减1，如果度数为0，加入到队列，循环直到队列为空</li>
<li>如果队列为空但仍有节点度数不为0，<strong>存在循环，否则不存在</strong></li>
</ol>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol>
<li>求最长或最短路径(Leetcode 310)</li>
<li>判断拓扑顺序(Leetcode外星人字典)</li>
<li>判断循环(Python代码返回None)</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>graph要含所有节点，包括没有边的节点。否则结果会有遗漏  </li>
<li>in_degree初始化要对所有节点赋0</li>
<li>第四步判断是否含循环必不可少，要根据题目要求来处理。除非L310 min height明确一定有解，而L269外星人字典就明确可能无解  </li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topological_sort</span><span class="params">(self, graph: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">	in_degree = [<span class="number">0</span>] * n</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(len(graph[i])):</span><br><span class="line">			in_degree[graph[i][j]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	start_nodes = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(in_degree)) <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>]</span><br><span class="line">	queue, res = deque(start_nodes), []</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> queue:</span><br><span class="line">		root = queue.popleft()</span><br><span class="line">		res.append(root)</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> graph[root]:</span><br><span class="line">			in_degree[i] -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> in_degree[i] == <span class="number">0</span>:</span><br><span class="line">				queue.append(i)</span><br><span class="line">	<span class="keyword">return</span> res <span class="keyword">if</span> len(res) == n <span class="keyword">else</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * num: 节点个数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">	<span class="comment">//populate inDegree</span></span><br><span class="line">	<span class="keyword">for</span>(ArrayList&lt;Integer&gt; adjacencyList : graph)&#123;</span><br><span class="line">		<span class="keyword">for</span>(Integer node : adjacencyList)&#123;</span><br><span class="line">			inDegree[node]++;</span><br><span class="line">		&#125;       	</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">			q.offer(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">		Integer v = q.poll();</span><br><span class="line">		count++;</span><br><span class="line">		System.out.print(v + <span class="string">"-&gt;"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line">			<span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">0</span>)</span><br><span class="line">				q.offer(neighbor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* check isCyclic  or not</span></span><br><span class="line"><span class="comment">	return count == num;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2021/11/29/trie/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 208 Implement Trie (Prefix Tree), 也可以用HashMap将所有前缀加入到Map来实现，效率稍低。  </p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>TrieNode用{}和is_end，insert, search, startswith用it和i迭代比较  </li>
<li>startswith含整个单词，如单词apple，startswith(‘apple’) -&gt; True  </li>
<li><del>Line 11记得加，也就是dict在取value是一定要先检验key是否存在。</del>可以不加，解决方案是用defaultdict（后版本）。  </li>
</ol>
<p>新版本比旧版本更简洁，体现在is_end的处理放在了for循环外。<br>存储结构举例：  a<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TrieNode(</span><br><span class="line">  children = &#123; </span><br><span class="line">              &apos;a&apos;:  TrieNode(is_End = True)</span><br><span class="line">		     &#125;</span><br><span class="line">  is_end = False</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="comment"># if word[i] not in it.children:</span></span><br><span class="line">                <span class="comment">#it.children[word[i]] = TrieNode()</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        <span class="keyword">return</span> it.is_end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[prefix[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>旧版本： 冗余了一个if语句if i == len(word) - 1   </p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="comment"># if word[i] not in it.children:</span></span><br><span class="line">                <span class="comment"># it.children[word[i]] = TrieNode()</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span>:</span><br><span class="line">                it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span> <span class="keyword">and</span> it.is_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prefix:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[prefix[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(prefix) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>，n为单词长度。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Pointers</title>
    <url>/2021/12/05/two-pointers/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>left is left pointer, i is right pointer</p>
<p>求最短串</p>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_pointers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		&lt;calculate condition such <span class="keyword">as</span> char_to_count&gt;</span><br><span class="line">		<span class="keyword">while</span> &lt;meets condition&gt;:</span><br><span class="line">			res = min(res, i - left + <span class="number">1</span>)</span><br><span class="line">			&lt;anti-calculate condition such <span class="keyword">as</span> char_to_count&gt;</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> &lt;result&gt;</span><br></pre></td></tr></table></figure>
<p>求最长串</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_pointers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">		&lt;calculate condition such <span class="keyword">as</span> char_to_count&gt;</span><br><span class="line">		<span class="keyword">while</span> &lt;does <span class="keyword">not</span> meet condition&gt;:</span><br><span class="line">			&lt;anti-calculate condition such <span class="keyword">as</span> char_to_count&gt;</span><br><span class="line">			left += <span class="number">1</span></span><br><span class="line">		res = max(res, i - left + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> &lt;result&gt;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
  <entry>
    <title>Union Find</title>
    <url>/2017/12/24/union-find/</url>
    <content><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS用于需要知道具体路径的问题，而并查集方法用于不需知道具体路径只关心连通性的问题。<br>此算法把同一个连通集归结为同一个根节点，作为判断是否一个连通集的标识。它用深度为2的扁平树组织起来。这是查找操作。<br>另一个关键操作是联合两个不同连通集，就是直接把根节点直接作为另一课树的子节点。在这个过程中，新的树深度可能会大于2，但当要union路径大于2的节点是，会对其进行路径压缩。<br>最巧妙的操作当属find操作，将路径进行压缩，变成长度为1的路径，见步骤4。<br>可能有人会考虑用HashMap而不是树，HashMap查找也是很高效，但联合操作比较费时，因为要更新另一个树的所有节点的根节点。</p>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol>
<li>初始化UnionFind类，包括3个属性：count（独立连通数）, parent（某节点的父节点）, rank（连通集排名，只有每个连通集根节点的rank不为0，其他点均为0。这是一个描述连通集规模的变量，如果规模越大，<br>rank值可能越大。合并时候，rank较小的话，规模也较小，这样用rank小的合并到rank大的，需要压缩路径的节点较少，复杂度更低）。合格的节点的parent初始化为自己的id，rank为0，count为所有合格节点数量。</li>
<li>遍历所有节点，<strong>union</strong>此节点及其相邻的节点（如上下左右）</li>
<li>union时候，先<strong>find</strong>两节点的根节点，若相同忽略。若不同，合并此两连通集：rank大的连通集，作为rank小的连通集的父节点。若rank相等，选任一作为另一个的父节点且把它的rank加1。count减1。<br>如下图，union 5和1的，find(6)会进行压缩路径，把6接到5下。<br><img src="/images/union-find-2.png" alt=""></li>
<li>find寻找根节点的同时，压缩成与根节点路径为1的连通。<br><img src="/images/union-find.png" alt=""></li>
</ol>
<p>例子矩阵：<br>{‘0’,’1’,’1’,’0’,’0’}<br>{‘1’,’1’,’1’,’0’,’0’}</p>
<h3 id="应用条件："><a href="#应用条件：" class="headerlink" title="应用条件："></a><strong>应用条件：</strong></h3><p>动态计算连通数如305. Number of Islands II</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>find中是if语句不是while语句，因为递归已经达到</li>
<li>union中，是祖先节点相连，不是输入相连</li>
<li>union的调用在类外面调用，不是在init里做</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, li)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">			self.parent[s] = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[s] != s:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[s] = self.find(self.parent[s])</span><br><span class="line">        <span class="keyword">return</span> self.parent[s]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        root, root2 = self.find(s1), self.find(s2)</span><br><span class="line">        <span class="keyword">if</span> root != root2:</span><br><span class="line">            self.parent[root] = root2 <span class="comment"># remember not self.parent[s] = s2</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>find要注意压缩路径parent[i] = find(parent[i])</p>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] parent;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Initialization</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialize your data structure here.</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找："><a href="#查找：" class="headerlink" title="查找："></a><strong>查找：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">		parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并："><a href="#合并：" class="headerlink" title="合并："></a><strong>合并：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root_a = find(a);</span><br><span class="line">	<span class="keyword">int</span> root_b = find(b);</span><br><span class="line">	<span class="keyword">if</span> (root_a != root_b)</span><br><span class="line">		parent[root_a] = root_b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">// # of connected components</span></span><br><span class="line">	<span class="keyword">int</span>[] parent;</span><br><span class="line">	<span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> m = grid.length;</span><br><span class="line">		<span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">		parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">		rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					parent[i * n + j] = i * n + j;</span><br><span class="line">					++count;</span><br><span class="line">				&#125;</span><br><span class="line">				rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">			parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> parent[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// union point x and y with rank</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rootx = find(x);</span><br><span class="line">		<span class="keyword">int</span> rooty = find(y);</span><br><span class="line">		<span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">				parent[rooty] = rootx;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">				parent[rootx] = rooty;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				parent[rooty] = rootx;</span><br><span class="line">				rank[rootx] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			--count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands3</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr = grid.length;</span><br><span class="line">	<span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">	UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">				grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">				<span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, (r - <span class="number">1</span>) * nc + c);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, (r + <span class="number">1</span>) * nc + c);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。遍历每个节点，而每个节点只会遍历4个相邻节点。</p>
<h3 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a><strong>Ref：</strong></h3><p><a href="http://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">并查集(Union-Find)算法介绍</a></p>
]]></content>
      <tags>
        <tag>Knowledge Base</tag>
      </tags>
  </entry>
</search>
