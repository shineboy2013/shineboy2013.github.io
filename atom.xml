<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-21T03:35:06.745Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-721/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-721/</id>
    <published>2022-01-21T03:34:29.553Z</published>
    <updated>2022-01-21T03:35:06.745Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>处理名字</li><li>union要处理重复</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/</id>
    <published>2022-01-20T10:10:33.912Z</published>
    <updated>2022-01-20T10:23:45.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br><br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br><br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,4,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,1,3,4,2]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>nums.length == n + 1</code><br><em>   <code>1 &lt;= nums[i] &lt;= n</code></em>   All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.<br><br><strong>Follow up:</strong><br><br><em>   How can we prove that at least one duplicate number must exist in <code>nums</code>?</em>   Can you solve the problem in linear runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数值二分法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li><li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line"><span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line"><span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 286 Walls and Gates</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/</id>
    <published>2022-01-20T09:36:10.895Z</published>
    <updated>2022-01-20T09:43:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values.<br><br><em>   <code>-1</code> A wall or an obstacle.</em>   <code>0</code> A gate.<br><em>   <code>INF</code> Infinity means an empty room. We use the value <code>2&lt;sup&gt;31&lt;/sup&gt; - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.<br><br>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt=""><br><br><pre><strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br><strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> rooms = [[-1]]<br><strong>Output:</strong> [[-1]]<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == rooms.length</code><br><em>   <code>n == rooms[i].length</code></em>   <code>1 &lt;= m, n &lt;= 250</code><br>*   <code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有房间到门的最短距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>属于多始点BFS类型</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>门的距离不更新，所以出列后要判断该点是否为门，不是用距离来判断</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OFFSET = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        gates = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rooms)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(rooms[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    gates.append((i, j, <span class="number">0</span>))</span><br><span class="line">        queue = collections.deque(gates)</span><br><span class="line">        visited = set(gates)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, distance = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> rooms[x][y] != <span class="number">0</span>: <span class="comment"># not distance != 0</span></span><br><span class="line">                rooms[x][y] = distance</span><br><span class="line">            <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">                _x, _y = x + _dx, y + _dy</span><br><span class="line">                <span class="keyword">if</span> _x &lt; <span class="number">0</span> <span class="keyword">or</span> _x &gt;= len(rooms) <span class="keyword">or</span> _y &lt; <span class="number">0</span> <span class="keyword">or</span> _y &gt;= len(rooms[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        rooms[_x][_y] == <span class="number">-1</span> <span class="keyword">or</span> (_x, _y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((_x, _y, distance + <span class="number">1</span>))</span><br><span class="line">                visited.add((_x, _y))</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(mn)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/walls-and-gates/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Yo
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 283 Move Zeroes</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/</id>
    <published>2022-01-20T08:58:11.187Z</published>
    <updated>2022-01-20T09:00:49.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.<br><br><strong>Note</strong> that you must do this in-place without making a copy of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,12]<br><strong>Output:</strong> [1,3,12,0,0]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you minimize the total number of operations done?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将数组的0全部移到数组末</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。Quicksort的partition的应用</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">non_zero_idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">nums[i], nums[non_zero_idx] = nums[non_zero_idx], nums[i]</span><br><span class="line">non_zero_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 282 Expression Add Operators</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/</id>
    <published>2022-01-20T07:00:41.425Z</published>
    <updated>2022-01-20T08:59:51.182Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/expression-add-operators" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators</em> <code>&#39;+&#39;</code><em>,</em> <code>&#39;-&#39;</code><em>, and/or</em> <code>&#39;*&#39;</code> <em>between the digits of</em> <code>num</code> <em>so that the resultant expression evaluates to the</em> <code>target</code> <em>value</em>.<br><br>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = “123”, target = 6<br><strong>Output:</strong> [“1<em>2</em>3”,”1+2+3”]<br><strong>Explanation:</strong> Both “1<em>2</em>3” and “1+2+3” evaluate to 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = “232”, target = 8<br><strong>Output:</strong> [“2<em>3+2”,”2+3</em>2”]<br><strong>Explanation:</strong> Both “2<em>3+2” and “2+3</em>2” evaluate to 8.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = “3456237490”, target = 9191<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no expressions that can be created from “3456237490” to evaluate to 9191.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num.length &lt;= 10</code></em>   <code>num</code> consists of only digits.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= target &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一串数字加入加减乘能得到target的所有可能性</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有可能用DFS。属于分割型DFS，在数位之间加符号，数位可以是1个到多个。<br>一轮递归分割出符号 + 数字<br>另一种选择是数字 + 符号，但需要额外变量sign，因为不能立刻计算到结果。也不符合正常逻辑。所以选择前者。</p><p>由于运算都是二元，也就是用上述分割法，第一个数要特别处理。所以DFS中要特别处理第一个数。这样可以开始写加减。引入prev_res作为DFS参数，这样只要prev_res 加减 该轮数字即可得到该轮结果。用DFS模板5个标准参数外加prev_res：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_res, path, res):</span><br></pre></td></tr></table></figure></p><p>这样只处理加减的DFS比较容易实现  </p><p>最大难点在于乘法，参考LeetCode 227 Basic Calculator II，加减和乘除属于两层计算需要分别处理，所以引入<strong>新参数prev_multi_res，用于保存乘法结果，而刚才的命名为prev_add_res保存加减乘的全部结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_add_res, prev_multi_res, path, res):</span><br></pre></td></tr></table></figure></p><p>举例2+3*4，按照原来的逻辑会计算到2+3=5，但此时如果遇到乘号，就要重新计算加法结果，先减去乘法结果，退回到2，再计算3*4=12这是乘法结果，再加回2得到新加法结果。进一步理解prev_multi_res，如果该轮是加减法，仍要将该轮的数作为prev_multi_res传到下轮DFS，因为如果下一轮是乘法，它就是第一个乘法的数。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>先实现加减法</li><li>再实现乘法</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>分割型DFS，选择每轮递归分割符号 + 数字。由于运算都是二元，<strong>特别处理第一个数</strong></li><li>引入参数prev_add_res, prev_multi_res. <strong>prev_multi_res若是加减，用(+/-)cur_num, 否则用乘法结果prev_multi_res * cur_num</strong>。注意若是减法cur_num用负号</li><li>分割时数字不能有前缀0</li><li>prev_res不用恢复状态因为是标量</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span><span class="params">(self, num: str, target: int)</span> -&gt; List[str]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(num, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, st, target, prev_add_res, prev_multi_res, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(num):</span><br><span class="line"><span class="keyword">if</span> target == prev_add_res:</span><br><span class="line">res.append(path)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(num)):</span><br><span class="line"><span class="keyword">if</span> i &gt; st <span class="keyword">and</span> num[st] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">cur_num = int(num[st:i + <span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> path: <span class="comment"># remember</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, str(cur_num), res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, path + <span class="string">'+'</span> + str(cur_num), res) <span class="comment"># use cur_num rather than cur</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res - cur_num, -cur_num, path + <span class="string">'-'</span> + str(cur_num), res) <span class="comment"># -cur_num rather than cur_num</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, (prev_add_res - prev_multi_res) + prev_multi_res * cur_num, prev_multi_res * cur_num, path + <span class="string">'*'</span> + str(cur_num), res) <span class="comment"># prev_multi_res * cur_num not cur_num</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(4<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>, 因为每个字符之间都有不加操作符，加3个操作符，所以是4，有n-1个间隔  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/expression-add-operators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 277 Find the Celebrity</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/</id>
    <published>2022-01-20T04:06:37.308Z</published>
    <updated>2022-01-20T04:20:05.576Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.<br><br>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is ask questions like: “Hi, A. Do you know B?” to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).<br><br>You are given a helper function <code>bool knows(a, b)</code> that tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.<br><br>Return <em>the celebrity’s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There is no celebrity.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == graph.length</code></em>   <code>n == graph[i].length</code><br><em>   <code>2 &lt;= n &lt;= 100</code></em>   <code>graph[i][j]</code> is <code>0</code> or <code>1</code>.<br><em>   <code>graph[i][i] == 1</code><br><br><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is `3 </em> n`, could you find a solution without exceeding the maximum number of calls?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过调用a是否认识b函数，找出名人。名人是除自己的所有人都认识他，他不认识其他所有人</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 169 Majority Element，用水王法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>找出可能名人，通过查看是否i后面的每一个人都认识i，若不是将candidate换成当前下标</li><li>按定义验证第一步的结果是否名人，两步验证</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>按照定义，若i不认识candiate才换candidate，用not。因为edge case是没有边或者图存在循环</li><li>验证时候，第二步验证candidate若认识任意人就不是名人，排除candidate认识自己。题目条件candidate认识自己。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment"># find potential candidate</span></span><br><span class="line">candidate = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">candidate = i</span><br><span class="line"><span class="comment"># validate</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> candidate != i <span class="keyword">and</span> knows(candidate, i):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-celebrity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 270 Closest Binary Search Tree Value</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/</id>
    <published>2022-01-19T10:20:20.197Z</published>
    <updated>2022-01-19T10:28:34.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">LeetCode</a></strong></p><div>Given the <code>root</code> of a binary search tree and a <code>target</code> value, return <em>the value in the BST that is closest to the</em> <code>target</code>. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 4.428571<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>. </em> <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code> * <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求BST中最接近target的值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>接近target的值在BST搜索路径上，越后搜索到的(越后入栈的)越接近，但最接近的可能大于或小于target(predecessors or successors)，只能逐一比较.<br>类似于LeetCode 272 Closest Binary Search Tree Value II</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>循环中用it，不能用root，注意检查</li><li>接近target的值在BST搜索路径上，逐一比较</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root: TreeNode, target: float)</span> -&gt; int:</span></span><br><span class="line">closest_vals = []</span><br><span class="line">it = root</span><br><span class="line"><span class="keyword">while</span> it:</span><br><span class="line">closest_vals.append(it.val)</span><br><span class="line"><span class="keyword">if</span> target &lt; it.val:</span><br><span class="line">it = it.left</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">it = it.right</span><br><span class="line">min_val, res = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> closest_vals:</span><br><span class="line"><span class="keyword">if</span> abs(target - n) &lt; min_val:</span><br><span class="line">min_val = abs(target - n)</span><br><span class="line">res = n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(h)</code>，空间复杂度<code>O(h)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/closest-binary-search-tree-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 268 Missing Number</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/</id>
    <published>2022-01-19T09:14:29.294Z</published>
    <updated>2022-01-19T09:23:13.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= nums[i] &lt;= n</code></em>   All the numbers of <code>nums</code> are <strong>unique</strong>.<br><br><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组缺失一个数，所有数应该在[0, n]内，求缺失数</p><h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="异或法解题思路II："><a href="#异或法解题思路II：" class="headerlink" title="异或法解题思路II："></a><strong>异或法解题思路II：</strong></h3><p>高斯原理</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">res = len(nums) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">res ^= i ^ n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p><hr><h3 id="数学法解题思路III："><a href="#数学法解题思路III：" class="headerlink" title="数学法解题思路III："></a><strong>数学法解题思路III：</strong></h3><p>高斯原理</p><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">n = len(nums)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> + n) * (n + <span class="number">1</span>) // <span class="number">2</span> - sum(nums)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Giv
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 266 Palindrome Permutation</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/</id>
    <published>2022-01-19T09:04:18.224Z</published>
    <updated>2022-01-19T09:07:29.265Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <code>true</code> if a permutation of the string could form a palindrome.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “code”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “carerac”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 5000</code></em>   <code>s</code> consists of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串的任一全排列是否存在回文字符串</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，也就是统计字符频率，奇数频率的字符最多有1个</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>统计字符频率，奇数频率的字符最多有1个</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 256 Paint House</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/</id>
    <published>2022-01-19T08:43:00.412Z</published>
    <updated>2022-01-19T08:51:13.879Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is a row of <code>n</code> houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br><br>The cost of painting each house with a certain color is represented by an <code>n x 3</code> cost matrix <code>costs</code>.<br><br><em>   For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with the color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on…<br><br>Return <em>the minimum cost to paint all houses</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> costs = [[17,2,17],[16,16,5],[14,3,19]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>Minimum cost: 2 + 5 + 3 = 10.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> costs = [[7,6,2]]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong></em>   <code>costs.length == n</code><br><em>   <code>costs[i].length == 3</code></em>   <code>1 &lt;= n &lt;= 100</code><br>*   <code>1 &lt;= costs[i][j] &lt;= 20</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排屋相邻不同色地涂色(3色)的最低成本</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>低频题。最值且涉及数值考虑用DP。由于相邻不能同色，所以是多状态DP，有3个状态，不妨多用一维表示，第二维只有3值。<br>dp[i][j]定义为第i间屋涂上第j色的最低总费用，递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归5步曲，多1，初始，多1，少1，答案。记得第一步初始化数组多1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(costs) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">return</span> min(dp[<span class="number">-1</span>][<span class="number">0</span>], dp[<span class="number">-1</span>][<span class="number">1</span>], dp[<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/paint-house/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;There 
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 249 Group Shifted Strings</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-249-group-shifted-strings/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-249-group-shifted-strings/</id>
    <published>2022-01-19T07:01:09.770Z</published>
    <updated>2022-01-19T07:07:20.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/group-shifted-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>We can shift a string by shifting each of its letters to its successive letter.<br><br><em>   For example, <code>&quot;abc&quot;</code> can be shifted to be <code>&quot;bcd&quot;</code>.<br><br>We can keep shifting the string to form a sequence.</em>   For example, we can keep shifting <code>&quot;abc&quot;</code> to form the sequence: <code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code>.<br><br>Given an array of strings <code>strings</code>, group all <code>strings[i]</code> that belong to the same shifting sequence. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strings = [“abc”,”bcd”,”acef”,”xyz”,”az”,”ba”,”a”,”z”]<br><strong>Output:</strong> [[“acef”],[“a”,”z”],[“abc”,”bcd”,”xyz”],[“az”,”ba”]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strings = [“a”]<br><strong>Output:</strong> [[“a”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strings.length &lt;= 200</code></em>   <code>1 &lt;= strings[i].length &lt;= 50</code><br>*   <code>strings[i]</code> consists of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将单词按等偏移量分组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>单词分组题，设计一个id。组内的每个单词里字母之间的差值是一致的，如abd, wxz, 差值分别为1和2，这是同一组。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求每个单词每个字母之间的差值，用下滑线连接作为id。注意差值可能为负数，所以要取mod变正</li><li>单一字母单词，不存在偏移量，id为空，所以代码不需要特殊处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span><span class="params">(self, strings: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">res = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">_id = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">_id += str((ord(s[j]) - ord(s[j - <span class="number">1</span>])) % <span class="number">26</span>) + <span class="string">'_'</span></span><br><span class="line">res[_id].append(s)</span><br><span class="line"><span class="keyword">return</span> list(res.values())</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>, n为单词个数, m为单词最长长度。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/group-shifted-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 243 Shortest Word Distance</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-243-shortest-word-distance/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-243-shortest-word-distance/</id>
    <published>2022-01-19T06:40:05.278Z</published>
    <updated>2022-01-19T06:42:46.603Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-word-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of strings <code>wordsDict</code> and two different strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between these two words in the list</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “coding”, word2 = “practice”<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “makes”, word2 = “coding”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= wordsDict.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>1 &lt;= wordsDict[i].length &lt;= 10<code>*</code>wordsDict[i]<code>consists of lowercase English letters.*</code>word1<code>and</code>word2<code>are in</code>wordsDict<code>.*</code>word1 != word2`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求单词列表中给定的两个单词的最短下标距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同向双指针</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>同向双指针，分别指向两单词，计算结果时必须是找到才比较</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, wordsDict: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">p1 = p2 = <span class="number">-1</span></span><br><span class="line">res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(wordsDict):</span><br><span class="line"><span class="keyword">if</span> word == word1:</span><br><span class="line">p1 = i</span><br><span class="line"><span class="keyword">if</span> word == word2:</span><br><span class="line">p2 = i</span><br><span class="line"><span class="keyword">if</span> p1 != <span class="number">-1</span> <span class="keyword">and</span> p2 != <span class="number">-1</span>:</span><br><span class="line">res = min(res, abs(p1 - p2))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-word-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 242 Valid Anagram</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-242-valid-anagram/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-242-valid-anagram/</id>
    <published>2022-01-19T06:20:06.174Z</published>
    <updated>2022-01-19T06:23:31.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “nagaram”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “rat”, t = “car”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, t.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s<code>and</code>t` consist of lowercase English letters.<br><br><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>验证变位词</p><h3 id="频率法解题思路-推荐-："><a href="#频率法解题思路-推荐-：" class="headerlink" title="频率法解题思路(推荐)："></a><strong>频率法解题思路(推荐)：</strong></h3><p>简单题</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="排序法算法II解题思路："><a href="#排序法算法II解题思路：" class="headerlink" title="排序法算法II解题思路："></a><strong>排序法算法II解题思路：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 241 Different Ways to Add Parentheses</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-241-different-ways-to-add-parentheses/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-241-different-ways-to-add-parentheses/</id>
    <published>2022-01-19T05:02:03.991Z</published>
    <updated>2022-01-19T05:13:13.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “2-1-1”<br><strong>Output:</strong> [0,2]<br><strong>Explanation:</strong><br>((2-1)-1) = 0<br>(2-(1-1)) = 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “2<em>3-4</em>5”<br><strong>Output:</strong> [-34,-14,-10,-10,10]<br><strong>Explanation:</strong><br>(2<em>(3-(4</em>5))) = -34<br>((2<em>3)-(4</em>5)) = -14<br>((2<em>(3-4))</em>5) = -10<br>(2<em>((3-4)</em>5)) = -10<br>(((2<em>3)-4)</em>5) = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= expression.length &lt;= 20</code></em>   <code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.<br>*   All the integer values in the input expression are in the range <code>[0, 99]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串含数字和加减乘除，求所有加括号方法得到的结果</p><h3 id="Catalan解题思路-推荐-："><a href="#Catalan解题思路-推荐-：" class="headerlink" title="Catalan解题思路(推荐)："></a><strong>Catalan解题思路(推荐)：</strong></h3><p>求所有结果，用DFS，由于需要左右递归，双边递归，所以用Catalan法模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>终止条件返回是一个list</strong></li><li>Python中用eval来计算字符串运算结果返回值为整数，所以归纳左右递归结果要用str转为字符串</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, expression: str)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> expression.isdigit():</span><br><span class="line"><span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">left_res = self.diffWaysToCompute(expression[:i])</span><br><span class="line">right_res = self.diffWaysToCompute(expression[i + <span class="number">1</span>:])</span><br><span class="line">res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code></p><hr><h3 id="记忆性搜索算法II解题思路："><a href="#记忆性搜索算法II解题思路：" class="headerlink" title="记忆性搜索算法II解题思路："></a><strong>记忆性搜索算法II解题思路：</strong></h3><p>大致同上，只不过加入记忆性搜索算法，但优化不算大</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute2</span><span class="params">(self, expression)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(expression, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, expression: str, cache)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> expression.isdigit():</span><br><span class="line"><span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line"><span class="keyword">if</span> expression <span class="keyword">in</span> cache:</span><br><span class="line"><span class="keyword">return</span> cache[expression]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">left_res = self.dfs(expression[:i], cache)</span><br><span class="line">right_res = self.dfs(expression[i + <span class="number">1</span>:], cache)</span><br><span class="line">res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line">cache[expression] = res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/different-ways-to-add-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Recursion" scheme="https://shineboy2013.github.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 095 Unique Binary Search Trees II</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-095-unique-binary-search-trees-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-095-unique-binary-search-trees-ii/</id>
    <published>2022-01-19T04:06:57.336Z</published>
    <updated>2022-01-19T04:12:07.050Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST’</strong>s (binary search trees), which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt=""><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 8</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求所有val为1-n的BST的所有可能性</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS中比较难的catalan类型。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>root = TreeNode(i)要在最内层for循环中</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt; end:</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line"><span class="keyword">if</span> start == end:</span><br><span class="line"><span class="keyword">return</span> [TreeNode(start)]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">left_nodes = self.dfs(start, i - <span class="number">1</span>)</span><br><span class="line">right_nodes = self.dfs(i + <span class="number">1</span>, end)</span><br><span class="line"><span class="keyword">for</span> _l <span class="keyword">in</span> left_nodes:</span><br><span class="line"><span class="keyword">for</span> _r <span class="keyword">in</span> right_nodes:</span><br><span class="line">root = TreeNode(i)</span><br><span class="line">root.left = _l</span><br><span class="line">root.right = _r</span><br><span class="line">res.append(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-binary-search-trees-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 240 Search a 2D Matrix II</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-240-search-a-2d-matrix-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-240-search-a-2d-matrix-ii/</id>
    <published>2022-01-19T03:11:37.299Z</published>
    <updated>2022-01-19T03:21:31.318Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Write an efficient algorithm that searches for a <code>target</code> value in an <code>m x n</code> integer <code>matrix</code>. The <code>matrix</code> has the following properties:<br><br><em>   Integers in each row are sorted in ascending from left to right.</em>   Integers in each column are sorted in ascending from top to bottom.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code></em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= n, m &lt;= 300</code></em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All the integers in each row are <strong>sorted</strong> in ascending order.</em>   All the integers in each column are <strong>sorted</strong> in ascending order.<br>*   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵按行按列有序，求是否存在target</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>矩阵有序题有3道：<br>LeetCode 074 Search a 2D Matrix 每一行有序，下一行的首元素大于上一行的尾元素 + 找target<br>LeetCode 240 Search a 2D Matrix II 按行按列有序 + 找target<br>LeetCode 378 Kth Smallest Element in a Sorted Matrix 按行按列有序 + 找第k大<br>矩阵结构方面，第一道每一行都是独立，所以可以独立地按行按列做二分法<br>后两道，矩阵二维连续，所以解法都是类BFS，从某个点开始，然后比较它相邻的两个点。出发点不同，第二道在近似矩阵中点(右上角或左下角)，第三道在左上角出发。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>从右上角出发，比较左和下节点。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> target &lt; matrix[i][j]:</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 235 Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-235-lowest-common-ancestor-of-a-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-235-lowest-common-ancestor-of-a-binary-tree/</id>
    <published>2022-01-19T01:51:21.005Z</published>
    <updated>2022-01-19T02:51:27.156Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br><br>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [2,1], p = 2, q = 1<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> will exist in the BST.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>BST中求给定的两节点的最低共同父亲节点</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况，也是用DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>pq一定存在，所以有**三种情况： 1) p或q是root，另一是其子孙。 2) p，q分列root两边。 3) p，q在root的一边。跟LeetCode 236 Lowest Common Ancestor of a Binary Tree不同的是，<br>第二种情况，不用递归即知道，因为这是BST。第一和第三种情况同</li><li>第二种情况由于要比较p, q, root顺序，所以要令p, q有序，Line 4-5</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> p.val &gt; q.val: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root, q, p)</span><br><span class="line"><span class="keyword">if</span> p.val &lt;= root.val &lt;= q.val <span class="keyword">or</span> p == root <span class="keyword">or</span> q == root: <span class="comment"># remember root is p or q</span></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 234 Palindrome Linked List</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-234-palindrome-linked-list/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-234-palindrome-linked-list/</id>
    <published>2022-01-19T00:53:52.430Z</published>
    <updated>2022-01-19T01:04:22.374Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,2,1]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is in the range <code>[1, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.</em>   <code>0 &lt;= Node.val &lt;= 9</code><br><br><strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一个LL是否回文</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>快慢指针 + Stack</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>快慢指针找到中点，找的同时，慢指针所有节点入栈。慢指针继续走，比较stack节点和慢指针节点。</li><li><strong>不涉及删除，所以不需要哟用到fake_node</strong></li><li><strong>中位数可能有1-2个</strong>。奇偶问题，若fast指向节点(另一情况是None), 表明是奇数个，slow在第二个循环前多走一步，跳过最中间的节点</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">fast, slow = head, head</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">stack.append(slow)</span><br><span class="line">slow = slow.next</span><br><span class="line">fast = fast.next.next</span><br><span class="line"><span class="keyword">if</span> fast:</span><br><span class="line">slow = slow.next</span><br><span class="line"><span class="keyword">while</span> slow:</span><br><span class="line"><span class="keyword">if</span> stack.pop().val != slow.val:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">slow = slow.next</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 296 Best Meeting Point</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-296-best-meeting-point/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-296-best-meeting-point/</id>
    <published>2022-01-18T22:31:59.677Z</published>
    <updated>2022-01-18T22:39:09.369Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> binary grid <code>grid</code> where each <code>1</code> marks the home of one friend, return <em>the minimal <strong>total travel distance</strong></em>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/meetingpoint-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> Given three friends living at (0,0), (0,4), and (2,2).<br>The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.<br>So return 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,1]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code></em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><em>   There will be <em>*at least two</em></em> friends in the <code>grid</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中1表示朋友的位置，求最佳见面位置，所有朋友到这个位置曼哈顿距离最短。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是数学题也是非高频题。如果是一维，求最佳位置，是所有朋友位置的中点，也就是左边朋友和右边朋友的数量是一样。求距离也就是用相向双指针，求每对点的距离。<br>推广到二维，同理，x和y坐标是独立的。分别求距离即可。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用相向双指针，求每对点的距离</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTotalDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">x_coordinates, y_coordinates = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">x_coordinates.append(i)</span><br><span class="line">y_coordinates.append(j)</span><br><span class="line">x_coordinates.sort()</span><br><span class="line">y_coordinates.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">left, right = <span class="number">0</span>, len(y_coordinates) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">res += y_coordinates[right] - y_coordinates[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">left, right = <span class="number">0</span>, len(x_coordinates) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">res += x_coordinates[right] - x_coordinates[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>, n为矩阵的长边大小  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-meeting-point/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 218 The Skyline Problem</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-218-the-skyline-problem/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-218-the-skyline-problem/</id>
    <published>2022-01-18T10:14:23.929Z</published>
    <updated>2022-01-18T22:03:00.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A city’s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.<br><br>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left&lt;sub&gt;i&lt;/sub&gt;, right&lt;sub&gt;i&lt;/sub&gt;, height&lt;sub&gt;i&lt;/sub&gt;]</code>:<br><br><em>   <code>left&lt;sub&gt;i&lt;/sub&gt;</code> is the x coordinate of the left edge of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.</em>   <code>right&lt;sub&gt;i&lt;/sub&gt;</code> is the x coordinate of the right edge of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.<br><em>   <code>height&lt;sub&gt;i&lt;/sub&gt;</code> is the height of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> building.<br><br>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.<br><br>The <strong>skyline</strong> should be represented as a list of “key points” <strong>sorted by their x-coordinate</strong> in the form <code>[[x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;],[x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.<br><br><strong>Note:</strong> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt=""><br><br><pre><strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]<br><strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]<br><strong>Explanation:</strong><br>Figure A shows the buildings of the input.<br>Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]<br><strong>Output:</strong> [[0,3],[5,0]]<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= buildings.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= left&lt;sub&gt;i&lt;/sub&gt; &lt; right&lt;sub&gt;i&lt;/sub&gt; &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></em>   <code>1 &lt;= height&lt;sub&gt;i&lt;/sub&gt; &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br>*   <code>buildings</code> is sorted by <code>left&lt;sub&gt;i&lt;/sub&gt;</code> in non-decreasing order.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p><strong>Heap(高度最大堆) + 端点排序法(先端点再高度逆序)</strong><br>不是高频题，但思路值得学习<br>Heap(高度最大堆): LeetCode 253 Meeting Rooms II方法一，终点的最小堆<br>端点排序法(先端点再高度逆序)： LeetCode 253 Meeting Rooms II方法二<br>meeting room是新线段的start逼栈顶终点出堆，此题也是同样，但用<strong>高度的最大堆</strong>维护当前最高大厦，这与题意符合。</p><ul><li><p>为什么要加入结束点?<br><img src="/images/L218.png" alt=""><br>两种情况，第一种情况没有问题，但第二种情况就会漏掉第一栋大厦的结束点。原因是出堆的点没有被处理，但出堆的点可能有多个而且若没有新大厦它不能出堆，所以结束点逼它出堆。</p></li><li><p>为什么高度逆序?<br><img src="/images/L218-2.png" alt=""><br>第一种情况在坐标2这个位置有两节点(2, 0, 0)第一栋大厦结束点, (2, 5, 3)第二栋大厦开始点，若不按高度排序，第一栋结束点会逼第一栋开始点出堆，产生天际线。若按高度逆序，后者先入堆，第一栋开始点出堆也不会产生天际线。类似于heapq.heapreplace先加入再删除或者LeetCode 354 Russian Doll Envelopes的排序方式</p></li></ul><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>先顺序排序端点再逆序高度</strong>，因为当结束点和始点重合时，让高度大的先入堆可以确保不会产生矮的天际线，否则这些矮的天际线实际被包含在高的大厦里。</li><li><strong>结束点也要加入循环但不入堆</strong>。这样产生两点：<br>1) start &gt;= heap[0][1]要取等号，否则不能让这栋大厦结束点出堆。<br>2) 结束点不入堆，因为它只用于产生结束点从而加入到结果集，它不产生高度，只有产生高度的点才会被加入到堆</li><li>与前高度不同，也就是高度发生变化就入堆</li><li>确保res[-1][1] != -heap[0][0]。用只有一栋大厦作为test case。<br>1) 因为用到了res[-1][1]，所以res初始化加入[0, 0]，第一个值不会用到所以无所谓，第二个值取非整数即可；<br>2) 最后结果要排除这个点，取res[1:]<br>3) 由于heap要永远有节点。初始化加入[0, float(‘inf’)]，高度为0，用于产生在地平线的点的高度，结束点为无穷大，确保不会被逼出堆。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSkyline</span><span class="params">(self, buildings: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">events = sorted(buildings + [[end, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _, end, _ <span class="keyword">in</span> buildings], key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">2</span>]))</span><br><span class="line">heap, res = [(<span class="number">0</span>, float(<span class="string">'inf'</span>))], [[<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> start, end, height <span class="keyword">in</span> events:</span><br><span class="line"><span class="keyword">while</span> heap <span class="keyword">and</span> start &gt;= heap[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> height &gt; <span class="number">0</span>: <span class="comment"># don't push ends into the heap</span></span><br><span class="line">heapq.heappush(heap, (-height, end))</span><br><span class="line"><span class="keyword">if</span> res[<span class="number">-1</span>][<span class="number">1</span>] != -heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">res.append([start, -heap[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">return</span> res[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(k)</code>, k为重合天际线个数，此复杂度跟Meeting Rooms II一致  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/the-skyline-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
  </entry>
  
</feed>
