<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-15T07:55:28.173Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 078 Subsets</title>
    <link href="https://shineboy2013.github.com/2022/01/14/lee-078/"/>
    <id>https://shineboy2013.github.com/2022/01/14/lee-078/</id>
    <published>2022-01-15T07:51:55.350Z</published>
    <updated>2022-01-15T07:55:28.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>组合知识点</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求结果含空集</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">res = [[]]</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(nums):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">path.append(nums[i])</span><br><span class="line">res.append(list(path))</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 065 Valid Number</title>
    <link href="https://shineboy2013.github.com/2022/01/13/lee-065/"/>
    <id>https://shineboy2013.github.com/2022/01/13/lee-065/</id>
    <published>2022-01-14T00:29:29.725Z</published>
    <updated>2022-01-14T01:13:53.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A <strong>valid number</strong> can be split up into these components (in order):<br><br>1.  A <strong>decimal number</strong> or an <strong>integer</strong>.<br>2.  (Optional) An <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code>, followed by an <strong>integer</strong>.<br><br>A <strong>decimal number</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One of the following formats:<br>    1.  One or more digits, followed by a dot <code>&#39;.&#39;</code>.<br>    2.  One or more digits, followed by a dot <code>&#39;.&#39;</code>, followed by one or more digits.<br>    3.  A dot <code>&#39;.&#39;</code>, followed by one or more digits.<br><br>An <strong>integer</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One or more digits.<br><br>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code>, while the following are not valid numbers: <code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>valid number</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “0”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “e”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “.”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 20</code></em>   <code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求合法小数指数形式</p><h3 id="类括号法解题思路-推荐-："><a href="#类括号法解题思路-推荐-：" class="headerlink" title="类括号法解题思路(推荐)："></a><strong>类括号法解题思路(推荐)：</strong></h3><p>有四种symbol，要保证先后关系。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>有四种symbol： 符号，数字，dot，exp。保证先后关系。<strong>exp的前后部分是独立的，唯一区别是后部分不能有dot</strong>，如1e2.2</li><li>实现类似于括号题用if语句来分别处理每种symbol：前面不能出现什么符号(<strong>e后面不能出现小数</strong>，也就是小数前面不能出现e)，或必须出现什么符号(仅一种情况：<strong>e前面必须出现数字</strong>)，如1e2. 然后该符号赋True</li><li>for循环后检查单个字符且不含数字情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">is_sign, is_digit, is_dot, is_exp = <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line"><span class="keyword">if</span> is_sign <span class="keyword">or</span> is_digit <span class="keyword">or</span> is_dot:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">is_digit = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] == <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">if</span> is_dot <span class="keyword">or</span> is_exp: <span class="comment"># 1e2.2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line"><span class="keyword">if</span> is_exp <span class="keyword">or</span> <span class="keyword">not</span> is_digit: <span class="comment"># e2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_exp = <span class="keyword">True</span></span><br><span class="line">is_digit = <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">False</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> (is_exp <span class="keyword">or</span> is_dot <span class="keyword">or</span> is_sign) <span class="keyword">and</span> <span class="keyword">not</span> is_digit <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="DFA算法II解题思路-不推荐-："><a href="#DFA算法II解题思路-不推荐-：" class="headerlink" title="DFA算法II解题思路(不推荐)："></a><strong>DFA算法II解题思路(不推荐)：</strong></h3><p>Deterministic Finite Automaton (DFA)状态机，也就是将状态写入一个map中作为config，代码较简洁，但很难想。</p><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;A &lt;st
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 063 Unique Paths II</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-063/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-063/</id>
    <published>2022-01-05T11:21:06.701Z</published>
    <updated>2022-01-05T11:25:12.631Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked 'Start' in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<strong>Output:</strong> 2<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]<strong>Output:</strong> 1&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵路径总数。有障碍</p><h3><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1] if obstacle[i][j-1] == 0</span><br><span class="line">         = 0                       if obstacle[i][j-1] == 1</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>obstacleGrid[i][j-1], j-1因为dp从1开始, 但i不是，因为dp不含i。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(obstacleGrid[<span class="number">0</span>]) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 062 Unique Paths</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-062/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-062/</id>
    <published>2022-01-05T11:14:56.806Z</published>
    <updated>2022-01-05T11:20:52.897Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10&lt;sup&gt;9&lt;/sup&gt;</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> m = 3, n = 7<strong>Output:</strong> 28&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> m = 3, n = 2<strong>Output:</strong> 3<strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Down&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵路径总数</p><h3><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>初始值dp[1] = 1而不是dp[0] = 1因为第二行的第一格不能加左边的虚拟格=1</li><li>range(m)不是range(len(m))</li><li>优化空间用一维</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># remember not dp[0] = 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m): <span class="comment"># remember no len(m)</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 064 Minimum Path Sum</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-064/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-064/</id>
    <published>2022-01-05T11:03:23.931Z</published>
    <updated>2022-01-05T11:08:16.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]<strong>Output:</strong> 7<strong>Explanation:</strong> Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]<strong>Output:</strong> 12&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵最短路径和。只能向下向右走。</p><h3><strong>解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>初始值为最大值，dp[0][1] = dp[1][0] = 0确保左上格正确。</li><li>模板四点注意事项</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid) + <span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 427 Construct Quad Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-427/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-427/</id>
    <published>2022-01-05T04:03:21.417Z</published>
    <updated>2022-01-05T04:47:19.236Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/construct-quad-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a <code>n * n</code> matrix <code>grid</code> of <code>0's</code> and <code>1's</code> only. We want to represent the <code>grid</code> with a Quad-Tree.</p><p>Return <em>the root of the Quad-Tree</em> representing the <code>grid</code>.</p><p>Notice that you can assign the value of a node to <strong>True</strong> or <strong>False</strong> when <code>isLeaf</code> is <strong>False</strong>, and both are <strong>accepted</strong> in the answer.</p><p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p><ul><li><code>val</code>: True if the node represents a grid of 1's or False if the node represents a grid of 0's.</li><li><code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.</li></ul><p>&lt;pre&gt;class Node {public boolean val;public boolean isLeaf;public Node topLeft;public Node topRight;public Node bottomLeft;public Node bottomRight;}&lt;/pre&gt;</p><p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p><ol><li>If the current grid has the same value (i.e all <code>1's</code> or all <code>0's</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.</li><li>If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.</li><li>Recurse for each of the children with the proper sub-grid.</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt=""></p><p>If you want to know more about the Quad-Tree, you can refer to the <a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank" rel="noopener">wiki</a>.</p><p><strong>Quad-Tree format:</strong></p><p>The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.</p><p>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.</p><p>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[0,1],[1,0]]<strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]<strong>Explanation:</strong> The explanation of this example is shown below:Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.<img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt="">&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]<strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]<strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.The topLeft, bottomLeft and bottomRight each has the same value.The topRight have different values so we divide it into 4 sub-grids where each has the same value.Explanation is shown in the photo below:<img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt="">&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2&lt;sup&gt;x&lt;/sup&gt;</code> where <code>0 &lt;= x &lt;= 6</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>由矩阵建四叉树。矩阵有0和1组成。按以下步骤：若子矩阵(变成为2的幂)只含1或0，生成一个叶子节点，值为该值；子矩阵含0和1混合，值为0或1(均为答案)，非叶子节点，递归四个同样大小的矩阵生成相应节点。<br>矩阵大小为2的幂，最小长度为1.</p><h3><strong>presum解题思路(推荐)：</strong></h3><p>这是我的方法，按照定义求解，定义是递归的，所以用DFS。而统计子矩阵和用presum提高效率。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>子矩阵presum用模板</li><li>终止条件为子矩阵sum是0或n平方</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(self, grid: List[List[int]])</span> -&gt; 'Node':</span></span><br><span class="line">presum = self.get_presum(grid)</span><br><span class="line"><span class="keyword">return</span> self.dfs(grid, (<span class="number">0</span>, <span class="number">0</span>), (len(grid) - <span class="number">1</span>, len(grid[<span class="number">0</span>]) - <span class="number">1</span>), presum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">grim_sum = self.get_grid_sum(top_left, bottom_right, presum)</span><br><span class="line"><span class="keyword">if</span> grim_sum == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">0</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">if</span> grim_sum == (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>) * (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">1</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">node = Node(<span class="number">1</span>, <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">row_mid = top_left[<span class="number">0</span>] + (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">col_mid = top_left[<span class="number">1</span>] + (bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]) // <span class="number">2</span></span><br><span class="line">node.topLeft = self.dfs(grid, top_left, (row_mid, col_mid), presum)</span><br><span class="line">node.topRight = self.dfs(grid, (top_left[<span class="number">0</span>], col_mid + <span class="number">1</span>), (row_mid, bottom_right[<span class="number">1</span>]), presum)</span><br><span class="line">node.bottomLeft = self.dfs(grid, (row_mid + <span class="number">1</span>, top_left[<span class="number">1</span>]), (bottom_right[<span class="number">0</span>], col_mid), presum)</span><br><span class="line">node.bottomRight = self.dfs(grid, (row_mid + <span class="number">1</span>, col_mid + <span class="number">1</span>), bottom_right, presum)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grid_sum</span><span class="params">(self, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">left = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[bottom_right[<span class="number">0</span>]][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">top = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][bottom_right[<span class="number">1</span>]]</span><br><span class="line">diag = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">or</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> presum[bottom_right[<span class="number">0</span>]][bottom_right[<span class="number">1</span>]] - left - top + diag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_presum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">presum = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">row_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">row_sum += grid[i][j]</span><br><span class="line">presum[i][j] = row_sum + (presum[i - <span class="number">1</span>][j] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> presum</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;`，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p><hr><h3><strong>单格DFS算法II解题思路：</strong></h3><p>也是DFS，但递归终止条件为长度1，也就是每个cell都是叶子节点，先递归然后再归纳，若四个儿子节点都是叶子节点且值都相等，合并为一个叶子节点。否则为非叶子节点。此算法实现更简单，但比较难想出。上述方法思想是按照题意。</p><p><a href="https://leetcode.com/problems/construct-quad-tree/discuss/154565/Java-recursive-solution" target="_blank" rel="noopener">Ref</a></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;<code>，空间复杂度</code>O(1)`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-quad-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Uber" scheme="https://shineboy2013.github.com/tags/Uber/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 387 First Unique Character in a String</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-387/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-387/</id>
    <published>2022-01-04T10:44:05.118Z</published>
    <updated>2022-01-04T10:46:37.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;leetcode&quot;<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;loveleetcode&quot;<strong>Output:</strong> 2&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;aabb&quot;<strong>Output:</strong> -1&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>s</code> consists of only lowercase English letters.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求字符串中第一个唯一的字符下标</p><h3><strong>解题思路：</strong></h3><p>Easy题。先统计频率，然后再遍历一次字符串找到频率为1的字符</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> char_to_count[s[i]] == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>, 26个字母为常量空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/first-unique-character-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 339 Nested List Weight Sum</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-339/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-339/</id>
    <published>2022-01-04T10:14:00.356Z</published>
    <updated>2022-01-04T10:20:24.285Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.</p><p>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer's value set to its <strong>depth</strong>.</p><p>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>depth</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex1.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<strong>Output:</strong> 10<strong>Explanation:</strong> Four 1's at depth 2, one 2 at depth 1. 1<em>2 + 1</em>2 + 2<em>1 + 1</em>2 + 1*2 = 10.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex2.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [1,[4,[6]]]<strong>Output:</strong> 27<strong>Explanation:</strong> One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1<em>1 + 4</em>2 + 6*3 = 27.&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [0]<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nestedList.length &lt;= 50</code></li><li>The values of the integers in the nested list is in the range <code>[-100, 100]</code>.</li><li>The maximum <strong>depth</strong> of any integer is less than or equal to <code>50</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求NestedInteger的和。越深，权重越高</p><h3><strong>解题思路：</strong></h3><p>BFS按层遍历</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>Line 9中，需要将NestedInteger展开，里面的所有的NestedInteger入列。Python中，用extend来加入list中所有元素到另一个list，而不是append</li><li>按层遍历模板中，不需要level变量，for可以达到。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque(nestedList)</span><br><span class="line">res, layer = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">level_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node.isInteger():</span><br><span class="line">queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">level_sum += node.getInteger()</span><br><span class="line">res += level_sum * layer</span><br><span class="line">layer += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/nested-list-weight-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;d
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 074 Search a 2D Matrix</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-074/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-074/</id>
    <published>2022-01-04T09:27:06.283Z</published>
    <updated>2022-01-04T09:26:58.167Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3<strong>Output:</strong> true&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13<strong>Output:</strong> false&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= matrix[i][j], target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>矩阵中每一行有序，下一行的首元素大于上一行的尾元素。求target是否在矩阵中</p><h3><strong>列+行搜索解题思路：</strong></h3><p>先对列做二分搜索，再对行</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">col = [matrix[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">row_idx = bisect.bisect(col, target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> row_idx &lt; <span class="number">0</span> <span class="keyword">or</span> row_idx &gt;= len(matrix):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> matrix[row_idx][<span class="number">0</span>] == target:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">col_idx = bisect.bisect(matrix[row_idx], target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> col_idx &lt; <span class="number">0</span> <span class="keyword">or</span> col_idx &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> matrix[row_idx][col_idx] == target <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(n)</code>, 可以写一个二分法来做列搜索，这样空间为常量。</p><hr><h3><strong>全矩阵搜索算法II解题思路：</strong></h3><p>对矩阵的左上，右下元素作为start, end得到mid转化成(i, j)找到矩阵位置。</p><h3><strong>Java代码：</strong></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi = matrix.length*matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line"><span class="comment">// Key is in a[lo..hi] or not present.</span></span><br><span class="line"><span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> x = mid/matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> y = mid%matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">if</span> (target &lt; matrix[x][y])</span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[x][y])</span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;g
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 008 String to Integer (atoi)</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-008/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-008/</id>
    <published>2022-01-04T08:58:32.853Z</published>
    <updated>2022-01-14T00:42:00.932Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++'s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>'-'</code> or <code>'+'</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2&lt;sup&gt;31&lt;/sup&gt;</code> should be clamped to <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>, and integers greater than <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code> should be clamped to <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>' '</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;42&quot;<strong>Output:</strong> 42<strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)^Step 2: &quot;42&quot; (no characters read because there is neither a '-' nor '+')^Step 3: &quot;&lt;u&gt;42&lt;/u&gt;&quot; (&quot;42&quot; is read in)^The parsed integer is 42.Since 42 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is 42.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;   -42&quot;<strong>Output:</strong> -42<strong>Explanation:</strong>Step 1: &quot;-42&quot; (leading whitespace is read and ignored)^Step 2: &quot;   &lt;u&gt;-&lt;/u&gt;42&quot; ('-' is read, so the result should be negative)^Step 3: &quot;   -&lt;u&gt;42&lt;/u&gt;&quot; (&quot;42&quot; is read in)^The parsed integer is -42.Since -42 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is -42.&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;4193 with words&quot;<strong>Output:</strong> 4193<strong>Explanation:</strong>Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)^Step 2: &quot;4193 with words&quot; (no characters read because there is neither a '-' nor '+')^Step 3: &quot;&lt;u&gt;4193&lt;/u&gt; with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)^The parsed integer is 4193.Since 4193 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is 4193.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>' '</code>, <code>'+'</code>, <code>'-'</code>, and <code>'.'</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>字符串转整数</p><h3><strong>解题思路：</strong></h3><p>关键是第一位是否符号的判断，之后是ord函数的运用</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>空字符或全空格返回0</li><li>[key]<strong>若有符号只能第一位是符号</strong>，连续是符号不合法返回0，如-+12, <strong>将符号处理放在循环外</strong></li><li>除符号外，若第一位为非数字，不合法，返回0</li><li>循环内，若出现非数字，跳出循环</li><li>计算符号，然后检查数字范围</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">s = s.strip()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> s[<span class="number">0</span>].isdigit():</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">res = res * <span class="number">10</span> + ord(char) - ord(<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res *= sign</span><br><span class="line"><span class="keyword">if</span> res &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line"><span class="keyword">return</span> -pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;d
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 016 3Sum Closest</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-016/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-016/</id>
    <published>2022-01-04T08:20:04.305Z</published>
    <updated>2022-01-04T08:22:15.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p><p>Return <em>the sum of the three integers</em>.</p><p>You may assume that each input would have exactly one solution.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-1,2,1,-4], target = 1<strong>Output:</strong> 2<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [0,0,0], target = 1<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>三数和最接近target</p><h3><strong>解题思路：</strong></h3><p>N/A</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>此题不需去重，若等于target可直接返回</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">temp = nums[i] + nums[left] + nums[right]</span><br><span class="line"><span class="keyword">if</span> abs(temp - target) &lt; abs(res - target):</span><br><span class="line">res = temp</span><br><span class="line"><span class="keyword">if</span> temp &lt; target:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> temp &gt; target:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 088 Merge Sorted Array</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-088/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-088/</id>
    <published>2022-01-04T07:58:40.595Z</published>
    <updated>2022-01-04T08:01:29.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<strong>Output:</strong> [1,2,2,3,5,6]<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [&lt;u&gt;1&lt;/u&gt;,&lt;u&gt;2&lt;/u&gt;,2,&lt;u&gt;3&lt;/u&gt;,5,6] with the underlined elements coming from nums1.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0<strong>Output:</strong> [1]<strong>Explanation:</strong> The arrays we are merging are [1] and [].The result of the merge is [1].&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1<strong>Output:</strong> [1]<strong>Explanation:</strong> The arrays we are merging are [] and [1].The result of the merge is [1].Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums1[i], nums2[j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li></ul><p><strong>Follow up:</strong> Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>合并两有序数组，最后结果储存在第一个数组</p><h3><strong>解题思路：</strong></h3><p>从后往前合并</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>i从m - 1而不是len(nums1) - 1开始，m和n是数组实际长度。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, len(nums1) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;g
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-034/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-034/</id>
    <published>2022-01-04T07:29:57.188Z</published>
    <updated>2022-01-04T07:32:22.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">LeetCode</a></strong></p><h3><strong>题目大意：</strong></h3><p>求有序数列中元素等于target的第一个和最后一个下标</p><h3><strong>解题思路：</strong></h3><p>用模板</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>数组为空的情况要返回-1</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">first = self.first_position(nums, target)</span><br><span class="line">last = self.last_position(nums, target)</span><br><span class="line"><span class="keyword">return</span> [first, last]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start+ (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 787 Cheapest Flights Within K Stops</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-787/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-787/</id>
    <published>2022-01-04T05:15:53.988Z</published>
    <updated>2022-01-04T05:31:17.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt;, price&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is a flight from city <code>from&lt;sub&gt;i&lt;/sub&gt;</code> to city <code>to&lt;sub&gt;i&lt;/sub&gt;</code> with cost <code>price&lt;sub&gt;i&lt;/sub&gt;</code>.</p><p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from</em> <code>src</code> <em>to</em> <code>dst</code> <em>with at most</em> <code>k</code> <em>stops.</em> If there is no such route, return<code>-1</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1<strong>Output:</strong> 200<strong>Explanation:</strong> The graph is shown.The cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0<strong>Output:</strong> 500<strong>Explanation:</strong> The graph is shown.The cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li><li><code>flights[i].length == 3</code></li><li><code>0 &lt;= from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt; &lt; n</code></li><li><code>from&lt;sub&gt;i&lt;/sub&gt; != to&lt;sub&gt;i&lt;/sub&gt;</code></li><li><code>1 &lt;= price&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li>There will not be any multiple flights between two cities.</li><li><code>0 &lt;= src, dst, k &lt; n</code></li><li><code>src != dst</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求只允许停k个站情况下，最便宜机票价格</p><h3><strong>解题思路：</strong></h3><p>BFS + Heap<br>这是单源最短路径的典型应用。可以用Dijkstra，机票价格相当于单源最短路径问题中的路径大小。一开始我用BFS，但得到TLE，因为存在循环，导致节点被重复访问(同一路径)。但一个节点的确可以被用不同路径访问。所以引入visited[node] = dis</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>node需要被多次访问，所以跟模板不同，visited的检测要放在neighbor循环之外且用node且初始化为空。visited不再是set，它需要记录node离src的距离。一方面用于循环检测，因为如果存在循环，会出现dist &gt;= visited[node]。若该节点的当前距离小于之前的最小距离，此时也要加入到heap，因为贪婪法，虽然此路径费用较高，但它距离更近，当k限制比较小时，此路径可能满足要求。这就是为什么一个节点会被多次访问的原因。</li><li><strong>若路径不存在返回-1</strong></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, k: int)</span> -&gt; int:</span></span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> flights:</span><br><span class="line">graph[pair[<span class="number">0</span>]].append((pair[<span class="number">1</span>], pair[<span class="number">2</span>]))</span><br><span class="line">heap = ([(<span class="number">0</span>, src, <span class="number">0</span>)])</span><br><span class="line">visited = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">p, node, dist = heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> node == dst <span class="keyword">and</span> dist &lt;= k + <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> visited <span class="keyword">and</span> dist &gt;= visited[node]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">visited[node] = dist</span><br><span class="line"><span class="keyword">for</span> neighbor, _price <span class="keyword">in</span> graph[node]:</span><br><span class="line">heapq.heappush(heap, (p + _price, neighbor, dist + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(VlogV)</code>，空间复杂度<code>O(V)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/cheapest-flights-within-k-stops&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 166 Fraction to Recurring Decimal</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-166/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-166/</id>
    <published>2022-01-04T01:30:18.321Z</published>
    <updated>2022-01-10T08:06:50.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p><p>If the fractional part is repeating, enclose the repeating part in parentheses.</p><p>If multiple answers are possible, return <strong>any of them</strong>.</p><p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10&lt;sup&gt;4&lt;/sup&gt;</code> for all the given inputs.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> numerator = 1, denominator = 2<strong>Output:</strong> &quot;0.5&quot;&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> numerator = 2, denominator = 1<strong>Output:</strong> &quot;2&quot;&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> numerator = 4, denominator = 333<strong>Output:</strong> &quot;0.(012)&quot;&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= numerator, denominator &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li><li><code>denominator != 0</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>N/A</p><h3><strong>解题思路：</strong></h3><p>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体</p><p><img src="/images/L166.PNG" alt=""></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li><strong>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体</strong>，并不是digit一样，而是余数。类似于L003 Longest Substring Without Repeating Characters，记录余数到商下标。循环中顺序很重要，与长除法一致(上图)。分子为remainder，查看remainder是否重复，若否，<strong>加入到map</strong>，乘以10，求商和新余数，进入下一轮迭代。</li><li>输入均为负数或其一为负数的情况，计算结果符号，分子分母分别转成正数</li><li>分子大于分母或分子小于分母的情况都归结为用分子除以分母，加入到结果，若有余数，再加小数点</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span><span class="params">(self, numerator: int, denominator: int)</span> -&gt; str:</span></span><br><span class="line">res, remainder_to_pos = <span class="string">''</span>, collections.defaultdict(int)</span><br><span class="line">is_negative, remainder = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> numerator / denominator &lt; <span class="number">0</span>:</span><br><span class="line">is_negative = <span class="number">-1</span></span><br><span class="line">numerator = abs(numerator)</span><br><span class="line">denominator = abs(denominator)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">if numerator &lt; denominator:</span></span><br><span class="line"><span class="string">res = '0.'</span></span><br><span class="line"><span class="string">remainder = numerator</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">res = str(numerator // denominator)</span></span><br><span class="line"><span class="string">remainder = numerator % denominator</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">res = str(numerator // denominator)</span><br><span class="line">remainder = numerator % denominator</span><br><span class="line"><span class="keyword">if</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line">res += <span class="string">'.'</span></span><br><span class="line"><span class="keyword">while</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> remainder <span class="keyword">in</span> remainder_to_pos:</span><br><span class="line">res = res[:remainder_to_pos[remainder]] + <span class="string">'('</span> + res[remainder_to_pos[remainder]:] + <span class="string">')'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">remainder_to_pos[remainder] = len(res)  <span class="comment"># remember</span></span><br><span class="line">remainder *= <span class="number">10</span> <span class="comment"># remember not numerator * 10 // denominator</span></span><br><span class="line">res += str(remainder // denominator)</span><br><span class="line">remainder %= denominator</span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">if</span> is_negative == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'-'</span> + res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/fraction-to-recurring-decimal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Airbnb" scheme="https://shineboy2013.github.com/tags/Airbnb/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 281 Zigzag Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-281/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-281/</id>
    <published>2022-01-04T00:10:33.027Z</published>
    <updated>2022-01-04T00:15:20.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/zigzag-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given two vectors of integers <code>v1</code> and <code>v2</code>, implement an iterator to return their elements alternately.</p><p>Implement the <code>ZigzagIterator</code> class:</p><ul><li><code>ZigzagIterator(List&lt;int&gt; v1, List&lt;int&gt; v2)</code> initializes the object with the two vectors <code>v1</code> and <code>v2</code>.</li><li><code>boolean hasNext()</code> returns <code>true</code> if the iterator still has elements, and <code>false</code> otherwise.</li><li><code>int next()</code> returns the current element of the iterator and moves the iterator to the next element.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> v1 = [1,2], v2 = [3,4,5,6]<strong>Output:</strong> [1,3,2,4,5,6]<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> v1 = [1], v2 = []<strong>Output:</strong> [1]&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> v1 = [], v2 = [1]<strong>Output:</strong> [1]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= v1.length, v2.length &lt;= 1000</code></li><li><code>1 &lt;= v1.length + v2.length &lt;= 2000</code></li><li><code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= v1[i], v2[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li></ul><p><strong>Follow up:</strong> What if you are given <code>k</code> vectors? How well can your code be extended to such cases?</p><p><strong>Clarification for the follow-up question:</strong></p><p>The &quot;Zigzag&quot; order is not clearly defined and is ambiguous for <code>k &gt; 2</code> cases. If &quot;Zigzag&quot; does not look right to you, replace &quot;Zigzag&quot; with &quot;Cyclic&quot;.</p><p><strong>Follow-up Example:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]<strong>Output:</strong> [1,4,8,2,5,9,3,6,7]&lt;/pre&gt;</p><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求两数组轮替取值的Iterator</p><h3><strong>解题思路：</strong></h3><p>将数组和数组下标分别存于新数组中。用一个list_index来记录要取哪个数组</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>用Iterator模板，hasNext也是找到下一个元素为止，由于只有两个数组，所以不用循环。取值是一个<strong>二维数组</strong>val = self.input[self.list_index][self.index[self.list_index]]</li><li>next中取值后指针要后移。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 284 Peeking Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-284/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-284/</id>
    <published>2022-01-03T23:45:41.427Z</published>
    <updated>2022-01-03T23:48:01.503Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/peeking-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.</p><p>Implement the <code>PeekingIterator</code> class:</p><ul><li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</li><li><code>int next()</code> Returns the next element in the array and moves the pointer to the next element.</li><li><code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</li><li><code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.</li></ul><p><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;][[[1, 2, 3]], [], [], [], [], []]<strong>Output</strong>[null, 1, 2, 2, 3, false]</p><p><strong>Explanation</strong>PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [&lt;u&gt;<strong>1</strong>&lt;/u&gt;,2,3]peekingIterator.next();    // return 1, the pointer moves to the next element [1,&lt;u&gt;<strong>2</strong>&lt;/u&gt;,3].peekingIterator.peek();    // return 2, the pointer does not move [1,&lt;u&gt;<strong>2</strong>&lt;/u&gt;,3].peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,&lt;u&gt;<strong>3</strong>&lt;/u&gt;]peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]peekingIterator.hasNext(); // return False&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li>All the calls to <code>next</code> and <code>peek</code> are valid.</li><li>At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.</li></ul><p><strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>实现数组的peeking Iterator。数组的Iterator是给定的。</p><h3><strong>解题思路：</strong></h3><p>预读一个数</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>预读一个next数</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterator)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.iterator = iterator</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.num</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/peeking-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/iterator/"/>
    <id>https://shineboy2013.github.com/2022/01/03/iterator/</id>
    <published>2022-01-03T21:46:50.282Z</published>
    <updated>2022-01-04T00:24:05.033Z</updated>
    
    <content type="html"><![CDATA[<h3><strong>算法思路：</strong></h3><p>hasNext, next都涉及计算下一个元素，大部分题目是先计算再返回。只有BST是先返回再计算，因为BST的下一个节点取决于要返回的节点，若返回了，就无法知道下一个节点。</p><h3><strong>注意事项：</strong></h3><ol><li>hasNext中，while循环找到下一个符合条件的元素</li><li>next中取值后<strong>指针要后移</strong>。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.stack = []</span><br><span class="line">&lt;add to stack&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> self.hasNext():</span><br><span class="line"><span class="keyword">return</span> self.stack.pop()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">while</span> &lt;until find the next element&gt;:</span><br><span class="line">   &lt;calculate&gt;</span><br><span class="line"><span class="keyword">return</span> &lt;next element&gt;</span><br></pre></td></tr></table></figure></p><h3><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2022/01/03/lee-251/" target="_blank" rel="noopener">LeetCode 251 Flatten 2D Vector</a><a href="https://shineboy2013.github.io/2022/01/03/lee-281/" target="_blank" rel="noopener">LeetCode 281 Zigzag Iterator</a><a href="https://shineboy2013.github.io/2022/01/03/lee-341/" target="_blank" rel="noopener">LeetCode 341 Flatten Nested List Iterator</a><a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></p><h3><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(N + V)/N</code>或<code>O(1)</code>，N为所有数，V为复合结构数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;hasNext, next都涉及计算下一个元素，大部分题目是先计算再返回。只有BST是先返回再计算，因为BST的下一个节点取决于要返回的节点，若返回了，就无法知道下一个节点。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;注
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 341 Flatten Nested List Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-341/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-341/</id>
    <published>2022-01-03T20:55:59.417Z</published>
    <updated>2022-01-03T21:20:27.310Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-nested-list-iterator" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p><p>Implement the <code>NestedIterator</code> class:</p><ul><li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li><li><code>int next()</code> Returns the next integer in the nested list.</li><li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li></ul><p>Your code will be tested with the following pseudocode:</p><p>&lt;pre&gt;initialize iterator with nestedListres = []while iterator.hasNext()append iterator.next() to the end of resreturn res&lt;/pre&gt;</p><p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<strong>Output:</strong> [1,1,2,1,1]<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [1,[4,[6]]]<strong>Output:</strong> [1,4,6]<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nestedList.length &lt;= 500</code></li><li>The values of the integers in the nested list is in the range <code>[-10&lt;sup&gt;6&lt;/sup&gt;, 10&lt;sup&gt;6&lt;/sup&gt;]</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>实现Nested List的Iterator。Nested List是NestedInteger的数组，NestedInteger可以是int，也可以是Nested List</p><h3><strong>解题思路：</strong></h3><p>有点似括号题但区别是从前往后读取。用Queue或Stack都可以，插入或删除其一需要反序，删除nestedinteger(=list)后要将它里面所有nestedinteger加入。Queue要从队首加入和删除，Stack要从栈顶加入和删除，用Stack比较方便。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>用Stack，<strong>逆序将nestedList中nestedinteger加入到stack，直到栈顶元素为int，hasNext才算结束</strong></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop().getInteger()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> <span class="keyword">not</span> self.stack[<span class="number">-1</span>].isInteger():</span><br><span class="line">            nestedList = self.stack.pop().getList()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">                self.stack.append(nestedList[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(L + N)</code>, N为所有数，V为nested list数，O(N + V)/N. O(1)如果不存在nested list</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flatten-nested-list-iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 251 Flatten 2D Vector</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-251/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-251/</id>
    <published>2022-01-03T18:21:06.327Z</published>
    <updated>2022-01-03T21:16:28.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-2d-vector/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Design an iterator to flatten a 2D vector. It should support the <code>next</code> and <code>hasNext</code> operations.</p><p>Implement the <code>Vector2D</code> class:</p><ul><li><code>Vector2D(int[][] vec)</code> initializes the object with the 2D vector <code>vec</code>.</li><li><code>next()</code> returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to <code>next</code> are valid.</li><li><code>hasNext()</code> returns <code>true</code> if there are still some elements in the vector, and <code>false</code> otherwise.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;Vector2D&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;][[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]<strong>Output</strong>[null, 1, 2, 3, true, true, 4, false]</p><p><strong>Explanation</strong>Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]);vector2D.next();    // return 1vector2D.next();    // return 2vector2D.next();    // return 3vector2D.hasNext(); // return Truevector2D.hasNext(); // return Truevector2D.next();    // return 4vector2D.hasNext(); // return False&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= vec.length &lt;= 200</code></li><li><code>0 &lt;= vec[i].length &lt;= 500</code></li><li><code>-500 &lt;= vec[i][j] &lt;= 500</code></li><li>At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>next</code> and <code>hasNext</code>.</li></ul><p><strong>Follow up:</strong> As an added challenge, try to code it using only <a href="http://www.cplusplus.com/reference/iterator/iterator/" target="_blank" rel="noopener">iterators in C++</a> or <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">iterators in Java</a>.</p><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>实现二维Vector的Iterator</p><h3><strong>解题思路：</strong></h3><p>用两个指针</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>单一Vector可以是空，所以next要循环找到非空的vector</li><li>next要col_id加一</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vec: List[List[int]])</span>:</span></span><br><span class="line">        self.vec = vec</span><br><span class="line">        self.row_id = <span class="number">0</span></span><br><span class="line">        self.col_id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            val = self.vec[self.row_id][self.col_id]</span><br><span class="line">            self.col_id += <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.row_id &lt; len(self.vec) <span class="keyword">and</span> self.col_id == len(self.vec[self.row_id]): <span class="comment"># remember while coz []</span></span><br><span class="line">            self.row_id += <span class="number">1</span></span><br><span class="line">            self.col_id = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.row_id == len(self.vec):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(1)</code>, N为所有数，V为vector数，O(N + V)/N. O(1)如果vector都不会空</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flatten-2d-vector/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
</feed>
