<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-30T07:23:03.623Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 259 3Sum Smaller</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/</id>
    <published>2022-01-30T07:18:03.625Z</published>
    <updated>2022-01-30T07:23:03.623Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an array of <code>n</code> integers <code>nums</code> and an integer <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-2,0,1,3], target = 2<strong>Output:</strong> 2<strong>Explanation:</strong> Because there are two triplets which sums are less than 2:[-2,0,1][-2,0,3]&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [], target = 0<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [0], target = 0<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>0 &lt;= n &lt;= 3500</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>-100 &lt;= target &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>找三数和小于target的组合个数</p><h3><strong>解题思路：</strong></h3><p>类似于三数和等于target，但当小于target时，直接求个数，类似于LeetCode 315 Count of Smaller Numbers After Self。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>res不是+1而是right - left</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">res += right - left <span class="comment"># remember</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-smaller/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 628 Maximum Product of Three Numbers</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/</id>
    <published>2022-01-30T03:29:22.897Z</published>
    <updated>2022-01-30T03:34:17.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an integer array <code>nums</code>, <em>find three numbers whose product is maximum and return the maximum product</em>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [1,2,3]<strong>Output:</strong> 6&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [1,2,3,4]<strong>Output:</strong> 24&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-1,-2,-3]<strong>Output:</strong> -6&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求数组任意三个数的最大乘积</p><h3><strong>排序法解题思路：</strong></h3><p>数学题，正负数分开，最大只可以是排序后最大的三个数(全正，全负)或最大整数乘以最小两个负数(正负均有)</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">-1</span>] * nums[<span class="number">-2</span>] * nums[<span class="number">-3</span>], nums[<span class="number">-1</span>] * nums[<span class="number">0</span>] * nums[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code></p><hr><h3><strong>Heap算法II解题思路：</strong></h3><p>由上述思路进一步优化，不需要全部排序，只需要知道最大的3个数和最小的两个数即可</p><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line">smallest = heapq.nsmallest(<span class="number">2</span>, nums)</span><br><span class="line"><span class="keyword">return</span> max(largest[<span class="number">0</span>] * largest[<span class="number">1</span>] * largest[<span class="number">2</span>], largest[<span class="number">0</span>] * smallest[<span class="number">0</span>] * smallest[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-product-of-three-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1143 Longest Common Subsequence</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-1143-longest-common-subsequence/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-1143-longest-common-subsequence/</id>
    <published>2022-01-29T20:29:31.376Z</published>
    <updated>2022-01-29T20:35:54.099Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code>0</code>.</p><p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><ul><li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.</li></ul><p>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;<strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest common subsequence is &quot;ace&quot; and its length is 3.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> text1 = &quot;abc&quot;, text2 = &quot;abc&quot;<strong>Output:</strong> 3<strong>Explanation:</strong> The longest common subsequence is &quot;abc&quot; and its length is 3.&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> text1 = &quot;abc&quot;, text2 = &quot;def&quot;<strong>Output:</strong> 0<strong>Explanation:</strong> There is no such common subsequence, so the result is 0.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> and <code>text2</code> consist of only lowercase English characters.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求两字符串的最大公共字符序列，不一定需要连续</p><h3><strong>解题思路：</strong></h3><p>两字符串最值问题用DPdp[i][j]为最大公共字符序列，最后一位不需要相等。递归式为:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = max(dp[i - 1][j], dp[i][j - 1])</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>DP五点注意事项</p><h3><strong>注意事项：</strong></h3><ol><li>不相等时候不需要dp[i - 1][j - 1]，因为已经包含在dp[i - 1][j]或dp[i][j - 1]中, <strong>DP属于累计DP</strong></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) <span class="comment"># no dp[i - 1][j - 1] but no impact</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 399 Evaluate Division</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-399-evaluate-division/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-399-evaluate-division/</id>
    <published>2022-01-28T07:27:27.518Z</published>
    <updated>2022-01-28T07:48:54.133Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;]</code> and <code>values[i]</code> represent the equation <code>A&lt;sub&gt;i&lt;/sub&gt; / B&lt;sub&gt;i&lt;/sub&gt; = values[i]</code>. Each <code>A&lt;sub&gt;i&lt;/sub&gt;</code> or <code>B&lt;sub&gt;i&lt;/sub&gt;</code> is a string that represents a single variable.</p><p>You are also given some <code>queries</code>, where <code>queries[j] = [C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;]</code> represents the <code>j&lt;sup&gt;th&lt;/sup&gt;</code> query where you must find the answer for <code>C&lt;sub&gt;j&lt;/sub&gt; / D&lt;sub&gt;j&lt;/sub&gt; = ?</code>.</p><p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p><p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]<strong>Explanation:</strong>Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em>return: [6.0, 0.5, -1.0, 1.0, -1.0 ]&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= equations.length &lt;= 20</code></li><li><code>equations[i].length == 2</code></li><li><code>1 &lt;= A&lt;sub&gt;i&lt;/sub&gt;.length, B&lt;sub&gt;i&lt;/sub&gt;.length &lt;= 5</code></li><li><code>values.length == equations.length</code></li><li><code>0.0 &lt; values[i] &lt;= 20.0</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= C&lt;sub&gt;j&lt;/sub&gt;.length, D&lt;sub&gt;j&lt;/sub&gt;.length &lt;= 5</code></li><li><code>A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;, C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;</code> consist of lower case English letters and digits.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>根据已知除法结果求其他除法表达式</p><h3><strong>解题思路：</strong></h3><p>这是G家的面试题。图问题，因为每个除法式相乘可以得到query所要的，所以属于图问题。可以用BFS来遍历图，如已知a/b = 2, b/c = 3, 需要知道a/c, 就是2 x 3，所以只要从a开始， c为BFS的target，迭代时不断相乘</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>核心思想： BFS来遍历图，迭代时不断相乘。<strong>无向图</strong>，因为a/c也可以c/a.</li><li>BFS的注意事项后两个：BFS无解时候不存在的时候返回-1</li><li>两种edge cases： 若query中任意元素不在图中，返回-1(题目要求), 若元素相等，返回1</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(equations):</span><br><span class="line">graph[li[<span class="number">0</span>]].append((li[<span class="number">1</span>], values[i]))</span><br><span class="line">graph[li[<span class="number">1</span>]].append((li[<span class="number">0</span>], <span class="number">1</span> / values[i])) <span class="comment"># remember it is an undirected graph</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line"><span class="keyword">if</span> query[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph <span class="keyword">or</span> query[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">res.append(<span class="number">-1.0</span>)</span><br><span class="line"><span class="keyword">elif</span> query[<span class="number">0</span>] <span class="keyword">in</span> graph <span class="keyword">and</span> query[<span class="number">0</span>] == query[<span class="number">1</span>]:</span><br><span class="line">res.append(<span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">val = self.bfs(graph, query)</span><br><span class="line">res.append(val)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, query)</span>:</span></span><br><span class="line">queue = collections.deque([(query[<span class="number">0</span>], <span class="number">1</span>)])</span><br><span class="line">visited = set([queue[<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node, parent_val = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == query[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> parent_val</span><br><span class="line"><span class="keyword">for</span> neighbor, val <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append((neighbor, parent_val * val))</span><br><span class="line">visited.add(neighbor)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(（V + E) * m)</code>，空间复杂度<code>O(E)</code>, m为query数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/evaluate-division/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 384 Shuffle an Array</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-384-shuffle-an-array/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-384-shuffle-an-array/</id>
    <published>2022-01-28T04:00:51.993Z</published>
    <updated>2022-01-28T04:21:59.986Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li><li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;][[[1, 2, 3]], [], [], []]<strong>Output</strong>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</p><p><strong>Explanation</strong>Solution solution = new Solution([1, 2, 3]);solution.shuffle();    // Shuffle the array [1,2,3] and return its result.// Any permutation of [1,2,3] must be equally likely to be returned.// Example: return [3, 1, 2]solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]</p><p>&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></li><li>All the elements of <code>nums</code> are <strong>unique</strong>.</li><li>At most <code>5 * 10&lt;sup&gt;4&lt;/sup&gt;</code> calls <strong>in total</strong> will be made to <code>reset</code> and <code>shuffle</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>随机重排数组</p><h3><strong>解题思路：</strong></h3><p>水塘抽样法</p><p>先看算法，再理解，第i个元素会被交换的概率：<br>某一个元素保留概率为(n - i) / (n - i + 1)某一个元素交换概率为1 / (n - i)所以从左到右遍历到第i个元素时，它被交换到后面的概率为 所有前面都保留 乘以 第i轮循环时被交换：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) / n * (n - 2) / (n - 1) ... (n - i) / (n - i + 1) * 1 / (n - i)</span><br></pre></td></tr></table></figure></p><p>前面都约了，最后等于1 / n</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>死记算法，跟后面的元素互换</li><li>复制原数组以防被改</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">self.original = list(nums)</span><br><span class="line">self.nums = nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">return</span> list(self.original)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">swap_idx = random.randrange(i, len(self.nums))</span><br><span class="line">self.nums[i], self.nums[swap_idx] = self.nums[swap_idx], self.nums[i]</span><br><span class="line"><span class="keyword">return</span> self.nums</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shuffle-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 370 Range Addition</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-370-range-addition/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-370-range-addition/</id>
    <published>2022-01-27T09:41:55.661Z</published>
    <updated>2022-01-27T09:49:27.299Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-addition/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given an integer <code>length</code> and an array <code>updates</code> where <code>updates[i] = [startIdx&lt;sub&gt;i&lt;/sub&gt;, endIdx&lt;sub&gt;i&lt;/sub&gt;, inc&lt;sub&gt;i&lt;/sub&gt;]</code>.</p><p>You have an array <code>arr</code> of length <code>length</code> with all zeros, and you have some operation to apply on <code>arr</code>. In the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> operation, you should increment all the elements <code>arr[startIdx&lt;sub&gt;i&lt;/sub&gt;], arr[startIdx&lt;sub&gt;i&lt;/sub&gt; + 1], ..., arr[endIdx&lt;sub&gt;i&lt;/sub&gt;]</code> by <code>inc&lt;sub&gt;i&lt;/sub&gt;</code>.</p><p>Return <code>arr</code> <em>after applying all the</em> <code>updates</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/27/rangeadd-grid.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]<strong>Output:</strong> [-2,0,3,5,3]&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]<strong>Output:</strong> [0,-4,2,2,2,4,4,-4,-4,-4]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>0 &lt;= updates.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>0 &lt;= startIdx&lt;sub&gt;i&lt;/sub&gt; &lt;= endIdx&lt;sub&gt;i&lt;/sub&gt; &lt; length</code></li><li><code>-1000 &lt;= inc&lt;sub&gt;i&lt;/sub&gt; &lt;= 1000</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>统一加一个数到子数组中，如此有好几个操作，求最后数组结果</p><h3><strong>解题思路：</strong></h3><p>差分数组，<strong>数加到首节点，数减在末节点 + 1，最后累加</strong></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li><strong>数加到首节点，数减在末节点 + 1，最后累加</strong></li><li>端点需要累加res[li[0]] += li[2], 而不是res[li[0]] = li[2]</li><li>len(res)而不是len(li)</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getModifiedArray</span><span class="params">(self, length: int, updates: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">res = [<span class="number">0</span>] * length</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> updates:</span><br><span class="line">res[li[<span class="number">0</span>]] += li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line"><span class="keyword">if</span> li[<span class="number">1</span>] + <span class="number">1</span> &lt; len(res): <span class="comment"># remember not len(li)</span></span><br><span class="line">res[li[<span class="number">1</span>] + <span class="number">1</span>] += -li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">res[i] += res[i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>, n, m分别为数组长度和update个数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-addition/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 366 Find Leaves of Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/26/leetcode-366-find-leaves-of-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/01/26/leetcode-366-find-leaves-of-binary-tree/</id>
    <published>2022-01-26T09:39:54.007Z</published>
    <updated>2022-01-27T08:59:43.552Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-leaves-of-binary-tree" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given the <code>root</code> of a binary tree, collect a tree's nodes as if you were doing this:</p><ul><li>Collect all the leaf nodes.</li><li>Remove all the leaf nodes.</li><li>Repeat until the tree is empty.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> root = [1,2,3,4,5]<strong>Output:</strong> [[4,5,3],[2],[1]]Explanation:[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> root = [1]<strong>Output:</strong> [[1]]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求逐层叶子剥离的所有叶子节点，按剥离顺序放入结果</p><h3><strong>解题思路：</strong></h3><p>考虑BFS从上到下，但深度不对，因为是从叶子节点开始计算的，如例子所示，根节点1的高度取决于儿子的最大深度。所以应该从底到上计算，也就是DFS</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>从底到上计算高度，取左右树的最大高度</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(root, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line"><span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">res.append([root.val])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res[<span class="number">0</span>].append(root.val)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">left_depth = self.dfs(root.left, res)</span><br><span class="line">right_depth = self.dfs(root.right, res)</span><br><span class="line">depth = max(left_depth, right_depth) + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> depth - <span class="number">1</span> &lt; len(res):</span><br><span class="line">res[depth - <span class="number">1</span>].append(root.val)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append([root.val])</span><br><span class="line"><span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-leaves-of-binary-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;l
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 364 Nested List Weight Sum II</title>
    <link href="https://shineboy2013.github.com/2022/01/26/leetcode-364-nested-list-weight-sum-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/26/leetcode-364-nested-list-weight-sum-ii/</id>
    <published>2022-01-26T08:59:15.266Z</published>
    <updated>2022-01-26T09:09:42.142Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.</p><p>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer's value set to its <strong>depth</strong>. Let <code>maxDepth</code> be the <strong>maximum depth</strong> of any integer.</p><p>The <strong>weight</strong> of an integer is <code>maxDepth - (the depth of the integer) + 1</code>.</p><p>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>weight</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex1.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<strong>Output:</strong> 8<strong>Explanation:</strong> Four 1's with a weight of 1, one 2 with a weight of 2.1<em>1 + 1</em>1 + 2<em>2 + 1</em>1 + 1*1 = 8&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/27/nestedlistweightsumiiex2.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [1,[4,[6]]]<strong>Output:</strong> 17<strong>Explanation:</strong> One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.1<em>3 + 4</em>2 + 6*1 = 17&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nestedList.length &lt;= 50</code></li><li>The values of the integers in the nested list is in the range <code>[-100, 100]</code>.</li><li>The maximum <strong>depth</strong> of any integer is less than or equal to <code>50</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求NestedInteger的和。越浅，权重越高</p><h3><strong>解题思路：</strong></h3><p>BFS按层遍历。此题类似于LeetCode 339 Nested List Weight Sum。归纳成更一般的方法：因为权重只与第几层有关。所以先求每一层的和，存到sums里面，再按照题目要求每个和乘以相应的权重求和。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>queue.extend(node.getList())将节点的儿子节点即node.getList()放入queue</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSumInverse</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque(nestedList)</span><br><span class="line">sums, max_depth, res = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">layer_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node.isInteger():</span><br><span class="line">layer_sum += node.getInteger()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line">sums.append(layer_sum)</span><br><span class="line">max_depth += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(sums):</span><br><span class="line">res += n * (max_depth - i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>, k为每层最多节点数 + 最大层数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/nested-list-weight-sum-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;l
      
    
    </summary>
    
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 359 Logger Rate Limiter</title>
    <link href="https://shineboy2013.github.com/2022/01/25/leetcode-359-logger-rate-limiter/"/>
    <id>https://shineboy2013.github.com/2022/01/25/leetcode-359-logger-rate-limiter/</id>
    <published>2022-01-26T07:30:11.442Z</published>
    <updated>2022-01-26T08:00:44.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/logger-rate-limiter/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Design a logger system that receives a stream of messages along with their timestamps. Each <strong>unique</strong> message should only be printed <strong>at most every 10 seconds</strong> (i.e. a message printed at timestamp <code>t</code> will prevent other identical messages from being printed until timestamp <code>t + 10</code>).</p><p>All messages will come in chronological order. Several messages may arrive at the same timestamp.</p><p>Implement the <code>Logger</code> class:</p><ul><li><code>Logger()</code> Initializes the <code>logger</code> object.</li><li><code>bool shouldPrintMessage(int timestamp, string message)</code> Returns <code>true</code> if the <code>message</code> should be printed in the given <code>timestamp</code>, otherwise returns <code>false</code>.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;Logger&quot;, &quot;shouldPrintMessage&quot;, &quot;shouldPrintMessage&quot;, &quot;shouldPrintMessage&quot;, &quot;shouldPrintMessage&quot;, &quot;shouldPrintMessage&quot;, &quot;shouldPrintMessage&quot;][[], [1, &quot;foo&quot;], [2, &quot;bar&quot;], [3, &quot;foo&quot;], [8, &quot;bar&quot;], [10, &quot;foo&quot;], [11, &quot;foo&quot;]]<strong>Output</strong>[null, true, true, false, false, false, true]</p><p><strong>Explanation</strong>Logger logger = new Logger();logger.shouldPrintMessage(1, &quot;foo&quot;);  // return true, next allowed timestamp for &quot;foo&quot; is 1 + 10 = 11logger.shouldPrintMessage(2, &quot;bar&quot;);  // return true, next allowed timestamp for &quot;bar&quot; is 2 + 10 = 12logger.shouldPrintMessage(3, &quot;foo&quot;);  // 3 &lt; 11, return falselogger.shouldPrintMessage(8, &quot;bar&quot;);  // 8 &lt; 12, return falselogger.shouldPrintMessage(10, &quot;foo&quot;); // 10 &lt; 11, return falselogger.shouldPrintMessage(11, &quot;foo&quot;); // 11 &gt;= 11, return true, next allowed timestamp for &quot;foo&quot; is 11 + 10 = 21&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= timestamp &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li><li>Every <code>timestamp</code> will be passed in non-decreasing order (chronological order).</li><li><code>1 &lt;= message.length &lt;= 30</code></li><li>At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>shouldPrintMessage</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>实现Logger打印的rate limiter</p><h3><strong>解题思路：</strong></h3><p>题不难，但有实际意义</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>shouldPrintMessage只有返回True时候才记录时间点。否则不记录。这属于<strong>元素相等的test case</strong></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.throttle_interval = <span class="number">10</span></span><br><span class="line">        self.msg_to_timestamp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldPrintMessage</span><span class="params">(self, timestamp: int, message: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">in</span> self.msg_to_timestamp <span class="keyword">and</span> timestamp - self.msg_to_timestamp[message] &lt; self.throttle_interval:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.msg_to_timestamp[message] = timestamp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/logger-rate-limiter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 337 House Robber III</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-337-house-robber-iii/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-337-house-robber-iii/</id>
    <published>2022-01-24T10:41:16.144Z</published>
    <updated>2022-01-24T10:56:45.195Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p><p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p><p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> root = [3,2,3,null,3,null,1]<strong>Output:</strong> 7<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> root = [3,4,5,1,3,null,1]<strong>Output:</strong> 9<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</li><li><code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>二叉树，相隔一层投，求最大值</p><h3><strong>解题思路：</strong></h3><p>多状态DP。返回值为，第一个是以root为结尾的最大值，第二个为以儿子层的前n最大值。</p><h3><strong>DFS解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>以儿子层的前n最大值 = max(left) + max(right)</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">res = self.dfs2(root)</span><br><span class="line"><span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">left = self.dfs2(root.left)</span><br><span class="line">right = self.dfs2(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>], max(left) + max(right)</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p><hr><h3><strong>记忆法搜索算法II解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = root.val + g(root.left) + g(root.right)  </span><br><span class="line">g(n) = max(f(root.left), g(root.left)) + max(f(root.right), g(root.right))</span><br></pre></td></tr></table></figure></p><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">f, g = &#123;&#125;, &#123;&#125;</span><br><span class="line">res = self.dfs(root, f, g)</span><br><span class="line"><span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, f, g)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">f[root.left], g[root.left] = self.dfs(root.left, f, g)</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">f[root.right], g[root.right] = self.dfs(root.right, f, g)</span><br><span class="line">f[root] = root.val + g[root.left] + g[root.right]</span><br><span class="line">g[root] = max(f[root.left], g[root.left]) + max(f[root.right], g[root.right])</span><br><span class="line"><span class="keyword">return</span> f[root], g[root]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 340 Longest Substring with At Most K Distinct Characters</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/</id>
    <published>2022-01-24T09:25:03.888Z</published>
    <updated>2022-01-24T09:28:05.865Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>that contains at most</em> <code>k</code> <em><strong>distinct</strong> characters</em>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;eceba&quot;, k = 2<strong>Output:</strong> 3<strong>Explanation:</strong> The substring is &quot;ece&quot; with length 3.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;aa&quot;, k = 1<strong>Output:</strong> 2<strong>Explanation:</strong> The substring is &quot;aa&quot; with length 2.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>0 &lt;= k &lt;= 50</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求最长子串，它含有最多k种字符</p><h3><strong>解题思路：</strong></h3><p>同向双指针，属于最长串类型</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>while条件中，反计算char_to_count，还要pop key</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">char_to_count, left, max_len = collections.defaultdict(int), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">char_to_count[char] += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> len(char_to_count) &gt; k:</span><br><span class="line">char_to_count[s[left]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char_to_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">char_to_count.pop(s[left])</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">max_len = max(max_len, i - left + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leet
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 346 Moving Average from Data Stream</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-346-moving-average-from-data-stream/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-346-moving-average-from-data-stream/</id>
    <published>2022-01-24T08:59:02.505Z</published>
    <updated>2022-01-24T09:01:50.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/moving-average-from-data-stream/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p><p>Implement the <code>MovingAverage</code> class:</p><ul><li><code>MovingAverage(int size)</code> Initializes the object with the size of the window <code>size</code>.</li><li><code>double next(int val)</code> Returns the moving average of the last <code>size</code> values of the stream.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;][[3], [1], [10], [3], [5]]<strong>Output</strong>[null, 1.0, 5.5, 4.66667, 6.0]</p><p><strong>Explanation</strong>MovingAverage movingAverage = new MovingAverage(3);movingAverage.next(1); // return 1.0 = 1 / 1movingAverage.next(10); // return 5.5 = (1 + 10) / 2movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= size &lt;= 1000</code></li><li><code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li>At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>next</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求data stream特定窗口的平均数</p><h3><strong>解题思路：</strong></h3><p>结构上跟LRU cache类似</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>用queue</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size: int)</span>:</span></span><br><span class="line">self.queue = collections.deque()</span><br><span class="line">self.size = size</span><br><span class="line">self.sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, val: int)</span> -&gt; float:</span></span><br><span class="line"><span class="keyword">if</span> len(self.queue) &lt; self.size:</span><br><span class="line">self.queue.append(val)</span><br><span class="line">self.sum += val</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n = self.queue.popleft()</span><br><span class="line">self.sum -= n</span><br><span class="line">self.queue.append(val)</span><br><span class="line">self.sum += val</span><br><span class="line"><span class="keyword">return</span> self.sum / len(self.queue)</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>next时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/moving-average-from-data-stream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 328 Odd Even Linked List</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-328-odd-even-linked-list/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-328-odd-even-linked-list/</id>
    <published>2022-01-24T04:47:53.344Z</published>
    <updated>2022-01-24T05:04:41.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p><p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p><p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p><p>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> head = [1,2,3,4,5]<strong>Output:</strong> [1,3,5,2,4]&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> head = [2,1,3,5,6,4,7]<strong>Output:</strong> [2,3,6,7,1,5,4]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>n ==</code>number of nodes in the linked list</li><li><code>0 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>重排LL， 先偶位再奇位</p><h3><strong>解题思路：</strong></h3><p>N/A</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>LL四点注意事项： 删除节点.next = None</li><li>空输入特别处理</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> head: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">odd_head = ListNode(<span class="number">0</span>)</span><br><span class="line">it, it_odd = head, odd_head</span><br><span class="line"><span class="keyword">while</span> it.next:</span><br><span class="line">it_odd.next = it.next</span><br><span class="line">it.next = it.next.next</span><br><span class="line"><span class="keyword">if</span> it.next:</span><br><span class="line">it = it.next</span><br><span class="line">it_odd = it_odd.next</span><br><span class="line">it_odd.next = <span class="keyword">None</span> <span class="comment"># remember</span></span><br><span class="line">it.next = odd_head.next</span><br><span class="line"><span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/odd-even-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 325 Maximum Size Subarray Sum Equals k</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-325-maximum-size-subarray-sum-equals-k/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-325-maximum-size-subarray-sum-equals-k/</id>
    <published>2022-01-24T04:05:47.958Z</published>
    <updated>2022-01-24T04:16:55.336Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the maximum length of a subarray that sums to</em> <code>k</code>. If there is not one, return <code>0</code> instead.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [1,-1,5,-2,3], k = 3<strong>Output:</strong> 4<strong>Explanation:</strong> The subarray [1, -1, 5, -2] sums to 3 and is the longest.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-2,-1,2,1], k = 1<strong>Output:</strong> 2<strong>Explanation:</strong> The subarray [-1, 2] sums to 1 and is the longest.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= k &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>最长子数组和等于k，求长度</p><h3><strong>解题思路：</strong></h3><p>一开始以为类似于LeetCode 209 Minimum Size Subarray Sum用同向双指针。但这题不是连续，因为此题含负数，不会连续大于等于target。考虑用presum的two sum法。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li><strong>加入presum[0] = 0</strong>，因为这样才可以得到以首元素开始的子数组和</li><li>若presum已经在hashmap中了，不要加入，因为要保证最长数组，如 [-1, 1], target = 0, index可以为0, 2</li><li>max_len答案只要初始化为0，不用最小值，因为最大长度必为非负</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># presum[i] - presum[j] = k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArrayLen</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">max_len, presum = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># not float('-inf')</span></span><br><span class="line">sum_to_idx = collections.defaultdict(int)</span><br><span class="line">sum_to_idx[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">presum += nums[i]</span><br><span class="line"><span class="keyword">if</span> presum - k <span class="keyword">in</span> sum_to_idx:</span><br><span class="line">max_len = max(max_len, i - sum_to_idx[presum - k] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> presum <span class="keyword">not</span> <span class="keyword">in</span> sum_to_idx: <span class="comment"># remember</span></span><br><span class="line">sum_to_idx[presum] = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 315 Count of Smaller Numbers After Self</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/</id>
    <published>2022-01-24T03:09:12.360Z</published>
    <updated>2022-01-24T03:14:43.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [5,2,6,1]<strong>Output:</strong> [2,1,1,0]<strong>Explanation:</strong>To the right of 5 there are <strong>2</strong> smaller elements (2 and 1).To the right of 2 there is only <strong>1</strong> smaller element (1).To the right of 6 there is <strong>1</strong> smaller element (1).To the right of 1 there is <strong>0</strong> smaller element.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-1]<strong>Output:</strong> [0]&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-1,-1]<strong>Output:</strong> [0,0]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>数组中，统计每一位比自己小的数。</p><h3><strong>解题思路：</strong></h3><p>一开始考虑用递减栈。但不可行。类似于merge sort，考虑统计逆序数</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>由于mergesort会改变数组顺序，所以统计数组count也要对应的数也会变，所以将原数组变成(数值, 下标)对，count就可以统计原数组</li><li>计算逆序对时候，放在nums[i][0] &lt;= nums[j][0]中，核心在count[nums[i][1]] += j - mid - 1</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">count = [<span class="number">0</span>] * len(nums)</span><br><span class="line">num_with_idx = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">self.merge_sort(num_with_idx, <span class="number">0</span>, len(nums) - <span class="number">1</span>, count)</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums, start, end, count)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt;= end:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">self.merge_sort(nums, start, mid, count)</span><br><span class="line">self.merge_sort(nums, mid + <span class="number">1</span>, end, count)</span><br><span class="line">self.merge(nums, start, mid, end, count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, start, mid, end, count)</span>:</span></span><br><span class="line">i, j = start, mid + <span class="number">1</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line"><span class="keyword">if</span> nums[i][<span class="number">0</span>] &lt;= nums[j][<span class="number">0</span>]:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= end:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-of-smaller-numbers-after-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Merge Sort" scheme="https://shineboy2013.github.com/tags/Merge-Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 348 Design Tic-Tac-Toe</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-348-design-tic-tac-toe/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-348-design-tic-tac-toe/</id>
    <published>2022-01-24T00:15:36.677Z</published>
    <updated>2022-01-24T00:22:51.263Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-tic-tac-toe/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Assume the following rules are for the tic-tac-toe game on an <code>n x n</code> board between two players:</p><ol><li>A move is guaranteed to be valid and is placed on an empty block.</li><li>Once a winning condition is reached, no more moves are allowed.</li><li>A player who succeeds in placing <code>n</code> of their marks in a horizontal, vertical, or diagonal row wins the game.</li></ol><p>Implement the <code>TicTacToe</code> class:</p><ul><li><code>TicTacToe(int n)</code> Initializes the object the size of the board <code>n</code>.</li><li><code>int move(int row, int col, int player)</code> Indicates that the player with id <code>player</code> plays at the cell <code>(row, col)</code> of the board. The move is guaranteed to be a valid move.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;TicTacToe&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;][[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]<strong>Output</strong>[null, 0, 0, 0, 0, 0, 0, 1]</p><p><strong>Explanation</strong>TicTacToe ticTacToe = new TicTacToe(3);Assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.ticTacToe.move(0, 0, 1); // return 0 (no one wins)|X| | || | | |    // Player 1 makes a move at (0, 0).| | | |</p><p>ticTacToe.move(0, 2, 2); // return 0 (no one wins)|X| |O|| | | |    // Player 2 makes a move at (0, 2).| | | |</p><p>ticTacToe.move(2, 2, 1); // return 0 (no one wins)|X| |O|| | | |    // Player 1 makes a move at (2, 2).| | |X|</p><p>ticTacToe.move(1, 1, 2); // return 0 (no one wins)|X| |O|| |O| |    // Player 2 makes a move at (1, 1).| | |X|</p><p>ticTacToe.move(2, 0, 1); // return 0 (no one wins)|X| |O|| |O| |    // Player 1 makes a move at (2, 0).|X| |X|</p><p>ticTacToe.move(1, 0, 2); // return 0 (no one wins)|X| |O||O|O| |    // Player 2 makes a move at (1, 0).|X| |X|</p><p>ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)|X| |O||O|O| |    // Player 1 makes a move at (2, 1).|X|X|X|&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li>player is <code>1</code> or <code>2</code>.</li><li><code>0 &lt;= row, col &lt; n</code></li><li><code>(row, col)</code> are <strong>unique</strong> for each different call to <code>move</code>.</li><li>At most <code>n&lt;sup&gt;2&lt;/sup&gt;</code> calls will be made to <code>move</code>.</li></ul><p><strong>Follow-up:</strong> Could you do better than <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> per <code>move()</code> operation?</p><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>设计井字过三关</p><h3><strong>解题思路：</strong></h3><p>游戏题。最重要是是数据结构，类似于LeetCode 051 N-Queens和LeetCode 037 Sudoku Solver用matrix记录每行，每列，对角线和反对角线的和。这样验证时候只需要O(1).</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>对角线和反对角线只有一条，所以要先判断move的这个点是否在对角线上。</li><li>由于用-1来代表某一个player，所以判断和时候，用abs</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.board_len = n</span><br><span class="line">        self.row = [<span class="number">0</span>] * n</span><br><span class="line">        self.col = [<span class="number">0</span>] * n</span><br><span class="line">        self.diag = <span class="number">0</span></span><br><span class="line">        self.anti_diag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, row: int, col: int, player: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> player == <span class="number">2</span>:</span><br><span class="line">            player = <span class="number">-1</span></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="keyword">if</span> row == col: <span class="comment"># remember</span></span><br><span class="line">            self.diag += player</span><br><span class="line">        <span class="keyword">if</span> row == self.board_len - <span class="number">1</span> - col:</span><br><span class="line">            self.anti_diag += player</span><br><span class="line">        does_win = abs(self.row[row]) == self.board_len <span class="keyword">or</span> abs(self.col[col]) == self.board_len <span class="keyword">or</span> \</span><br><span class="line">                abs(self.diag) == self.board_len <span class="keyword">or</span> abs(self.anti_diag) == self.board_len <span class="comment"># remember abs</span></span><br><span class="line">        <span class="keyword">if</span> does_win:</span><br><span class="line">            <span class="keyword">if</span> player == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> player</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>move时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-tic-tac-toe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;g
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 317 Shortest Distance from All Buildings</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/</id>
    <published>2022-01-23T23:33:23.203Z</published>
    <updated>2022-01-23T23:50:32.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given an <code>m x n</code> grid <code>grid</code> of values <code>0</code>, <code>1</code>, or <code>2</code>, where:</p><ul><li>each <code>0</code> marks <strong>an empty land</strong> that you can pass by freely,</li><li>each <code>1</code> marks <strong>a building</strong> that you cannot pass through, and</li><li>each <code>2</code> marks <strong>an obstacle</strong> that you cannot pass through.</li></ul><p>You want to build a house on an empty land that reaches all buildings in the <strong>shortest total travel</strong> distance. You can only move up, down, left, and right.</p><p>Return <em>the <strong>shortest travel distance</strong> for such a house</em>. If it is not possible to build such a house according to the above rules, return <code>-1</code>.</p><p>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.</p><p>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]<strong>Output:</strong> 7<strong>Explanation:</strong> Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.So return 7.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,0]]<strong>Output:</strong> 1&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1]]<strong>Output:</strong> -1&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li><li>There will be <strong>at least one</strong> building in the <code>grid</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>找到所有大厦最短距离的点，这个点不能是大厦也不能是障碍</p><h3><strong>解题思路：</strong></h3><p>一开始觉得类似于LeetCode 296 Best Meeting Point，但由于有障碍，所以不能用贪婪法。最值考虑用BFS。属于对所有节点BFS。类似于LeetCode 200 Number of Islands，<br>从每一栋大厦开始做BFS，计算每个点到此大厦距离。然后对累计到这个点的总距离矩阵dis中。最后求距离矩阵的最小值。</p><p>此题难点在于-1的情况，也就是一个点不能到达其中一个building或者是这个building不能到达的点。所以要再用一个矩阵house_count来记录每一个点能到达的大厦数。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>-1的情况，用一个矩阵house_count来记录每一个点能到达的大厦数。</li><li>用常数记录矩阵长和宽，不用x &gt;= len(grid) or y &gt;= len(grid[0]), 否则会TLE</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dis = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">house_count = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">total_houses = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">self.bfs(grid, i, j, dis, house_count)</span><br><span class="line">total_houses += <span class="number">1</span></span><br><span class="line">min_dis = float(<span class="string">'inf'</span>) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dis)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dis[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> dis[i][j] &gt; <span class="number">0</span> <span class="keyword">and</span> house_count[i][j] == total_houses:</span><br><span class="line">min_dis = min(min_dis, dis[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> min_dis == float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_dis <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, start_x, start_y, dis, house_count)</span>:</span></span><br><span class="line">h = len(grid)</span><br><span class="line">w = len(grid[<span class="number">0</span>]) <span class="comment"># remember otherwise TLE</span></span><br><span class="line">queue = collections.deque([(start_x, start_y, <span class="number">0</span>)])</span><br><span class="line">visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">x, y = node[<span class="number">0</span>] + _dx, node[<span class="number">1</span>] + _dy</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= h <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= w <span class="keyword">or</span> grid[x][y] != <span class="number">0</span> <span class="keyword">or</span> visited[x][y]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append((x, y, node[<span class="number">2</span>] + <span class="number">1</span>))</span><br><span class="line">visited[x][y] = <span class="keyword">True</span></span><br><span class="line">dis[x][y] += node[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">house_count[x][y] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm * nm)</code>，空间复杂度<code>O(nm)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-distance-from-all-buildings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 304 Range Sum Query 2D - Immutable</title>
    <link href="https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/"/>
    <id>https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/</id>
    <published>2022-01-21T10:03:16.136Z</published>
    <updated>2022-01-21T10:08:55.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:</p><ul><li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li></ul><p>Implement the NumMatrix class:</p><ul><li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li><li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input</strong>[&quot;NumMatrix&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;][[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<strong>Output</strong>[null, 8, 11, 12]</p><p><strong>Explanation</strong>NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li><li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li><li>At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>sumRegion</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求子矩阵和</p><h3><strong>解题思路：</strong></h3><p>计算presum公式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j] - dp[i-1][j-1]</span><br></pre></td></tr></table></figure></p><p>计算子矩阵公式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>dp有左上边界，计算子矩阵注意dp和输入差1</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp[<span class="number">0</span>])):</span><br><span class="line">                self.dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + self.dp[i - <span class="number">1</span>][j] + self.dp[i][j - <span class="number">1</span>] - self.dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(nm)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-sum-query-2d-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 721 Accounts Merge</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/</id>
    <published>2022-01-21T03:34:29.553Z</published>
    <updated>2022-01-21T09:32:04.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]<strong>Output:</strong> [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]<strong>Explanation:</strong>The first and second John's are the same person as they have the common email &quot;johnsmith@mail.com&quot;.The third John and Mary are different people as none of their email addresses are used by other accounts.We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]<strong>Output:</strong> [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= accounts.length &lt;= 1000</code></li><li><code>2 &lt;= accounts[i].length &lt;= 10</code></li><li><code>1 &lt;= accounts[i][j] &lt;= 30</code></li><li><code>accounts[i][0]</code> consists of English letters.</li><li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p><h3><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li><li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li><li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line">name_dict = collections.defaultdict(str)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">res, visited = [], set()</span><br><span class="line"><span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line"><span class="keyword">if</span> sub_res:</span><br><span class="line">res.append(sub_res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">res, name = [], <span class="string">''</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line">res.append(node)</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">name = name_dict[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">res.sort()</span><br><span class="line">res.insert(<span class="number">0</span>, name)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p><hr><h3><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p><h3><strong>注意事项：</strong></h3><ol><li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li><li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li><li>处理名字</li><li>有重复邮件</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/accounts-merge/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/</id>
    <published>2022-01-20T10:10:33.912Z</published>
    <updated>2022-01-20T10:23:45.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [1,3,4,2,2]<strong>Output:</strong> 2&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [3,1,3,4,2]<strong>Output:</strong> 3&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li><li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li></ul><p><strong>Follow up:</strong></p><ul><li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li><li>Can you solve the problem in linear runtime complexity?</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p><h3><strong>解题思路：</strong></h3><p>数值二分法</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li><li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line"><span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line"><span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;l
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
</feed>
