<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2020-05-10T17:16:05.650Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 010 Regular Expression Matching</title>
    <link href="https://shineboy2013.github.com/2020/05/10/lee-010/"/>
    <id>https://shineboy2013.github.com/2020/05/10/lee-010/</id>
    <published>2020-05-10T16:48:10.451Z</published>
    <updated>2020-05-10T17:16:05.650Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode 010 Regular Expression Matching</a></strong></p><div><br><br>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.<br><br><pre>‘.’ Matches any single character.<br>‘<em>‘ Matches zero or more of the preceding element.<br></em></pre><br><br>The matching should cover the <strong>entire</strong> input string (not partial).<br><br><strong>Note:</strong>   <code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.<br><em>   <code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or `</em>`.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ means zero or more of the preceding element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “.</em>“ means “zero or more (<em>) of any character (.)”.<br></em></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong><br>s = “aab”<br>p = “ca<em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches “aab”.<br></em></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong><br>s = “mississippi”<br>p = “misis<em>p</em>.”<br><strong>Output:</strong> false<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>这道求正则表达式匹配的题和那道Leetocde 044 Wildcard Matching很类似，不同点在于*的意义不同，在之前那道题中，<br>*表示可以代替任意个数的不同字符，而这道题中的*表示之前一个字符（同样字符）可以有0-N个匹配。此题更难一些。    </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。两字符串匹配题基本就是DP而且知道子问题答案可以推导下一个。    </p><ol><li>定义dp[i][j]为字符串s[i-1]和p[j-1]是否能匹配。  </li><li>递归式为dp[i][j] = dp[i-1][j-1] &amp;&amp; (p[j-1] == <strong>.</strong> || s[i-1] == p[j-1])<br>OR ((dp[i-1][j] &amp;&amp; <strong>(s[i-1] == p[j-2] || p[j-2] == .)</strong>) || dp[i][<strong>j-2</strong>]) &amp;&amp; p[j-1] == *<br>第一种情况为非*，通配一样字符或.<br>第二种情况为*，如果通配<strong>（有条件：与p的前一个字符相等或p为.）</strong>就是只移动s，dp[i-1][j]。若不通配就只移动p<strong>及其前一个字符</strong>。  </li><li>方向为从左到右，从上到下。初始值为dp[0][0] = true。以及若s为空，p为多个*时候，dp[0][j]=true。</li></ol><p>与Wildcard Matching不同之处用黑体标注了：  </p><ol><li>用.代替?  </li><li>*情况，不匹配p移动两位而不是一位。  </li><li>*情况，匹配带条件而不是无条件。  </li><li>初始化用dp[0][j-2]而不是j-1。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归式含*不匹配情况dp[i][j-2]。  </li><li>初始化s为空，p为多个*。此情况其实与程序符合，因为i=1开始，所以i=0的时候，dp[i-1][j]为负值省去，<br>只取dp[i][j-2]。   </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line"><span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>) <span class="comment">// remember s="", p="a*"</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">dp[i][j] = (dp[i][j-<span class="number">2</span>] || ((s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) </span><br><span class="line">|| p.charAt(j-<span class="number">2</span>) == <span class="string">'.'</span>) &amp;&amp; dp[i-<span class="number">1</span>][j]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) </span><br><span class="line">|| p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[dp.length -<span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*m)</code>，空间复杂度为<code>O(n*m)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/regular-expression-matching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 010 Regular Expressi
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 044 Wildcard Matching</title>
    <link href="https://shineboy2013.github.com/2020/05/10/lee-044/"/>
    <id>https://shineboy2013.github.com/2020/05/10/lee-044/</id>
    <published>2020-05-10T16:18:47.532Z</published>
    <updated>2020-05-10T16:47:09.432Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">LeetCode 044 Wildcard Matching</a></strong></p><div><br><br>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.<br><br><pre>‘?’ Matches any single character.<br>‘<em>‘ Matches any sequence of characters (including the empty sequence).<br></em></pre><br><br>The matching should cover the <strong>entire</strong> input string (not partial).<br><br><strong>Note:</strong>   <code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.<br><em>   <code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>&lt;font face=&quot;monospace&quot;&gt;?&lt;/font&gt;</code> or `</em>`.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>s = “aa”<br>p = “<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ matches any sequence.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong><br>s = “cb”<br>p = “?a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong><br>s = “adceb”<br>p = “<em>a</em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong><br>s = “acdcb”<br>p = “a<em>c?b”<br><em>*Output:</em></em> false<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通配符外卡匹配问题，有特殊字符”*“和”?”，其中”?” 能代替任何字符，”*“能代替任何字符串。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。两字符串匹配题基本就是DP而且知道子问题答案可以推导下一个。    </p><ol><li>定义dp[i][j]为字符串s[i-1]和p[j-1]是否能匹配。  </li><li>递归式为dp[i][j] = dp[i-1][j-1] &amp;&amp; (p[j-1]==? || s[i-1]==p[j-1])<br>OR (dp[i-1][j] || dp[i][j-1]) &amp;&amp; p[j-1]==*<br>第一种情况为非*，通配一样字符或?<br>第二种情况为*，如果通配就是只移动s，dp[i-1][j]。若不通配就只移动p。  </li><li>方向为从左到右，从上到下。初始值为dp[0][0] = true。以及若s为空，p为多个*时候，dp[0][j]=true。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归式含*不匹配情况dp[i][j-1]，我写的时候忽略了。  </li><li>初始化s为空，p为多个*。此情况其实与程序符合，因为i=1开始，所以i=0的时候，dp[i-1][j]为负值省去，<br>只取dp[i][j-1]。  </li><li>一开始写的corner case并入到递归式处理。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if(s.isEmpty() &amp;&amp; p.isEmpty())</span></span><br><span class="line"><span class="comment">//return true;</span></span><br><span class="line"><span class="comment">//if(!s.isEmpty() &amp;&amp; p.isEmpty())</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="comment">//if(s.isEmpty() &amp;&amp; !p.isEmpty() &amp;&amp; isAllStars(p))</span></span><br><span class="line"><span class="comment">//return true;</span></span><br><span class="line"><span class="comment">//if(s.isEmpty() &amp;&amp; !p.isEmpty())</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line"><span class="comment">// remember empty s can match any prefix *** character in p making sure dp[0][j] = true</span></span><br><span class="line"><span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++)</span><br><span class="line">dp[i][j] = (dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; (p.charAt(j-<span class="number">1</span>) == <span class="string">'?'</span> || s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>)))</span><br><span class="line"><span class="comment">// miss dp[i][j-1] means no match on *</span></span><br><span class="line">|| ((dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">1</span>]) &amp;&amp; p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>); </span><br><span class="line"><span class="keyword">return</span> dp[dp.length -<span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*m)</code>，空间复杂度为<code>O(n*m)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/wildcard-matching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 044 Wildcard Matching&lt;/a&gt;&lt;/str
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>记忆性搜索</title>
    <link href="https://shineboy2013.github.com/2020/05/09/memoization/"/>
    <id>https://shineboy2013.github.com/2020/05/09/memoization/</id>
    <published>2020-05-09T23:28:48.775Z</published>
    <updated>2020-05-09T23:34:02.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS将子问题的解存于结果中。cache[st] = result. st是子问题边界。  </p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><p>用于求所有可能性，且这些可能性有重复，记忆性搜索可以用于剪枝。  </p><ol><li>Leetcode 139</li><li>Leetcode 140</li></ol><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>key为子问题索引st，value为子问题的解。  </li><li>紧跟终结条件，若在cache中，返回子问题的解。  </li><li>循环结束，将子问题的结果存于cache。  </li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;DFS将子问题的解存于结果中。cache[st] = result. st是子问题
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
      <category term="Memoization" scheme="https://shineboy2013.github.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 140 Word Break II</title>
    <link href="https://shineboy2013.github.com/2020/05/09/lee-140/"/>
    <id>https://shineboy2013.github.com/2020/05/09/lee-140/</id>
    <published>2020-05-09T23:22:25.398Z</published>
    <updated>2020-05-10T16:42:25.730Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">LeetCode 140 Word Break II</a></strong></p><div><br><br>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.<br><br><strong>Note:</strong><br><br><em>   The same word in the dictionary may be reused multiple times in the segmentation.</em>   You may assume the dictionary does not contain duplicate words.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “<code>catsanddog</code>“<br>wordDict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code><br><strong>Output:</strong> <code>[  &quot;cats and dog&quot;,  &quot;cat sand dog&quot;]</code><br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br><strong>Output:</strong> [<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br><strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>Output:</strong> []</pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，求被“字典集合”（wordDict）中的单词拼接的所有方案。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。求所有可能性想到DFS，前面Lintcode 683提到可能会有重复解。所以用Cache。    </p><p><strong>Cache模板：</strong>  </p><ol><li>key为子问题索引st，value为子问题的解。  </li><li>紧跟终结条件，若在cache中，返回子问题的解。  </li><li>循环结束，将子问题的结果存于cache。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>将两个输入都转换成小写。  </li><li>复制子问题的解，不能直接在解List<string>上编辑。</string></li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty())</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">wordDictLower.add(c.toLowerCase());</span><br><span class="line">s = s.toLowerCase();</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">return</span> dfs(s, wordDictLower, s.length(), cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> st, Map&lt;Integer, List&lt;String&gt;&gt; cache)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(st == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line"><span class="keyword">if</span>(cache.containsKey(st))</span><br><span class="line"><span class="keyword">return</span> cache.get(st);</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st; i++) &#123;</span><br><span class="line">String word = s.substring(i, st);</span><br><span class="line"><span class="keyword">if</span>(!wordDict.contains(word))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; sub = dfs(s, wordDict, i, cache); </span><br><span class="line"><span class="comment">// copy solution for subproblem, don't edit on sub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sub.size(); j++)</span><br><span class="line">result.add((sub.get(j) + <span class="string">" "</span> + word).trim());</span><br><span class="line">&#125;</span><br><span class="line">cache.put(st, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度为<code>O(解大小)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-break-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 140 Word Break II&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Memoization" scheme="https://shineboy2013.github.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 683 Word Break III</title>
    <link href="https://shineboy2013.github.com/2020/05/09/lin-683/"/>
    <id>https://shineboy2013.github.com/2020/05/09/lin-683/</id>
    <published>2020-05-09T20:05:20.549Z</published>
    <updated>2020-05-10T07:23:27.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.lintcode.com/problem/word-break-iii/" target="_blank" rel="noopener">LintCode 683 Word Break III</a></strong></p><div><br><br>Give a dictionary of words and a sentence with all whitespace removed, return the number of sentences you can form by inserting whitespaces to the sentence so that each word can be found in the dictionary.<br><br><strong>Example 1:</strong><br><br><pre><br>Input:<br>“CatMat”<br>[“Cat”, “Mat”, “Ca”, “tM”, “at”, “C”, “Dog”, “og”, “Do”]<br>Output: 3<br>Explanation:<br>we can form 3 sentences, as follows:<br>“CatMat” = “Cat” + “Mat”<br>“CatMat” = “Ca” + “tM” + “at”<br>“CatMat” = “C” + “at” + “Mat”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><br>Input:<br>“a”<br>[]<br>Output: 0<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，被“字典集合”（wordDict）中的单词拼接而成的可能性种数。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。如果知道s[0:n-1)很容易知道s[0:n)是否有解，既然和子问题有关，就用DP。  </p><ol><li>定义dp[i]为字符串s[0,i)是合法分解种数。</li><li>判断一个字符串是否可以合法分解，方案是尝试在每一位进行分解，若其中一个可分解，即有解，加入到dp[i]中。<br>递归式为dp[i] += dp[k] * isWord(s[k:i)), 0 &lt;= k &lt; i. </li><li>方向为从左到右i=0..n, 初始值为dp[0] = 1. </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>将两个输入都转换成小写。 </li><li>dp[n+1]而不是dp[n]，而for循环从1开始。  </li><li>递归中dp[i]用+操作符。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak3</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; lowerDict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String c : dict)</span><br><span class="line">lowerDict.add(c.toLowerCase());</span><br><span class="line">dict = lowerDict;</span><br><span class="line">s = s.toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] = sum(dp[i][k] * isWord(s[k,j])), i=0..n-1, j=i..n-1</span></span><br><span class="line"><span class="comment">// dp[0][n-1] = sum(dp[0][k] * isWord(s[k,n-1]))</span></span><br><span class="line"><span class="comment">// dp[n] = sum(dp[k] * isWord(s[k,n]))</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">dp[i] += dp[k] * (dict.contains(s.substring(k, i)) ? <span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。  </p><p>这道题一开始走过一些弯路，首先我觉得类似于Catalan算法，左右半部都是子问题，所以写了以下算法：  </p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak3_wrong</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] = sum(dp[i][k] * dp[k][j])</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// use "ab" as an example</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= s.length(); len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + len; j++) &#123;</span><br><span class="line"><span class="comment">//"a","b"</span></span><br><span class="line">dp[i][i+len] += dp[i][j] * dp[j][i+len];    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"ab"</span></span><br><span class="line"><span class="keyword">if</span>(dict.contains(s.substring(i, i+len)))</span><br><span class="line">dp[i][i+len]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个方法会有重复解，比如<br>“abc”, “a”,”b”,”c”<br>-&gt; <code>dp[&quot;ab&quot;] * dp[&quot;c&quot;] = 1</code><br>-&gt; <code>dp[&quot;a&quot;] * dp[&quot;bc&quot;] = 1</code><br>所以解重复，因为这问题是单边子问题而不是Catalan问题。<br>更改版本为单边子问题，一开始用dp[n]导致初始化稍复杂，其实初始化可以并入到递归式，只要用dp[n+1]即可。  </p><h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wordBreak32</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">dp[i] = dict.contains(s.substring(<span class="number">0</span>, i + <span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">dp[i] += dp[k] * (dict.contains(s.substring(k + <span class="number">1</span>, i + <span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.lintcode.com/problem/word-break-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LintCode 683 Word Break III&lt;/a&gt;&lt;/strong
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 139 Word Break</title>
    <link href="https://shineboy2013.github.com/2020/05/09/lee-139/"/>
    <id>https://shineboy2013.github.com/2020/05/09/lee-139/</id>
    <published>2020-05-09T18:13:14.876Z</published>
    <updated>2020-05-09T20:03:02.792Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">LeetCode 139 Word Break</a></strong></p><div><br><br>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.<br><br><strong>Note:</strong><br><br><em>   The same word in the dictionary may be reused multiple times in the segmentation.</em>   You may assume the dictionary does not contain duplicate words.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, wordDict = [“leet”, “code”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “applepenapple”, wordDict = [“apple”, “pen”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because <code>&quot;</code>applepenapple<code>&quot;</code> can be segmented as <code>&quot;</code>apple pen apple<code>&quot;</code>.<br>             Note that you are allowed to reuse a dictionary word.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br><strong>Output:</strong> false<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个字符串s，是否能够被“字典集合”（wordDict）中的单词拼接而成。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题。如果知道s[0:n-1)很容易知道s[0:n)是否有解，既然和子问题有关，就用DP。  </p><ol><li>定义dp[i]为字符串s[0,i)是否可以合法分解。</li><li>判断一个字符串是否可以合法分解，方案是尝试在每一位进行分解，若其中一个可分解，即有解。<br>递归式为dp[i] |= dp[k] &amp;&amp; isWord(s[k:i)), 0 &lt;= k &lt; i. </li><li>方向为从左到右i=0..n, 初始值为dp[0] = true. </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>将两个输入都转换成小写。  </li><li>递归中dp[i]用或操作符。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty() || wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">wordDictLower.add(c.toLowerCase());</span><br><span class="line">s = s.toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;<span class="comment">//"a"</span></span><br><span class="line">dp[i] |= dp[k] &amp;&amp; wordDictLower.contains(s.substring(k, i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。</p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>这题也可以额用DFS来解。如果可以用DP就尽量用DP，只有求所有可能性才只能用DFS而不能用DP。<br>这道题递归子问题dfs[:n]为子串[0:n)是否可合法拆解。对于子问题而言，需要对其范围内i=[0:st)的每个可能位置分解<br>dfs[:i) + word[i:st)从而求出dfs(st)的解，只有任一分解成功，dfs(st)=true，否则false。 </p><p>Cache的应用场景： 如果子问题重复就要用Cache。<br>例如dfs(10)=dfs(9)+s[9:9] = (dfs(8) + s[8:8]) + s[9:9]<br>           =dfs(8)+s[8:9]<br>dfs(8)由第一层递归第二个循环s[8:9]和第二层递归s[9:9]达到，这是重复的子问题dfs(8)。如果不cache，dfs(8)的求解<br>是重复的。  </p><p><strong>Cache模板：</strong>  </p><ol><li>key为子问题索引st，value为子问题的解。  </li><li>紧跟终结条件，若在cache中，返回子问题的解。  </li><li>循环结束，将子问题的结果存于cache。  </li></ol><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>将两个输入都转换成小写。</li><li>递归中先查询词是否在字典中再递归。如果顺序调转就会LTE，因为这些子问题是白费的。  </li><li>递归终结条件为st==0而不是st==s.length()因为子问题递归从右到左。  </li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreakDFS</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isEmpty() || wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Set&lt;String&gt; wordDictLower = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String c : wordDict)</span><br><span class="line">wordDictLower.add(c.toLowerCase());</span><br><span class="line">s = s.toLowerCase();</span><br><span class="line">Map&lt;Integer, Boolean&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">return</span> dfs(s, wordDictLower, s.length(), cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subproblem's answer dfs[:st)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> st, Map&lt;Integer, Boolean&gt; cache)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(st == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(cache.containsKey(st))</span><br><span class="line"><span class="keyword">return</span> cache.get(st);</span><br><span class="line"><span class="keyword">boolean</span> re = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(wordDict.contains(s.substring(i, st)) &amp;&amp; dfs(s, wordDict, i, cache))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(st, re);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 139 Word Break&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Memoization" scheme="https://shineboy2013.github.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 146 LRU Cache</title>
    <link href="https://shineboy2013.github.com/2020/05/04/lee-146/"/>
    <id>https://shineboy2013.github.com/2020/05/04/lee-146/</id>
    <published>2020-05-05T05:58:23.494Z</published>
    <updated>2020-05-05T06:26:40.855Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode 146 LRU Cache</a></strong></p><div><br><br>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.<br><br><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br><br>The cache is initialized with a <strong>positive</strong> capacity.<br><br><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?<br><br><strong>Example:</strong><br><br><pre>LRUCache cache = new LRUCache( 2 /<em> capacity </em>/ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计LRU。就是最就的cache会先被删除。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为是Cache，get是O(1)，自然想到用HashMap。如果不限容量，get，put都可以O(1)。限容量的情况下，<br>就要删除部分数据，这里要求按key的时间排序，所以考虑用一个串将keys串联起来。而key的添加和删除<br>也要O(1)，所以考虑用LinkedList。HashMap和LinkedList的组合很常见。这里value就指向LL中的Node，<br>而Node中含key和value，key又可以让Node只向HashMap，做到互相索引。分析get和set，get就只要从Map<br>中读Node的value即可。set比较复杂，含三种情况：  </p><ol><li>已有节点  </li><li>不含节点且少于容量  </li><li>不含节点且大于等于容量  </li></ol><p>对应链表操作为：  </p><ol><li>删除该节点且插入到末尾  </li><li>插入新节点到末尾  </li><li>删除头节点且插入新节点到末尾  </li></ol><p>总结链表操作为两个：  </p><ol><li>删除某节点  </li><li>插入新节点到末尾  </li></ol><p>实现上可以分为单链表和双链表。单链表要让Map指向节点的父节点。实现上很麻烦，因为更新节点都会涉及<br>两个keys上HashMap更新，即使已有节点换到末尾同样要两次更新Map。但双链表对此情况就避免了Map的更新。  </p><p>DummyNode的选择：一开始我只选用了DummyHead，但capacity=1的时候要判断末节点是否为空很麻烦，由于<br>经常性的插入末节点，所以根据若头结点涉及插入删除就应该用dummyNode的原则，末节点也增加dummyNode<br>程序就简洁很多。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>set中，若节点存在，更更新value。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">ListNode head; <span class="comment">// from oldest to newest</span></span><br><span class="line">ListNode tail;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L146LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">pushback(key);</span><br><span class="line"><span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">pushback(key);</span><br><span class="line">map.get(key).val = value; <span class="comment">// remember to update the value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map.size() == capacity) &#123;</span><br><span class="line">map.remove(head.next.key);</span><br><span class="line">deleteNode(head.next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new key</span></span><br><span class="line">ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">addNodeToTail(newNode);</span><br><span class="line">map.put(key, newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushback</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">ListNode curNode = map.get(key);</span><br><span class="line">deleteNode(curNode);</span><br><span class="line">addNodeToTail(curNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNodeToTail</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">ListNode prevTailNode = tail.prev;</span><br><span class="line">prevTailNode.next = curNode;</span><br><span class="line">curNode.prev = prevTailNode;</span><br><span class="line">curNode.next = tail;</span><br><span class="line">tail.prev = curNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete head node and updated node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">ListNode nextNode = curNode.next;</span><br><span class="line">ListNode prevNode = curNode.prev;</span><br><span class="line">prevNode.next = nextNode;</span><br><span class="line">nextNode.prev = prevNode;</span><br><span class="line">curNode.next = <span class="keyword">null</span>;</span><br><span class="line">curNode.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span> ListNode next;</span><br><span class="line"><span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 146 LRU Cache&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 126 Word Ladder II</title>
    <link href="https://shineboy2013.github.com/2020/05/03/lee-126/"/>
    <id>https://shineboy2013.github.com/2020/05/03/lee-126/</id>
    <published>2020-05-04T01:09:53.727Z</published>
    <updated>2020-05-04T08:15:59.088Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">LeetCode 126 Word Ladder</a></strong></p><div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time<br>2.  Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.<br><br><strong>Note:</strong><br><br><em>   Return an empty list if there is no such transformation sequence.</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong><br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> []<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求所有最少的变换路径。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>更难于Leetcode 127，BFS用于找最短路径而DFS找路径，此题正是贯彻这一思想，先用BFS找出最短路径，<br>然后根据最短路径值找出所有路径。找BFS解的同时建图用邻接表表示Map<string, list<string="">&gt;(这是<br>部分图，与解相关的图)和解集合Map<string, integer="">(从始点到不同节点的最短距离)，这两个信息正是<br>Dijkistra的图输入和解。DFS从始点开始遍历邻接节点，确保沿着最短路径走，最短路径为<br>map.get(cur)+1=map.get(next)表示当前节点到始点距离+1=儿节点到始点距离，终止条件为找到目标节点。  </string,></string,></p><ol><li>在遍历所有邻接节点的时候，如果不加筛选对所有邻接节点都做DFS会造成LTE。关键是要利用BFS中所有<br>节点到单源的最短路径来剪枝。只需DFS最短路径上的节点，否则跳过。  </li><li>利用了单源最短路径映射表distance后，不需要记录visited，因为重复的节点不会在最短路劲上。  </li><li>Cache nextWords的结果。     </li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建字典。  </li><li>BFS访问，得到图和单源最短路径Map，以及最短路径距离。  </li><li>DFS求路径，按最短路径剪枝。    </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>建图要先建点，再建边。若不先建点， graph.get(cur)会NPE。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(beginWord == <span class="keyword">null</span> || endWord == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line"><span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line"><span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">ladderLength(beginWord, endWord, dict, graph);</span><br><span class="line">path.add(beginWord);</span><br><span class="line">dfs(beginWord, endWord, dict, graph, path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String endWord, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">HashMap&lt;String, List&lt;String&gt;&gt; graph, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(cur)) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String word : graph.get(cur)) &#123;</span><br><span class="line">path.add(word);</span><br><span class="line"><span class="keyword">if</span>(distance.get(word) - <span class="number">1</span> == distance.get(cur)) <span class="comment">// use distance, resolve LTE the most important</span></span><br><span class="line">dfs(word, endWord, distance, graph, path, res);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache getNextWords</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Map&lt;String, Integer&gt; dict, Map&lt;String, List&lt;String&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(beginWord);</span><br><span class="line">visited.add(beginWord);</span><br><span class="line"><span class="keyword">for</span>(String s : dict.keySet()) &#123;<span class="comment">// remember</span></span><br><span class="line">graph.put(s, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">String word = q.poll();</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line"><span class="keyword">return</span> dict.get(word);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line">graph.put(word, <span class="keyword">new</span> ArrayList&lt;&gt;(nextWords));</span><br><span class="line"><span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(s))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q.offer(s);</span><br><span class="line">visited.add(s);</span><br><span class="line">dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">map.put(word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line"><span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line"><span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line"><span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">result.add(newWord);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code><br>时间复杂度为<code>O(n<em><em>L</em><sup>2</sup> + m</em>k)</code>，空间复杂度<code>O(n)</code>，m为答案个数, k为最短路径值。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 126 Word Ladder&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="https://shineboy2013.github.com/2020/05/03/combination/"/>
    <id>https://shineboy2013.github.com/2020/05/03/combination/</id>
    <published>2020-05-03T21:53:45.466Z</published>
    <updated>2020-05-03T22:00:12.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 078的题目。这里作为知识点归纳。  </p><ol><li>递归中i=st开始。  </li><li>回溯： path递归后去恢复状态。  </li><li>dfs中传入i+1。  </li><li>结果要复制new ArrayList&lt;&gt;(path)  </li><li>一般来说，终止条件才加入结果，但由于子集任何path修改都是子集，所有立即加入。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>找所有可能性</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); <span class="comment">//empty set</span></span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">dfs(nums, <span class="number">0</span>, path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> st, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(st == nums.length)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = st; i &lt; nums.length; i++) &#123;</span><br><span class="line">path.add(nums[i]);</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">dfs(nums, i + <span class="number">1</span>, path, res);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>2</em><sup>n</sup>)</code> ，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Leetcode 078的题目。这里作为知识点归纳。  &lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>排列</title>
    <link href="https://shineboy2013.github.com/2020/05/03/permutation/"/>
    <id>https://shineboy2013.github.com/2020/05/03/permutation/</id>
    <published>2020-05-03T21:48:49.111Z</published>
    <updated>2020-05-03T21:57:41.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 046的题目。这里作为知识点归纳。  </p><ol><li>类似于组合题，但用到了visited数组且递归中从i=0开始。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>找所有可能性</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">dfs(nums, <span class="keyword">new</span> HashSet&lt;&gt;(), path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, Set&lt;Integer&gt; visited, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(i))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">visited.add(i);</span><br><span class="line">path.add(nums[i]);</span><br><span class="line">dfs(nums, visited, path, res);</span><br><span class="line">visited.remove(i);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Leetcode 046的题目。这里作为知识点归纳。  &lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://shineboy2013.github.com/2020/04/26/quick-sort/"/>
    <id>https://shineboy2013.github.com/2020/04/26/quick-sort/</id>
    <published>2020-04-27T06:45:44.547Z</published>
    <updated>2020-04-27T06:54:06.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>递归找pivot，然后按小于pivot和大于等于pivot分成两组。每轮递归，pivot肯定在正确（最终）位置上</li><li>partition方法类似于Leetcode75的sort colors一样用两个指针i和noSmallerIdx。i是循环指针，而<br>noSmallerIdx是第二组大于等于pivot的首元素，或者理解为将要交换的位置。  </li><li>循环结束后，将pivot交换到正确的位置上。</li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>排序</li><li>快速选择quick select</li><li>partition，如Leetcode 75</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">quickSort(arr, left, pivotPos - <span class="number">1</span>);</span><br><span class="line">quickSort(arr, pivotPos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> noSmallerIdx = left;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; pivot) </span><br><span class="line">swap(arr, noSmallerIdx++, i);</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, noSmallerIdx, right);</span><br><span class="line"><span class="keyword">return</span> noSmallerIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;递归找pivot，然后按小于pivot和大于等于pivot分成两组。每
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>BST的非递归中序遍历</title>
    <link href="https://shineboy2013.github.com/2020/04/26/bst-iterative/"/>
    <id>https://shineboy2013.github.com/2020/04/26/bst-iterative/</id>
    <published>2020-04-26T18:52:08.235Z</published>
    <updated>2020-04-26T19:01:10.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>首先初始化将root的所有左儿子加入到stack。</li><li>开始循环，取出节点，判断其右儿子不为空，因为左儿子已经访问过。  </li><li>若右子树不为空，跟初始化一样，将右子树的所有左儿子加入到栈中。  </li><li>用到两个指针node和n，分别指向出栈节点和遍历所有左儿子节点。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>BST的关于Iterator的题目<a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">Leetcode 173</a></li><li>不需要遍历所有节点而需要遍历某些节点的题目如求某target最接近N个节点。<a href="https://shineboy2013.github.io/2020/04/26/lee-272/" target="_blank" rel="noopener">Leetcode 272</a></li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">iterativeInorder</span><span class="params">(BinaryNode p)</span> </span>&#123;  </span><br><span class="line">Stack&lt;BinaryNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryNode&gt;();  </span><br><span class="line">BinaryNode head = p;</span><br><span class="line"><span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(head);</span><br><span class="line">head = head.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryNode node = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">node = stack.pop();</span><br><span class="line">System.out.print(node.data);</span><br><span class="line"><span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinaryNode n = node.right; </span><br><span class="line"><span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>，最差为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先初始化将root的所有左儿子加入到stack。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 272 Closest Binary Search Tree Value II</title>
    <link href="https://shineboy2013.github.com/2020/04/26/lee-272/"/>
    <id>https://shineboy2013.github.com/2020/04/26/lee-272/</id>
    <published>2020-04-26T18:31:21.211Z</published>
    <updated>2020-04-26T19:13:39.012Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="noopener">LeetCode 272 Closest Binary Search Tree Value II</a></strong></p><p>Given a non-empty binary search tree and a target value, find <em>k</em> values in the BST that are closest to the target.</p><p>Note:</p><ul><li>Given target value is a floating point.</li><li>You may assume <em>k</em> is always valid, that is: <em>k</em>≤ total nodes.</li><li>You are guaranteed to have only one unique set of <em>k</em> values in the BST that are closest to the target.</li></ul><p>Example:</p><pre>Input: root = [4,2,5,1,3], target = 3.714286, and _k_ = 2    4   / \  2   5 / \1   3Output: [4,3]</pre><p>Follow up:<br>Assume that the BST is balanced, could you solve it in less than <em>O</em>(<em>n</em>) runtime (where <em>n</em> = total nodes)?</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找BST中给定目标的最接近的k个值。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>首先观察得到最接近的节点一定在二叉树的搜索路径上的节点的其中一个。这样可以分成两组<br>前驱节点和后驱节点（比target大），加入到两个stack中，由BST的iterator可以知道这两个<br>stack的越靠近栈首就越接近target，所以出栈的一定是最接近target的。只要比较两栈首元素<br>即可。如果某个节点出栈要找其儿子节点填充。找前驱节点和后驱节点的方法是相反的。这里可<br>参照KB的BST非递归中序遍历。    </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>target - preOrder.peek().val &lt; postOrder.peek().val - target的条件前<br>记得加上!preOrder.isEmpty()</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123;</span><br><span class="line">List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">if(root == null)</span><br><span class="line">return res;</span><br><span class="line">Stack&lt;TreeNode&gt; preOrder = new Stack&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; postOrder = new Stack&lt;&gt;();</span><br><span class="line">findTargetAndPopulateStacks(preOrder, postOrder, root, target);</span><br><span class="line"></span><br><span class="line">while(k-- &gt; 0) &#123;</span><br><span class="line">if(postOrder.isEmpty() || (!preOrder.isEmpty() &amp;&amp; </span><br><span class="line">target - preOrder.peek().val &lt; postOrder.peek().val - target))</span><br><span class="line">getPredecessor(preOrder, res);</span><br><span class="line">else </span><br><span class="line">getSuccessor(postOrder, res);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findTargetAndPopulateStacks(Stack&lt;TreeNode&gt; preOrder, Stack&lt;TreeNode&gt; postOrder, </span><br><span class="line">TreeNode root, double target) &#123;</span><br><span class="line">TreeNode node = root;</span><br><span class="line">while(node != null) &#123;</span><br><span class="line">if(node.val &lt; target) &#123; </span><br><span class="line">preOrder.push(node);</span><br><span class="line">node = node.right;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">postOrder.push(node);</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getSuccessor(Stack&lt;TreeNode&gt; postOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">TreeNode node = postOrder.pop();</span><br><span class="line">res.add(node.val);</span><br><span class="line">if(node.right != null) &#123;</span><br><span class="line">TreeNode n = node.right;</span><br><span class="line">while(n != null) &#123;</span><br><span class="line">postOrder.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPredecessor(Stack&lt;TreeNode&gt; preOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">TreeNode node = preOrder.pop();</span><br><span class="line">res.add(node.val);</span><br><span class="line">if(node.left != null) &#123;</span><br><span class="line">TreeNode n = node.left;</span><br><span class="line">while(n != null) &#123;</span><br><span class="line">preOrder.push(n);</span><br><span class="line">n = n.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为O(k + logn)，空间复杂度O(logn)。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/closest-binary-search-tree-value-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 272 Closest 
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 173 Binary Search Tree Iterator</title>
    <link href="https://shineboy2013.github.com/2020/04/26/lee-173/"/>
    <id>https://shineboy2013.github.com/2020/04/26/lee-173/</id>
    <published>2020-04-26T07:02:25.769Z</published>
    <updated>2020-04-26T19:05:51.968Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></strong></p><div><br><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br><br>Calling <code>next()</code> will return the next smallest number in the BST.<br><br><strong>Example:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt=""></strong><br><br><pre>BSTIterator iterator = new BSTIterator(root);<br>iterator.next();    // return 3<br>iterator.next();    // return 7<br>iterator.hasNext(); // return true<br>iterator.next();    // return 9<br>iterator.hasNext(); // return true<br>iterator.next();    // return 15<br>iterator.hasNext(); // return true<br>iterator.next();    // return 20<br>iterator.hasNext(); // return false<br></pre><br><br><strong>Note:</strong><br><br><em>   <code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</em>   You may assume that <code>next()</code> call will always be valid, that is, there will be at least a next smallest number in the BST when <code>next()</code> is called.<br><br></div><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>参照KB中BST的非递归中序遍历。将其分拆为初始化以及去掉stack不为空的循环分别为所求。 </p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L173BinarySearchTreeIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">TreeNode head = root;</span><br><span class="line"><span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">s.push(head);</span><br><span class="line">head = head.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recommended</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TreeNode node = s.pop(); </span><br><span class="line"><span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;<span class="comment">// left node has been visited</span></span><br><span class="line">TreeNode n = node.right; </span><br><span class="line"><span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">s.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !s.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next的平均时间复杂度(amortized complexity)为<code>O(1)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-search-tree-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 173 Binary Search Tr
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="https://shineboy2013.github.com/2020/04/21/binary-search/"/>
    <id>https://shineboy2013.github.com/2020/04/21/binary-search/</id>
    <published>2020-04-22T00:28:02.383Z</published>
    <updated>2020-04-22T00:34:42.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>循环条件start + 1 &lt; end。 当跳出循环时，start和end的关系只能是相等或相邻。<br>相等是若数组只有一个元素，没有进入循环时出现。当进入过循环，一定是相邻。</li><li>跳出循环后比较start和end的关系从而判断答案。  </li></ol><p>这可以满足二分法找first position或者last position, peak element的题目。<br>first position中若等于target，end = mid，因为要在左半部分找，相反last<br>position在右半部分找，所以start = mid。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>有序数组找目标</li><li>没给定目标情况下，找峰值</li><li>没给定目标情况下，求数值，如求根号</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">start = mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line"><span class="comment">// Depends on the target on the right side or left side. For fist pos, use end = mid</span></span><br><span class="line">start = mid; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">end = mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[end] == target)</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line"><span class="keyword">if</span>(nums[start] == target)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;循环条件start + 1 &amp;lt; end。 当跳出循环时，star
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1197 Minimum Knight Moves</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-1197/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-1197/</id>
    <published>2020-04-21T02:01:15.387Z</published>
    <updated>2020-04-21T02:14:46.630Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-knight-moves/" target="_blank" rel="noopener">LeetCode 1197 Minimum Knight Moves</a></strong></p><p>In an infinite chess board with coordinates from <code>-infinity</code> to <code>+infinity</code>, you have a knight at square <code>[0, 0]</code>.</p><p>A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" alt=""></p><p>Return the minimum number of steps needed to move the knight to the square <code>[x, y]</code>.  It is guaranteed the answer exists.</p><p>Example 1:</p><pre>Input: x = 2, y = 1Output: 1Explanation: [0, 0] → [2, 1]</pre><p>Example 2:</p><pre>Input: x = 5, y = 5Output: 4Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]</pre><p>Constraints:</p><ul><li><code>|x| + |y| &lt;= 300</code></li></ul><p>Because x and y are constrained to be in range[-300, 300], we can use BFS to find the minimum steps needed to reach target(x, y). Furthermore, we can only consider the case that x &gt;=0 &amp;&amp; y &gt;=0 since the chess board is symmetric.  The bfs implementation is pretty straightforward. There are two important points you need to be careful with.</p><ol><li>Pruning. We can limit the search dimension within 310 * 310. Any moves that lead to a position that is outside this box will not yield an optimal result.</li></ol><p>2. Initially, you used a Set of type int[] to track visited positions. This caused TLE because you didn’t overwrite the hashCode and equals methods for int[]. As a result, Set uses the default hashCode and equals method when checking if an element is already in the set. For equals(), The default implementation provided by the JDK is based on memory location — two objects are equal if and only if they are stored in the same memory address. For a comprehensive reading, refer to <a href="https://dzone.com/articles/working-with-hashcode-and-equals-in-java" target="_blank" rel="noopener">https://dzone.com/articles/working-with-hashcode-and-equals-in-java</a></p><p>O(x * y) runtime and space</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>象棋一样，走日字到达目标点的最小次数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建距离map。  </li><li>BFS访问。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>用map记录距离一定要将首节点加入到map中，否则求距离时候会NPE。</strong>  </li><li>visited我一开始实现用HashSet但因为没有实现equals导致LTE，改成矩阵即可。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] directX = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] directY = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point source, Point destination)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Point&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Map&lt;Point, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(source, <span class="number">0</span>); <span class="comment">// remember</span></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">q.offer(source);</span><br><span class="line">visited[source.x][source.y] = <span class="keyword">true</span>; <span class="comment">// use hashSet is wrong.</span></span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">Point p = q.poll();</span><br><span class="line"><span class="keyword">if</span>(p.x == destination.x &amp;&amp; p.y == destination.y)</span><br><span class="line"><span class="keyword">return</span> map.get(p);</span><br><span class="line"><span class="keyword">for</span>(Point neighbor : getNeighbors(p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isValid(grid, neighbor) || visited[neighbor.x][neighbor.y])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line">visited[neighbor.x][neighbor.y] = <span class="keyword">true</span>;</span><br><span class="line">map.put(neighbor, map.get(p) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Point&gt; <span class="title">getNeighbors</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">List&lt;Point&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">result.add(<span class="keyword">new</span> Point(point.x + directX[i], point.y + directY[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point point)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(point.x &gt;= <span class="number">0</span> &amp;&amp; point.x &lt; grid.length &amp;&amp; point.y &gt;= <span class="number">0</span> &amp;&amp; point.y &lt; grid[<span class="number">0</span>].length </span><br><span class="line">&amp;&amp; !grid[point.x][point.y])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为棋盘大小<code>O(n*m)</code>，空间复杂度<code>O(n)</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-knight-moves/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 1197 Minimum Knight Moves&lt;/
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 127 Word Ladder</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-127/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-127/</id>
    <published>2020-04-20T22:08:38.780Z</published>
    <updated>2020-05-04T01:11:35.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">LeetCode 127 Word Ladder</a></strong></p><div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time.<br>2.  Each transformed word must exist in the word list.<br><br><strong>Note:</strong><br><br><em>   Return 0 if there is no such transformation sequence.</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong> 5<br><br><strong>Explanation:</strong> As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> 0<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求最少变换次数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>这是图，所以要有visited记录是否重复访问。</li><li>字典的实现两个作用： 快速查找，以及记录距离可以省下一轮循环。总共两重循环。  </li><li>getNextWords的实现。通过变换每位上字母，比较巧妙。    </li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建字典。  </li><li>BFS访问。  </li><li>求所有距离为1的相邻单词getNextWords。    </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>getNextWords的实现不含自己。  </li><li>注意题目条件，开始词和终结词不一定在字典中，要将它们加入去。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"><span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line"><span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line"><span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(beginWord);</span><br><span class="line">visited.add(beginWord);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">String word = q.poll();</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line"><span class="keyword">return</span> dict.get(word);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line"><span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(s))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q.offer(s);</span><br><span class="line">visited.add(s);</span><br><span class="line">dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">map.put(word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line"><span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line"><span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line"><span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">result.add(newWord);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code><br>时间复杂度为<code>O(n*<em>L</em><sup>2</sup>)</code>，空间复杂度<code>O(n)</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 127 Word Ladder&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;di
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297 Serialize and Deserialize Binary Tree</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-297/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-297/</id>
    <published>2020-04-20T18:36:09.608Z</published>
    <updated>2020-04-21T00:48:36.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">LeetCode 297 Serialize and Deserialize Binary Tree</a></strong></p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Example: </strong></p><pre>You may serialize the following tree:    1   / \  2   3     / \    4   5as `"[1,2,3,null,null,4,5]"`</pre><p><strong>Clarification:</strong> The above format is the same as <a href="/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Note: </strong>Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>序列化和反序列化二叉树。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS可以涉及三重循环</p><ol><li>q不为空  </li><li>是否按层遍历  </li><li>是否为图  </li></ol><p>这题不需要按层遍历，所以不用第二重。而且只是二叉树，不用第三重循环。</p><p>编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">   #     3</span><br><span class="line">        /  \</span><br><span class="line">       2   #</span><br><span class="line">      / \</span><br><span class="line">     #   #</span><br><span class="line">=&gt; 1,#,3,2,#,#,#</span><br></pre></td></tr></table></figure></p><h3 id="BFS解题步骤："><a href="#BFS解题步骤：" class="headerlink" title="BFS解题步骤："></a><strong>BFS解题步骤：</strong></h3><p>serialize:  </p><ol><li>建queue，然后首节点入列</li><li>进入q的非空循环，队首出列，分别加入左右子树。由于左右子树可能为空，所以队首为空时continue<br>且val加入到结果字符串<br>乘以下标距离即为横向藏水增量，更新底部进入下一次出栈。  </li><li>用#代替null且删去末尾的#和，  </li></ol><p>deserialize:<br>这方法难实现点。用两个指针来代表遍历上一层和该层节点们。q出列的节点是上一层节点head，而idx指向的是<br>该层节点。这样head.left = Node(tokens[idx])就建立了它们的关系。两指针分别向后一位。每轮循环父指针<br>向后一位，而idx向后两位，因为有左右儿子。</p><ol><li>建queue，然后首节点入列</li><li>进入q的非空循环，队首出列，分别生成非空左右子树，且建立父子关系。idx走两步，非空儿子加入q。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>字符串相等判断用equals，不用==。  </li><li>deserialize中循环条件要加入idx &lt; tokens.length因为serialize末尾#已经删除。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.add(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">TreeNode n = q.poll();</span><br><span class="line">sb.append(n == <span class="keyword">null</span> ? <span class="string">"null"</span> : n.val);</span><br><span class="line">sb.append(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">q.add(n.left);</span><br><span class="line">q.add(n.right);</span><br><span class="line">&#125;</span><br><span class="line">String res = sb.toString().replaceAll(<span class="string">"null"</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="keyword">int</span> endIdx = res.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(res.charAt(endIdx) == <span class="string">','</span> || res.charAt(endIdx) == <span class="string">'#'</span>)</span><br><span class="line">endIdx--;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;"</span> + res.substring(<span class="number">0</span>, endIdx + <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize2</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">String str = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String[] tokens = str.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[<span class="number">0</span>]));</span><br><span class="line">q.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty() &amp;&amp; idx &lt; tokens.length) &#123;</span><br><span class="line">TreeNode head = q.poll();</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">head.left = generateChildNode(idx++, tokens, q);</span><br><span class="line">head.right = generateChildNode(idx++, tokens, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">generateChildNode</span><span class="params">(<span class="keyword">int</span> idx, String[] tokens, Queue&lt;TreeNode&gt; q)</span> </span>&#123;</span><br><span class="line">TreeNode root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; tokens.length &amp;&amp; !<span class="string">"#"</span>.equals(tokens[idx])) &#123;</span><br><span class="line">root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[idx]));</span><br><span class="line">q.offer(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="DFS算法II解题思路："><a href="#DFS算法II解题思路：" class="headerlink" title="DFS算法II解题思路："></a><strong>DFS算法II解题思路：</strong></h3><p>DFS的serialize很简单，但deserialize比较难。有点类似于前序遍历的递归版，需要维护一个指针p来记录<br>已处理的字符串。  </p><p>编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">  2   3</span><br><span class="line">5  6</span><br><span class="line">=&gt; 1,2,5,#,#,6,#,#,3,#,#</span><br></pre></td></tr></table></figure></p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">String rootStr = root.val+<span class="string">""</span>;</span><br><span class="line">String lStr = serialize(root.left);</span><br><span class="line">String rStr = serialize(root.right);</span><br><span class="line"><span class="keyword">return</span> rootStr+<span class="string">","</span>+lStr+<span class="string">","</span>+rStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line">items = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> deserializeR(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeR</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(data==<span class="keyword">null</span>||data.length()==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(p&gt;=data.length())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">String curVal = getNext(data);</span><br><span class="line"><span class="keyword">if</span>(curVal.equals(<span class="string">"#"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">TreeNode newRoot = <span class="keyword">new</span> TreeNode(Integer.parseInt(curVal));</span><br><span class="line">newRoot.left = deserializeR(data);</span><br><span class="line">newRoot.right = deserializeR(data);</span><br><span class="line"><span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">String[] items = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNext</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(items==<span class="keyword">null</span>)</span><br><span class="line">items = s.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">return</span> items[p++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 297 Serial
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 133 Clone Graph</title>
    <link href="https://shineboy2013.github.com/2020/04/19/lee-133/"/>
    <id>https://shineboy2013.github.com/2020/04/19/lee-133/</id>
    <published>2020-04-20T06:41:45.806Z</published>
    <updated>2020-04-21T00:48:42.315Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">LeetCode 133 Clone Graph</a></strong></p><p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory" target="_blank" rel="noopener">connected</a>#Connected_graph)</strong> undirected graph.</p><p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> (clone) of the graph.</p><p>Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><pre>class Node {    public int val;    public List<node> neighbors;}</node></pre><p><strong>Test case format:</strong></p><p>For simplicity sake, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code>val = 1</code>, the second node with <code>val = 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p><strong>Adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt=""></p><pre>**Input:** adjList = [[2,4],[1,3],[2,4],[1,3]]**Output:** [[2,4],[1,3],[2,4],[1,3]]**Explanation:** There are 4 nodes in the graph.1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" alt=""></p><pre>**Input:** adjList = [[]]**Output:** [[]]**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</pre><p><strong>Example 3:</strong></p><pre>**Input:** adjList = []**Output:** []**Explanation:** This an empty graph, it does not have any nodes.</pre><p><strong>Example 4:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph-1.png" alt=""></p><pre>**Input:** adjList = [[2],[1]]**Output:** [[2],[1]]</pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= Node.val &lt;= 100</code></li><li><code>Node.val</code> is unique for each node.</li><li>Number of Nodes will not exceed 100.</li><li>There is no repeated edges and no self-loops in the graph.</li><li>The Graph is connected and all nodes can be visited starting from the given node.</li></ul><p></p><p></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>深度复制图。注意要复制所有邻接节点。 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>空节点判断。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph2</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">bfs(node, map);</span><br><span class="line"><span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</span><br><span class="line">Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(node);</span><br><span class="line">map.put(node, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">UndirectedGraphNode head = q.poll();</span><br><span class="line"><span class="keyword">for</span>(UndirectedGraphNode neighbor : head.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(neighbor)) &#123;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line"><span class="comment">// Clone vertex</span></span><br><span class="line">map.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clone edge</span></span><br><span class="line">map.get(head).neighbors.add(map.get(neighbor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>三步走。分开写逻辑会显得清晰点。第一步，BFS搜索所有节点，变成邻接表。第二步，复制节点。第三步，复制边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// another bfs3 method uses 3 steps, convert graph to adjacent list by bfs (flatten the graph), </span><br><span class="line">//clone vertices, clone edges</span><br><span class="line">public void bfs3(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map) &#123;</span><br><span class="line">ArrayList&lt;UndirectedGraphNode&gt; nodes = getNodes(node);</span><br><span class="line"></span><br><span class="line">// Copy vertices</span><br><span class="line">for(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">UndirectedGraphNode newNode = new UndirectedGraphNode(old.label);</span><br><span class="line">map.put(old, newNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Copy edges</span><br><span class="line">for(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">for(UndirectedGraphNode neighbor : old.neighbors) &#123;</span><br><span class="line">map.get(old).neighbors.add(map.get(neighbor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;UndirectedGraphNode&gt; getNodes(UndirectedGraphNode node) &#123;</span><br><span class="line">Queue&lt;UndirectedGraphNode&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;UndirectedGraphNode&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">q.offer(node);</span><br><span class="line">result.add(node); // Use result set so we can save the visited set</span><br><span class="line">while(!q.isEmpty()) &#123;</span><br><span class="line">UndirectedGraphNode n = q.poll();</span><br><span class="line">for(UndirectedGraphNode neighbor : n.neighbors) &#123;</span><br><span class="line">if(result.contains(neighbor))</span><br><span class="line">continue;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line">result.add(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;UndirectedGraphNode&gt; reList = new ArrayList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">reList.addAll(result);</span><br><span class="line">return reList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="算法II解题思路：-1"><a href="#算法II解题思路：-1" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>DFS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</span><br><span class="line">HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;Integer, UndirectedGraphNode&gt;();</span><br><span class="line">return cloneGraphR(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public UndirectedGraphNode cloneGraphR(UndirectedGraphNode node,</span><br><span class="line">HashMap&lt;Integer, UndirectedGraphNode&gt; map) &#123;</span><br><span class="line">if (node == null)</span><br><span class="line">return node;</span><br><span class="line">if (map.containsKey(node.label))</span><br><span class="line">return map.get(node.label);</span><br><span class="line"></span><br><span class="line">UndirectedGraphNode result = new UndirectedGraphNode(node.label);</span><br><span class="line">map.put(node.label, result);</span><br><span class="line">for (UndirectedGraphNode child : node.neighbors) &#123;</span><br><span class="line">result.neighbors.add(cloneGraphR(child, map));</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/clone-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 133 Clone Graph&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 248 Strobogrammatic Number III</title>
    <link href="https://shineboy2013.github.com/2020/03/08/lee-248/"/>
    <id>https://shineboy2013.github.com/2020/03/08/lee-248/</id>
    <published>2020-03-09T01:39:06.644Z</published>
    <updated>2020-04-21T00:48:50.595Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/strobogrammatic-number-iii/" target="_blank" rel="noopener">LeetCode 248 Strobogrammatic Number III</a></strong></p><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p><p><strong>Example:</strong> </p><pre>**Input: low = "50", high = "100"**Output:** 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers.</pre><p><strong>Note:</strong> Because the range might be a large number, the lowand high numbers are represented as string.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求某范围的旋转数的个数。旋转数是这个数旋转180度还是一样，如0, 1, 8， 还含两位的如69， 96. </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是M公司的题目。类似于L351安卓解码种数，数字间有关系，求[m, n]范围间种数。用DFS将每一位填上合法位，此题区别是<br>需要它有对称性，所以DFS从中间向两边。API为f(res, low, high, map), res为当前结果字符串，map为旋转数的映射关系，<br>终止条件为res超过high，若在范围内，结果+1，也就是先将自己加入到结果中，然后两边加入旋转字符，进入下一轮递归，<br>累加到结果中。  </p><p>注意: 与上题一样，和最左位不能为0除了0自己本身。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>奇偶位。对称中心既可以是奇数位也可以是偶数位。  </li><li>最左位为0，不合法如0880，但0本身除外。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strobogrammaticInRange</span><span class="params">(String low, String high)</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"6"</span>, <span class="string">"9"</span>);</span><br><span class="line">map.put(<span class="string">"9"</span>, <span class="string">"6"</span>);</span><br><span class="line">map.put(<span class="string">"1"</span>, <span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="string">"8"</span>, <span class="string">"8"</span>);</span><br><span class="line">map.put(<span class="string">"0"</span>, <span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">result += dfs(<span class="string">""</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"1"</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"0"</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"8"</span>, low, high, map);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String res, String low, String high, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res.length() &gt; high.length() || (res.length() == high.length() &amp;&amp; res.compareTo(high) &gt; <span class="number">0</span>)) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((res.length() == low.length() &amp;&amp; res.compareTo(low) &gt;= <span class="number">0</span>)  || res.length() &gt; low.length()) </span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(res.length() &gt; <span class="number">1</span> &amp;&amp; res.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">result += dfs(entry.getKey() + res + entry.getValue(), low, high, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/strobogrammatic-number-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 248 Strobogrammatic N
      
    
    </summary>
    
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
</feed>
