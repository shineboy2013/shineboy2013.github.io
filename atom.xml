<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-18T08:40:38.803Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 809 Expressive Words</title>
    <link href="https://shineboy2013.github.com/2021/12/18/lee-809/"/>
    <id>https://shineboy2013.github.com/2021/12/18/lee-809/</id>
    <published>2021-12-18T08:25:24.764Z</published>
    <updated>2021-12-18T08:40:38.803Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/expressive-words/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Sometimes people repeat letters to represent extra feeling. For example:<br><br><em>   <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code></em>   <code>&quot;hi&quot; -&gt; &quot;hiiii&quot;</code><br><br>In these strings like <code>&quot;heeellooo&quot;</code>, we have groups of adjacent letters that are all the same: <code>&quot;h&quot;</code>, <code>&quot;eee&quot;</code>, <code>&quot;ll&quot;</code>, <code>&quot;ooo&quot;</code>.<br><br>You are given a string <code>s</code> and an array of query strings <code>words</code>. A query word is <strong>stretchy</strong> if it can be made to be equal to <code>s</code> by any number of applications of the following extension operation: choose a group consisting of characters <code>c</code>, and add some number of characters <code>c</code> to the group so that the size of the group is <strong>three or more</strong>.<br><br><em>   For example, starting with <code>&quot;hello&quot;</code>, we could do an extension on the group <code>&quot;o&quot;</code> to get <code>&quot;hellooo&quot;</code>, but we cannot get <code>&quot;helloo&quot;</code> since the group <code>&quot;oo&quot;</code> has a size less than three. Also, we could do another extension like <code>&quot;ll&quot; -&gt; &quot;lllll&quot;</code> to get <code>&quot;helllllooo&quot;</code>. If <code>s = &quot;helllllooo&quot;</code>, then the query word <code>&quot;hello&quot;</code> would be <strong>stretchy</strong> because of these two extension operations: <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>.<br><br>Return <em>the number of query strings that are <strong>stretchy</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “heeellooo”, words = [“hello”, “hi”, “helo”]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>We can extend “e” and “o” in the word “hello” to get “heeellooo”.<br>We can’t extend “helo” to get “heeellooo” because the group “ll” is not size 3 or more.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “zzzzzyyyyy”, words = [“zzyy”,”zy”,”zyy”]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length, words.length &lt;= 100</code><br><em>   <code>1 &lt;= words[i].length &lt;= 100</code></em>   <code>s</code> and <code>words[i]</code> consist of lowercase letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Cisco常考题<br>定义了一种富于表现力的单词，就是说某个字母可以重复三次或以上，叫stretchy<br>找给定的单词列表中的单词可以成为stretchy单词的个数  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计每个字符的个数，然后比较对应每个字符个数 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 13的条件，若个数不等，word的字符个数大于stretchy的字符个数(word不能删除字符)，或者stretchy的个数小于3，就不满足    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">s_count = self.get_count(s)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">char_count = self.get_count(word)</span><br><span class="line"><span class="keyword">if</span> len(char_count) != len(s_count):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s_count)):</span><br><span class="line">char_s, count_s = s_count[i]</span><br><span class="line">char_w, count_w = char_count[i]</span><br><span class="line"><span class="keyword">if</span> char_w != char_s:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> count_s != count_w <span class="keyword">and</span> (count_w &gt; count_s <span class="keyword">or</span> count_s &lt; <span class="number">3</span>): <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == len(s_count) - <span class="number">1</span>:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(self, s)</span>:</span></span><br><span class="line">s += <span class="string">' '</span></span><br><span class="line">s_count, count = [], <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] != s[i - <span class="number">1</span>]:</span><br><span class="line">s_count.append((s[i - <span class="number">1</span>], count))</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> s_count</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/expressive-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;S
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 829 Consecutive Numbers Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-829/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-829/</id>
    <published>2021-12-17T03:46:42.282Z</published>
    <updated>2021-12-17T04:46:22.326Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <em>the number of ways you can write</em> <code>n</code> <em>as the sum of consecutive positive integers.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> 5 = 2 + 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 9<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 9 = 4 + 5 = 2 + 3 + 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 15<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续整数的和等于N的个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>只有Fintech考，数学题。思路见注释  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x, x+1, ... , x+k-1</span></span><br><span class="line"><span class="comment"># (x + x+k-1) * k / 2 = 2x+k-1) = n, x = [n - k(k-1)/2]/k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(<span class="number">2</span> * n) + <span class="number">1</span>)):</span><br><span class="line"><span class="keyword">if</span> (n - i * (i - <span class="number">1</span>) / <span class="number">2</span>) % i == <span class="number">0</span>:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/consecutive-numbers-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 041 First Missing Positive</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-041/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-041/</id>
    <published>2021-12-17T03:38:45.498Z</published>
    <updated>2021-12-17T03:47:45.279Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.<br><br>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,0]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,4,-1,1]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [7,8,9,11,12]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 5 </em> 10<sup>5</sup><code>*</code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找第一个缺失的正整数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于quick sort里面的partition，满足某些条件才移动指针  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>第一个正确元素为1，所以预期数组为[1, 2, 3…]，从1开始并不是从0开始。  </li><li>交换元素的条件：需要交换nums[i] != i + 1, 可以交换[1 &lt;= nums[i] &lt;= len(nums)], 不会死循环(nums[nums[i] - 1] != nums[i])    </li><li>若满足条件，无限交换，直到不满足条件。不满足条件才移动遍历指针i</li><li>交换两元素涉及内嵌数组，所以不能用comment上的。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line"><span class="keyword">if</span> nums[i] != i + <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line"><span class="comment"># nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]</span></span><br><span class="line">self.swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= len(nums):</span><br><span class="line"><span class="keyword">if</span> j != nums[j - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 588 Design In-Memory File System</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-588/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-588/</id>
    <published>2021-12-16T22:55:02.876Z</published>
    <updated>2021-12-16T23:59:42.644Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-in-memory-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>如数据库系统的B+树一样，用Trie</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>TrieNode含children和files，都是dict，<strong>只能是目录节点</strong>。因为不知道最后一个路劲部分是文件还是目录，所以ls里面需要遍历直到倒数第二个节点，再判断是哪种情况。另一个种设计是采取is_file, content，既可以是目录节点也可以是文件节点，本文采取前者     </li><li>ls:题目要求目录可以含目录和文件。两种情况：若是文件，返回[文件]含在一个list中；若是目录，返回它下面的目录+文件  </li><li>ls:返回结果要排序  </li><li>ls:输入path可以是/或/a/b，所以/要特殊化处理，只能是目录，所以只有一种情况：目录和文件    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ls</span><span class="params">(self, path: str)</span> -&gt; List[str]:</span>  <span class="comment"># req remember /a not /a/</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(self.root.children.keys()) + list(self.root.files.keys())) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">        dirs = path[<span class="number">1</span>:].split(<span class="string">'/'</span>)</span><br><span class="line">        it = self.ls_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dirs[<span class="number">-1</span>] <span class="keyword">in</span> it.files:</span><br><span class="line">            <span class="keyword">return</span> [dirs[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># return files if no dir, no mixed types in same dir</span></span><br><span class="line">            <span class="keyword">return</span> sorted(list(it.children[dirs[<span class="number">-1</span>]].children.keys()) + list(it.children[dirs[<span class="number">-1</span>]].files.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(self, path: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        path = path[<span class="number">1</span>:]</span><br><span class="line">        dirs = path.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        self.mkdir_internal(dirs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addContentToFile</span><span class="params">(self, filePath: str, content: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self.mkdir_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        filename = dirs[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">not</span> <span class="keyword">in</span> it.files:</span><br><span class="line">            it.files[filename] = <span class="string">''</span></span><br><span class="line">        it.files[filename] += content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readContentFromFile</span><span class="params">(self, filePath: str)</span> -&gt; str:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>)  <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self.ls_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> it.files[dirs[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ls_internal</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">            it = it.children[dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir_internal</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">            <span class="keyword">if</span> dir <span class="keyword">not</span> <span class="keyword">in</span> it.children: <span class="comment"># a</span></span><br><span class="line">                it.children[dir] = TrieNode() <span class="comment">#</span></span><br><span class="line">            it = it.children[dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.files = collections.defaultdict(str) <span class="comment"># use dict coz filename can't be duplicate and faster for lookup</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>, n为路径长度  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-in-memory-file-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1041 Robot Bounded In Circle</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-1041/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-1041/</id>
    <published>2021-12-16T20:37:05.135Z</published>
    <updated>2021-12-16T20:41:07.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/robot-bounded-in-circle/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>On an infinite plane, a robot initially stands at <code>(0, 0)</code> and faces north. The robot can receive one of three instructions:<br><br><em>   <code>&quot;G&quot;</code>: go straight 1 unit;</em>   <code>&quot;L&quot;</code>: turn 90 degrees to the left;<br><em>   <code>&quot;R&quot;</code>: turn 90 degrees to the right.<br><br>The robot performs the <code>instructions</code> given in order, and repeats them forever.<br><br>Return <code>true</code> if and only if there exists a circle in the plane such that the robot never leaves the circle.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> instructions = “GGLLGG”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).<br>When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> instructions = “GG”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The robot moves north indefinitely.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> instructions = “GL”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; …</pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= instructions.length &lt;= 100</code><br>*   <code>instructions[i]</code> is <code>&#39;G&#39;</code>, <code>&#39;L&#39;</code> or, <code>&#39;R&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>循环按模式走是否回到原点  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，很难证明。定理是，只要按照给定模式走完，若回到原点或最后方向不是向北，都能回到原点  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isRobotBounded</span><span class="params">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class="line">DIRECTION_CONVERT_LEFT = &#123;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">DIRECTION_CONVERT_RIGHT = &#123;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">path, direction, position = instructions, (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> path:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'L'</span>:</span><br><span class="line">direction = DIRECTION_CONVERT_LEFT[direction]</span><br><span class="line"><span class="keyword">elif</span> char == <span class="string">'R'</span>:</span><br><span class="line">direction = DIRECTION_CONVERT_RIGHT[direction]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">position = (position[<span class="number">0</span>] + direction[<span class="number">0</span>], position[<span class="number">1</span>] + direction[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> position == (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">or</span> direction != (<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-bounded-in-circle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 680 Valid Palindrome II</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-680/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-680/</id>
    <published>2021-12-16T08:58:10.905Z</published>
    <updated>2021-12-16T09:04:39.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <code>true</code> <em>if the</em> <code>s</code> <em>can be palindrome after deleting <strong>at most one</strong> character from it</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aba”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abca”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You could delete the character ‘c’.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “abc”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> consists of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>删除一个字符变成回文字符串 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是O(n^2)，要优化到O(n)且这是关于元素之间的关系，考虑用Two pointers</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>当发现不相等的字符，不能简单认为s[i + 1] == s[j]就觉得应该删除左边字符，因为可能是刚好相等，如bddbd，第一个b和倒数第二个b相等，如果删除第一个b，就会得到False，所以应该<strong>删除左边字符和删除右边字符同时都要试</strong>    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; j:</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line"><span class="keyword">if</span> self.is_palindrome(s[i + <span class="number">1</span>:j + <span class="number">1</span>]) <span class="keyword">or</span> self.is_palindrome(s[i:j]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-palindrome-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 811 Subdomain Visit Count</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-811/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-811/</id>
    <published>2021-12-16T07:29:39.870Z</published>
    <updated>2021-12-16T07:34:12.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subdomain-visit-count/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>统计domain个数  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>N/A    </p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">domain_to_count = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> pair_str <span class="keyword">in</span> cpdomains:</span><br><span class="line">pair = pair_str.split(<span class="string">' '</span>)</span><br><span class="line">count = int(pair[<span class="number">0</span>])</span><br><span class="line">domain = pair[<span class="number">1</span>]</span><br><span class="line">domain_to_count[domain] += count</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> domain.find(<span class="string">'.'</span>, pos) &gt;= <span class="number">0</span>:</span><br><span class="line">domain = domain[domain.index(<span class="string">'.'</span>, pos) + <span class="number">1</span>:]</span><br><span class="line">domain_to_count[domain] += count</span><br><span class="line"><span class="keyword">return</span> [<span class="string">'&#123;&#125; &#123;&#125;'</span>.format(_count, _domain) <span class="keyword">for</span> _domain, _count <span class="keyword">in</span> domain_to_count.items()]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subdomain-visit-count/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1326 Minimum Number of Taps to Open to Water a Garden</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-1326/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-1326/</id>
    <published>2021-12-16T05:18:45.763Z</published>
    <updated>2021-12-16T07:00:25.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is a one-dimensional garden on the x-axis. The garden starts at the point <code>0</code> and ends at the point <code>n</code>. (i.e The length of the garden is <code>n</code>).<br><br>There are <code>n + 1</code> taps located at points <code>[0, 1, ..., n]</code> in the garden.<br><br>Given an integer <code>n</code> and an integer array <code>ranges</code> of length <code>n + 1</code> where <code>ranges[i]</code> (0-indexed) means the <code>i-th</code> tap can water the area <code>[i - ranges[i], i + ranges[i]]</code> if it was open.<br><br>Return <em>the minimum number of taps</em> that should be open to water the whole garden, If the garden cannot be watered return <strong>-1</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png" alt=""><br><br><pre><strong>Input:</strong> n = 5, ranges = [3,4,1,1,0,0]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The tap at point 0 can cover the interval [-3,3]<br>The tap at point 1 can cover the interval [-3,5]<br>The tap at point 2 can cover the interval [1,3]<br>The tap at point 3 can cover the interval [2,4]<br>The tap at point 4 can cover the interval [4,4]<br>The tap at point 5 can cover the interval [5,5]<br>Opening Only the second tap will water the whole garden [0,5]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3, ranges = [0,0,0,0]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> Even if you activate all the four taps you cannot water the whole garden.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 7, ranges = [1,2,1,0,2,1,0,1]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>ranges.length == n + 1</code><br>*   <code>0 &lt;= ranges[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>用多少个水龙头覆盖整个花园</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两个难点，此题类似于jump game，这一层某个水龙头浇到最远点的水龙头也就是这一层的水龙头，这是难点一。<br>难点二是跟jump game不同，这题可以往前跳，也就是如例子中，点2表示从1跳到3，因为它的范围是1. 所以要重新计算每个水龙头的起点=它的左半范围起点  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>第一步转化成jump game，jump game每个数值都是长度。若左半范围起点小于等于0，所有这些水龙头归结到起点0，长度为i + ranges[i], 其余情况是ranges[i] * 2    </li><li>完全用jump game的程序</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTaps</span><span class="params">(self, n: int, ranges: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">nums = [<span class="number">0</span>] * len(ranges)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ranges)):</span><br><span class="line"><span class="keyword">if</span> i - ranges[i] &lt;= <span class="number">0</span>:</span><br><span class="line">nums[<span class="number">0</span>] = max(nums[<span class="number">0</span>], ranges[i] + i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums[i - ranges[i]] = max(nums[i - ranges[i]], ranges[i] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>): <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">if</span> i &lt;= end:  <span class="comment"># -3 &lt;= 0</span></span><br><span class="line">next_end = max(next_end, i + nums[i])  <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">if</span> i == end:</span><br><span class="line">end = next_end</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">if</span> next_end &gt;= len(nums) - <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 055 Jump Game</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-055/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-055/</id>
    <published>2021-12-16T03:20:34.603Z</published>
    <updated>2021-12-16T03:24:50.078Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.<br><br>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1,0,4]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>0 &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>参考Jump game II，区别在于如果i &lt;= end才更新，</li><li>返回next_end要大于等于(可以cover)最后一个元素下标  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">end, next_end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line"><span class="keyword">return</span> next_end &gt;= len(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You are 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 045 Jump Game II</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-045/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-045/</id>
    <published>2021-12-16T02:50:08.907Z</published>
    <updated>2021-12-16T03:21:49.294Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.<br><br>Each element in the array represents your maximum jump length at that position.<br><br>Your goal is to reach the last index in the minimum number of jumps.<br><br>You can assume that you can always reach the last index.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,0,1,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>0 &lt;= nums[i] &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>end, next_end分别表示该层和下一层的边界，end从0开始，表示第0个数是第一层，遍历每个数，从0开始。   </li><li>这个<strong>边界是inclusive的</strong>，所以当i==end时候，不应该res加1，是下一轮循环才是下一层的开始。有两种实现，我的实现是第一种，标准答案是遍历到最后一个数的前一个，因为最后一个数已经是目标，所以不需要计算next_end，更不需要层数+1。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">update_end = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> update_end:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line">update_end = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line">update_end = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 528 Random Pick with Weight</title>
    <link href="https://shineboy2013.github.com/2021/12/14/lee-528/"/>
    <id>https://shineboy2013.github.com/2021/12/14/lee-528/</id>
    <published>2021-12-15T06:22:38.057Z</published>
    <updated>2021-12-15T06:32:42.680Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> index.<br><br>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.<br><br><em>   For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”]<br>[[[1]],[]]<br><strong>Output</strong><br>[null,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1]);<br>solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”]<br>[[[1,3]],[],[],[],[],[]]<br><strong>Output</strong><br>[null,1,1,1,1,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1, 3]);<br>solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.<br><br>Since this is a randomization problem, multiple answers are allowed.<br>All of the following outputs can be considered correct:<br>[null,1,1,1,1,0]<br>[null,1,1,1,1,1]<br>[null,1,1,1,0,0]<br>[null,1,1,1,0,1]<br>[null,1,0,1,0,0]<br>……<br>and so on.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= w.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>1 &lt;= w[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>pickIndex</code> will be called at most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> times.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据数组每个元素的weight来决定其出现的概率： weight/sum of weight  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>模拟运算过程，先求和，然后根据上述公式分配概率： 如[1, 3], 小于0.25属于第一个元素，大于属于后一个元素，我们不用小数，还原回整数<br>所以数值小于1属于第一个元素，大于1小于4属于后一个，想到用presum，然后在presum搜索某个value，就想到二分法。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>random.randint前闭后闭      </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, w: List[int])</span>:</span></span><br><span class="line">        self.presum = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> w:</span><br><span class="line">            sum += n</span><br><span class="line">            self.presum.append(sum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        rand_value = random.randint(<span class="number">0</span>, self.presum[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect(self.presum, rand_value)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1ogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/random-pick-with-weight/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Randomized" scheme="https://shineboy2013.github.com/tags/Randomized/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1396 Design Underground System</title>
    <link href="https://shineboy2013.github.com/2021/12/14/lee-1396/"/>
    <id>https://shineboy2013.github.com/2021/12/14/lee-1396/</id>
    <published>2021-12-15T05:56:09.154Z</published>
    <updated>2021-12-15T06:04:06.382Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-underground-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.<br><br>Implement the <code>UndergroundSystem</code> class:<br><br><em>   <code>void checkIn(int id, string stationName, int t)</code>    </em>   A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.<br>    <em>   A customer can only be checked into one place at a time.</em>   <code>void checkOut(int id, string stationName, int t)</code><br>    <em>   A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.</em>   <code>double getAverageTime(string startStation, string endStation)</code><br>    <em>   Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.    </em>   The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.<br>    <em>   The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.    </em>   There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.<br><br>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t&lt;sub&gt;1&lt;/sub&gt;</code> then checks out at time <code>t&lt;sub&gt;2&lt;/sub&gt;</code>, then <code>t&lt;sub&gt;1&lt;/sub&gt; &lt; t&lt;sub&gt;2&lt;/sub&gt;</code>. All events happen in chronological order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“UndergroundSystem”,”checkIn”,”checkIn”,”checkIn”,”checkOut”,”checkOut”,”checkOut”,”getAverageTime”,”getAverageTime”,”checkIn”,”getAverageTime”,”checkOut”,”getAverageTime”]<br>[[],[45,”Leyton”,3],[32,”Paradise”,8],[27,”Leyton”,10],[45,”Waterloo”,15],[27,”Waterloo”,20],[32,”Cambridge”,22],[“Paradise”,”Cambridge”],[“Leyton”,”Waterloo”],[10,”Leyton”,24],[“Leyton”,”Waterloo”],[10,”Waterloo”,38],[“Leyton”,”Waterloo”]]<br><br><strong>Output</strong><br>[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]<br><br><strong>Explanation</strong><br>UndergroundSystem undergroundSystem = new UndergroundSystem();<br>undergroundSystem.checkIn(45, “Leyton”, 3);<br>undergroundSystem.checkIn(32, “Paradise”, 8);<br>undergroundSystem.checkIn(27, “Leyton”, 10);<br>undergroundSystem.checkOut(45, “Waterloo”, 15);  // Customer 45 “Leyton” -&gt; “Waterloo” in 15-3 = 12<br>undergroundSystem.checkOut(27, “Waterloo”, 20);  // Customer 27 “Leyton” -&gt; “Waterloo” in 20-10 = 10<br>undergroundSystem.checkOut(32, “Cambridge”, 22); // Customer 32 “Paradise” -&gt; “Cambridge” in 22-8 = 14<br>undergroundSystem.getAverageTime(“Paradise”, “Cambridge”); // return 14.00000. One trip “Paradise” -&gt; “Cambridge”, (14) / 1 = 14<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 11.00000. Two trips “Leyton” -&gt; “Waterloo”, (10 + 12) / 2 = 11<br>undergroundSystem.checkIn(10, “Leyton”, 24);<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 11.00000<br>undergroundSystem.checkOut(10, “Waterloo”, 38);  // Customer 10 “Leyton” -&gt; “Waterloo” in 38-24 = 14<br>undergroundSystem.getAverageTime(“Leyton”, “Waterloo”);    // return 12.00000. Three trips “Leyton” -&gt; “Waterloo”, (10 + 12 + 14) / 3 = 12<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input</strong><br>[“UndergroundSystem”,”checkIn”,”checkOut”,”getAverageTime”,”checkIn”,”checkOut”,”getAverageTime”,”checkIn”,”checkOut”,”getAverageTime”]<br>[[],[10,”Leyton”,3],[10,”Paradise”,8],[“Leyton”,”Paradise”],[5,”Leyton”,10],[5,”Paradise”,16],[“Leyton”,”Paradise”],[2,”Leyton”,21],[2,”Paradise”,30],[“Leyton”,”Paradise”]]<br><br><strong>Output</strong><br>[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]<br><br><strong>Explanation</strong><br>UndergroundSystem undergroundSystem = new UndergroundSystem();<br>undergroundSystem.checkIn(10, “Leyton”, 3);<br>undergroundSystem.checkOut(10, “Paradise”, 8); // Customer 10 “Leyton” -&gt; “Paradise” in 8-3 = 5<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 5.00000, (5) / 1 = 5<br>undergroundSystem.checkIn(5, “Leyton”, 10);<br>undergroundSystem.checkOut(5, “Paradise”, 16); // Customer 5 “Leyton” -&gt; “Paradise” in 16-10 = 6<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 5.50000, (5 + 6) / 2 = 5.5<br>undergroundSystem.checkIn(2, “Leyton”, 21);<br>undergroundSystem.checkOut(2, “Paradise”, 30); // Customer 2 “Leyton” -&gt; “Paradise” in 30-21 = 9<br>undergroundSystem.getAverageTime(“Leyton”, “Paradise”); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= id, t &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></em>   <code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code><br><em>   All strings consist of uppercase and lowercase English letters and digits.</em>   There will be at most <code>2 * 10&lt;sup&gt;4&lt;/sup&gt;</code> calls <strong>in total</strong> to <code>checkIn</code>, <code>checkOut</code>, and <code>getAverageTime</code>.<br>*   Answers within <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> of the actual value will be accepted.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两站之间的平均时间。checkin和checkout都会发生，一个人不能连续checkin两次。站都是按先到后。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用两个Map来记录customer id -&gt; 站台和时间，另一个记录起始站pair -&gt; 总距离多少trip pair  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>collections.defaultdict(lambda: [0, 0]) 用于value是pair     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start_to_end_time = &#123;&#125;</span><br><span class="line">        self.start_end_to_total = collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># cant use defaultdict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.start_to_end_time[id] = (stationName, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">not</span> <span class="keyword">in</span> self.start_to_end_time:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        (start_station, start_time) = self.start_to_end_time[id]</span><br><span class="line">        total, n_trips = self.start_end_to_total[(start_station, stationName)]</span><br><span class="line">        total += t - start_time</span><br><span class="line">        n_trips += <span class="number">1</span></span><br><span class="line">        self.start_end_to_total[(start_station, stationName)] = (total, n_trips)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        total, n_trips = self.start_end_to_total[(startStation, endStation)]</span><br><span class="line">        <span class="keyword">return</span> total / n_trips</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-underground-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Bloomberg" scheme="https://shineboy2013.github.com/tags/Bloomberg/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 394 Decode String</title>
    <link href="https://shineboy2013.github.com/2021/12/13/lee-394/"/>
    <id>https://shineboy2013.github.com/2021/12/13/lee-394/</id>
    <published>2021-12-14T02:34:58.198Z</published>
    <updated>2021-12-14T07:57:57.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an encoded string, return its decoded string.<br><br>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.<br><br>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.<br><br>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “3[a]2[bc]”<br><strong>Output:</strong> “aaabcbc”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “3[a2[c]]”<br><strong>Output:</strong> “accaccacc”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “2[abc]3[cd]ef”<br><strong>Output:</strong> “abcabccdcdcdef”<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> s = “abc3[cd]xyz”<br><strong>Output:</strong> “abccdcdcdxyz”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 30</code></em>   <code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.<br><em>   <code>s</code> is guaranteed to be <strong>a valid</strong> input.</em>   All the integers in <code>s</code> are in the range <code>[1, 300]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将循环体表示展开</p><h3 id="Stack解题思路-推荐-："><a href="#Stack解题思路-推荐-：" class="headerlink" title="Stack解题思路(推荐)："></a><strong>Stack解题思路(推荐)：</strong></h3><p>见到括号就考虑用Stack，此题有字符和数字，所以考虑用<strong>两个Stack</strong>  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>运用模板</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>同级相加如a2[c]b3[d]x，所以一发现左括号，就将空字符入char_stack栈，方便同级相加     </li><li>有两个地方需要与栈顶字符串相加，也就是同级相加，遇到右括号和遇到数字</li><li>避免特殊化处理，初始字符串加上1[s]</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">res, num, stack_num, stack_str = <span class="string">''</span>, <span class="number">0</span>, [], []</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">num = num * <span class="number">10</span> + int(char)</span><br><span class="line"><span class="keyword">elif</span> char == <span class="string">'['</span>:</span><br><span class="line">stack_num.append(num) <span class="comment"># [3]</span></span><br><span class="line">stack_str.append(res) <span class="comment"># 2c</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">elif</span> char == <span class="string">']'</span>:</span><br><span class="line">tmp = stack_str.pop() <span class="comment"># '2c'</span></span><br><span class="line">n = stack_num.pop() <span class="comment"># 3</span></span><br><span class="line">res = tmp + n * res <span class="comment"># 2c + 3*d=ccddd</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += char</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="递归算法II解题思路-不推荐-："><a href="#递归算法II解题思路-不推荐-：" class="headerlink" title="递归算法II解题思路(不推荐)："></a><strong>递归算法II解题思路(不推荐)：</strong></h3><p>用index作为全局变量，扫每一个字符，类似于Leetcode 297。<br>遇到字符append到result，遇到数字记录次数k，遇到左括号就递归decodeString(s), 递归返回decodedString, 跳过右括号，result.append(decodedString) k次，最后返回result。  </p><p>如3[a2[c]]  </p><h3 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a><strong>伪代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decodeString(<span class="string">'3[a2[c]]'</span>)</span><br><span class="line">    k = <span class="number">3</span>  </span><br><span class="line">    acc = decodeString(<span class="string">'a2[c]'</span>)</span><br><span class="line">         result = a</span><br><span class="line">         k = <span class="number">2</span></span><br><span class="line">         <span class="string">'c'</span>  = decodeString(<span class="string">'c'</span>)</span><br><span class="line">         result = acc</span><br><span class="line">   result = accaccacc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/decode-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 560 Subarray Sum Equals K</title>
    <link href="https://shineboy2013.github.com/2021/12/13/lee-560/"/>
    <id>https://shineboy2013.github.com/2021/12/13/lee-560/</id>
    <published>2021-12-13T22:53:34.279Z</published>
    <updated>2021-12-13T23:53:00.373Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,1], k = 2<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3], k = 3<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 2 </em> 10<sup>4</sup><code>*</code>-1000 &lt;= nums[i] &lt;= 1000<code>*</code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>子数组和等于k</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>子数组和第一时间想到presum，而数组元素之间关系也应该想到two sum  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>加0到presum中或者加0到sum_to_idx字典中，确保presum本身可以等于k     </li><li>数组含负数，也即是presum中可以含有多个相同的值，所以sum_to_idx要转成频数而不是下标。如[-1, 1, -1, 1], k=0结果为4，而不是3, 容易漏整个数组和     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># presum = [0, 1, 2, 3], target = presum[i] - k = presum[j]</span></span><br><span class="line"><span class="comment"># add 0 to presum so that presum[i] = k</span></span><br><span class="line"><span class="comment"># [0, -1, 0, -1, 0]</span></span><br><span class="line"><span class="comment"># [0, 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">presum, res = [<span class="number">0</span>], <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">presum.append(presum[<span class="number">-1</span>] + n) <span class="comment"># 0, 1, 2, 3</span></span><br><span class="line">sum_to_idx = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(presum)): <span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> presum[i] - k <span class="keyword">in</span> sum_to_idx: <span class="comment"># 1-1</span></span><br><span class="line">res += sum_to_idx[presum[i] - k] <span class="comment">#4</span></span><br><span class="line">sum_to_idx[presum[i]] += <span class="number">1</span> <span class="comment"># &#123;0:2, -1:2, 2:2&#125;</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 031 Next Permutation</title>
    <link href="https://shineboy2013.github.com/2021/12/13/lee-031/"/>
    <id>https://shineboy2013.github.com/2021/12/13/lee-031/</id>
    <published>2021-12-13T21:00:12.500Z</published>
    <updated>2021-12-13T21:17:10.298Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.<br><br>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).<br><br>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a></strong> and use only constant extra memory.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> [1,3,2]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1]<br><strong>Output:</strong> [1,2,3]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,5]<br><strong>Output:</strong> [1,5,1]<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 100</code></em>   <code>0 &lt;= nums[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>下一个全排列数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>找到从后往前升序的第一个非升序数，如135864的5     </li><li>找到从后往前比步骤1中大的数，调换，如6，变成136854</li><li>后边部分按升序排列或者做reverse(更高效)</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Python语法问题： reverse子列表，跟倒序遍历数组一样，要指明前后边界，前面边界值更大    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 135864 -&gt; 136854 -&gt; 136458</span></span><br><span class="line"><span class="comment"># 1355864 -&gt; 1356458</span></span><br><span class="line"><span class="comment"># 99</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">to_be_swapped_index, greater_index = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]: <span class="comment"># 5 &lt; 8</span></span><br><span class="line">to_be_swapped_index = i <span class="comment"># 2</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> to_be_swapped_index == <span class="number">-1</span>:</span><br><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, to_be_swapped_index, <span class="number">-1</span>): <span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> nums[to_be_swapped_index] &lt; nums[i]: <span class="comment"># 5 &lt; 6</span></span><br><span class="line">greater_index = i <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment"># 136854</span></span><br><span class="line">nums[to_be_swapped_index], nums[greater_index] = nums[greater_index], nums[to_be_swapped_index]</span><br><span class="line"><span class="comment"># nums[to_be_swapped_index + 1:] = sorted(nums[to_be_swapped_index + 1:]) # 136458</span></span><br><span class="line">nums[to_be_swapped_index + <span class="number">1</span>:] = nums[:to_be_swapped_index:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;I
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shineboy2013.github.com/2021/12/13/lee-000/"/>
    <id>https://shineboy2013.github.com/2021/12/13/lee-000/</id>
    <published>2021-12-13T19:38:49.724Z</published>
    <updated>2021-12-13T21:17:04.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 014 Longest Common Prefix</title>
    <link href="https://shineboy2013.github.com/2021/12/13/lee-014/"/>
    <id>https://shineboy2013.github.com/2021/12/13/lee-014/</id>
    <published>2021-12-13T18:47:54.419Z</published>
    <updated>2021-12-13T18:56:54.462Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Write a function to find the longest common prefix string amongst an array of strings.<br><br>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“flower”,”flow”,”flight”]<br><strong>Output:</strong> “fl”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“dog”,”racecar”,”car”]<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> There is no common prefix among the input strings.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 200</code></em>   <code>0 &lt;= strs[i].length &lt;= 200</code><br>*   <code>strs[i]</code> consists of only lower-case English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串列表的最长前缀</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求最小值len初始值用最大值而不是0  </li><li>char = strs[0][i]而不是char = strs[i]   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">min_len, res = sys.maxsize, <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">min_len = min(min_len, len(s))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(min_len):</span><br><span class="line">char = strs[<span class="number">0</span>][i]</span><br><span class="line">same_char = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line"><span class="keyword">if</span> char != strs[j][i]:</span><br><span class="line">same_char = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> same_char:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res += char</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 002 Add Two Numbers</title>
    <link href="https://shineboy2013.github.com/2021/12/12/lee-002/"/>
    <id>https://shineboy2013.github.com/2021/12/12/lee-002/</id>
    <published>2021-12-12T20:24:32.934Z</published>
    <updated>2021-12-13T19:01:51.547Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/add-two-numbers" target="_blank" rel="noopener">LeetCode</a></strong></p><div><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p><br><br><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><br><br><p>&nbsp;</p><br><p><strong>Example 1:</strong></p><br><img alt="" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" style="width: 483px; height: 342px;"><br><pre><strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]<br><strong>Output:</strong> [7,0,8]<br><strong>Explanation:</strong> 342 + 465 = 807.<br></pre><br><br><p><strong>Example 2:</strong></p><br><br><pre><strong>Input:</strong> l1 = [0], l2 = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><p><strong>Example 3:</strong></p><br><br><pre><strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br><strong>Output:</strong> [8,9,9,9,0,0,0,1]<br></pre><br><br><p>&nbsp;</p><br><p><strong>Constraints:</strong></p><br><br><ul><br>    <li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><br>    <li><code>0 &lt;= Node.val &lt;= 9</code></li><br>    <li>It is guaranteed that the list represents a number that does not have leading zeros.</li><br></ul><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数位链表(从最低位到最高位)相加</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于merge sort  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>其中一个可能较长，所以主循环出来后还要继续循环较长的链表，类似于merge sort</li><li>所有链表遍历完后，carry可能还会是1，要加一个if语句特别处理     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: <span class="string">'ListNode'</span>, l2: <span class="string">'ListNode'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">carry = <span class="number">0</span></span><br><span class="line">it, it2, it_res = l1, l2, fake_head</span><br><span class="line"><span class="keyword">while</span> it <span class="keyword">and</span> it2:</span><br><span class="line">value = it.val + it2.val + carry</span><br><span class="line">carry = <span class="number">1</span> <span class="keyword">if</span> value &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">value %= <span class="number">10</span></span><br><span class="line">it_res.next = ListNode(value)</span><br><span class="line">it, it2, it_res = it.next, it2.next, it_res.next</span><br><span class="line"><span class="keyword">while</span> it:  <span class="comment"># remember it can be longer than it2</span></span><br><span class="line">value = it.val + carry</span><br><span class="line">carry = <span class="number">1</span> <span class="keyword">if</span> value &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">value %= <span class="number">10</span></span><br><span class="line">it_res.next = ListNode(value)</span><br><span class="line">it, it_res = it.next, it_res.next</span><br><span class="line"><span class="keyword">while</span> it2:</span><br><span class="line">value = it2.val + carry</span><br><span class="line">carry = <span class="number">1</span> <span class="keyword">if</span> value &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">value %= <span class="number">10</span></span><br><span class="line">it_res.next = ListNode(value)</span><br><span class="line">it2, it_res = it2.next, it_res.next</span><br><span class="line"><span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">it_res.next = ListNode(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;p&gt;You are 
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2106 Maximum Fruits Harvested After at Most K Steps</title>
    <link href="https://shineboy2013.github.com/2021/12/12/lee-2106/"/>
    <id>https://shineboy2013.github.com/2021/12/12/lee-2106/</id>
    <published>2021-12-12T11:23:19.584Z</published>
    <updated>2021-12-13T19:02:37.691Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array <code>fruits</code> where <code>fruits[i] = [position&lt;sub&gt;i&lt;/sub&gt;, amount&lt;sub&gt;i&lt;/sub&gt;]</code> depicts <code>amount&lt;sub&gt;i&lt;/sub&gt;</code> fruits at the position <code>position&lt;sub&gt;i&lt;/sub&gt;</code>. <code>fruits</code> is already <strong>sorted</strong> by <code>position&lt;sub&gt;i&lt;/sub&gt;</code> in <strong>ascending order</strong>, and each <code>position&lt;sub&gt;i&lt;/sub&gt;</code> is <strong>unique</strong>.<br><br>You are also given an integer <code>startPos</code> and an integer <code>k</code>. Initially, you are at the position <code>startPos</code>. From any position, you can either walk to the <strong>left or right</strong>. It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis, and you can walk <strong>at most</strong> <code>k</code> steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.<br><br>Return <em>the <strong>maximum total number</strong> of fruits you can harvest</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/1.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4<br><strong>Output:</strong> 9<br><strong>Explanation:</strong><br>The optimal way is to:<br>- Move right to position 6 and harvest 3 fruits<br>- Move right to position 8 and harvest 6 fruits<br>You moved 3 steps and harvested 3 + 6 = 9 fruits in total.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/2.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4<br><strong>Output:</strong> 14<br><strong>Explanation:</strong><br>You can move at most k = 4 steps, so you cannot reach position 0 nor 10.<br>The optimal way is to:<br>- Harvest the 7 fruits at the starting position 5<br>- Move left to position 4 and harvest 1 fruit<br>- Move right to position 6 and harvest 2 fruits<br>- Move right to position 7 and harvest 4 fruits<br>You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/11/21/3.png" alt=""><br><br><pre><strong>Input:</strong> fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2<br><strong>Output:</strong> 0<br><strong>Explanation:</strong><br>You can move at most k = 2 steps and cannot reach any position with fruits.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= fruits.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>fruits[i].length == 2</code><br><em>   `0 &lt;= startPos, position<sub>i</sub> &lt;= 2 </em> 10<sup>5</sup><code>*</code>position<sub>i-1</sub> &lt; position<sub>i</sub><code>for any</code>i &gt; 0<code>(**0-indexed**)*</code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup><code>*</code>0 &lt;= k &lt;= 2 * 10<sup>5</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>向左向右在规定步数内采集每一格的水果，求最大水果数  </p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始考虑用BFS，但由于每个点可以走两次，如先往左再往右，所以不能用BFS<br>每个点不能走3次，因为贪婪法。所以只要计算单向路径的水果数，单向路径水果数只要计算[startPos - k - 1, startPos + k + 1]的这个区间即可<br>然后重复路径的范围是[0, k/2 + 1], 枚举这些值然后用<strong>presum</strong>得到单向路径水果数。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先判断不合法的情况sum(gas) &lt; sum(cost)   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxTotalFruits</span><span class="params">(self, fruits: List[List[int]], startPos: int, k: int)</span> -&gt; int:</span></span><br><span class="line">pos_to_fruits = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> fruits:</span><br><span class="line">pos_to_fruits[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>]</span><br><span class="line">presum = collections.defaultdict(int)</span><br><span class="line">presum[startPos - k - <span class="number">1</span>] = pos_to_fruits[startPos - k - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(startPos - k, startPos + k + <span class="number">1</span>):</span><br><span class="line">presum[i] += presum[i<span class="number">-1</span>] + pos_to_fruits[i]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">res = max(res, presum[startPos + k - i * <span class="number">2</span>] - presum[startPos - i - <span class="number">1</span>])</span><br><span class="line">res = max(res, presum[startPos + i] - presum[startPos - k + i * <span class="number">2</span> - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k + n)</code>，空间复杂度<code>O(n + k)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2104 Sum of Subarray Ranges</title>
    <link href="https://shineboy2013.github.com/2021/12/12/lee-2104/"/>
    <id>https://shineboy2013.github.com/2021/12/12/lee-2104/</id>
    <published>2021-12-12T11:07:08.056Z</published>
    <updated>2021-12-13T19:03:13.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/sum-of-subarray-ranges/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>nums</code>. The <strong>range</strong> of a subarray of <code>nums</code> is the difference between the largest and smallest element in the subarray.<br><br>Return <em>the <strong>sum of all</strong> subarray ranges of</em> <code>nums</code><em>.</em><br><br>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The 6 subarrays of nums are the following:<br>[1], range = largest - smallest = 1 - 1 = 0<br>[2], range = 2 - 2 = 0<br>[3], range = 3 - 3 = 0<br>[1,2], range = 2 - 1 = 1<br>[2,3], range = 3 - 2 = 1<br>[1,2,3], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,3]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The 6 subarrays of nums are the following:<br>[1], range = largest - smallest = 1 - 1 = 0<br>[3], range = 3 - 3 = 0<br>[3], range = 3 - 3 = 0<br>[1,3], range = 3 - 1 = 2<br>[3,3], range = 3 - 3 = 0<br>[1,3,3], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [4,-2,-3,4,1]<br><strong>Output:</strong> 59<br><strong>Explanation:</strong> The sum of all subarray ranges of nums is 59.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code></em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子数组的最大值最小值之差的和</p><h3 id="Stack算法思路："><a href="#Stack算法思路：" class="headerlink" title="Stack算法思路："></a><strong>Stack算法思路：</strong></h3><p>参考Leetcode 907，分别求子数组最小值的相反数，子数组的最大值，这两个值的和即为所求  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>最小值用递增栈，最大值用递减栈       </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subArrayRanges</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">arr = list(nums)</span><br><span class="line">arr.insert(<span class="number">0</span>, -sys.maxsize)</span><br><span class="line">arr.append(-sys.maxsize)</span><br><span class="line">stack, res, = [], <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &lt; arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">prev_idx = stack.pop()</span><br><span class="line">res -= arr[prev_idx] * (prev_idx - stack[<span class="number">-1</span>]) * (i - prev_idx)</span><br><span class="line">stack.append(i)</span><br><span class="line"></span><br><span class="line">arr = list(nums)</span><br><span class="line">arr.insert(<span class="number">0</span>, sys.maxsize)</span><br><span class="line">arr.append(sys.maxsize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> arr[i] &gt; arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">prev_idx = stack.pop()</span><br><span class="line">res += arr[prev_idx] * (prev_idx - stack[<span class="number">-1</span>]) * (i - prev_idx)</span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="累计和算法II解题思路："><a href="#累计和算法II解题思路：" class="headerlink" title="累计和算法II解题思路："></a><strong>累计和算法II解题思路：</strong></h3><p>比暴力法稍优，两重循环覆盖所有子数组[i, j]，每轮循环得到最大最小值，然后O(1)内求该区间内所有最大最小值差值和。</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subArrayRanges</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">min_value, max_value = nums[i], nums[i]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">min_value = min(min_value, nums[j])</span><br><span class="line">max_value = max(max_value, nums[j])</span><br><span class="line">sum += max_value - min_value</span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^2)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/sum-of-subarray-ranges/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
</feed>
