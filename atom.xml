<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-02-08T07:26:22.003Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1448 Count Good Nodes in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/</id>
    <published>2022-02-08T07:07:29.316Z</published>
    <updated>2022-02-08T07:26:22.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named <strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.<br><br>Return the number of <strong>good</strong> nodes in the binary tree.<br><br><strong>Example 1:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.<br>Root Node (3) is always a good node.<br>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.<br>Node 5 -&gt; (3,4,5) is the maximum value in the path<br>Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,3,null,4,2]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because “3” is higher than it.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.</em>   Each node’s value is between <code>[-10^4, 10^4]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个节点是good表示该节点从root到自己的路径上，所有节点都小于等于自己。求二叉树的good节点个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计左右子树的good节点个数，最重要是引入类似于min, max验证BST，<strong>引入path_max来记录路径上的最大值</strong>，只要该节点值大于path_max就是good节点。DFS返回good节点个数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>引入path_max来记录路径上的最大值</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(root, float(<span class="string">'-inf'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path_max)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">left = self.dfs(root.left, max(root.val, path_max))</span><br><span class="line">right = self.dfs(root.right, max(root.val, path_max))</span><br><span class="line">res = left + right</span><br><span class="line"><span class="keyword">if</span> path_max &lt;= root.val:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-good-nodes-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1304 Find N Unique Integers Sum up to Zero</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/</id>
    <published>2022-02-08T07:03:16.849Z</published>
    <updated>2022-02-08T07:05:51.085Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong> integers such that they add up to <code>0</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> [-7,-1,1,3,4]<br><strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [-1,0,1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求n个数的数组使得数组和为0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，只要将相反数放入数组即可</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</span><br><span class="line">res.append(i + <span class="number">1</span>)</span><br><span class="line">res.append(-i - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 984 String Without AAA or BBB</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/</id>
    <published>2022-02-08T06:42:39.348Z</published>
    <updated>2022-02-08T06:45:10.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integers <code>a</code> and <code>b</code>, return <strong>any</strong> string <code>s</code> such that:<br><br><em>   <code>s</code> has length <code>a + b</code> and contains exactly <code>a</code> <code>&#39;a&#39;</code> letters, and exactly <code>b</code> <code>&#39;b&#39;</code> letters,</em>   The substring <code>&#39;aaa&#39;</code> does not occur in <code>s</code>, and<br><em>   The substring <code>&#39;bbb&#39;</code> does not occur in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 2<br><strong>Output:</strong> “abb”<br><strong>Explanation:</strong> “abb”, “bab” and “bba” are all correct answers.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 4, b = 1<br><strong>Output:</strong> “aabaa”<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b &lt;= 100</code><br>*   It is guaranteed such an <code>s</code> exists for the given <code>a</code> and <code>b</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个整数代表ab的个数，生成一个字符串，字符串ab频数不能超过这2个数，不能有连续的aaa, bbb, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>参考LeetCode 1405 Longest Happy String, 此题不用heap因为只有两种字符</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不能连续的处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span><span class="params">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">0</span> <span class="keyword">or</span> b &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'a'</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-without-aaa-or-bbb/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1405 Longest Happy String</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/</id>
    <published>2022-02-08T06:20:09.075Z</published>
    <updated>2022-02-08T06:32:41.593Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-happy-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>happy</strong> if it satisfies the following conditions:<br><br><em>   <code>s</code> only contains the letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</em>   <code>s</code> does not contain any of <code>&quot;aaa&quot;</code>, <code>&quot;bbb&quot;</code>, or <code>&quot;ccc&quot;</code> as a substring.<br><em>   <code>s</code> contains <strong>at most</strong> <code>a</code> occurrences of the letter <code>&#39;a&#39;</code>.</em>   <code>s</code> contains <strong>at most</strong> <code>b</code> occurrences of the letter <code>&#39;b&#39;</code>.<br><em>   <code>s</code> contains <strong>at most</strong> <code>c</code> occurrences of the letter <code>&#39;c&#39;</code>.<br><br>Given three integers <code>a</code>, <code>b</code>, and <code>c</code>, return <em>the <strong>longest possible happy</strong> string</em>. If there are multiple longest happy strings, return <em>any of them</em>. If there is no such string, return <em>the empty string</em> <code>&quot;&quot;</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within a string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 1, c = 7<br><strong>Output:</strong> “ccaccbcc”<br><strong>Explanation:</strong> “ccbccacc” would also be a correct answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 7, b = 1, c = 0<br><strong>Output:</strong> “aabaa”<br><strong>Explanation:</strong> It is the only correct answer in this case.<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b, c &lt;= 100</code><br>*   <code>a + b + c &gt; 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定三个整数代表abc的个数，生成一个字符串，字符串abc频数不能超过这3个数，不能有连续的aaa, bbb, ccc, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由第一个例子看出，先尽量用频数最多的字符，直到连续3个为止，然后再用次多的，如此反复做。这里用到最多和次多，所以考虑用Heap</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>每次选频数最高的字符，但若此字符已连续3次，选次高的，用heap。 </li><li>大于0的频数才加入到heap Line 4和Line 17</li><li>heapreplace等于heappop次高的和heappush最高的。<strong>既然要有次高，heap就不能为空</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">heapq.heappush(heap, (-a, <span class="string">'a'</span>))</span><br><span class="line"><span class="keyword">if</span> b &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-b, <span class="string">'b'</span>))</span><br><span class="line"><span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-c, <span class="string">'c'</span>))</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">count, char = heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == char:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">count, char = heapq.heapreplace(heap, (count, char))</span><br><span class="line">res += char</span><br><span class="line"><span class="keyword">if</span> count + <span class="number">1</span>:</span><br><span class="line">heapq.heappush(heap, (count + <span class="number">1</span>, char))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-happy-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1647 Minimum Deletions to Make Character Frequencies Unique</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/</id>
    <published>2022-02-08T02:42:06.875Z</published>
    <updated>2022-02-08T02:47:59.204Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.<br><br>Given a string <code>s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>s</code> <em><strong>good</strong>.</em><br><br>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>&quot;aab&quot;</code>, the <strong>frequency</strong> of <code>&#39;a&#39;</code> is <code>2</code>, while the <strong>frequency</strong> of <code>&#39;b&#39;</code> is <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> <code>s</code> is already good.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aaabbbcc”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete two ‘b’s resulting in the good string “aaabcc”.<br>Another way it to delete one ‘b’ and one ‘c’ resulting in the good string “aaabbc”.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ceabaacb”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete both ‘c’s resulting in the good string “eabaab”.<br>Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> contains only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串，求最小删除次数使得字符串的每一种字符频率不同</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解，若遇到频率相同的字符，就将其减一，也就是删除一个字符，使得它不再与其他字符频率相同直到0. 关键在用一个unique_count的set来记录频数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用一个unique_count的set来记录频数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDeletions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line">unique_count = set()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char, count <span class="keyword">in</span> char_to_count.items():</span><br><span class="line">cur_count = count</span><br><span class="line"><span class="keyword">while</span> cur_count <span class="keyword">in</span> unique_count:</span><br><span class="line">cur_count -= <span class="number">1</span></span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cur_count &gt; <span class="number">0</span>:</span><br><span class="line">unique_count.add(cur_count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>Karat 003 Nonogram</title>
    <link href="https://shineboy2013.github.com/2022/02/07/karat-003/"/>
    <id>https://shineboy2013.github.com/2022/02/07/karat-003/</id>
    <published>2022-02-07T10:16:22.375Z</published>
    <updated>2022-02-07T10:23:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>A nonogram is a logic puzzle, similar to a crossword, in which the player is given<br>a blank grid and has to color it according to some instructions. Specifically,<br>each cell can be either black or white, which we will represent as 0 for black and<br>1 for white.<br>+————+<br>| 1 1 1 1 |<br>| 0 1 1 1 |<br>| 0 1 0 0 |<br>| 1 1 0 1 |<br>| 0 0 1 1 |<br>+————+<br>For each row and column, the instructions give the lengths of contiguous runs of<br>black (0) cells. For example, the instructions for one row of [ 2, 1 ] indicate<br>that there must be a run of two black cells, followed later by another run of one<br>black cell, and the rest of the row filled with white cells.<br>These are valid solutions: [ 1, 0, 0, 1, 0 ] and [ 0, 0, 1, 1, 0 ] and also [ 0,<br>0, 1, 0, 1 ]<br>This is not valid: [ 1, 0, 1, 0, 0 ] since the runs are not in the correct order.<br>This is not valid: [ 1, 0, 0, 0, 1 ] since the two runs of 0s are not separated by<br>1s.<br>Your job is to write a function to validate a possible solution against a set of<br>instructions. Given a 2D matrix representing a player’s solution; and instructions<br>for each row along with additional instructions for each column; return True or<br>False according to whether both sets of instructions match.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Nonogram日本游戏，0表示黑子，[2, 1]表示黑子的连续数目，如棋盘状态[ 1, 0, 0, 1, 0 ]，表示连续黑子数为[2, 1]<br>[ 1, 0, 0, 0, 1 ]连续黑子数为[3]. 验证棋盘的每一行和每一列是否满足rows和cols所指定的连续黑子数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归只有一种情况</li><li>答案需求全局</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_nonogram</span><span class="params">(self, matrix, rows, cols)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(matrix[i]) != rows[i]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">col_vals = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">col_vals.append(matrix[i][j])</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(col_vals) != cols[j]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 1, 0, 0, 1, 0 ] -&gt; [2, 1], # of 0s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_consecutive_zeros</span><span class="params">(self, matrix_row)</span>:</span></span><br><span class="line">count, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> matrix_row:</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A nonogram is a logic puzzle, similar to a crossword, in which the player is given&lt;br&gt;a blank grid and has to color it according to some 
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1522 Diameter of N-Ary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/</id>
    <published>2022-02-07T09:33:44.019Z</published>
    <updated>2022-02-07T09:38:33.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-n-ary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>root</code> of an <a href="https://leetcode.com/articles/introduction-to-n-ary-trees/" target="_blank" rel="noopener">N-ary tree</a>, you need to compute the length of the diameter of the tree.<br><br>The diameter of an N-ary tree is the length of the <strong>longest</strong> path between any two nodes in the tree. This path may or may not pass through the root.<br><br>(<em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Diameter is shown in red color.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [1,null,2,null,3,4,null,5,null,6]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br><strong>Output:</strong> 7<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The depth of the n-ary tree is less than or equal to <code>1000</code>.</em>   The total number of nodes is between <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 543 Diameter of Binary Tree，但此题为N叉树</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DFS</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求数组中最大的两数和，用去掉最大值的方法得到次大值。还要注意初始值加入[1, 1]，避免没有儿子节点或只有一个的情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">path_len = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">path_len.append(dfs(child) + <span class="number">1</span>)</span><br><span class="line">largest = max(path_len)</span><br><span class="line">path_len.remove(largest)</span><br><span class="line">second_largest = max(path_len)</span><br><span class="line">total = largest + second_largest - <span class="number">1</span></span><br><span class="line">max_len = max(total, max_len)</span><br><span class="line"><span class="keyword">return</span> largest</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-n-ary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 543 Diameter of Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-543-diameter-of-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-543-diameter-of-binary-tree/</id>
    <published>2022-02-07T08:22:20.125Z</published>
    <updated>2022-02-07T08:29:16.844Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.<br><br>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.<br><br>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1,2]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种情况：自己+左，自己+右，左+右，不要漏掉最后一种</li><li>用nonlocal就不用定义self.max_len的全局变量</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">left = dfs(root.left) + <span class="number">1</span></span><br><span class="line">right = dfs(root.right) + <span class="number">1</span></span><br><span class="line">res = max(left, right)</span><br><span class="line">total = left + right - <span class="number">1</span></span><br><span class="line">max_len = max(res, total, max_len)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 549 Binary Tree Longest Consecutive Sequence II</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/</id>
    <published>2022-02-07T07:51:56.353Z</published>
    <updated>2022-02-07T08:33:53.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive path in the tree</em>.<br><br>A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.<br><br><em>   For example, <code>[1,2,3,4]</code> and <code>[4,3,2,1]</code> are both considered valid, but the path <code>[1,2,4,3]</code> is not valid.<br><br>On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The longest consecutive path is [1, 2] or [2, 1].<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest consecutive path is [1, 2, 3] or [3, 2, 1].<br></pre><br><br><strong>Constraints:</strong></em>   The number of nodes in the tree is in the range <code>[1, 3 * 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><em>   `-3 </em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求任意节点到另一个节点的最长连续数列的长度(由小到大)</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 298 Binary Tree Longest Consecutive Sequence，不过由于父亲到儿子可能递增或递减，所以DFS返回值也返回递增和递减的长度</p><p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p><p>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>DFS返回值也返回递增和递减的长度</li><li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># (increasing, decreasing) from root</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">inc = desc = <span class="number">1</span></span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:</span><br><span class="line">lpath += left[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right[<span class="number">0</span>]</span><br><span class="line">inc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val - <span class="number">1</span> == root.left.val:</span><br><span class="line">lpath += left[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val - <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right[<span class="number">1</span>]</span><br><span class="line">desc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">total = inc + desc - <span class="number">1</span></span><br><span class="line">max_len = max(inc, desc, total, max_len)</span><br><span class="line"><span class="keyword">return</span> inc, desc</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 298 Binary Tree Longest Consecutive Sequence</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/</id>
    <published>2022-02-07T07:22:19.605Z</published>
    <updated>2022-02-07T08:34:15.058Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive sequence path</em>.<br><br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,null,3,2,null,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range `[1, 3 </em> 10<sup>4</sup>]<code>.*</code>-3 <em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 </em> 10<sup>4</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求从父到子的最长连续数列的长度(由小到大)</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题意是从父到儿子的有小到大数列，而不是儿子到父亲</li><li>以root为起点的最长数列，若root不符合条件，不加入left或right的长度</li><li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有三种情况：自己，自己+左，自己+右</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:  <span class="comment"># remember not ==</span></span><br><span class="line">lpath += left</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right</span><br><span class="line">res = max(lpath, rpath)</span><br><span class="line">max_len = max(res, max_len)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/st
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 785 Is Graph Bipartite?</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-785-is-graph-bipartite/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-785-is-graph-bipartite/</id>
    <published>2022-02-07T06:49:11.703Z</published>
    <updated>2022-02-07T06:58:11.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:<br><br><em>   There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</em>   There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).<br><em>   If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</em>   The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.<br><br>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.<br><br>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>graph.length == n</code></em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= graph[u].length &lt; n</code></em>   <code>0 &lt;= graph[u][i] &lt;= n - 1</code><br><em>   <code>graph[u]</code> does not contain <code>u</code>.</em>   All the values of <code>graph[u]</code> are <strong>unique</strong>.<br>*   If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>无向图中是否存在一个划分，将节点分为两集合，任何一条边都连接着两个集合，也就是不存在一条边在单一集合内。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</li><li>题意表示，图可能是有几个连通图，所以要从每个节点做BFS，除非节点已访问过， Line 4. node_to_color作为visited的功能</li><li>return True在两个函数中要写，否则返回None</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">node_to_color = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> node_to_color: <span class="comment"># disconnected nodes</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">node_to_color[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, i, node_to_color):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, n, node_to_color)</span>:</span></span><br><span class="line">queue = collections.deque([n])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color <span class="keyword">and</span> node_to_color[neighbor] != <span class="number">1</span> - node_to_color[node]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">node_to_color[neighbor] = <span class="number">1</span> - node_to_color[node]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/is-graph-bipartite/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 770. Basic Calculator IV</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-770-basic-calculator-iv/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-770-basic-calculator-iv/</id>
    <published>2022-02-07T04:05:26.527Z</published>
    <updated>2022-02-07T06:08:59.750Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-iv/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code><br><br><em>   An expression alternates chunks and symbols, with a space separating each chunk and symbol.</em>   A chunk is either an expression in parentheses, a variable, or a non-negative integer.<br><em>   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.<br><br>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.</em>   For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.<br><br>The format of the output is as follows:<br><br><em>   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.    </em>   For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.<br><em>   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.    </em>   For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.<br><em>   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.</em>   An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.<br><em>   Terms (including constant terms) with coefficient <code>0</code> are not included.    </em>   For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “e + 8 - a + 5”, evalvars = [“e”], evalints = [1]<br><strong>Output:</strong> [“-1<em>a”,”14”]<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “e - 8 + temperature - pressure”, evalvars = [“e”, “temperature”], evalints = [1, 12]<br><strong>Output:</strong> [“-1pressure”,”5”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> expression = “(e + 8) <em> (e - 8)”, evalvars = [], evalints = []<br><strong>Output:</strong> [“1</em>e<em>e”,”-64”]<br></em></pre><br><br><strong>Constraints:</strong>   <code>1 &lt;= expression.length &lt;= 250</code><br><em>   <code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, `’</em>‘<code>,</code>‘(‘<code>,</code>‘)’<code>,</code>‘ ‘<code>.*</code>expression<code>does not contain any leading or trailing spaces.*   All the tokens in</code>expression<code>are separated by a single space.*</code>0 &lt;= evalvars.length &lt;= 100<code>*</code>1 &lt;= evalvars[i].length &lt;= 20<code>*</code>evalvars[i]<code>consists of lowercase English letters.*</code>evalints.length == evalvars.length<code>*</code>-100 &lt;= evalints[i] &lt;= 100`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>表达式含有若干变量evalvars及其对应值evalints，且含加减乘和括号，求结果。若变量不在evalvars就简化表达式</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题<strong>不需要掌握</strong>，若考到就认命好了。之前的LeetCode 224 Basic Calculator含有括号和加法已经是Hard，此题不但有括号和加减乘，还有变量，难度不止提高一个数量级。不过不可以用eval函数的条件去掉了。所以就是考察eval。<br>如果不含变量，直接调用eval即可求解  </p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line"><span class="keyword">return</span> eval(expression)</span><br></pre></td></tr></table></figure><p>含变量且变量有值，就调用字典将变量替代掉，这里考到了regex替代函数re.sub</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">token = s.group()</span><br><span class="line">s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">converted_expr = re.sub(<span class="string">r'\w+'</span>, f, expression)</span><br><span class="line">res = eval(converted_expr)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于变量可能没有值，所以核心思路是用dict进行计算，如x + 2，用集合求和{(x,): 1} + {(): 2}得到{(‘x’,): 1, (): -2}，用dict来计算及保存结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>regex替代变量</li><li>将表达式用f包装，如(f(“x”) + f(“8”)) * (f(“x”) - f(“8”))</li><li>实现dict的加减乘</li><li>dict的计算结果转成题目所求</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span><span class="params">(Counter)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">self.update(other)</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">self.subtract(other)</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">product = MyCounter()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> other:</span><br><span class="line">xy = tuple(sorted(x + y))</span><br><span class="line">product[xy] += self[x] * other[y]</span><br><span class="line"><span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">token = s</span><br><span class="line">s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line"><span class="keyword">return</span> MyCounter(&#123;(s, ): <span class="number">1</span>&#125;) <span class="keyword">if</span> s.isalpha() <span class="keyword">else</span> MyCounter(&#123;(): int(s)&#125;)</span><br><span class="line"></span><br><span class="line">converted_expr = re.sub(<span class="string">r'(\w+)'</span>, <span class="string">r'f("\1")'</span>, expression)</span><br><span class="line"><span class="comment"># (f("x") + f("8")) * (f("x") - f("8"))</span></span><br><span class="line">res = eval(converted_expr) <span class="comment">#</span></span><br><span class="line"><span class="comment"># C(&#123;('x', 'x'): 1, ('x',): 0, (): -64&#125;)</span></span><br><span class="line"><span class="keyword">return</span> [<span class="string">'*'</span>.join((str(res[x]), ) + x)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> sorted(res, key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line"><span class="keyword">if</span> res[x]]</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator-iv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Karat 002 Longest Common Continuous Subarray</title>
    <link href="https://shineboy2013.github.com/2022/01/30/karat-002/"/>
    <id>https://shineboy2013.github.com/2022/01/30/karat-002/</id>
    <published>2022-01-30T09:46:41.967Z</published>
    <updated>2022-02-01T02:51:05.252Z</updated>
    
    <content type="html"><![CDATA[<p>[<br>  [“3234.html”, “xys.html”, “7hsaa.html”], // user1<br>  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2<br>]</p><p>输出两个user的最长连续且相同的访问记录。</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续最长子数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 1143先求最长公共子字符串。</p><p>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p><p>不同之处在于： </p><ol><li>由于是连续，所以递归只有相同的情况，其他情况为0。 </li><li>答案不是最后一位，而是全局最值</li></ol><p>递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = 0</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归只有一种情况</li><li>答案需求全局</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">res = max(res, dp[i][j])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>回到原题，输入是列表而不是字符串，但原理一样。还有需要输出公共结果，而不是数字</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuousSubarray</span><span class="params">(self, history1, history2)</span>:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history1) + <span class="number">1</span>)]</span><br><span class="line">max_len, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> history1[i - <span class="number">1</span>] == history2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">max_len = dp[i][j]</span><br><span class="line">res = history1[i - dp[i][j]:i]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[&lt;br&gt;  [“3234.html”, “xys.html”, “7hsaa.html”], // user1&lt;br&gt;  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2&lt;br&gt;]&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 518 Coin Change 2</title>
    <link href="https://shineboy2013.github.com/2022/01/30/leetcode-518-coin-change-2/"/>
    <id>https://shineboy2013.github.com/2022/01/30/leetcode-518-coin-change-2/</id>
    <published>2022-01-30T08:11:02.133Z</published>
    <updated>2022-02-02T21:07:55.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br><br>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.<br><br>You may assume that you have an infinite number of each kind of coin.<br><br>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> amount = 5, coins = [1,2,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> amount = 3, coins = [2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> amount = 10, coins = [10]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= coins.length &lt;= 300</code></em>   <code>1 &lt;= coins[i] &lt;= 5000</code><br><em>   All the values of <code>coins</code> are <strong>unique</strong>.</em>   <code>0 &lt;= amount &lt;= 5000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求兑换硬币的种数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 322 Coin Change，那题求最小个数，此题求总数，也是用DP。<br>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = sum(dp[j]), i = j + coins[i]</span><br></pre></td></tr></table></figure></p><p>LeetCode 377 Combination Sum IV 题目基本一样，唯一区别是结果元素有序，属于排列<br>LeetCode 518 Coin Change 2 题目基本一样，唯一区别是结果元素无序，属于组合</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>递归5部曲</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>for循环顺序不能错，先coin再dp</strong>，否则会有重复计算，如dp[3] = 2 + 1和1 + 2. 字面上理解也是可以知道重复。但如果coin先的话，就只能用1的硬币，第二轮是只能用2的硬币，如此类推，显然不会重复，dp[3] = dp[2] + 1(只用硬币1), dp[1] + 2(只用硬币2) </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[j], i = j + coins[i]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)): <span class="comment"># [0, 0]</span></span><br><span class="line"><span class="keyword">if</span> i + coin &lt;= amount:</span><br><span class="line">dp[i + coin] += dp[i]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*amount)</code>，空间复杂度<code>O(amount)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/coin-change-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 259 3Sum Smaller</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/</id>
    <published>2022-01-30T07:18:03.625Z</published>
    <updated>2022-01-30T07:23:03.623Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of <code>n</code> integers <code>nums</code> and an integer <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-2,0,1,3], target = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Because there are two triplets which sums are less than 2:<br>[-2,0,1]<br>[-2,0,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [0], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>0 &lt;= n &lt;= 3500</code><br><em>   <code>-100 &lt;= nums[i] &lt;= 100</code></em>   <code>-100 &lt;= target &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找三数和小于target的组合个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于三数和等于target，但当小于target时，直接求个数，类似于LeetCode 315 Count of Smaller Numbers After Self。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>res不是+1而是right - left</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">res += right - left <span class="comment"># remember</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-smaller/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 628 Maximum Product of Three Numbers</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/</id>
    <published>2022-01-30T03:29:22.897Z</published>
    <updated>2022-01-30T03:34:17.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, <em>find three numbers whose product is maximum and return the maximum product</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4]<br><strong>Output:</strong> 24<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-2,-3]<br><strong>Output:</strong> -6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>3 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-1000 &lt;= nums[i] &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组任意三个数的最大乘积</p><h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>数学题，正负数分开，最大只可以是排序后最大的三个数(全正，全负)或最大整数乘以最小两个负数(正负均有)</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">-1</span>] * nums[<span class="number">-2</span>] * nums[<span class="number">-3</span>], nums[<span class="number">-1</span>] * nums[<span class="number">0</span>] * nums[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="Heap算法II解题思路："><a href="#Heap算法II解题思路：" class="headerlink" title="Heap算法II解题思路："></a><strong>Heap算法II解题思路：</strong></h3><p>由上述思路进一步优化，不需要全部排序，只需要知道最大的3个数和最小的两个数即可</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line">smallest = heapq.nsmallest(<span class="number">2</span>, nums)</span><br><span class="line"><span class="keyword">return</span> max(largest[<span class="number">0</span>] * largest[<span class="number">1</span>] * largest[<span class="number">2</span>], largest[<span class="number">0</span>] * smallest[<span class="number">0</span>] * smallest[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-product-of-three-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1143 Longest Common Subsequence</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-1143-longest-common-subsequence/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-1143-longest-common-subsequence/</id>
    <published>2022-01-29T20:29:31.376Z</published>
    <updated>2022-01-29T20:35:54.099Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong>.</em> If there is no <strong>common subsequence</strong>, return <code>0</code>.<br><br>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.<br><br><em>   For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code>.<br><br>A <strong>common subsequence</strong> of two strings is a subsequence that is common to both strings.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> text1 = “abcde”, text2 = “ace”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest common subsequence is “ace” and its length is 3.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> text1 = “abc”, text2 = “abc”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest common subsequence is “abc” and its length is 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> text1 = “abc”, text2 = “def”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There is no such common subsequence, so the result is 0.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br>*   <code>text1</code> and <code>text2</code> consist of only lowercase English characters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两字符串的最大公共字符序列，不一定需要连续</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两字符串最值问题用DP<br>dp[i][j]为最大公共字符序列，最后一位不需要相等。递归式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = max(dp[i - 1][j], dp[i][j - 1])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DP五点注意事项</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不相等时候不需要dp[i - 1][j - 1]，因为已经包含在dp[i - 1][j]或dp[i][j - 1]中, <strong>DP属于累计DP</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) <span class="comment"># no dp[i - 1][j - 1] but no impact</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 399 Evaluate Division</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-399-evaluate-division/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-399-evaluate-division/</id>
    <published>2022-01-28T07:27:27.518Z</published>
    <updated>2022-01-28T07:48:54.133Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;]</code> and <code>values[i]</code> represent the equation <code>A&lt;sub&gt;i&lt;/sub&gt; / B&lt;sub&gt;i&lt;/sub&gt; = values[i]</code>. Each <code>A&lt;sub&gt;i&lt;/sub&gt;</code> or <code>B&lt;sub&gt;i&lt;/sub&gt;</code> is a string that represents a single variable.<br><br>You are also given some <code>queries</code>, where <code>queries[j] = [C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;]</code> represents the <code>j&lt;sup&gt;th&lt;/sup&gt;</code> query where you must find the answer for <code>C&lt;sub&gt;j&lt;/sub&gt; / D&lt;sub&gt;j&lt;/sub&gt; = ?</code>.<br><br>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.<br><br><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br><strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]<br><strong>Explanation:</strong><br>Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em><br>queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em><br>return: [6.0, 0.5, -1.0, 1.0, -1.0 ]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br><strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br><strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= equations.length &lt;= 20</code></em>   <code>equations[i].length == 2</code><br><em>   <code>1 &lt;= A&lt;sub&gt;i&lt;/sub&gt;.length, B&lt;sub&gt;i&lt;/sub&gt;.length &lt;= 5</code></em>   <code>values.length == equations.length</code><br><em>   <code>0.0 &lt; values[i] &lt;= 20.0</code></em>   <code>1 &lt;= queries.length &lt;= 20</code><br><em>   <code>queries[i].length == 2</code></em>   <code>1 &lt;= C&lt;sub&gt;j&lt;/sub&gt;.length, D&lt;sub&gt;j&lt;/sub&gt;.length &lt;= 5</code><br>*   <code>A&lt;sub&gt;i&lt;/sub&gt;, B&lt;sub&gt;i&lt;/sub&gt;, C&lt;sub&gt;j&lt;/sub&gt;, D&lt;sub&gt;j&lt;/sub&gt;</code> consist of lower case English letters and digits.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据已知除法结果求其他除法表达式</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是G家的面试题。图问题，因为每个除法式相乘可以得到query所要的，所以属于图问题。可以用BFS来遍历图，如已知a/b = 2, b/c = 3, 需要知道a/c, 就是2 x 3，所以只要从a开始， c为BFS的target，迭代时不断相乘</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>核心思想： BFS来遍历图，迭代时不断相乘。<strong>无向图</strong>，因为a/c也可以c/a.</li><li>BFS的注意事项后两个：BFS无解时候不存在的时候返回-1</li><li>两种edge cases： 若query中任意元素不在图中，返回-1(题目要求), 若元素相等，返回1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(equations):</span><br><span class="line">graph[li[<span class="number">0</span>]].append((li[<span class="number">1</span>], values[i]))</span><br><span class="line">graph[li[<span class="number">1</span>]].append((li[<span class="number">0</span>], <span class="number">1</span> / values[i])) <span class="comment"># remember it is an undirected graph</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line"><span class="keyword">if</span> query[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph <span class="keyword">or</span> query[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">res.append(<span class="number">-1.0</span>)</span><br><span class="line"><span class="keyword">elif</span> query[<span class="number">0</span>] <span class="keyword">in</span> graph <span class="keyword">and</span> query[<span class="number">0</span>] == query[<span class="number">1</span>]:</span><br><span class="line">res.append(<span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">val = self.bfs(graph, query)</span><br><span class="line">res.append(val)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, query)</span>:</span></span><br><span class="line">queue = collections.deque([(query[<span class="number">0</span>], <span class="number">1</span>)])</span><br><span class="line">visited = set([queue[<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node, parent_val = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == query[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> parent_val</span><br><span class="line"><span class="keyword">for</span> neighbor, val <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append((neighbor, parent_val * val))</span><br><span class="line">visited.add(neighbor)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(（V + E) * m)</code>，空间复杂度<code>O(E)</code>, m为query数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/evaluate-division/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 384 Shuffle an Array</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-384-shuffle-an-array/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-384-shuffle-an-array/</id>
    <published>2022-01-28T04:00:51.993Z</published>
    <updated>2022-01-28T04:21:59.986Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.<br><br>Implement the <code>Solution</code> class:<br><br><em>   <code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</em>   <code>int[] reset()</code> Resets the array to its original configuration and returns it.<br><em>   <code>int[] shuffle()</code> Returns a random shuffling of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Solution”, “shuffle”, “reset”, “shuffle”]<br>[[[1, 2, 3]], [], [], []]<br><strong>Output</strong><br>[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1, 2, 3]);<br>solution.shuffle();    // Shuffle the array [1,2,3] and return its result.<br>                       // Any permutation of [1,2,3] must be equally likely to be returned.<br>                       // Example: return [3, 1, 2]<br>solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]<br>solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]<br><br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= nums.length &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></em>   All the elements of <code>nums</code> are <strong>unique</strong>.<br><em>   At most `5 </em> 10<sup>4</sup><code>calls **in total** will be made to</code>reset<code>and</code>shuffle`.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>随机重排数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>水塘抽样法</p><p>先看算法，再理解，第i个元素会被交换的概率：<br>某一个元素保留概率为(n - i) / (n - i + 1)<br>某一个元素交换概率为1 / (n - i)<br>所以从左到右遍历到第i个元素时，它被交换到后面的概率为 所有前面都保留 乘以 第i轮循环时被交换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) / n * (n - 2) / (n - 1) ... (n - i) / (n - i + 1) * 1 / (n - i)</span><br></pre></td></tr></table></figure></p><p>前面都约了，最后等于1 / n </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>死记算法，跟后面的元素互换</li><li>复制原数组以防被改</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">self.original = list(nums)</span><br><span class="line">self.nums = nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">return</span> list(self.original)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.nums)):</span><br><span class="line">swap_idx = random.randrange(i, len(self.nums))</span><br><span class="line">self.nums[i], self.nums[swap_idx] = self.nums[swap_idx], self.nums[i]</span><br><span class="line"><span class="keyword">return</span> self.nums</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shuffle-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;G
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 370 Range Addition</title>
    <link href="https://shineboy2013.github.com/2022/01/27/leetcode-370-range-addition/"/>
    <id>https://shineboy2013.github.com/2022/01/27/leetcode-370-range-addition/</id>
    <published>2022-01-27T09:41:55.661Z</published>
    <updated>2022-01-27T09:49:27.299Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-addition/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer <code>length</code> and an array <code>updates</code> where <code>updates[i] = [startIdx&lt;sub&gt;i&lt;/sub&gt;, endIdx&lt;sub&gt;i&lt;/sub&gt;, inc&lt;sub&gt;i&lt;/sub&gt;]</code>.<br><br>You have an array <code>arr</code> of length <code>length</code> with all zeros, and you have some operation to apply on <code>arr</code>. In the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> operation, you should increment all the elements <code>arr[startIdx&lt;sub&gt;i&lt;/sub&gt;], arr[startIdx&lt;sub&gt;i&lt;/sub&gt; + 1], ..., arr[endIdx&lt;sub&gt;i&lt;/sub&gt;]</code> by <code>inc&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>Return <code>arr</code> <em>after applying all the</em> <code>updates</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/27/rangeadd-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]<br><strong>Output:</strong> [-2,0,3,5,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]<br><strong>Output:</strong> [0,-4,2,2,2,4,4,-4,-4,-4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= updates.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= startIdx&lt;sub&gt;i&lt;/sub&gt; &lt;= endIdx&lt;sub&gt;i&lt;/sub&gt; &lt; length</code></em>   <code>-1000 &lt;= inc&lt;sub&gt;i&lt;/sub&gt; &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>统一加一个数到子数组中，如此有好几个操作，求最后数组结果</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>差分数组，<strong>数加到首节点，数减在末节点 + 1，最后累加</strong></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>数加到首节点，数减在末节点 + 1，最后累加</strong></li><li>端点需要累加res[li[0]] += li[2], 而不是res[li[0]] = li[2]</li><li>len(res)而不是len(li)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getModifiedArray</span><span class="params">(self, length: int, updates: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">res = [<span class="number">0</span>] * length</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> updates:</span><br><span class="line">res[li[<span class="number">0</span>]] += li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line"><span class="keyword">if</span> li[<span class="number">1</span>] + <span class="number">1</span> &lt; len(res): <span class="comment"># remember not len(li)</span></span><br><span class="line">res[li[<span class="number">1</span>] + <span class="number">1</span>] += -li[<span class="number">2</span>] <span class="comment"># remember += not =</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">res[i] += res[i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>, n, m分别为数组长度和update个数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-addition/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
</feed>
