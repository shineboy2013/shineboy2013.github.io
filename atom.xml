<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-21T10:08:55.790Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 304 Range Sum Query 2D - Immutable</title>
    <link href="https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/"/>
    <id>https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/</id>
    <published>2022-01-21T10:03:16.136Z</published>
    <updated>2022-01-21T10:08:55.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:<br><br><em>   Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br>Implement the NumMatrix class:</em>   <code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.<br><em>   <code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt=""><br><br><pre><strong>Input</strong><br>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<br><strong>Output</strong><br>[null, 8, 11, 12]<br><br><strong>Explanation</strong><br>NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == matrix.length</code><br><em>   <code>n == matrix[i].length</code></em>   <code>1 &lt;= m, n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= row1 &lt;= row2 &lt; m</code><br><em>   <code>0 &lt;= col1 &lt;= col2 &lt; n</code></em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>sumRegion</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子矩阵和</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>计算presum公式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j] - dp[i-1][j-1]</span><br></pre></td></tr></table></figure></p><p>计算子矩阵公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dp有左上边界，计算子矩阵注意dp和输入差1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp[<span class="number">0</span>])):</span><br><span class="line">                self.dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + self.dp[i - <span class="number">1</span>][j] + self.dp[i][j - <span class="number">1</span>] - self.dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-sum-query-2d-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;d
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 721 Accounts Merge</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/</id>
    <published>2022-01-21T03:34:29.553Z</published>
    <updated>2022-01-21T09:32:04.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> accounts = [[“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],[“John”,”johnsmith@mail.com”,”john00@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Output:</strong> [[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Explanation:</strong><br>The first and second John’s are the same person as they have the common email “johnsmith@mail.com”.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’],<br>[‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> accounts = [[“Gabe”,”Gabe0@m.co”,”Gabe3@m.co”,”Gabe1@m.co”],[“Kevin”,”Kevin3@m.co”,”Kevin5@m.co”,”Kevin0@m.co”],[“Ethan”,”Ethan5@m.co”,”Ethan4@m.co”,”Ethan0@m.co”],[“Hanzo”,”Hanzo3@m.co”,”Hanzo1@m.co”,”Hanzo0@m.co”],[“Fern”,”Fern5@m.co”,”Fern1@m.co”,”Fern0@m.co”]]<br><strong>Output:</strong> [[“Ethan”,”Ethan0@m.co”,”Ethan4@m.co”,”Ethan5@m.co”],[“Gabe”,”Gabe0@m.co”,”Gabe1@m.co”,”Gabe3@m.co”],[“Hanzo”,”Hanzo0@m.co”,”Hanzo1@m.co”,”Hanzo3@m.co”],[“Kevin”,”Kevin0@m.co”,”Kevin3@m.co”,”Kevin5@m.co”],[“Fern”,”Fern0@m.co”,”Fern1@m.co”,”Fern5@m.co”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= accounts.length &lt;= 1000</code></em>   <code>2 &lt;= accounts[i].length &lt;= 10</code><br><em>   <code>1 &lt;= accounts[i][j] &lt;= 30</code></em>   <code>accounts[i][0]</code> consists of English letters.<br>*   <code>accounts[i][j] (for j &gt; 0)</code> is a valid email.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p><h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li><li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li><li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line">name_dict = collections.defaultdict(str)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">res, visited = [], set()</span><br><span class="line"><span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line"><span class="keyword">if</span> sub_res:</span><br><span class="line">res.append(sub_res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">res, name = [], <span class="string">''</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line">res.append(node)</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">name = name_dict[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">res.sort()</span><br><span class="line">res.insert(<span class="number">0</span>, name)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p><hr><h3 id="UnionFind算法II解题思路-不推荐-："><a href="#UnionFind算法II解题思路-不推荐-：" class="headerlink" title="UnionFind算法II解题思路(不推荐)："></a><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li><li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li><li>处理名字</li><li>有重复邮件</li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/accounts-merge/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Giv
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/</id>
    <published>2022-01-20T10:10:33.912Z</published>
    <updated>2022-01-20T10:23:45.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br><br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br><br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,4,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,1,3,4,2]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>nums.length == n + 1</code><br><em>   <code>1 &lt;= nums[i] &lt;= n</code></em>   All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.<br><br><strong>Follow up:</strong><br><br><em>   How can we prove that at least one duplicate number must exist in <code>nums</code>?</em>   Can you solve the problem in linear runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数值二分法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li><li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line"><span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line"><span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 286 Walls and Gates</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/</id>
    <published>2022-01-20T09:36:10.895Z</published>
    <updated>2022-01-20T09:43:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values.<br><br><em>   <code>-1</code> A wall or an obstacle.</em>   <code>0</code> A gate.<br><em>   <code>INF</code> Infinity means an empty room. We use the value <code>2&lt;sup&gt;31&lt;/sup&gt; - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.<br><br>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt=""><br><br><pre><strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br><strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> rooms = [[-1]]<br><strong>Output:</strong> [[-1]]<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == rooms.length</code><br><em>   <code>n == rooms[i].length</code></em>   <code>1 &lt;= m, n &lt;= 250</code><br>*   <code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有房间到门的最短距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>属于多始点BFS类型</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>门的距离不更新，所以出列后要判断该点是否为门，不是用距离来判断</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OFFSET = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        gates = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rooms)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(rooms[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    gates.append((i, j, <span class="number">0</span>))</span><br><span class="line">        queue = collections.deque(gates)</span><br><span class="line">        visited = set(gates)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, distance = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> rooms[x][y] != <span class="number">0</span>: <span class="comment"># not distance != 0</span></span><br><span class="line">                rooms[x][y] = distance</span><br><span class="line">            <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">                _x, _y = x + _dx, y + _dy</span><br><span class="line">                <span class="keyword">if</span> _x &lt; <span class="number">0</span> <span class="keyword">or</span> _x &gt;= len(rooms) <span class="keyword">or</span> _y &lt; <span class="number">0</span> <span class="keyword">or</span> _y &gt;= len(rooms[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        rooms[_x][_y] == <span class="number">-1</span> <span class="keyword">or</span> (_x, _y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((_x, _y, distance + <span class="number">1</span>))</span><br><span class="line">                visited.add((_x, _y))</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(mn)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/walls-and-gates/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Yo
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 283 Move Zeroes</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/</id>
    <published>2022-01-20T08:58:11.187Z</published>
    <updated>2022-01-20T09:00:49.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.<br><br><strong>Note</strong> that you must do this in-place without making a copy of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,12]<br><strong>Output:</strong> [1,3,12,0,0]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you minimize the total number of operations done?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将数组的0全部移到数组末</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。Quicksort的partition的应用</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">non_zero_idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">nums[i], nums[non_zero_idx] = nums[non_zero_idx], nums[i]</span><br><span class="line">non_zero_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 282 Expression Add Operators</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/</id>
    <published>2022-01-20T07:00:41.425Z</published>
    <updated>2022-01-20T08:59:51.182Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/expression-add-operators" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators</em> <code>&#39;+&#39;</code><em>,</em> <code>&#39;-&#39;</code><em>, and/or</em> <code>&#39;*&#39;</code> <em>between the digits of</em> <code>num</code> <em>so that the resultant expression evaluates to the</em> <code>target</code> <em>value</em>.<br><br>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = “123”, target = 6<br><strong>Output:</strong> [“1<em>2</em>3”,”1+2+3”]<br><strong>Explanation:</strong> Both “1<em>2</em>3” and “1+2+3” evaluate to 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = “232”, target = 8<br><strong>Output:</strong> [“2<em>3+2”,”2+3</em>2”]<br><strong>Explanation:</strong> Both “2<em>3+2” and “2+3</em>2” evaluate to 8.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = “3456237490”, target = 9191<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no expressions that can be created from “3456237490” to evaluate to 9191.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num.length &lt;= 10</code></em>   <code>num</code> consists of only digits.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= target &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一串数字加入加减乘能得到target的所有可能性</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有可能用DFS。属于分割型DFS，在数位之间加符号，数位可以是1个到多个。<br>一轮递归分割出符号 + 数字<br>另一种选择是数字 + 符号，但需要额外变量sign，因为不能立刻计算到结果。也不符合正常逻辑。所以选择前者。</p><p>由于运算都是二元，也就是用上述分割法，第一个数要特别处理。所以DFS中要特别处理第一个数。这样可以开始写加减。引入prev_res作为DFS参数，这样只要prev_res 加减 该轮数字即可得到该轮结果。用DFS模板5个标准参数外加prev_res：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_res, path, res):</span><br></pre></td></tr></table></figure></p><p>这样只处理加减的DFS比较容易实现  </p><p>最大难点在于乘法，参考LeetCode 227 Basic Calculator II，加减和乘除属于两层计算需要分别处理，所以引入<strong>新参数prev_multi_res，用于保存乘法结果，而刚才的命名为prev_add_res保存加减乘的全部结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_add_res, prev_multi_res, path, res):</span><br></pre></td></tr></table></figure></p><p>举例2+3*4，按照原来的逻辑会计算到2+3=5，但此时如果遇到乘号，就要重新计算加法结果，先减去乘法结果，退回到2，再计算3*4=12这是乘法结果，再加回2得到新加法结果。进一步理解prev_multi_res，如果该轮是加减法，仍要将该轮的数作为prev_multi_res传到下轮DFS，因为如果下一轮是乘法，它就是第一个乘法的数。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>先实现加减法</li><li>再实现乘法</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>分割型DFS，选择每轮递归分割符号 + 数字。由于运算都是二元，<strong>特别处理第一个数</strong></li><li>引入参数prev_add_res, prev_multi_res. <strong>prev_multi_res若是加减，用(+/-)cur_num, 否则用乘法结果prev_multi_res * cur_num</strong>。注意若是减法cur_num用负号</li><li>分割时数字不能有前缀0</li><li>prev_res不用恢复状态因为是标量</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span><span class="params">(self, num: str, target: int)</span> -&gt; List[str]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(num, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, st, target, prev_add_res, prev_multi_res, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(num):</span><br><span class="line"><span class="keyword">if</span> target == prev_add_res:</span><br><span class="line">res.append(path)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(num)):</span><br><span class="line"><span class="keyword">if</span> i &gt; st <span class="keyword">and</span> num[st] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">cur_num = int(num[st:i + <span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> path: <span class="comment"># remember</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, str(cur_num), res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, path + <span class="string">'+'</span> + str(cur_num), res) <span class="comment"># use cur_num rather than cur</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res - cur_num, -cur_num, path + <span class="string">'-'</span> + str(cur_num), res) <span class="comment"># -cur_num rather than cur_num</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, (prev_add_res - prev_multi_res) + prev_multi_res * cur_num, prev_multi_res * cur_num, path + <span class="string">'*'</span> + str(cur_num), res) <span class="comment"># prev_multi_res * cur_num not cur_num</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(4<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>, 因为每个字符之间都有不加操作符，加3个操作符，所以是4，有n-1个间隔  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/expression-add-operators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 277 Find the Celebrity</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/</id>
    <published>2022-01-20T04:06:37.308Z</published>
    <updated>2022-01-20T04:20:05.576Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.<br><br>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is ask questions like: “Hi, A. Do you know B?” to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).<br><br>You are given a helper function <code>bool knows(a, b)</code> that tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.<br><br>Return <em>the celebrity’s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There is no celebrity.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == graph.length</code></em>   <code>n == graph[i].length</code><br><em>   <code>2 &lt;= n &lt;= 100</code></em>   <code>graph[i][j]</code> is <code>0</code> or <code>1</code>.<br><em>   <code>graph[i][i] == 1</code><br><br><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is `3 </em> n`, could you find a solution without exceeding the maximum number of calls?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过调用a是否认识b函数，找出名人。名人是除自己的所有人都认识他，他不认识其他所有人</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 169 Majority Element，用水王法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>找出可能名人，通过查看是否i后面的每一个人都认识i，若不是将candidate换成当前下标</li><li>按定义验证第一步的结果是否名人，两步验证</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>按照定义，若i不认识candiate才换candidate，用not。因为edge case是没有边或者图存在循环</li><li>验证时候，第二步验证candidate若认识任意人就不是名人，排除candidate认识自己。题目条件candidate认识自己。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment"># find potential candidate</span></span><br><span class="line">candidate = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">candidate = i</span><br><span class="line"><span class="comment"># validate</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> candidate != i <span class="keyword">and</span> knows(candidate, i):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-celebrity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 270 Closest Binary Search Tree Value</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/</id>
    <published>2022-01-19T10:20:20.197Z</published>
    <updated>2022-01-19T10:28:34.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">LeetCode</a></strong></p><div>Given the <code>root</code> of a binary search tree and a <code>target</code> value, return <em>the value in the BST that is closest to the</em> <code>target</code>. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 4.428571<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>. </em> <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code> * <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求BST中最接近target的值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>接近target的值在BST搜索路径上，越后搜索到的(越后入栈的)越接近，但最接近的可能大于或小于target(predecessors or successors)，只能逐一比较.<br>类似于LeetCode 272 Closest Binary Search Tree Value II</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>循环中用it，不能用root，注意检查</li><li>接近target的值在BST搜索路径上，逐一比较</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root: TreeNode, target: float)</span> -&gt; int:</span></span><br><span class="line">closest_vals = []</span><br><span class="line">it = root</span><br><span class="line"><span class="keyword">while</span> it:</span><br><span class="line">closest_vals.append(it.val)</span><br><span class="line"><span class="keyword">if</span> target &lt; it.val:</span><br><span class="line">it = it.left</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">it = it.right</span><br><span class="line">min_val, res = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> closest_vals:</span><br><span class="line"><span class="keyword">if</span> abs(target - n) &lt; min_val:</span><br><span class="line">min_val = abs(target - n)</span><br><span class="line">res = n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(h)</code>，空间复杂度<code>O(h)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/closest-binary-search-tree-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 268 Missing Number</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/</id>
    <published>2022-01-19T09:14:29.294Z</published>
    <updated>2022-01-19T09:23:13.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= nums[i] &lt;= n</code></em>   All the numbers of <code>nums</code> are <strong>unique</strong>.<br><br><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组缺失一个数，所有数应该在[0, n]内，求缺失数</p><h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="异或法解题思路II："><a href="#异或法解题思路II：" class="headerlink" title="异或法解题思路II："></a><strong>异或法解题思路II：</strong></h3><p>高斯原理</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">res = len(nums) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">res ^= i ^ n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p><hr><h3 id="数学法解题思路III："><a href="#数学法解题思路III：" class="headerlink" title="数学法解题思路III："></a><strong>数学法解题思路III：</strong></h3><p>高斯原理</p><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">n = len(nums)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> + n) * (n + <span class="number">1</span>) // <span class="number">2</span> - sum(nums)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Giv
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 266 Palindrome Permutation</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/</id>
    <published>2022-01-19T09:04:18.224Z</published>
    <updated>2022-01-19T09:07:29.265Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <code>true</code> if a permutation of the string could form a palindrome.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “code”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “carerac”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 5000</code></em>   <code>s</code> consists of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串的任一全排列是否存在回文字符串</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，也就是统计字符频率，奇数频率的字符最多有1个</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>统计字符频率，奇数频率的字符最多有1个</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 256 Paint House</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/</id>
    <published>2022-01-19T08:43:00.412Z</published>
    <updated>2022-01-19T08:51:13.879Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is a row of <code>n</code> houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br><br>The cost of painting each house with a certain color is represented by an <code>n x 3</code> cost matrix <code>costs</code>.<br><br><em>   For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with the color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on…<br><br>Return <em>the minimum cost to paint all houses</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> costs = [[17,2,17],[16,16,5],[14,3,19]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>Minimum cost: 2 + 5 + 3 = 10.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> costs = [[7,6,2]]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong></em>   <code>costs.length == n</code><br><em>   <code>costs[i].length == 3</code></em>   <code>1 &lt;= n &lt;= 100</code><br>*   <code>1 &lt;= costs[i][j] &lt;= 20</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排屋相邻不同色地涂色(3色)的最低成本</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>低频题。最值且涉及数值考虑用DP。由于相邻不能同色，所以是多状态DP，有3个状态，不妨多用一维表示，第二维只有3值。<br>dp[i][j]定义为第i间屋涂上第j色的最低总费用，递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归5步曲，多1，初始，多1，少1，答案。记得第一步初始化数组多1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(costs) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">return</span> min(dp[<span class="number">-1</span>][<span class="number">0</span>], dp[<span class="number">-1</span>][<span class="number">1</span>], dp[<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/paint-house/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;There 
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 249 Group Shifted Strings</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-249-group-shifted-strings/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-249-group-shifted-strings/</id>
    <published>2022-01-19T07:01:09.770Z</published>
    <updated>2022-01-19T07:07:20.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/group-shifted-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>We can shift a string by shifting each of its letters to its successive letter.<br><br><em>   For example, <code>&quot;abc&quot;</code> can be shifted to be <code>&quot;bcd&quot;</code>.<br><br>We can keep shifting the string to form a sequence.</em>   For example, we can keep shifting <code>&quot;abc&quot;</code> to form the sequence: <code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code>.<br><br>Given an array of strings <code>strings</code>, group all <code>strings[i]</code> that belong to the same shifting sequence. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strings = [“abc”,”bcd”,”acef”,”xyz”,”az”,”ba”,”a”,”z”]<br><strong>Output:</strong> [[“acef”],[“a”,”z”],[“abc”,”bcd”,”xyz”],[“az”,”ba”]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strings = [“a”]<br><strong>Output:</strong> [[“a”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strings.length &lt;= 200</code></em>   <code>1 &lt;= strings[i].length &lt;= 50</code><br>*   <code>strings[i]</code> consists of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将单词按等偏移量分组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>单词分组题，设计一个id。组内的每个单词里字母之间的差值是一致的，如abd, wxz, 差值分别为1和2，这是同一组。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求每个单词每个字母之间的差值，用下滑线连接作为id。注意差值可能为负数，所以要取mod变正</li><li>单一字母单词，不存在偏移量，id为空，所以代码不需要特殊处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span><span class="params">(self, strings: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">res = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">_id = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">_id += str((ord(s[j]) - ord(s[j - <span class="number">1</span>])) % <span class="number">26</span>) + <span class="string">'_'</span></span><br><span class="line">res[_id].append(s)</span><br><span class="line"><span class="keyword">return</span> list(res.values())</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>, n为单词个数, m为单词最长长度。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/group-shifted-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 243 Shortest Word Distance</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-243-shortest-word-distance/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-243-shortest-word-distance/</id>
    <published>2022-01-19T06:40:05.278Z</published>
    <updated>2022-01-19T06:42:46.603Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-word-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of strings <code>wordsDict</code> and two different strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between these two words in the list</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “coding”, word2 = “practice”<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> wordsDict = [“practice”, “makes”, “perfect”, “coding”, “makes”], word1 = “makes”, word2 = “coding”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= wordsDict.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>1 &lt;= wordsDict[i].length &lt;= 10<code>*</code>wordsDict[i]<code>consists of lowercase English letters.*</code>word1<code>and</code>word2<code>are in</code>wordsDict<code>.*</code>word1 != word2`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求单词列表中给定的两个单词的最短下标距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同向双指针</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>同向双指针，分别指向两单词，计算结果时必须是找到才比较</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, wordsDict: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">p1 = p2 = <span class="number">-1</span></span><br><span class="line">res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(wordsDict):</span><br><span class="line"><span class="keyword">if</span> word == word1:</span><br><span class="line">p1 = i</span><br><span class="line"><span class="keyword">if</span> word == word2:</span><br><span class="line">p2 = i</span><br><span class="line"><span class="keyword">if</span> p1 != <span class="number">-1</span> <span class="keyword">and</span> p2 != <span class="number">-1</span>:</span><br><span class="line">res = min(res, abs(p1 - p2))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-word-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 242 Valid Anagram</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-242-valid-anagram/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-242-valid-anagram/</id>
    <published>2022-01-19T06:20:06.174Z</published>
    <updated>2022-01-19T06:23:31.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “nagaram”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “rat”, t = “car”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, t.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s<code>and</code>t` consist of lowercase English letters.<br><br><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>验证变位词</p><h3 id="频率法解题思路-推荐-："><a href="#频率法解题思路-推荐-：" class="headerlink" title="频率法解题思路(推荐)："></a><strong>频率法解题思路(推荐)：</strong></h3><p>简单题</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> collections.Counter(s) == collections.Counter(t)</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="排序法算法II解题思路："><a href="#排序法算法II解题思路：" class="headerlink" title="排序法算法II解题思路："></a><strong>排序法算法II解题思路：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 241 Different Ways to Add Parentheses</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-241-different-ways-to-add-parentheses/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-241-different-ways-to-add-parentheses/</id>
    <published>2022-01-19T05:02:03.991Z</published>
    <updated>2022-01-19T05:13:13.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “2-1-1”<br><strong>Output:</strong> [0,2]<br><strong>Explanation:</strong><br>((2-1)-1) = 0<br>(2-(1-1)) = 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “2<em>3-4</em>5”<br><strong>Output:</strong> [-34,-14,-10,-10,10]<br><strong>Explanation:</strong><br>(2<em>(3-(4</em>5))) = -34<br>((2<em>3)-(4</em>5)) = -14<br>((2<em>(3-4))</em>5) = -10<br>(2<em>((3-4)</em>5)) = -10<br>(((2<em>3)-4)</em>5) = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= expression.length &lt;= 20</code></em>   <code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.<br>*   All the integer values in the input expression are in the range <code>[0, 99]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串含数字和加减乘除，求所有加括号方法得到的结果</p><h3 id="Catalan解题思路-推荐-："><a href="#Catalan解题思路-推荐-：" class="headerlink" title="Catalan解题思路(推荐)："></a><strong>Catalan解题思路(推荐)：</strong></h3><p>求所有结果，用DFS，由于需要左右递归，双边递归，所以用Catalan法模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>终止条件返回是一个list</strong></li><li>Python中用eval来计算字符串运算结果返回值为整数，所以归纳左右递归结果要用str转为字符串</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, expression: str)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> expression.isdigit():</span><br><span class="line"><span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">left_res = self.diffWaysToCompute(expression[:i])</span><br><span class="line">right_res = self.diffWaysToCompute(expression[i + <span class="number">1</span>:])</span><br><span class="line">res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code></p><hr><h3 id="记忆性搜索算法II解题思路："><a href="#记忆性搜索算法II解题思路：" class="headerlink" title="记忆性搜索算法II解题思路："></a><strong>记忆性搜索算法II解题思路：</strong></h3><p>大致同上，只不过加入记忆性搜索算法，但优化不算大</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute2</span><span class="params">(self, expression)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(expression, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, expression: str, cache)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> expression.isdigit():</span><br><span class="line"><span class="keyword">return</span> [int(expression)] <span class="comment"># remember to use list</span></span><br><span class="line"><span class="keyword">if</span> expression <span class="keyword">in</span> cache:</span><br><span class="line"><span class="keyword">return</span> cache[expression]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(expression):</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">left_res = self.dfs(expression[:i], cache)</span><br><span class="line">right_res = self.dfs(expression[i + <span class="number">1</span>:], cache)</span><br><span class="line">res += [eval(str(_l) + char + str(_r)) <span class="keyword">for</span> _l <span class="keyword">in</span> left_res <span class="keyword">for</span> _r <span class="keyword">in</span> right_res] <span class="comment"># remember eval and str</span></span><br><span class="line">cache[expression] = res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/different-ways-to-add-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Recursion" scheme="https://shineboy2013.github.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 095 Unique Binary Search Trees II</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-095-unique-binary-search-trees-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-095-unique-binary-search-trees-ii/</id>
    <published>2022-01-19T04:06:57.336Z</published>
    <updated>2022-01-19T04:12:07.050Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST’</strong>s (binary search trees), which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt=""><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 8</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求所有val为1-n的BST的所有可能性</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS中比较难的catalan类型。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>root = TreeNode(i)要在最内层for循环中</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt; end:</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line"><span class="keyword">if</span> start == end:</span><br><span class="line"><span class="keyword">return</span> [TreeNode(start)]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">left_nodes = self.dfs(start, i - <span class="number">1</span>)</span><br><span class="line">right_nodes = self.dfs(i + <span class="number">1</span>, end)</span><br><span class="line"><span class="keyword">for</span> _l <span class="keyword">in</span> left_nodes:</span><br><span class="line"><span class="keyword">for</span> _r <span class="keyword">in</span> right_nodes:</span><br><span class="line">root = TreeNode(i)</span><br><span class="line">root.left = _l</span><br><span class="line">root.right = _r</span><br><span class="line">res.append(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度Catalan数为<code>O(C[n] += C[i-1]*C[n-i])</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-binary-search-trees-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 240 Search a 2D Matrix II</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-240-search-a-2d-matrix-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-240-search-a-2d-matrix-ii/</id>
    <published>2022-01-19T03:11:37.299Z</published>
    <updated>2022-01-19T03:21:31.318Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Write an efficient algorithm that searches for a <code>target</code> value in an <code>m x n</code> integer <code>matrix</code>. The <code>matrix</code> has the following properties:<br><br><em>   Integers in each row are sorted in ascending from left to right.</em>   Integers in each column are sorted in ascending from top to bottom.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code></em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= n, m &lt;= 300</code></em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All the integers in each row are <strong>sorted</strong> in ascending order.</em>   All the integers in each column are <strong>sorted</strong> in ascending order.<br>*   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵按行按列有序，求是否存在target</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>矩阵有序题有3道：<br>LeetCode 074 Search a 2D Matrix 每一行有序，下一行的首元素大于上一行的尾元素 + 找target<br>LeetCode 240 Search a 2D Matrix II 按行按列有序 + 找target<br>LeetCode 378 Kth Smallest Element in a Sorted Matrix 按行按列有序 + 找第k大<br>矩阵结构方面，第一道每一行都是独立，所以可以独立地按行按列做二分法<br>后两道，矩阵二维连续，所以解法都是类BFS，从某个点开始，然后比较它相邻的两个点。出发点不同，第二道在近似矩阵中点(右上角或左下角)，第三道在左上角出发。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>从右上角出发，比较左和下节点。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> target &lt; matrix[i][j]:</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 235 Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-235-lowest-common-ancestor-of-a-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-235-lowest-common-ancestor-of-a-binary-tree/</id>
    <published>2022-01-19T01:51:21.005Z</published>
    <updated>2022-01-19T02:51:27.156Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br><br>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt=""><br><br><pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [2,1], p = 2, q = 1<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> will exist in the BST.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>BST中求给定的两节点的最低共同父亲节点</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况，也是用DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>pq一定存在，所以有**三种情况： 1) p或q是root，另一是其子孙。 2) p，q分列root两边。 3) p，q在root的一边。跟LeetCode 236 Lowest Common Ancestor of a Binary Tree不同的是，<br>第二种情况，不用递归即知道，因为这是BST。第一和第三种情况同</li><li>第二种情况由于要比较p, q, root顺序，所以要令p, q有序，Line 4-5</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> p.val &gt; q.val: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root, q, p)</span><br><span class="line"><span class="keyword">if</span> p.val &lt;= root.val &lt;= q.val <span class="keyword">or</span> p == root <span class="keyword">or</span> q == root: <span class="comment"># remember root is p or q</span></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 234 Palindrome Linked List</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-234-palindrome-linked-list/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-234-palindrome-linked-list/</id>
    <published>2022-01-19T00:53:52.430Z</published>
    <updated>2022-01-19T01:04:22.374Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,2,1]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is in the range <code>[1, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.</em>   <code>0 &lt;= Node.val &lt;= 9</code><br><br><strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一个LL是否回文</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>快慢指针 + Stack</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>快慢指针找到中点，找的同时，慢指针所有节点入栈。慢指针继续走，比较stack节点和慢指针节点。</li><li><strong>不涉及删除，所以不需要哟用到fake_node</strong></li><li><strong>中位数可能有1-2个</strong>。奇偶问题，若fast指向节点(另一情况是None), 表明是奇数个，slow在第二个循环前多走一步，跳过最中间的节点</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">fast, slow = head, head</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">stack.append(slow)</span><br><span class="line">slow = slow.next</span><br><span class="line">fast = fast.next.next</span><br><span class="line"><span class="keyword">if</span> fast:</span><br><span class="line">slow = slow.next</span><br><span class="line"><span class="keyword">while</span> slow:</span><br><span class="line"><span class="keyword">if</span> stack.pop().val != slow.val:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">slow = slow.next</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 296 Best Meeting Point</title>
    <link href="https://shineboy2013.github.com/2022/01/18/leetcode-296-best-meeting-point/"/>
    <id>https://shineboy2013.github.com/2022/01/18/leetcode-296-best-meeting-point/</id>
    <published>2022-01-18T22:31:59.677Z</published>
    <updated>2022-01-18T22:39:09.369Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-meeting-point/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> binary grid <code>grid</code> where each <code>1</code> marks the home of one friend, return <em>the minimal <strong>total travel distance</strong></em>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/meetingpoint-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> Given three friends living at (0,0), (0,4), and (2,2).<br>The point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.<br>So return 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,1]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code></em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><em>   There will be <em>*at least two</em></em> friends in the <code>grid</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中1表示朋友的位置，求最佳见面位置，所有朋友到这个位置曼哈顿距离最短。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是数学题也是非高频题。如果是一维，求最佳位置，是所有朋友位置的中点，也就是左边朋友和右边朋友的数量是一样。求距离也就是用相向双指针，求每对点的距离。<br>推广到二维，同理，x和y坐标是独立的。分别求距离即可。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用相向双指针，求每对点的距离</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTotalDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">x_coordinates, y_coordinates = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">x_coordinates.append(i)</span><br><span class="line">y_coordinates.append(j)</span><br><span class="line">x_coordinates.sort()</span><br><span class="line">y_coordinates.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">left, right = <span class="number">0</span>, len(y_coordinates) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">res += y_coordinates[right] - y_coordinates[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">left, right = <span class="number">0</span>, len(x_coordinates) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">res += x_coordinates[right] - x_coordinates[left]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>, n为矩阵的长边大小  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-meeting-point/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
</feed>
