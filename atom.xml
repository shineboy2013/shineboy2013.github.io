<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-05T08:09:53.200Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Two Pointers</title>
    <link href="https://shineboy2013.github.com/2021/12/05/two-pointers/"/>
    <id>https://shineboy2013.github.com/2021/12/05/two-pointers/</id>
    <published>2021-12-05T08:05:50.056Z</published>
    <updated>2021-12-05T08:09:53.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>j is left pointer, i is right pointer</p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_pointers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;meets condition&gt;:</span><br><span class="line">&lt;calculate result&gt;</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> &lt;result&gt;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;j is left pointer, i is right pointer&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 209 Minimum Size Subarray Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-209/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-209/</id>
    <published>2021-12-05T08:01:05.962Z</published>
    <updated>2021-12-05T08:03:52.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求最小值，所以min_len初始化最大值  </li><li>长度为i - j + 1写例子来计算     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">min_len, num_sum, j = sys.maxsize, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">num_sum += nums[i]</span><br><span class="line"><span class="keyword">while</span> num_sum &gt;= target:</span><br><span class="line">min_len = min(min_len, i - j + <span class="number">1</span>)</span><br><span class="line">num_sum -= nums[j]</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == sys.maxsize <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 373 Find K Pairs with Smallest Sums</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-373/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-373/</id>
    <published>2021-12-05T07:23:00.289Z</published>
    <updated>2021-12-05T07:26:08.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>类似于BFS模板，只不过是将queue换成heap。  </li><li>将两数和加入到heap中，而不是下标的和(粗心)  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span><span class="params">(self, nums1: List[int], nums2: List[int], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">heap, res = [(nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)], []</span><br><span class="line">visited = set([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">node = heapq.heappop(heap)</span><br><span class="line">res.append([nums1[node[<span class="number">1</span>]], nums2[node[<span class="number">2</span>]]])</span><br><span class="line"><span class="keyword">if</span> len(res) == k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">_x, _y = node[<span class="number">1</span>] + _dx, node[<span class="number">2</span>] + _dy</span><br><span class="line"><span class="keyword">if</span> _x &lt; len(nums1) <span class="keyword">and</span> _y &lt; len(nums2) <span class="keyword">and</span> (_x, _y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">heapq.heappush(heap, (nums1[_x] + nums2[_y], _x, _y))</span><br><span class="line">visited.add((_x, _y))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; class=&quot;headerlink&quot; title=&quot;注意事项：&quot;&gt;&lt;/a&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类似于BFS模板，只不过是将queue换成heap。  &lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 236 Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-236/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-236/</id>
    <published>2021-12-05T05:54:04.675Z</published>
    <updated>2021-12-05T05:55:14.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"><span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python代码：&quot;&gt;&lt;a href=&quot;#Python代码：&quot; class=&quot;headerlink&quot; title=&quot;Python代码：&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python代码：&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight pyt
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 291 Word Pattern II</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-291/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-291/</id>
    <published>2021-12-04T08:56:20.388Z</published>
    <updated>2021-12-04T09:19:51.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于word break，但由于要存储处理过map和set，DP不能处理，所以只能用DFS    </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较映射，用Map比较A-&gt;B的映射，如已有a-&gt;dog, 另一对映射a-&gt;cat通过查找Map知道不合法。B-&gt;A的映射可通过将map的所有value存到一个set中知道。如a-&gt;dog, b-&gt;dog. b不在Map中但b对应的dog在set中，不合法。<br>DFS的API为dfs(pattern, word, pattern_to_word, used_set)  </li><li>若pattern的字母出现过，如aba，不应进入循环，更不应该加入到map和set中，应该用startswith比较word判断是否合法，若是，直接下一轮DFS(Line 11 -15)     </li><li>1中的两情况的第一种情况以及第二种情况的前半部分(b不在map中)在2中已经处理，所以只要在循环中处理第二种情况后半部分(b对应的dog在set中)即可(Line 22 - 23)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordPatternMatch</span><span class="params">(self, pattern: str, s: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> pattern <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(pattern, s, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, pattern, s, start_p, start_s, pattern_to_s, s_set)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">and</span> start_s &gt;= len(s):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">or</span> start_s &gt;= len(s):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">char = pattern[start_p]</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> pattern_to_s:</span><br><span class="line">word = pattern_to_s[char]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s[start_s:].startswith(word):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, start_s + len(word), pattern_to_s, s_set)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(start_s, len(s)):</span><br><span class="line">matched_word = s[start_s:j + <span class="number">1</span>]</span><br><span class="line"><span class="string">'''if char in pattern_to_s and pattern_to_s[char] != matched_word:</span></span><br><span class="line"><span class="string">continue</span></span><br><span class="line"><span class="string">if char not in pattern_to_s and matched_word in s_set:  # remembers</span></span><br><span class="line"><span class="string">continue'''</span></span><br><span class="line"><span class="keyword">if</span> matched_word <span class="keyword">in</span> s_set:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">pattern_to_s[char] = matched_word</span><br><span class="line">s_set.add(matched_word)</span><br><span class="line"><span class="keyword">if</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, j + <span class="number">1</span>, pattern_to_s, s_set):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">s_set.remove(matched_word)</span><br><span class="line">pattern_to_s.pop(char)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度为<code>O(解大小)</code>。   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;类似于word break，但由于要存储处理过map和set，DP不能处理，所以只
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 212 Word Search II</title>
    <link href="https://shineboy2013.github.com/2021/12/03/lee-212/"/>
    <id>https://shineboy2013.github.com/2021/12/03/lee-212/</id>
    <published>2021-12-04T04:40:24.094Z</published>
    <updated>2021-12-04T05:35:11.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Trie来保存单词列表，这样每次DFS的每一步都可以O(1)时间知道是否和单词吻合，而不是O(n)</li><li>难点1: Trie的接口有startswith, search, insert，仅insert可以用，其他两个不支持与DFS同步搜索。所以要写一个新函数：其实修改startsWith将for循环去掉当然DFS的API也要改，去掉word, word_index加入trie, trie_node, path, res  </li><li>TLE错误，因为比如矩阵为[abc]，单词列表为abc, abc, abc，这样abc加入到结果后就不应该再搜abc，因为结果不能重且效率大打折扣。如果找到了单词，就应该将它从Trie中去掉，避免无谓的搜索，条件是该节点children长度为0，就父节点就将key删除。如果还有儿子节点只能标记is_end为False。Line 29 - 31和35 - 36</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        trie, res = Trie(), []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(word)</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, visited, trie, trie.get_head(), <span class="string">''</span>, res)</span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, visited, trie, trie_node, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        trie_child = trie.search_one_node(board[start_x][start_y], trie_node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trie_child:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        path += board[start_x][start_y]</span><br><span class="line">        <span class="keyword">if</span> trie_child.is_end:</span><br><span class="line">            res.append(path)</span><br><span class="line">            trie_child.is_end = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">                trie_node.children.pop(board[start_x][start_y])</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            self.dfs(board, start_x + dx, start_y + dy, visited, trie, trie_child, path, res)</span><br><span class="line">        path = path[:<span class="number">-1</span>]</span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            trie_node.children.pop(board[start_x][start_y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span>:</span><br><span class="line">                it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_one_node</span><span class="params">(self, c: str, trie_node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> trie_node.children[c]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*4*3<sup>L-1</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向,第一个可以4个方向，其他步是3个方向    </p><p>有一个方法是不用Trie而是将单词所有prefix放入到set中，但会TLE，因为时间复杂度为<code>O(<em>n</em><sup>2</sup><em>3</em><sup>n*n</sup>)</code>，它不会剪枝，从顶点出发，最差情况是z型走完board，此时路径长度为n*n.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 079 Word Search</title>
    <link href="https://shineboy2013.github.com/2021/12/03/lee-079/"/>
    <id>https://shineboy2013.github.com/2021/12/03/lee-079/</id>
    <published>2021-12-03T22:10:46.406Z</published>
    <updated>2021-12-04T05:28:34.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点在于判断不合法情况的顺序，比DFS模板稍复杂。这些语句都在for循环外，按此顺序： word_index和(start_x, start_y)不合法，该点访问过(模板)，字母不等。<br>然后visited为True，循环后visited为False      </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, i, j, word, <span class="number">0</span>, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, word, word_index, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word_index &gt;= len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> board[start_x][start_y] != word[word_index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board, start_x + dx, start_y + dy, word, word_index + <span class="number">1</span>, visited):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*<em>3</em><sup>L</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 023 Merge k Sorted Lists</title>
    <link href="https://shineboy2013.github.com/2021/12/02/lee-023/"/>
    <id>https://shineboy2013.github.com/2021/12/02/lee-023/</id>
    <published>2021-12-03T05:12:37.578Z</published>
    <updated>2021-12-03T07:47:07.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>heap不能比较ListNode大小，要实现<strong>lt</strong>函数或者将(node.val, node)对加入到heap中(此法Leetcode有编译错误但PyCharm可过)  </li><li>出堆后node的next赋None    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> x, y: (x.val &lt; y.val)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[Optional[ListNode]])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">        heap = []</span><br><span class="line">        fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> head <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                heappush(heap, head)</span><br><span class="line">        it = fake_head</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            node = heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                heappush(heap, node.next)</span><br><span class="line">            node.next = <span class="keyword">None</span></span><br><span class="line">            it.next = node</span><br><span class="line">            it = it.next</span><br><span class="line">        <span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(k)</code>.</p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>Devide and Conquer  </p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>k.next = None因为删除节点，所以赋None，这句不加也行，但作为良好习惯建议加，且不能在i = i.next前加，否则i会变空。      </li><li>查lists是否为空</li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists2</span><span class="params">(self, lists: List[List[<span class="string">'ListNode'</span>]])</span> -&gt; 'ListNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">return</span> self.merge_sort(lists, <span class="number">0</span>, len(lists) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, lists, start, end)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt;= end:</span><br><span class="line"><span class="keyword">return</span> lists[start]</span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">li = self.merge_sort(lists, start, mid)</span><br><span class="line">li2 = self.merge_sort(lists, mid + <span class="number">1</span>, end)</span><br><span class="line"><span class="keyword">return</span> self.merge_two_lists(li, li2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_two_lists</span><span class="params">(self, li, li2)</span>:</span></span><br><span class="line">i, j, res = li, li2, ListNode(<span class="number">0</span>)</span><br><span class="line">k = res</span><br><span class="line"><span class="keyword">while</span> i <span class="keyword">and</span> j:</span><br><span class="line"><span class="keyword">if</span> i.val &lt; j.val:</span><br><span class="line">k.next = i</span><br><span class="line">i = i.next</span><br><span class="line">k = k.next</span><br><span class="line">k.next = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">k.next = j</span><br><span class="line">j = j.next</span><br><span class="line">k = k.next</span><br><span class="line">k.next = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> i:</span><br><span class="line">k.next = i</span><br><span class="line"><span class="keyword">if</span> j:</span><br><span class="line">k.next = j</span><br><span class="line"><span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>不管多少次递归，每次递归的一层总的节点数为n，而对k做二分，所以递归数为logk, 时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>.</p><hr><h3 id="算法III解题思路："><a href="#算法III解题思路：" class="headerlink" title="算法III解题思路："></a><strong>算法III解题思路：</strong></h3><p>算法二的迭代法  </p><h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>输入大小的奇偶处理      </li><li>返回值是lists[0]而不是lists</li></ol><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists3</span><span class="params">(self, lists: List[List[<span class="string">'ListNode'</span>]])</span> -&gt; 'ListNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">while</span> len(lists) &gt; <span class="number">1</span>:</span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">if</span> len(lists) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">lists.append([])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lists), <span class="number">2</span>):</span><br><span class="line">tmp.append(self.merge_two_lists(lists[i], lists[i + <span class="number">1</span>]))</span><br><span class="line">lists = tmp</span><br><span class="line"><span class="keyword">return</span> lists[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>同算法二.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Divide and Conquer" scheme="https://shineboy2013.github.com/tags/Divide-and-Conquer/"/>
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Merge Sort" scheme="https://shineboy2013.github.com/tags/Merge-Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 300 Longest Increasing Subsequence</title>
    <link href="https://shineboy2013.github.com/2021/12/01/lee-300/"/>
    <id>https://shineboy2013.github.com/2021/12/01/lee-300/</id>
    <published>2021-12-02T07:39:53.639Z</published>
    <updated>2021-12-02T10:07:50.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>初始化从1开始，因为一个数是递增序列  </li><li>返回值不是dp[-1]，而是所有dp的最大值    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">dp[i] = max(dp[j]) + <span class="number">1</span>, <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; nums[j<span class="number">-1</span>], <span class="number">1</span> &lt;= j &lt; i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="comment"># dp = [0, 1, 0]</span></span><br><span class="line">dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="comment"># i = 2</span></span><br><span class="line"><span class="comment"># j = 1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line"><span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[j - <span class="number">1</span>]:</span><br><span class="line">dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">res = max(res, dp[i])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>.</p><hr><h3 id="打印路径："><a href="#打印路径：" class="headerlink" title="打印路径："></a><strong>打印路径：</strong></h3><p>N/A</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>path数组大小和原数组一样，因为path数组的下标和值都是下标，这样不用-1，直接nums[pos]，不容易错  </li><li>多了Line 11 - 12和14 - 15，需要记录产生最大值的下标  </li><li>打印的时候path数组的下标和值都是下标，而值是前一个下标，所以是pos = positions[pos]，循环次数为dp值，开始下标为dp值对应的下标path[:biggest_pos + 1]。   </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS_with_path</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res, path = <span class="number">1</span>, [<span class="number">0</span>] * len(nums)  <span class="comment"># remember no + 1</span></span><br><span class="line">biggest_pos = <span class="number">-1</span></span><br><span class="line">dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line"><span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[j - <span class="number">1</span>]:</span><br><span class="line">dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> dp[i] == dp[j] + <span class="number">1</span>:</span><br><span class="line">path[i - <span class="number">1</span>] = j - <span class="number">1</span></span><br><span class="line">res = max(res, dp[i])</span><br><span class="line"><span class="keyword">if</span> res == dp[i]:</span><br><span class="line">biggest_pos = i - <span class="number">1</span></span><br><span class="line">path_list = self.print_path(nums, path[:biggest_pos + <span class="number">1</span>], res)</span><br><span class="line"><span class="keyword">return</span> path_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(self, nums, path, dp_value)</span>:</span></span><br><span class="line">pos, res = len(path) - <span class="number">1</span>, []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(dp_value):</span><br><span class="line">res.append(nums[pos])</span><br><span class="line">pos = path[pos]</span><br><span class="line"><span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>N/A  </p><h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>bisect_left类似于greater_or_equal_position但若equal时，取第一个，但greater_or_equal_position是取最后一个，此题没关系，因为相等的数会被替换掉，递增序列中不会存在相等的数    </li></ol><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">pos = bisect.bisect_left(res, nums[i])</span><br><span class="line"><span class="keyword">if</span> pos &lt; len(res):</span><br><span class="line">res[pos] = nums[i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append(nums[i])</span><br><span class="line"><span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 264 Ugly Number II</title>
    <link href="https://shineboy2013.github.com/2021/11/30/lee-264/"/>
    <id>https://shineboy2013.github.com/2021/11/30/lee-264/</id>
    <published>2021-12-01T04:23:12.089Z</published>
    <updated>2021-12-01T06:45:13.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>与BFS模板一样，visited要在if里面。可以理解为一个数有三条边产生三个新数，所以和BFS模板一样   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">heap, visited = [<span class="number">1</span>], set([<span class="number">1</span>])</span><br><span class="line">primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &gt;= <span class="number">1</span>:</span><br><span class="line">res = heappop(heap)</span><br><span class="line"><span class="keyword">for</span> factor <span class="keyword">in</span> primes:</span><br><span class="line">tmp = factor * res</span><br><span class="line"><span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">heappush(heap, tmp)</span><br><span class="line">visited.add(tmp)</span><br><span class="line">n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>.</p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>比较难想，不推荐，但思路可用于其他题如L373。<strong>指针的数乘以指向数组的数</strong>，此题中指针为p2, p3, p5, 分别代表2， 3， 5， 数组为res数组，每次比较它们的积。    </p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>与上题一样要去重，此时，3个乘积中可能会相同且最小，同时移动这些指针     </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            num = min(<span class="number">2</span> * res[p2], <span class="number">3</span> * res[p3], <span class="number">5</span> * res[p5])</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">2</span> * res[p2]:</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">3</span> * res[p3]:</span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">5</span> * res[p5]:</span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">            res.append(num)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A&lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; c
      
    
    </summary>
    
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1429 First Unique Number</title>
    <link href="https://shineboy2013.github.com/2021/11/30/lee-1429/"/>
    <id>https://shineboy2013.github.com/2021/11/30/lee-1429/</id>
    <published>2021-12-01T04:13:01.365Z</published>
    <updated>2021-12-01T04:22:33.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Dict + LL。此题非常类似于LRU。      </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>注意两种情况，节点不在Map, 在Map中，对应的LL操作同样是add_to_tail和remove_node不过少了move_to_tail。    </li><li>头尾dummy node，初始化要相连。    </li><li>注意删除顺序，先删map中的entry再删Node。否则会出现NPE。新加入是顺序相反。删除节点要将prev和next赋None</li><li>区别还有ListNode不需要key，因为输入是单值，不是key-value对。数据结构多了set来记录出现超过两次的元素，直接忽略    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstUnique</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    2, 3, 5, 5</span></span><br><span class="line"><span class="string">    dict:</span></span><br><span class="line"><span class="string">    &#123;2:1</span></span><br><span class="line"><span class="string">     3:1</span></span><br><span class="line"><span class="string">     5:2 (remove)</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">    LinkedList: 2, 3, 5(r), 5(r)</span></span><br><span class="line"><span class="string">    dict:</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        2: Node(2)</span></span><br><span class="line"><span class="string">        3: Node(3)</span></span><br><span class="line"><span class="string">        5: Node(5)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># only store unique elements</span></span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.key_to_node = &#123;&#125;  <span class="comment"># only store unique elements</span></span><br><span class="line">        self.non_unique_set = set()</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            self.add(n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showFirstUnique</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.key_to_node) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.head.next.val</span><br><span class="line">    <span class="comment"># 2, 3, 5, 5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">in</span> self.non_unique_set:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_node:</span><br><span class="line">            new_node = ListNode(value)</span><br><span class="line">            self.add_to_tail(new_node)</span><br><span class="line">            self.key_to_node[value] = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            to_be_removed_node = self.key_to_node[value]</span><br><span class="line">            self.key_to_node.pop(value)</span><br><span class="line">            self.remove_node(to_be_removed_node)</span><br><span class="line">            self.non_unique_set.add(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor = self.tail.prev</span><br><span class="line">        predecessor.next, node.prev = node, predecessor</span><br><span class="line">        node.next, self.tail.prev = self.tail, node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next = None, prev = None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Dict + LL。此题非常类似于LRU。      &lt;/p&gt;
&lt;h3 id=&quot;注
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 380 Insert Delete GetRandom O(1)</title>
    <link href="https://shineboy2013.github.com/2021/11/30/lee-380/"/>
    <id>https://shineboy2013.github.com/2021/11/30/lee-380/</id>
    <published>2021-12-01T03:04:29.750Z</published>
    <updated>2021-12-01T03:08:19.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Dict + List  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>检查若删除最后一个元素发现问题，remove中删除key要放在最后，不能放中间  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.key_to_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.key_to_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        self.key_to_index[val] = len(self.nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.key_to_index:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        index = self.key_to_index[val]</span><br><span class="line">        last_val = self.nums[len(self.nums) - <span class="number">1</span>]</span><br><span class="line">        self.nums[index] = last_val</span><br><span class="line">        self.key_to_index[last_val] = index</span><br><span class="line">        self.key_to_index.pop(val)  <span class="comment"># remember to put it last</span></span><br><span class="line">        self.nums.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[random.randint(<span class="number">0</span>, len(self.nums) - <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Dict + List  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 269 Alien Dictionary</title>
    <link href="https://shineboy2013.github.com/2021/11/29/lee-269/"/>
    <id>https://shineboy2013.github.com/2021/11/29/lee-269/</id>
    <published>2021-11-30T06:09:47.410Z</published>
    <updated>2021-11-30T08:37:08.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求： 空字符顺序前于非空字母，否则字典不合法，如abc -&gt; ab, c不能前于空字符，无解。简而言之，后面单词不能是前面的前缀return False if len(word) &gt; len(word2) else True     </li><li>模板问题： graph要含所有节点，包括没有边的节点。否则结果会有遗漏graph = Counter({c: [] for word in words for c in word})    </li><li>模板问题： in_degree初始化要对所有节点赋0， in_degree[c] = 0。in_degree = collections.defaultdict(int)并不能产生key  </li><li>模板问题： 第四步判断是否含循环必不可少，题目要求可能不合法，return res if len(graph) == len(res) else ‘’  </li><li>语法错误： graph.items()记得加items。res是str不是list  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alienOrder</span><span class="params">(self, words: List[str])</span> -&gt; str:</span></span><br><span class="line"><span class="comment"># graph = collections.defaultdict(list)</span></span><br><span class="line">graph = Counter(&#123;c: [] <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">for</span> c <span class="keyword">in</span> word&#125;)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(words)):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.populate_one_order(words[i - <span class="number">1</span>], words[i], graph):</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">in_degree = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> graph.keys():</span><br><span class="line">in_degree[c] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key, li <span class="keyword">in</span> graph.items():</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)):</span><br><span class="line">in_degree[li[j]] += <span class="number">1</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">queue = deque([node <span class="keyword">for</span> node, in_degree_num <span class="keyword">in</span> in_degree.items() <span class="keyword">if</span> in_degree_num == <span class="number">0</span>])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line">res += node</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> in_degree[neighbor] == <span class="number">0</span>:</span><br><span class="line">queue.append(neighbor)</span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">if</span> len(graph) == len(res) <span class="keyword">else</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">populate_one_order</span><span class="params">(self, word, word2, graph)</span>:</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(word), len(word2))):</span><br><span class="line"><span class="keyword">if</span> word[j] != word2[j]:</span><br><span class="line">graph[word[j]].append(word2[j])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len(word) &gt; len(word2) <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(O + E)</code>，V为节点数，E为边数，n为单词数，L为最长单词长度，O = nL， E = L，而空间复杂度图的空间为O + E，而queue空间最多为26条边，26个字母，in_degree空间为O(V)。所以总的时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(nL)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A&lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; c
      
    
    </summary>
    
    
      <category term="Topological Sort" scheme="https://shineboy2013.github.com/tags/Topological-Sort/"/>
    
      <category term="Breadth-First Search" scheme="https://shineboy2013.github.com/tags/Breadth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="https://shineboy2013.github.com/2021/11/29/trie/"/>
    <id>https://shineboy2013.github.com/2021/11/29/trie/</id>
    <published>2021-11-30T00:47:38.487Z</published>
    <updated>2021-12-04T04:40:02.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 208 Implement Trie (Prefix Tree), 也可以用HashMap将所有前缀加入到Map来实现，效率稍低。  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>TrieNode用{}和is_end，insert, search, startswith用it和i迭代比较  </li><li>startswith含整个单词，如单词apple，startswith(‘apple’) -&gt; True  </li><li><del>Line 11记得加，也就是dict在取value是一定要先检验key是否存在。</del>可以不加，解决方案是用defaultdict（后版本）。  </li></ol><p>新版本比旧版本更简洁，体现在is_end的处理放在了for循环外。<br>存储结构举例：  a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TrieNode(</span><br><span class="line">  children = &#123; </span><br><span class="line">              &apos;a&apos;:  TrieNode(is_End = True)</span><br><span class="line">     &#125;</span><br><span class="line">  is_end = False</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="comment"># if word[i] not in it.children:</span></span><br><span class="line">                <span class="comment">#it.children[word[i]] = TrieNode()</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">        <span class="keyword">return</span> it.is_end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[prefix[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>旧版本  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="comment"># if word[i] not in it.children:</span></span><br><span class="line">                <span class="comment"># it.children[word[i]] = TrieNode()</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span>:</span><br><span class="line">                it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span> <span class="keyword">and</span> it.is_end:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prefix:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[prefix[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(prefix) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>，n为单词长度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Leetcode 208 Implement Trie (Prefix Tree)
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1048 Longest String Chain</title>
    <link href="https://shineboy2013.github.com/2021/11/27/lee-1048/"/>
    <id>https://shineboy2013.github.com/2021/11/27/lee-1048/</id>
    <published>2021-11-28T07:34:39.183Z</published>
    <updated>2021-11-30T08:42:24.960Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-string-chain/" target="_blank" rel="noopener">LeetCode 1048 Longest String Chain</a></strong></p><h3 id="Problem-Overview"><a href="#Problem-Overview" class="headerlink" title="Problem Overview"></a><strong>Problem Overview</strong></h3><p>Get longgest one-character transformation in the given list</p><h3 id="Thinking-Process"><a href="#Thinking-Process" class="headerlink" title="Thinking Process"></a><strong>Thinking Process</strong></h3><p>This problem is similar to Word Break (reversed to get neighbors) but it is a multi-source longest path problem. </p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a><strong>Steps</strong></h3><ol><li>Loop through each word  </li><li>BFS from each word and get the max distance    </li><li>Get the max of distance    </li></ol><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><ol><li>max_dis = 1 by default in BFS  </li><li>To improve the complexity, make the distance map global so that the distance of each node will be calculated once.<br>To do that, <strong>sort the list</strong> from longest to shortest and make sure the it is greedy to get the max distance</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">word_dict, distance = set(words), &#123;&#125;</span><br><span class="line">max_dis = <span class="number">0</span></span><br><span class="line">words.sort(key=len, reverse=<span class="keyword">True</span>)  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">dis = self.bfs(word, word_dict, distance)</span><br><span class="line">max_dis = max(max_dis, dis)</span><br><span class="line"><span class="keyword">return</span> max_dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word, word_dict, distance)</span>:</span></span><br><span class="line">queue = deque([word])</span><br><span class="line">visited = &#123;word&#125;</span><br><span class="line"><span class="keyword">if</span> word <span class="keyword">in</span> distance:  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> distance[word]</span><br><span class="line">distance[word] = <span class="number">1</span></span><br><span class="line">max_dis = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> self.get_neighbors(node, word_dict):</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">distance[neighbor] = distance[node] + <span class="number">1</span></span><br><span class="line">max_dis = max(max_dis, distance[neighbor])</span><br><span class="line"><span class="keyword">return</span> max_dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_neighbors</span><span class="params">(self, word, word_dict)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">new_word = word[:i] + word[i + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> new_word <span class="keyword">in</span> word_dict:</span><br><span class="line">res.append(new_word)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a><strong>Analysis</strong></h3><p>Though there is a loop and bfs like n^2, actually it is a traversal in a graph. n * L (n is # of nodes, L is max of path<br>single-source) is the num of edges. Another L is to get neighbors.<br>Time complexity<code>O(nlogn + n*<em>L</em><sup>2</sup>)</code>, Space complexity<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-string-chain/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 1048 Longest String Chain&lt;/
      
    
    </summary>
    
    
      <category term="tiktok" scheme="https://shineboy2013.github.com/tags/tiktok/"/>
    
  </entry>
  
  <entry>
    <title>DP</title>
    <link href="https://shineboy2013.github.com/2021/11/27/dp/"/>
    <id>https://shineboy2013.github.com/2021/11/27/dp/</id>
    <published>2021-11-27T20:32:31.335Z</published>
    <updated>2021-12-04T21:42:04.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>定义状态/函数： </li><li>递归式，从培养思路开始，写n = 1， k = 1， k = 2写几个例子方便写递归式  </li><li>1)遍历方向： 与递归式有关 -&gt; 坐标型(二维，与相邻状态相关，L010正则表达式及字符串题), 一维步长型(很常见与该状态的所有前状态相关，硬币个数，word break，LIS)，二维步长型或区间型(第一个循环是步长，戳破气球)<br>2)初始值<br>3)滚动内存省空间<br>DP边界问题是难点  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>[初始化]dp数组大小比原数组大1，因为令边界计算方便. 遍历从1开始</li><li>[初始化]初始化矩阵Python用dp = [[0 for _ in range(M)] for _ in range(N)], <strong>M为col数，再row数</strong></li><li>[实现]实现时候递归式要合法，保证边界内，如dp[i - t] =&gt; i - t &gt;=0</li><li>[优化]是否可以用滚动内存优化空间</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(self, s)</span>:</span></span><br><span class="line">dp = [<span class="keyword">False</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>打印路径： path为以最大值为结尾的数组（已截取）   </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(self, nums, path, dp_value)</span>:</span></span><br><span class="line">pos, res = len(path) - <span class="number">1</span>, []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(dp_value):</span><br><span class="line">res.append(nums[pos])</span><br><span class="line">pos = path[pos]</span><br><span class="line"><span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义状态/函数： &lt;/li&gt;
&lt;li&gt;递归式，从培养思路开始，写n =
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2080 Range Frequency Queries</title>
    <link href="https://shineboy2013.github.com/2021/11/20/lee-2080/"/>
    <id>https://shineboy2013.github.com/2021/11/20/lee-2080/</id>
    <published>2021-11-21T05:13:58.347Z</published>
    <updated>2021-11-21T08:42:09.410Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-frequency-queries/" target="_blank" rel="noopener">LeetCode 2080 Range Frequency Queries</a></strong></p><p>Design a data structure to find the <strong>frequency</strong> of a given value in a given subarray.</p><p>The <strong>frequency</strong> of a value in a subarray is the number of occurrences of that value in the subarray.</p><p>Implement the <code>RangeFreqQuery</code> class:</p><ul><li><code>RangeFreqQuery(int[] arr)</code> Constructs an instance of the class with the given <strong>0-indexed</strong> integer array <code>arr</code>.</li><li><code>int query(int left, int right, int value)</code> Returns the <strong>frequency</strong> of <code>value</code> in the subarray <code>arr[left...right]</code>.</li></ul><p>A <strong>subarray</strong> is a contiguous sequence of elements within an array. <code>arr[left...right]</code> denotes the subarray that contains the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> (<strong>inclusive</strong>).</p><p><strong>Example 1:</strong></p><pre>**Input**["RangeFreqQuery", "query", "query"][[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]**Output**[null, 1, 2]**Explanation**RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);rangeFreqQuery.query(1, 2, 4); // return 1\. The value 4 occurs 1 time in the subarray [33, 4]rangeFreqQuery.query(0, 11, 33); // return 2\. The value 33 occurs 2 times in the whole array.</pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>1 &lt;= arr[i], value &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li><li>At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>query</code></li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构，支持在指定的子数组中某target的频数。    </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题有意思，有望成为经典题。第一种方法写用以每个字母为结尾的frequency_dict作为数据结构，query只需要用frequency_dict[right]-frequency_dict[left-1]，<br>空间复杂度为<code>O(n<sup>2</sup>)</code>得到TLE。第二种方法用bucket sort，就是将值作为key存到dict中，而value是下标List，query时候得到对应List，遍历<br>一次即可，但仍然得到TLE。第三种方法改进用Binary search得到下标List的左右界。二分法用greater_or_equal_position以及small_or_equal_position.<br>所以最终方案采取bucket sort + binary search</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>dict记录值到下标列表的映射  </li><li>二分法找left和right的index从而求个数  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Binary search用greater_or_equal_position以及small_or_equal_position. </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">        self.frequency_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> self.frequency_dict:</span><br><span class="line">                self.frequency_dict[n] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.frequency_dict[n].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, left: int, right: int, value: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> self.frequency_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        index_list = self.frequency_dict[value]</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        count = 0</span></span><br><span class="line"><span class="string">        for index in index_list:</span></span><br><span class="line"><span class="string">            if left &lt;= index &lt;= right:</span></span><br><span class="line"><span class="string">                count += 1</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        left_pos = self.greater_or_equal_position(index_list, left)</span><br><span class="line">        right_pos = self.smaller_or_equal_position(index_list, right)</span><br><span class="line">        <span class="keyword">if</span> left_pos == <span class="number">-1</span> <span class="keyword">or</span> right_pos == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> right_pos - left_pos + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater_or_equal_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smaller_or_equal_position</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[end] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">if</span> nums[start] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>用defaultdict(list)和bisect来优化程序  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">self.frequency_dict = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">self.frequency_dict[n].append(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, left: int, right: int, value: int)</span> -&gt; int:</span></span><br><span class="line">index_list = self.frequency_dict[value]</span><br><span class="line">left_pos = bisect.bisect(index_list, left - <span class="number">1</span>)</span><br><span class="line">right_pos = bisect.bisect(index_list, right)</span><br><span class="line"><span class="keyword">return</span> right_pos - left_pos</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-frequency-queries/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 2080 Range Frequency Que
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2079 Watering Plants</title>
    <link href="https://shineboy2013.github.com/2021/11/20/lee-2079/"/>
    <id>https://shineboy2013.github.com/2021/11/20/lee-2079/</id>
    <published>2021-11-21T04:54:04.268Z</published>
    <updated>2021-11-21T05:13:39.456Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/watering-plants/" target="_blank" rel="noopener">LeetCode 2079 Watering Plants</a></strong></p><p>You want to water <code>n</code> plants in your garden with a watering can. The plants are arranged in a row and are labeled from <code>0</code> to <code>n - 1</code> from left to right where the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> plant is located at <code>x = i</code>. There is a river at <code>x = -1</code> that you can refill your watering can at.</p><p>Each plant needs a specific amount of water. You will water the plants in the following way:</p><ul><li>Water the plants in order from left to right.</li><li>After watering the current plant, if you do not have enough water to <strong>completely</strong> water the next plant, return to the river to fully refill the watering can.</li><li>You <strong>cannot</strong> refill the watering can early.</li></ul><p>You are initially at the river (i.e., <code>x = -1</code>). It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis.</p><p>Given a <strong>0-indexed</strong> integer array <code>plants</code> of <code>n</code> integers, where <code>plants[i]</code> is the amount of water the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> plant needs, and an integer <code>capacity</code> representing the watering can capacity, return <em>the <strong>number of steps</strong> needed to water all the plants</em>.</p><p><strong>Example 1:</strong></p><pre>**Input:** plants = [2,2,3,3], capacity = 5**Output:** 14**Explanation:** Start at the river with a full watering can:- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).- Walk to plant 3 (4 steps) and water it.Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.</pre><p><strong>Example 2:</strong></p><pre>**Input:** plants = [1,1,1,4,2,3], capacity = 4**Output:** 30**Explanation:** Start at the river with a full watering can:- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).- Water plant 3 (4 steps). Return to river (4 steps).- Water plant 4 (5 steps). Return to river (5 steps).- Water plant 5 (6 steps).Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.</pre><p><strong>Example 3:</strong></p><pre>**Input:** plants = [7,7,7,7,7,7,7], capacity = 8**Output:** 49**Explanation:** You have to refill before watering each plant.Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.</pre><p><strong>Constraints:</strong></p><ul><li><code>n == plants.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= plants[i] &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code></li><li><code>max(plants[i]) &lt;= capacity &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>x坐标上分别是浇每棵植物需要的水量，用数组plants表示，-1上为河水可以打水，capacity是容器大小。若发现水不够，就要回到河里将容器打满水。问浇完所有植物的总步数  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题类似于Leetcode 2073，可以按部就班按每个plant计算，但是为了提高效率，一般采取归结为更高一层次计算。<br>这题更高层次是每次去洒水再回去河边作为一个循环。最后一个循环不用回河边所以是单程。       </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>计算一次来回的距离，条件为剩余的水不够浇该次的植物  </li><li>退出循环后，计算单程距离  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如果满足capacity也要递归到下一轮再计算，也就是Line 5取等号</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wateringPlants</span><span class="params">(self, plants: List[int], capacity: int)</span> -&gt; int:</span></span><br><span class="line">sum, steps = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(plants):</span><br><span class="line">sum += plants[i]</span><br><span class="line"><span class="keyword">if</span> sum &lt;= capacity:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">steps += i * <span class="number">2</span>  <span class="comment"># back to river</span></span><br><span class="line">sum = plants[i]</span><br><span class="line"><span class="keyword">if</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">steps += len(plants)</span><br><span class="line"><span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/watering-plants/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 2079 Watering Plants&lt;/a&gt;&lt;/strong
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>合并排序</title>
    <link href="https://shineboy2013.github.com/2021/11/15/merge-sort/"/>
    <id>https://shineboy2013.github.com/2021/11/15/merge-sort/</id>
    <published>2021-11-15T10:37:01.085Z</published>
    <updated>2021-11-15T21:36:58.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>递归分前半和后半排序然后合并。  </p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>排序</li><li>求逆序数</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>merge函数中更改输入nums。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">self.m_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m_sort</span><span class="params">(self, nums: List[int], start: int, end: int)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt;= end:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">self.m_sort(nums, start, mid)</span><br><span class="line">self.m_sort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">self.merge(nums, start, mid, end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums: List[int], start: int, mid: int, end: int)</span>:</span></span><br><span class="line">i, j, res = start, mid + <span class="number">1</span>, []</span><br><span class="line"><span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= end:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;递归分前半和后半排序然后合并。  &lt;/p&gt;
&lt;h3 id=&quot;应用：&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>Heap</title>
    <link href="https://shineboy2013.github.com/2021/11/14/heap/"/>
    <id>https://shineboy2013.github.com/2021/11/14/heap/</id>
    <published>2021-11-15T07:01:39.803Z</published>
    <updated>2021-11-15T07:05:44.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最小堆可以维持堆顶元素为最小值。    </p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>求数组第k个大的数  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapreplace, heappush</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_heap</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> i &lt; k:</span><br><span class="line">heappush(res, nums[i])</span><br><span class="line"><span class="keyword">elif</span> nums[i] &gt; res[<span class="number">0</span>]:</span><br><span class="line">heapreplace(res, nums[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最小堆可以维持堆顶元素为最小值。    &lt;/p&gt;
&lt;h3 id=&quot;应用：&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
</feed>
