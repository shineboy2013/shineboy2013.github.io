<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-01T03:25:52.721Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 101 Symmetric Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/30/lee-101/"/>
    <id>https://shineboy2013.github.com/2021/12/30/lee-101/</id>
    <published>2021-12-30T09:48:56.828Z</published>
    <updated>2022-01-01T03:25:52.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt=""></p><pre>**Input:** root = [1,2,2,3,4,4,3]**Output:** true</pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt=""></p><pre>**Input:** root = [1,2,2,null,3,null,3]**Output:** false</pre><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断二叉树是否对称</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，但难点是转化成比较两棵树是否对称</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点是转化成比较两棵树是否对称    </li><li>还要比较值相等，root.val == root2.val</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> self.is_symmetric(root.left, root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetric</span><span class="params">(self, root, root2)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> root.val == root2.val <span class="keyword">and</span> self.is_symmetric(root.left, root2.right) <span class="keyword">and</span> self.is_symmetric(root.right, root2.left)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/symmetric-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given the &lt;co
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 102 Binary Tree Level Order Traversal</title>
    <link href="https://shineboy2013.github.com/2021/12/30/lee-102/"/>
    <id>https://shineboy2013.github.com/2021/12/30/lee-102/</id>
    <published>2021-12-30T09:26:06.359Z</published>
    <updated>2021-12-30T09:30:03.132Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[3],[9,20],[15,7]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 2000]</code>.</em>   <code>-1000 &lt;= Node.val &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树按层遍历</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用BFS模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">queue, res = collections.deque([root]), []</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">level = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line">level.append(node.val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">queue.append(node.left)</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">queue.append(node.right)</span><br><span class="line">res.append(level)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 103 Binary Tree Zigzag Level Order Traversal</title>
    <link href="https://shineboy2013.github.com/2021/12/30/lee-103/"/>
    <id>https://shineboy2013.github.com/2021/12/30/lee-103/</id>
    <published>2021-12-30T09:11:24.325Z</published>
    <updated>2021-12-30T09:13:49.594Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[3],[20,9],[15,7]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 2000]</code>.</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按层遍历二叉树。偶数层逆向</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用BFS按层遍历模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>多这一行level.append(node.val)   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">res = []</span><br><span class="line">queue = collections.deque([root])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">level = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line">level.append(node.val)</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">queue.append(node.left)</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">queue.append(node.right)</span><br><span class="line"><span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.append(level[::<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append(level)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/st
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 114 Flatten Binary Tree to Linked List</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-114/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-114/</id>
    <published>2021-12-30T07:26:20.108Z</published>
    <updated>2021-12-30T07:36:57.509Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p><div>Given the <code>root</code> of a binary tree, flatten the tree into a “linked list”: <em> The “linked list” should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>. </em> The “linked list” should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank" rel="noopener"><strong>pre-order</strong> <strong>traversal</strong></a> of the binary tree. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,5,3,4,null,6]<br><strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[0, 2000]</code>. </em> <code>-100 &lt;= Node.val &lt;= 100</code> <strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将二叉树转成以右节点相连的LL</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>递归需要知道左右递归末尾节点，这样才可以将右节点的首节点接到左节点的末尾。所以递归函数输入是root，返回LL末尾节点  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归函数输入是root，返回LL末尾节点    </li><li>如果left_end是空，也就是<strong>没有左节点，就不用交换</strong>。返回right_end, left_end, root三者中非空者。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">self.dfs(root)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">left_end = self.dfs(root.left)</span><br><span class="line">right_end = self.dfs(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> left_end: <span class="comment"># remember</span></span><br><span class="line">left_end.right = root.right</span><br><span class="line">root.right, root.left = root.left, <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> right_end:</span><br><span class="line"><span class="keyword">return</span> right_end</span><br><span class="line"><span class="keyword">elif</span> left_end:</span><br><span class="line"><span class="keyword">return</span> left_end</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flatten-binary-tree-to-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 070 Climbing Stairs</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-070/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-070/</id>
    <published>2021-12-30T04:17:32.216Z</published>
    <updated>2021-12-30T04:24:03.235Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are climbing a staircase. It takes <code>n</code> steps to reach the top.<br><br>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> There are two ways to climb to the top.<br>1. 1 step + 1 step<br>2. 2 steps<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> There are three ways to climb to the top.<br>1. 1 step + 1 step + 1 step<br>2. 1 step + 2 steps<br>3. 2 steps + 1 step<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 45</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>爬楼梯的方法数。一次可以爬一级或二级</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DP的经典题<br>递归式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] = dp[n - 1] + dp[n - 2]</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归式含两个前状态，所以用两个变量。Python的优势是可以同时赋值，所以不需要用临时变量     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[n] = dp[n - 1] + dp[n - 2]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">prev, cur = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>): <span class="comment"># 4</span></span><br><span class="line">cur, prev = cur + prev, cur <span class="comment"># 5, 3</span></span><br><span class="line"><span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Yo
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 254 Factor Combinations</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-254/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-254/</id>
    <published>2021-12-30T03:26:48.088Z</published>
    <updated>2022-01-01T03:18:37.821Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Numbers can be regarded as the product of their factors.<br><br><em>   For example, <code>8 = 2 x 2 x 2 = 2 x 4</code>.<br><br>Given an integer <code>n</code>, return <em>all possible combinations of its factors</em>. You may return the answer in <strong>any order</strong>.<br><br><strong>Note</strong> that the factors should be in the range <code>[2, n - 1]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 12<br><strong>Output:</strong> [[2,6],[3,4],[2,2,3]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 37<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有因式分解</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有解，所以用DFS。类似于LeetCode 039 Combination Sum元素可复用。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>类似于元素可复用的组合和。但更似<strong>全组合模板，append发生在循环中</strong>，而不是终止条件中。比如12，遇到2就把商[2, 6]加入到结果  </li><li>数值区间的组合，start和target都是数值，而不是数组长度。i是从start开始，而不是从2开始，<strong>保证path里的数有序</strong>   </li><li>target // i &lt; i <strong>保证path里的数有序</strong>，否则12=232，不可行  </li><li>i从start循环到math.sqrt(n) + 1，否则会TLE   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFactors</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(n, <span class="number">2</span>, n, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, start, target, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, int(math.sqrt(n) + <span class="number">1</span>)): <span class="comment"># remember to use start</span></span><br><span class="line"><span class="keyword">if</span> target % i != <span class="number">0</span> <span class="keyword">or</span> target // i &lt; i: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">path.append(i)</span><br><span class="line">res.append(list(path + [target // i]))</span><br><span class="line">self.dfs(n, i, target // i, path, res) </span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(# of prime factors)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/factor-combinations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 377 Combination Sum IV</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-377/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-377/</id>
    <published>2021-12-29T23:22:34.011Z</published>
    <updated>2022-01-01T03:18:58.972Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-iv/submissions/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.<br><br>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3], target = 4<br><strong>Output:</strong> 7<br><strong>Explanation:</strong><br>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>Note that different sequences are counted as different combinations.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [9], target = 3<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 200</code></em>   <code>1 &lt;= nums[i] &lt;= 1000</code><br><em>   All the elements of <code>nums</code> are <strong>unique</strong>.</em>   <code>1 &lt;= target &lt;= 1000</code><br><br><strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有可能组合的和等于target。元素可以复用且顺序在组合中可以任意。   </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题似组合又似排列，是组合的结果再全排列。求种数另一种的方法是DP. dp[n]为target=n所有的所有组合种数。属于数值-&gt;个数型DP<br>递归公式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n + num[i]] = dp[n], n = [1, tgt], i = [0, len(nums) - 1]</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dp[i + nums[j]] += dp[i] 而不是dp[i] + 1 </li><li>dp[0] = 1表示数值为0，可以不用任何数就能获得，所以是1种     </li><li>先排序，否则如[3, 1, 2, 4]，返回dp[1] = 0, 但应该是dp[1] = 1  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[n + num[i]] = dp[n], n = [1, tgt], i = [0, len(nums) - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">nums.sort() <span class="comment"># remember</span></span><br><span class="line">dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> i + nums[j] &gt; target:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">dp[i + nums[j]] += dp[i] <span class="comment"># remember no +1</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*target)</code>，空间复杂度<code>O(target)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum-iv/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 216 Combination Sum III</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-216/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-216/</id>
    <published>2021-12-29T20:38:20.462Z</published>
    <updated>2021-12-29T20:43:21.751Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:<br><br><em>   Only numbers <code>1</code> through <code>9</code> are used.</em>   Each number is used <strong>at most once</strong>.<br><br>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> k = 3, n = 7<br><strong>Output:</strong> [[1,2,4]]<br><strong>Explanation:</strong><br>1 + 2 + 4 = 7<br>There are no other valid combinations.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> k = 3, n = 9<br><strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]<br><strong>Explanation:</strong><br>1 + 2 + 6 = 9<br>1 + 3 + 5 = 9<br>2 + 3 + 4 = 9<br>There are no other valid combinations.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> k = 4, n = 1<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no valid combinations.<br>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= k &lt;= 9</code></em>   <code>1 &lt;= n &lt;= 60</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数字1-9的组合个数为k的组合和等于k，每个元素最多用一次</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Leetcode 40和77的结合。个数和target都要达到。用if k == 0 and target == 0   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k: int, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">nums = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">res = []</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, k, n, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, start, k, target, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> target == <span class="number">0</span>:</span><br><span class="line">res.append(list(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">path.append(nums[i])</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, target - nums[i], path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>k</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 077 Combinations</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-077/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-077/</id>
    <published>2021-12-29T19:45:45.667Z</published>
    <updated>2021-12-29T20:42:43.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.<br><br>You may return the answer in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 4, k = 2<br><strong>Output:</strong><br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 1, k = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 20</code></em>   <code>1 &lt;= k &lt;= n</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求大小为k的所有可能组合</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>引入k作为模板API中的target，<strong>k为0作为终止条件</strong>。   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">nums = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">path, result = [], []</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, k, path, result)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, k, path, result)</span>:</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">result.append(list(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">path.append(nums[i])</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, k - <span class="number">1</span>, path, result)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>k</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/combinations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 040 Combination Sum II</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-040/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-040/</id>
    <published>2021-12-29T19:32:00.919Z</published>
    <updated>2021-12-29T19:36:12.239Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.<br><br>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.<br><br><strong>Note:</strong> The solution set must not contain duplicate combinations.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8<br><strong>Output:</strong><br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> candidates = [2,5,2,1,2], target = 5<br><strong>Output:</strong><br>[<br>[1,2,2],<br>[5]<br>]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= candidates.length &lt;= 100</code></em>   <code>1 &lt;= candidates[i] &lt;= 50</code><br>*   <code>1 &lt;= target &lt;= 30</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求组合和等于目标。元素不可复用且结果去重</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>类似于Leetcode 39，有两点不同。要去重，<strong>i &gt; start</strong>并不是i &gt; 0, 且比较前一个元素  </li><li>因为元素不可重复，下一轮递归i + 1    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">candidates.sort()</span><br><span class="line">res = []</span><br><span class="line">self.dfs(candidates, <span class="number">0</span>, target, [], res)</span><br><span class="line"><span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, start, target, path, res)</span>:</span> <span class="comment"># [1, 2], 0, 0, [1, 1], [1, 1]</span></span><br><span class="line"><span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">res.append(list(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)): <span class="comment"># [2]</span></span><br><span class="line"><span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i - <span class="number">1</span>] == candidates[i]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">path.append(candidates[i]) <span class="comment"># [1,1]</span></span><br><span class="line">self.dfs(candidates, i + <span class="number">1</span>, target - candidates[i], path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 039 Combination Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/29/lee-039/"/>
    <id>https://shineboy2013.github.com/2021/12/29/lee-039/</id>
    <published>2021-12-29T18:51:22.510Z</published>
    <updated>2021-12-29T19:09:32.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.<br><br>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.<br><br>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> candidates = [2,3,6,7], target = 7<br><strong>Output:</strong> [[2,2,3],[7]]<br><strong>Explanation:</strong><br>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 = 7.<br>These are the only two combinations.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> candidates = [2,3,5], target = 8<br><strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> candidates = [2], target = 1<br><strong>Output:</strong> []<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= candidates.length &lt;= 30</code></em>   <code>1 &lt;= candidates[i] &lt;= 200</code><br><em>   All elements of <code>candidates</code> are <strong>distinct</strong>.</em>   <code>1 &lt;= target &lt;= 500</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求组合和等于目标。元素可以复用</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用组合模板，先排序</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用标准组合模板dfs(self, candidates, start, target, path, res)，元素可以复用，所以下一轮递归从i开始</li><li>Python中path.pop()没有参数   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">candidates.sort()</span><br><span class="line">res = []</span><br><span class="line">self.dfs(candidates, <span class="number">0</span>, target, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, start, target, path, res)</span>:</span> <span class="comment"># [1, 2], 0, 0, [1, 1], [1, 1]</span></span><br><span class="line"><span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">res.append(list(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)): <span class="comment"># [2]</span></span><br><span class="line">path.append(candidates[i]) <span class="comment"># [1,1]</span></span><br><span class="line">self.dfs(candidates, i, target - candidates[i], path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Gi
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1650 Lowest Common Ancestor of a Binary Tree III</title>
    <link href="https://shineboy2013.github.com/2021/12/28/lee-1650/"/>
    <id>https://shineboy2013.github.com/2021/12/28/lee-1650/</id>
    <published>2021-12-29T06:35:19.634Z</published>
    <updated>2021-12-29T06:48:00.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two nodes of a binary tree <code>p</code> and <code>q</code>, return <em>their lowest common ancestor (LCA)</em>.<br><br>Each node will have a reference to its parent node. The definition for <code>Node</code> is below:<br><br><pre>class Node {<br>    public int val;<br>    public Node left;<br>    public Node right;<br>    public Node parent;<br>}<br></pre><br><br>According to the <strong><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a></strong>: “The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1,2], p = 1, q = 2<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code>.</em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All <code>Node.val</code> are <strong>unique</strong>.</em>   <code>p != q</code><br>*   <code>p</code> and <code>q</code> exist in the tree.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求带父节点的树中的两个节点的LCA。节点值唯一，且两输入节点不同，且一定存在</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>某一个节点的左右父节点存入set中，另一节点的每个父节点在set中找     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, p: <span class="string">'Node'</span>, q: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">parent_set = set()</span><br><span class="line">it = p</span><br><span class="line"><span class="keyword">while</span> it:</span><br><span class="line">parent_set.add(it)</span><br><span class="line">it = it.parent</span><br><span class="line">it = q</span><br><span class="line"><span class="keyword">while</span> it:</span><br><span class="line"><span class="keyword">if</span> it <span class="keyword">in</span> parent_set:</span><br><span class="line"><span class="keyword">return</span> it</span><br><span class="line">it = it.parent</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(n)</code>，n和m为所有父亲路径长  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 238 Product of Array Except Self</title>
    <link href="https://shineboy2013.github.com/2021/12/28/lee-238/"/>
    <id>https://shineboy2013.github.com/2021/12/28/lee-238/</id>
    <published>2021-12-29T06:10:30.854Z</published>
    <updated>2021-12-29T06:47:15.114Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.<br><br>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br><br>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4]<br><strong>Output:</strong> [24,12,8,6]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1,1,0,-3,3]<br><strong>Output:</strong> [0,0,9,0,0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>-30 &lt;= nums[i] &lt;= 30</code><br><em>   The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.<br><br><strong>Follow up:</strong> Can you solve the problem in <code>O(1)</code>extra space complexity? (The output array <em>*does not</em></em> count as extra space for space complexity analysis.)<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求每个数对应的结果： 数组出自己外全部相乘  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>累计思想</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>两轮计算，从左到右，再从右到左，用res数组作为临时计算结果。从左到右，计算res[i] = num[0] x nums[i - 1], 从右到左类似   </li><li>res初始值为1，因为从左到右是跳过第0个值的，而从右到左中res[i] *= product，若初始为0，结果res[i] = 0   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">n = len(nums)</span><br><span class="line">res, product = [<span class="number">1</span>] * n, nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">res[i] = product <span class="comment"># [1, 1]</span></span><br><span class="line">product *= nums[i]</span><br><span class="line">product = nums[<span class="number">-1</span>] <span class="comment"># 2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">res[i] *= product <span class="comment"># [2, 1]</span></span><br><span class="line">product *= nums[i]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/product-of-array-except-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;d
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Prefix Sum" scheme="https://shineboy2013.github.com/tags/Prefix-Sum/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 037 Sudoku Solver</title>
    <link href="https://shineboy2013.github.com/2021/12/28/lee-037/"/>
    <id>https://shineboy2013.github.com/2021/12/28/lee-037/</id>
    <published>2021-12-28T21:54:39.986Z</published>
    <updated>2021-12-29T05:45:59.136Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode</a></strong></p><div>Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy <strong>all of the following rules</strong>: 1. Each of the digits <code>1-9</code> must occur exactly once in each row. 2. Each of the digits <code>1-9</code> must occur exactly once in each column. 3. Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid. The <code>&#39;.&#39;</code> character indicates empty cells. <strong>Example 1:</strong> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br><strong>Output:</strong> [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br><strong>Explanation:</strong> The input board is shown above and the only valid solution is shown below:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""><br></pre><br><br><strong>Constraints:</strong> <em> <code>board.length == 9</code> </em> <code>board[i].length == 9</code> <em> <code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>. </em> It is <strong>guaranteed</strong> that the input board has only one solution.</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>日本游戏。需要保证每行每列每个9个方块的数是1-9里唯一。</p><h3 id="Global-dict解题思路-推荐-："><a href="#Global-dict解题思路-推荐-：" class="headerlink" title="Global dict解题思路(推荐)："></a><strong>Global dict解题思路(推荐)：</strong></h3><p>DFS。利用DFS模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用三种全局性dict(row, col, box)来记录所有已填的数，方便dfs时候迅速判断是否合法。这是比算法II优胜的地方。Python中不存在list of set只能用list of dict： [collections.defaultdict(int) for _ in range(len(board))]  </li><li><strong>初始化要将棋局上所有已有的数加入到dict中</strong>。一开始是dfs时候才加，但这样填的数不知道后面的格是否已经存在。题意保证有解，所以这些数不需验证重复。    </li><li>for循环是1-9是数字但棋盘是字符，所以要<strong>字符和数字转化</strong>，选择统一转成数字，不转的话dict会实效。  </li><li>box_dict的id转换： i // 3 * 3 + j // 3 </li><li>终止条件为start_x == len(board) - 1 and start_y == len(board[0])   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">row_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))] <span class="comment"># remember</span></span><br><span class="line">col_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">box_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">self.add_to_dict(board, i, j, row_dict, col_dict, box_dict) <span class="comment"># rememeber</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(board, <span class="number">0</span>, <span class="number">0</span>, row_dict, col_dict, box_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">start_x += <span class="number">1</span></span><br><span class="line">start_y = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict) <span class="comment"># guarantee solution</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(board, k, start_x, start_y, row_dict, col_dict, box_dict):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">board[start_x][start_y] = str(k)</span><br><span class="line">self.add_to_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line"><span class="keyword">if</span> self.dfs(board, start_x, start_y + <span class="number">1</span>, row_dict, col_dict, box_dict):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">self.remove_from_dict(board, start_x, start_y, row_dict, col_dict, box_dict)</span><br><span class="line">board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">row_dict[i][int(board[i][j])] = <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">col_dict[j][int(board[i][j])] = <span class="number">1</span></span><br><span class="line">box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][int(board[i][j])] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_from_dict</span><span class="params">(self, board, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line">row_dict[i].pop(int(board[i][j]))</span><br><span class="line">col_dict[j].pop(int(board[i][j]))</span><br><span class="line">box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>].pop(int(board[i][j]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, k, i, j, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> k <span class="keyword">in</span> row_dict[i] <span class="keyword">or</span> k <span class="keyword">in</span> col_dict[j] <span class="keyword">or</span> k <span class="keyword">in</span> box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>]: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(9<sup>n*n</sup>)</code>，空间复杂度<code>O(n)</code>，n为边长  </p><hr><h3 id="常量空间算法II解题思路："><a href="#常量空间算法II解题思路：" class="headerlink" title="常量空间算法II解题思路："></a><strong>常量空间算法II解题思路：</strong></h3><p>我一开始的方法，每填一位就验证。</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveSudoku2</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs2(board, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, board, start_x, start_y)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start_x == len(board) - <span class="number">1</span> <span class="keyword">and</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> start_y == len(board[<span class="number">0</span>]):</span><br><span class="line">start_x += <span class="number">1</span></span><br><span class="line">start_y = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> board[start_x][start_y] != <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>) <span class="comment"># guarantee solution</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">if self.is_sudoku(board, start_x, start_y):</span></span><br><span class="line"><span class="string">return self.dfs(board, start_x, start_y + 1)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">return False</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">board[start_x][start_y] = str(k)</span><br><span class="line"><span class="keyword">if</span> self.is_sudoku2(board, start_x, start_y) <span class="keyword">and</span> self.dfs2(board, start_x, start_y + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">board[start_x][start_y] = <span class="string">'.'</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sudoku2</span><span class="params">(self, board, x, y)</span>:</span></span><br><span class="line"><span class="comment"># row, # col, # square</span></span><br><span class="line"><span class="keyword">if</span> self.is_valid(board, x, <span class="number">0</span>, x, len(board[<span class="number">0</span>]) - <span class="number">1</span>) <span class="keyword">and</span> self.is_valid(board, <span class="number">0</span>, y, len(board) - <span class="number">1</span>, y) <span class="keyword">and</span> \</span><br><span class="line">self.is_valid(board, x // <span class="number">3</span> * <span class="number">3</span>, y // <span class="number">3</span> * <span class="number">3</span>, x // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>, y // <span class="number">3</span> * <span class="number">3</span> + <span class="number">2</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, board, start_x, start_y, end_x, end_y)</span>:</span></span><br><span class="line">num_set = set()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start_x, end_x + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(start_y, end_y + <span class="number">1</span>):</span><br><span class="line">val = board[i][j]</span><br><span class="line"><span class="keyword">if</span> val == <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> int(val) <span class="keyword">in</span> num_set:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">num_set.add(int(val))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(81<sup>n*n</sup>)</code>，空间复杂度<code>O(1)</code>，n为边长  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;Write a prog
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 871 Minimum Number of Refueling Stops</title>
    <link href="https://shineboy2013.github.com/2021/12/28/lee-871/"/>
    <id>https://shineboy2013.github.com/2021/12/28/lee-871/</id>
    <published>2021-12-28T10:25:39.285Z</published>
    <updated>2021-12-28T18:21:07.789Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.<br><br>There are gas stations along the way. The gas stations are represented as an array <code>stations</code> where <code>stations[i] = [position&lt;sub&gt;i&lt;/sub&gt;, fuel&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> gas station is <code>position&lt;sub&gt;i&lt;/sub&gt;</code> miles east of the starting position and has <code>fuel&lt;sub&gt;i&lt;/sub&gt;</code> liters of gas.<br><br>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.<br><br>Return <em>the minimum number of refueling stops the car must make in order to reach its destination</em>. If it cannot reach the destination, return <code>-1</code>.<br><br>Note that if the car reaches a gas station with <code>0</code> fuel left, the car can still refuel there. If the car reaches the destination with <code>0</code> fuel left, it is still considered to have arrived.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 1, startFuel = 1, stations = []<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> We can reach the target without refueling.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 1, stations = [[10,100]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We can not reach the target (or even the first gas station).<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We start with 10 liters of fuel.<br>We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.<br>Then, we drive from position 10 to position 60 (expending 50 liters of fuel),<br>and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.<br>We made 2 refueling stops along the way, so we return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target, startFuel &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></em>   <code>0 &lt;= stations.length &lt;= 500</code><br><em>   <code>0 &lt;= position&lt;sub&gt;i&lt;/sub&gt; &lt;= position&lt;sub&gt;i+1&lt;/sub&gt; &lt; target</code></em>   <code>1 &lt;= fuel&lt;sub&gt;i&lt;/sub&gt; &lt; 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>其最小加油次数使得能到达目标  </p><h3 id="Heap解题思路-推荐-："><a href="#Heap解题思路-推荐-：" class="headerlink" title="Heap解题思路(推荐)："></a><strong>Heap解题思路(推荐)：</strong></h3><p>由于是重叠区间题，考虑用heap。求最小值，所以用最大堆。heap存的油数。  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>每到一个加油站，先将油预存到heap中。startFuel为到达某个站后的剩余油数，若startFuel为负，从heap中取油，且累计加油次数。  </li><li>用heap模板，遍历数组也就是加油站。  </li><li>若加完油后，仍为负数，返回-1。</li><li>因为要计算target是否能达到，所以不妨<strong>将target加入到stations</strong>中，这样startFuel的计算可以包括target     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">heap, res, prev_pos = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">stations.append([target, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> pos, fuel <span class="keyword">in</span> stations:</span><br><span class="line">startFuel -= pos - prev_pos</span><br><span class="line"><span class="keyword">while</span> heap <span class="keyword">and</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line">startFuel += -heapq.heappop(heap)</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> startFuel &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">heapq.heappush(heap, -fuel)</span><br><span class="line">prev_pos = pos</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code> </p><hr><h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>一开始考虑用jump game，但此题可以在同一层加多次油。比如start fuel有100 mi，而加油站有3个，所以同一层可以加3次油。所以层数和加油次数不是一个概念。<br>既然是最值考虑另一种方法DP。这题有两个难点:<br>第一个难点是DP式： dp不采用题目的最小加油次数，考虑jump game的分析，转化成dp[i]为停i个站加油能达到的最远距离。或者这样思考，若定义走到第n个站需要最小加油次数，这个n颗粒度不够细，可以换成miles，不如将下标和数值互换。<br>第二个难点是递归式。首先知道假设dp[2]能到达的范围内有一个加油站，加油后dp[3] = dp[2] + 该油站的油数。递归式为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span><br></pre></td></tr></table></figure><p>有个前提条件是dp[2]必须能达到当前的加油站。比如要更新dp[3]从任意两个加油站dp[2] + 加油站[i]可能获得。还可能是从dp[2] + 加油站[i+1]获得，如此类推，要试完stations[i..n]。<br><strong>dp值从后往前更新</strong>，因为当前加油站在后方。   </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dp定义和递归式     </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max&#123;dp[i-1] + stations[i-1][1]&#125;, dp[i-1] &gt;= stations[i-1][0], stations[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target: int, startFuel: int, stations: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [startFuel] + [<span class="number">0</span>] * len(stations)</span><br><span class="line"><span class="keyword">for</span> i, (pos, fuel) <span class="keyword">in</span> enumerate(stations):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> dp[j] &gt;= pos:</span><br><span class="line">dp[j + <span class="number">1</span>] = max(dp[j + <span class="number">1</span>], dp[j] + fuel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, miles <span class="keyword">in</span> enumerate(dp):</span><br><span class="line"><span class="keyword">if</span> miles &gt;= target:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-refueling-stops/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 909 Snakes and Ladders</title>
    <link href="https://shineboy2013.github.com/2021/12/27/lee-909/"/>
    <id>https://shineboy2013.github.com/2021/12/27/lee-909/</id>
    <published>2021-12-27T21:50:38.164Z</published>
    <updated>2021-12-28T03:48:03.037Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n&lt;sup&gt;2&lt;/sup&gt;</code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank" rel="noopener"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.<br><br>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:<br><br><em>   Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n&lt;sup&gt;2&lt;/sup&gt;)]</code>.    </em>   This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.<br><em>   If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.</em>   The game ends when you reach the square <code>n&lt;sup&gt;2&lt;/sup&gt;</code>.<br><br>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have a snake or ladder.<br><br>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent snake or ladder.<br><br><em>   For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.<br><br>Return <em>the least number of moves required to reach the square</em> <code>n&lt;sup&gt;2&lt;/sup&gt;</code><em>. If it is not possible to reach the square, return</em> <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt=""><br><br><pre><strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong><br>In the beginning, you start at square 1 (at row 5, column 0).<br>You decide to move to square 2 and must take the ladder to square 15.<br>You then decide to move to square 17 and must take the snake to square 13.<br>You then decide to move to square 14 and must take the ladder to square 35.<br>You then decide to move to square 36, ending the game.<br>This is the lowest possible number of moves to reach the last square, so return 4.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> board = [[-1,-1],[-1,3]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong></em>   <code>n == board.length == board[i].length</code><br><em>   <code>2 &lt;= n &lt;= 20</code></em>   <code>grid[i][j]</code> is either <code>-1</code> or in the range <code>[1, n&lt;sup&gt;2&lt;/sup&gt;]</code>.<br>*   The squares labeled <code>1</code> and <code>n&lt;sup&gt;2&lt;/sup&gt;</code> do not have any ladders or snakes.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二维版上每格label从1到n^2, 从左到右或从右到左(梅花间竹)，从下到上。每次走1-6步，格上可能有梯子和蛇，梯子是快进，蛇是回退直接到达目标格。求从1到n^2所需要步数。始点和目标不含梯子和蛇。</p><h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>求最值两个方法：DP和BFS。一开始考虑用DP，但状态很复杂，因为存在回退，这样回退后要重新计算回退之后的DP值。<br>由于此题没有方向性而且似jump game，所以考虑用DP。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题意：对于梯子和蛇，它不能停留在梯子和蛇的起点，只能够停在终点，所以梯子和蛇的起点到1的距离为无穷大。其实可以留在起点，比如一个格同时是蛇的终点和梯子的起点。题意表明不能在同一步中两次用梯子或蛇。   </li><li>根据上述题意，程序中对应是<strong>如碰到儿子中有梯子和蛇的起点，完全忽略它，立刻转换成终点，也就是不入列，不如visited，不计算距离，完全当其透明</strong>。开始犯的错误是将其入列，出列才计算梯子终点。此算法仍然可以满足上述题意，此时梯子的起点会被加入到visited和distance，queue中，因为它确实停在那里了。  </li><li>visited在计算完梯子和蛇的终点后才处理，而不是进入for loop后  </li><li>neighbor不能超过n，达不到目标返回-1  </li><li>另一个难点在label转成坐标从而查找是否有梯子和蛇</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">n = len(board) * len(board)</span><br><span class="line">queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">visited = set([<span class="number">1</span>])</span><br><span class="line">distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == n:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line"><span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">dest_label = board[board_x][board_y]</span><br><span class="line">next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next_step <span class="keyword">in</span> visited: <span class="comment"># remember to put it after dest_label</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">queue.append(next_step)</span><br><span class="line">visited.add(next_step)</span><br><span class="line">distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">row_id = label // n <span class="comment"># 0</span></span><br><span class="line">col_id = label % n</span><br><span class="line"><span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><p>另一种优化是只入最远的节点，类似于jump game。</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(board) * len(board)</span><br><span class="line">queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">visited = set([<span class="number">1</span>])</span><br><span class="line">distance = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == n:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line">max_non_jump = node</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> range(node + <span class="number">1</span>, node + <span class="number">7</span>):</span><br><span class="line"><span class="keyword">if</span> neighbor &gt; n:  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">board_x, board_y = self.get_board_cell(len(board), neighbor)</span><br><span class="line">dest_label = board[board_x][board_y]</span><br><span class="line">next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> neighbor</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next_step <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line">queue.append(next_step)</span><br><span class="line">visited.add(next_step)</span><br><span class="line">distance[next_step] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">max_non_jump = next_step</span><br><span class="line"><span class="keyword">if</span> max_non_jump <span class="keyword">in</span> visited:  <span class="comment"># remember to put it after dest_label</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(max_non_jump)</span><br><span class="line">visited.add(max_non_jump)</span><br><span class="line">distance[max_non_jump] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_board_cell</span><span class="params">(self, n, label)</span>:</span> <span class="comment"># 6, 6</span></span><br><span class="line">label -= <span class="number">1</span> <span class="comment"># rememeber</span></span><br><span class="line">row_id = label // n <span class="comment"># 0</span></span><br><span class="line">col_id = label % n</span><br><span class="line"><span class="keyword">return</span> n - <span class="number">1</span> - row_id, n - <span class="number">1</span> - col_id <span class="keyword">if</span> row_id % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> col_id</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>/6)</code>，空间复杂度<code>O(n<sup>2</sup>/6)</code>  </p><hr><h3 id="DP算法II解题思路-不推荐-："><a href="#DP算法II解题思路-不推荐-：" class="headerlink" title="DP算法II解题思路(不推荐)："></a><strong>DP算法II解题思路(不推荐)：</strong></h3><p>非常容易错，且效率更低，需要回退重新计算dp值。 dp[i] + 1 &lt; dp[dest_label]保证不会在无限回退，i = dest_label - 1要在break前做，而不是更前，否二影响dp[dest_label]计算</p><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders_dp</span><span class="params">(self, board: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">N = len(board) * len(board) + <span class="number">1</span></span><br><span class="line">dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># remember</span></span><br><span class="line"><span class="comment"># i is label id</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># for i in range(2, N):</span></span><br><span class="line"><span class="keyword">while</span> i &lt; N:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line"><span class="keyword">if</span> i + k &lt; N:</span><br><span class="line">board_x, board_y = self.get_board_cell(len(board), i + k)</span><br><span class="line">dest_label = board[board_x][board_y]</span><br><span class="line">next_step = dest_label <span class="keyword">if</span> dest_label != <span class="number">-1</span> <span class="keyword">else</span> i + k</span><br><span class="line"><span class="keyword">if</span> dest_label != <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> dest_label &lt; i <span class="keyword">and</span> dp[i] + <span class="number">1</span> &lt; dp[dest_label]: <span class="comment"># remember </span></span><br><span class="line">dp[dest_label] = min(dp[dest_label], dp[i] + <span class="number">1</span>)</span><br><span class="line">i = dest_label - <span class="number">1</span> <span class="comment"># remember to assign at the end</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">dp[next_step] = min(dp[next_step], dp[i] + <span class="number">1</span>) <span class="comment"># remember + 1 inside min</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/snakes-and-ladders/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 987 Vertical Order Traversal of a Binary Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/27/lee-987/"/>
    <id>https://shineboy2013.github.com/2021/12/27/lee-987/</id>
    <published>2021-12-27T20:08:31.755Z</published>
    <updated>2021-12-27T20:19:00.699Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.<br><br>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.<br><br>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.<br><br>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br><strong>Explanation:</strong><br>Column -1: Only node 9 is in this column.<br>Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.<br>Column 1: Only node 20 is in this column.<br>Column 2: Only node 7 is in this column.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5,6,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>Column -2: Only node 4 is in this column.<br>Column -1: Only node 2 is in this column.<br>Column 0: Nodes 1, 5, and 6 are in this column.<br>          1 is at the top, so it comes first.<br>          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.<br>Column 1: Only node 3 is in this column.<br>Column 2: Only node 7 is in this column.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,6,5,7]<br><strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]<br><strong>Explanation:</strong><br>This case is the exact same as example 2, but with nodes 5 and 6 swapped.<br>Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 1000]</code>.</em>   <code>0 &lt;= Node.val &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序打印二叉树，若列号同，同一行的节点按值排序 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>与<a href="https://shineboy2013.github.io/2021/12/24/lee-314/" target="_blank" rel="noopener">LeetCode 314 Binary Tree Vertical Order Traversal</a>类似，用BFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>一开始以为同一列的同一行的节点在queue是一个紧接一个出列。但同一行节点可能先出列col=3, col=4， col=3。而且同一列同一行的节点有多个，不止两个。所以<strong>将row_id也加入到queue节点中，row_id也加入到map中，最后遍历结果时，将同一row_id节点排序</strong>  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">col_to_node_list = collections.defaultdict(list)</span><br><span class="line">min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">queue = collections.deque([(root, <span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node, row_id, col_id = queue.popleft()</span><br><span class="line">col_to_node_list[col_id].append((node.val, row_id))</span><br><span class="line">min_col, max_col = min(min_col, col_id), max(max_col, col_id)</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">queue.append((node.left, row_id + <span class="number">1</span>, col_id - <span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">queue.append((node.right, row_id + <span class="number">1</span>, col_id + <span class="number">1</span>))</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">last_row_id, same_row, same_col = <span class="number">-1</span>, [], []</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> col_to_node_list[i]:</span><br><span class="line"><span class="keyword">if</span> last_row_id == pair[<span class="number">1</span>]:</span><br><span class="line">same_row.append(pair[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">same_col += sorted(same_row)</span><br><span class="line">same_row = [pair[<span class="number">0</span>]]</span><br><span class="line">last_row_id = pair[<span class="number">1</span>]</span><br><span class="line">same_col += sorted(same_row)</span><br><span class="line">res.append(same_col)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，稍大于O(n), 因为同一列同一行节点要排序    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/s
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 453 Minimum Moves to Equal Array Elements</title>
    <link href="https://shineboy2013.github.com/2021/12/26/lee-453/"/>
    <id>https://shineboy2013.github.com/2021/12/26/lee-453/</id>
    <published>2021-12-27T07:26:35.925Z</published>
    <updated>2021-12-27T08:12:24.426Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.<br><br>In one move, you can increment <code>n - 1</code> elements of the array by <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Only three moves are needed (remember each move increments two elements):<br>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,1,1]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></em>   The answer is guaranteed to fit in a <strong>32-bit</strong> integer.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最小移动步数使得数组所有数相等。每次移动是将n-1个元素加1</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最小值考虑用DP。但比较难写递归式，以[1, 2, 3]为例，值为3，现在是[1, 2, 3, 6]，由于dp[3]的最终状态为[4, 4, 4], 而最终状态加上新元素为[4, 4, 4, 9], 由6变成9是因为dp[3] = 3，表示移动了3步，新元素6，移动的3步全部参与了，所以变成9<br>由[4, 4, 4, 9], 4变9，需要5步，所以结果dp[4] = dp[3] + 5 = 8  </p><p>公式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + (nums[i] + dp[i] - equal_num)  </span><br><span class="line">equal_num = nums[i] + dp[i]</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组要排序  </li><li>equal_num初始值为nums[0]    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line">dp, equal_num = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">new_val = n + dp</span><br><span class="line">dp = dp + (n + dp - equal_num) <span class="comment"># 2</span></span><br><span class="line">equal_num = new_val <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-moves-to-equal-array-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 926 Flip String to Monotone Increasing</title>
    <link href="https://shineboy2013.github.com/2021/12/26/lee-926/"/>
    <id>https://shineboy2013.github.com/2021/12/26/lee-926/</id>
    <published>2021-12-27T06:17:44.346Z</published>
    <updated>2021-12-27T06:43:58.192Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A binary string is monotone increasing if it consists of some number of <code>0</code>‘s (possibly none), followed by some number of <code>1</code>‘s (also possibly none).<br><br>You are given a binary string <code>s</code>. You can flip <code>s[i]</code> changing it from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.<br><br>Return <em>the minimum number of flips to make</em> <code>s</code> <em>monotone increasing</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “00110”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> We flip the last digit to get 00111.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “010110”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We flip to get 011111, or alternatively 000111.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “00011000”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> We flip to get 00000000.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>01字符串中Flip其中一些将它变成00111,0和1的个数是任意。  </p><h3 id="DP解题思路-推荐-："><a href="#DP解题思路-推荐-：" class="headerlink" title="DP解题思路(推荐)："></a><strong>DP解题思路(推荐)：</strong></h3><p>求最小值考虑用BFS或者DP。BFS的复杂度可能比较大，DP定义为以s[i]为结尾的最小flip数，但由于不知道具体排列(末状态)是什么或者结尾是什么，所以比较难从子问题推导出来。<br>不妨用两个dp来计算，<br>dp为以0为结尾的最小flip数<br>dp2为以1为结尾的最小flip数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = dp     if s[i] = &apos;0&apos;</span><br><span class="line">   = dp + 1 if s[i] = &apos;1&apos;</span><br><span class="line">   </span><br><span class="line">dp2 = min(dp2 + 1, dp + 1)     if s[i] = &apos;0&apos;</span><br><span class="line">    = min(dp2, dp)             if s[i] = &apos;1&apos;</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Python的dp和dp2同时由前状态赋值，这样避免用临时变量     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">dp, dp2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">dp, dp2 = dp, min(dp, dp2) + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp, dp2 = dp + <span class="number">1</span>, min(dp2, dp)</span><br><span class="line"><span class="keyword">return</span> min(dp, dp2)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p><hr><h3 id="presum算法II解题思路："><a href="#presum算法II解题思路：" class="headerlink" title="presum算法II解题思路："></a><strong>presum算法II解题思路：</strong></h3><p>统计1的个数，若是0同时统计从0 flip到1的个数，取两者较小为新flip数。较难理解，不推荐    </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">ones, flips = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'1'</span>:</span><br><span class="line">ones += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">flips += <span class="number">1</span></span><br><span class="line">flips = min(ones, flips)</span><br><span class="line"><span class="keyword">return</span> flips</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flip-string-to-monotone-increasing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 828 Count Unique Characters of All Substrings of a Given String</title>
    <link href="https://shineboy2013.github.com/2021/12/26/lee-828/"/>
    <id>https://shineboy2013.github.com/2021/12/26/lee-828/</id>
    <published>2021-12-27T03:47:53.235Z</published>
    <updated>2021-12-27T04:48:52.041Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Let’s define a function <code>countUniqueChars(s)</code> that returns the number of unique characters on <code>s</code>.<br><br><em>   For example if <code>s = &quot;LEETCODE&quot;</code> then <code>&quot;L&quot;</code>, <code>&quot;T&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;O&quot;</code>, <code>&quot;D&quot;</code> are the unique characters since they appear only once in <code>s</code>, therefore <code>countUniqueChars(s) = 5</code>.<br><br>Given a string <code>s</code>, return the sum of <code>countUniqueChars(t)</code> where <code>t</code> is a substring of s.<br><br>Notice that some substrings can be repeated so in this case you have to count the repeated ones too.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ABC”<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> All possible substrings are: “A”,”B”,”C”,”AB”,”BC” and “ABC”.<br>Evey substring is composed with only unique letters.<br>Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ABA”<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> The same as example 1, except <code>countUniqueChars</code>(“ABA”) = 1.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “LEETCODE”<br><strong>Output:</strong> 92<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length &lt;= 10</code><sup>5</sup><br>*   <code>s</code> consists of uppercase English letters only.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子串的唯一字符的个数的总和</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是所有子串O(n^2)，统计唯一字符个数O(n), 复杂度为O(n^3). 尝试优化统计那一步，用presum map来详见可以O(1)求得，但内存过大，仍然TLE。<br>求个个数且是字符串题，考虑用DP。此题还有点似Leetcode 003 Longest Substring Without Repeating Characters。  </p><p>写几个找规律且从简单开始，也就是没有重复<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A: 1</span><br><span class="line">AB: 1                + 2 + 1 = 4, 1是dp[1], 2是以B结尾的2个子串有两个B，最后一个1表示AB串中有一个A  </span><br><span class="line">       B</span><br><span class="line">      AB        </span><br><span class="line">ABC： 4           + 3 + 2 + 1 = 10， 4是dp[2], 2是以C结尾的3个子串有三个C，2个B，1个A. Delta = 6  </span><br><span class="line">        C</span><br><span class="line">       BC</span><br><span class="line">      ABC  </span><br><span class="line">ABCB:10      + 2 + 3 + 0 + 1 = 16, 同理是上一个DP结果和从后往前每个字母在新子串中的唯一数。由于出现重复，B从4个变成2个，前一个B变成0个，其他加法项是不变的。Delta = 6 + 4 - 2 x 2 = 6 公式为Delta = Delta + 当前长度 - (i - 上一个重复元素下标) x 2    </span><br><span class="line">         B</span><br><span class="line">        CB</span><br><span class="line">       BCB</span><br><span class="line">      ABCB  </span><br><span class="line">ABCBA:16 + 4 + 2 + 3 + 0 + 0 = 25 = 16 + delta 验证公式delta = 6 + 5 - 1 x 2 = 9    </span><br><span class="line">          A </span><br><span class="line">         BA</span><br><span class="line">        CBA</span><br><span class="line">       BCBA</span><br><span class="line">      ABCBA </span><br><span class="line">ABCBAC:25 + 3 + 4 + 2 + 0 + 0 + 0 = 34 = 25 + delta 验证公式delta = 9 + 6 - (6 - 3) x 2 = 9    </span><br><span class="line">           C </span><br><span class="line">          AC </span><br><span class="line">         BAC</span><br><span class="line">        CBAC</span><br><span class="line">       BCBAC</span><br><span class="line">      ABCBAC </span><br><span class="line">ABCBACA:34 + 2 + 3 + 0 + 2 + 0 + 0 + 0 = 41 = 34 + delta 验证公式delta = 9 + 7 - (7 - 2) x 2 = 6不匹配，新A本来是7个变成2个，而次新A上一轮有4个最多减4个并不能减5个，所以x 2是不对的。      </span><br><span class="line">            A </span><br><span class="line">           CA </span><br><span class="line">          ACA </span><br><span class="line">         BACA</span><br><span class="line">        CBACA</span><br><span class="line">       BCBACA</span><br><span class="line">      ABCBACA</span><br></pre></td></tr></table></figure></p><p>公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Delta = Delta + 当前长度 - (i - 上一个重复元素下标) - 上个重复元素对应的加法项delta[j]</span><br><span class="line">Res += Delta</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>delta_sum为上一轮的增加的唯一元素个数<br>delta[i]为下标为i的元素的唯一个数的增量  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>公式中减去重复个数不能乘以2，因为上一个重复元素的增量可能不够减     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">res, delta_sum, delta, char_to_index = <span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>] * len(s), collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">cur_len = i + <span class="number">1</span></span><br><span class="line">delta[i] = cur_len</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> char_to_index:</span><br><span class="line">delta[i] -= char_to_index[s[i]] + <span class="number">1</span></span><br><span class="line">delta_sum += delta[i] - delta[char_to_index[s[i]]]</span><br><span class="line">delta[char_to_index[s[i]]] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">delta_sum += delta[i]</span><br><span class="line">res += delta_sum</span><br><span class="line">char_to_index[s[i]] = i</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="两个Map算法II解题思路-推荐-："><a href="#两个Map算法II解题思路-推荐-：" class="headerlink" title="两个Map算法II解题思路(推荐)："></a><strong>两个Map算法II解题思路(推荐)：</strong></h3><p>公式中上个重复元素对应的加法项也就是上个重复元素与上上个重复元素的距离，所以引入另一个map来记录，避免用delta[i]，算法更加简单。  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">last_last_char_to_index = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">-1</span>)</span><br><span class="line">res, delta = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">delta += i - last_char_to_index[c] - (last_char_to_index[c] - last_last_char_to_index[c])</span><br><span class="line">last_last_char_to_index[c] = last_char_to_index[c]</span><br><span class="line">last_char_to_index[c] = i</span><br><span class="line">res += delta</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
