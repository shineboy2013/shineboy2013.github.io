<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-03-02T07:00:09.665Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 772 Basic Calculator III</title>
    <link href="https://shineboy2013.github.com/2022/03/01/leetcode-772-basic-calculator-iii/"/>
    <id>https://shineboy2013.github.com/2022/03/01/leetcode-772-basic-calculator-iii/</id>
    <published>2022-03-02T06:31:18.494Z</published>
    <updated>2022-03-02T07:00:09.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement a basic calculator to evaluate a simple expression string.<br><br>The expression string contains only non-negative integers, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code> operators, and open <code>&#39;(&#39;</code> and closing parentheses <code>&#39;)&#39;</code>. The integer division should <strong>truncate toward zero</strong>.<br><br>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>.<br><br><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “1+1”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “6-4/2”<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “2<em>(5+5</em>2)/3+(6/2+8)”<br><strong>Output:</strong> 21<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.<br><em>   <code>s</code> is a <em>*valid</em></em> expression.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除且有括号。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 227求加减乘除，这里多了括号，括号内含加减乘除，所以每对括号是一轮DFS。遇到左括号，就进入递归，遇到右括号就返回递归值</p><p><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a> 括号加减法, 同一层括号内求和遇括号入栈<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a> 加减乘除, 和的每一项入栈，方便出栈计乘除<br>[LeetCode 772 Basic Calculator III] 加减乘除括号, L227的递归版</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不同于L227, 类似于填位法将i作为DFS参数传入，返回括号内的值以及i。i放入while循环， i += 1要加入到空格情况和循环最后</li><li>最后位加入加号要移除DFS中，放入主函数</li><li><strong>注意处理括号情况的顺序，左括号在空格后，右括号在最后</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">s += <span class="string">'+'</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, i)</span>:</span></span><br><span class="line">res, num, stack, op = <span class="number">0</span>, <span class="number">0</span>, [], <span class="string">'+'</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">char = s[i]</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">num, i = self.dfs(s, i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span> char.isdigit():</span><br><span class="line">num = num * <span class="number">10</span> + int(char)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">stack.append(-num)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">stack.append(num) <span class="comment"># [4+2*1]</span></span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">prev = stack.pop()</span><br><span class="line">stack.append(prev * num)</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">prev = stack.pop()</span><br><span class="line">stack.append(int(prev / num))  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">op = char</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">return</span> sum(stack), i</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 432 All O one Data Structure</title>
    <link href="https://shineboy2013.github.com/2022/02/24/leetcode-432-all-oone-data-structure/"/>
    <id>https://shineboy2013.github.com/2022/02/24/leetcode-432-all-oone-data-structure/</id>
    <published>2022-02-24T09:36:23.632Z</published>
    <updated>2022-02-24T09:54:39.638Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Design a data structure to store the strings’ count with the ability to return the strings with minimum and maximum counts.<br><br>Implement the <code>AllOne</code> class:<br><br><em>   <code>AllOne()</code> Initializes the object of the data structure.</em>   <code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.<br><em>   <code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</em>   <code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><em>   <code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“AllOne”, “inc”, “inc”, “getMaxKey”, “getMinKey”, “inc”, “getMaxKey”, “getMinKey”]<br>[[], [“hello”], [“hello”], [], [], [“leet”], [], []]<br><strong>Output</strong><br>[null, null, null, “hello”, “hello”, null, “hello”, “leet”]<br><br><strong>Explanation</strong><br>AllOne allOne = new AllOne();<br>allOne.inc(“hello”);<br>allOne.inc(“hello”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “hello”<br>allOne.inc(“leet”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “leet”<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= key.length &lt;= 10</code><br><em>   <code>key</code> consists of lowercase English letters.</em>   It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.<br><em>   At most `5 </em> 10<sup>4</sup><code>calls will be made to</code>inc<code>,</code>dec<code>,</code>getMaxKey<code>, and</code>getMinKey`.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构，使其支持增加或减少一个单词的频数，最大或最小单词的频数。注意最小频数不能为0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这个频数有点似LRU的分层思路，加入self.max_freq, 其他操作都可以实现，但是dec操作不能达到O(1), 因为若某个最小频数单词从1变成0，需要检索频率到下一个有节点的层。<br>改进就是要将频率的的值连起来，所以参考LRU，map的key是频率，value是node，node中含有freq，形成一个环。而node含有该频率对应的单词set，inc/dec就是将单词移动另一个node中</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>与LRU区别: map的key是频率，node含有频率和单词set，数据结构加入key_to_count。LL是从最大频率到最小频率</li><li>inc操作将节点从原频率node移到下一个频率node，若新node不存在，调用append_before. 然后从原频率node的单词set中删除该单词，若set为空，删除此node以及map中的entry</li><li>dec与inc类似，但要注意频率变成0的情况：不移到新的node，且从key_to_count中删除该单词</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.freq_to_node = &#123;&#125;</span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line">        self.key_to_count = collections.defaultdict(int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.tail</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">            self.freq_to_node[count] = self.append_before(old_node)</span><br><span class="line">        new_node = self.freq_to_node[count]</span><br><span class="line">        new_node.key_set.add(key)</span><br><span class="line">        self.key_to_count[key] = count</span><br><span class="line"></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.head</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">                self.freq_to_node[count] = self.append_after(old_node)</span><br><span class="line">            new_node = self.freq_to_node[count]</span><br><span class="line">            new_node.key_set.add(key)</span><br><span class="line">            self.key_to_count[key] = count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.key_to_count.pop(key)</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.tail <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.head <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_before</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq + <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node.prev, node</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_after</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq - <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node, node.next</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, freq=<span class="number">0</span>, next=None, prev=None)</span>:</span></span><br><span class="line">        self.key_set = set()</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/all-oone-data-structure/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2034 Stock Price Fluctuation</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-2034-stock-price-fluctuation/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-2034-stock-price-fluctuation/</id>
    <published>2022-02-17T04:00:04.962Z</published>
    <updated>2022-02-17T04:05:06.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/stock-price-fluctuation/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a stream of <strong>records</strong> about a particular stock. Each record contains a <strong>timestamp</strong> and the corresponding <strong>price</strong> of the stock at that timestamp.<br><br>Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream <strong>correcting</strong> the price of the previous wrong record.<br><br>Design an algorithm that:<br><br><em>   <strong>Updates</strong> the price of the stock at a particular timestamp, <strong>correcting</strong> the price from any previous records at the timestamp.</em>   Finds the <strong>latest price</strong> of the stock based on the current records. The <strong>latest price</strong> is the price at the latest timestamp recorded.<br><em>   Finds the <strong>maximum price</strong> the stock has been based on the current records.</em>   Finds the <strong>minimum price</strong> the stock has been based on the current records.<br><br>Implement the <code>StockPrice</code> class:<br><br><em>   <code>StockPrice()</code> Initializes the object with no price records.</em>   <code>void update(int timestamp, int price)</code> Updates the <code>price</code> of the stock at the given <code>timestamp</code>.<br><em>   <code>int current()</code> Returns the <strong>latest price</strong> of the stock.</em>   <code>int maximum()</code> Returns the <strong>maximum price</strong> of the stock.<br><em>   <code>int minimum()</code> Returns the <strong>minimum price</strong> of the stock.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“StockPrice”, “update”, “update”, “current”, “maximum”, “update”, “maximum”, “update”, “minimum”]<br>[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]<br><strong>Output</strong><br>[null, null, null, 5, 10, null, 5, null, 2]<br><br><strong>Explanation</strong><br>StockPrice stockPrice = new StockPrice();<br>stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].<br>stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].<br>stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.<br>stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.<br>stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.<br>                          // Timestamps are [1,2] with corresponding prices [3,5].<br>stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.<br>stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].<br>stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= timestamp, price &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made <strong>in total</strong> to <code>update</code>, <code>current</code>, <code>maximum</code>, and <code>minimum</code>.</em>   <code>current</code>, <code>maximum</code>, and <code>minimum</code> will be called <strong>only after</strong> <code>update</code> has been called <strong>at least once</strong>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现一个关于股票的数据结构，可以更新时间点对应的股价，最大最小值，最新价格</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最大最小值容易想到用heap，但heap不支持更新，难点是怎么支持更新股价。<br>仍然(price, timestamp)加入到heap中，在出堆时验证</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>验证堆顶： 若股价和时间不匹配(用time_to_price验证)，表示这是stale股价，不断去掉，直到验证成功为止，最后加入到堆中</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.time_to_price = &#123;&#125;</span><br><span class="line">        self.cur_time = <span class="number">0</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, timestamp: int, price: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.time_to_price[timestamp] = price</span><br><span class="line">        self.cur_time = max(self.cur_time, timestamp)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        heapq.heappush(self.max_heap, (-price, timestamp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.time_to_price[self.cur_time]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        <span class="keyword">while</span> -price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.max_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> -price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        <span class="keyword">while</span> price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> price</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>update时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/stock-price-fluctuation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2128 Remove All Ones With Row and Column Flips</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/</id>
    <published>2022-02-17T03:23:00.458Z</published>
    <updated>2022-02-17T03:26:03.012Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> binary matrix <code>grid</code>.<br><br>In one operation, you can choose <strong>any</strong> row or column and flip each value in that row or column (i.e., changing all <code>0</code>‘s to <code>1</code>‘s, and all <code>1</code>‘s to <code>0</code>‘s).<br><br>Return <code>true</code> <em>if it is possible to remove all</em> <code>1</code><em>‘s from</em> <code>grid</code> using <strong>any</strong> number of operations or <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103191300-1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way to remove all 1’s from grid is to:<br>- Flip the middle row<br>- Flip the middle column<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181204-7.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,0],[0,0,0],[0,0,0]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> It is impossible to remove all 1’s from grid.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181224-8.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are no 1’s in grid.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code></em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个矩阵，每次可以flip一行或一列，求是否可以令矩阵变成全0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从例子找规律，<br>010和010属于一种类型<br>010和101也是同一种，每一行必须符合任何一种类型才是解</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">row_patten, row_pattern_invert = grid[<span class="number">0</span>], [<span class="number">1</span> - n <span class="keyword">for</span> n <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line"><span class="keyword">if</span> grid[i] != row_patten <span class="keyword">and</span> grid[i] != row_pattern_invert:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/s
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 843 Guess the Word</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-843-guess-the-word/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-843-guess-the-word/</id>
    <published>2022-02-17T02:54:15.165Z</published>
    <updated>2022-02-17T03:04:48.287Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>This is an <strong><em>interactive problem</em></strong>.<br><br>You are given an array of <strong>unique</strong> strings <code>wordlist</code> where <code>wordlist[i]</code> is <code>6</code> letters long, and one word in this list is chosen as <code>secret</code>.<br><br>You may call <code>Master.guess(word)</code> to guess a word. The guessed word should have type <code>string</code> and must be from the original list with <code>6</code> lowercase letters.<br><br>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <code>secret</code> word. Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.<br><br>For each test case, you have exactly <code>10</code> guesses to guess the word. At the end of any number of calls, if you have made <code>10</code> or fewer calls to <code>Master.guess</code> and at least one of these guesses was <code>secret</code>, then you pass the test case.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br><strong>Explanation:</strong><br>master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>We made 5 calls to master.guess and one of them was the secret, so we pass the test case.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> secret = “hamada”, wordlist = [“hamada”,”khaled”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= wordlist.length &lt;= 100</code></em>   <code>wordlist[i].length == 6</code><br><em>   <code>wordlist[i]</code> consist of lowercase English letters.</em>   All the strings of <code>wordlist</code> are <strong>unique</strong>.<br><em>   <code>secret</code> exists in <code>wordlist</code>.</em>   <code>numguesses == 10</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定单词列表，每个单词长度为6， 其中一个为答案，每次猜一个单词。给一个API会告诉你猜的单词有多少位命中(位置,数值), 求是否可以10次内猜对</p><h3 id="暴力法解题思路："><a href="#暴力法解题思路：" class="headerlink" title="暴力法解题思路："></a><strong>暴力法解题思路：</strong></h3><p>较直观的解法是抽第一个单词出来，然后call API, 然后再filter wordlist使得新的单词列表里的单词的命中位数也是一样的。每轮缩少范围。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord2</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">guess = wordlist[<span class="number">0</span>]</span><br><span class="line">res = master.guess(guess)</span><br><span class="line">wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line"><span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="统计频率算法II解题思路-推荐-："><a href="#统计频率算法II解题思路-推荐-：" class="headerlink" title="统计频率算法II解题思路(推荐)："></a><strong>统计频率算法II解题思路(推荐)：</strong></h3><p>上述方法跟单词个数有关，如果很多的话，就会超过10次。考虑单词长度为6，而可以猜10次。考虑用26字母存储法，也就是统计频率。统计每位的频率，然后将频率作为这一位的分数，求每个单词的总分。<br>一定要选择单词列表中的某个单词去猜，如果不在列表中返回为-1，这个信息没有任何作用。<br>选择总分最高的去猜，原理是它最具代表性，这样可以快速排除很多单词，有点类似于二分法。反之，若用频率低的单词，也就只能排除一个单词。</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">char_to_count = [collections.Counter(w[i] <span class="keyword">for</span> w <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">guess = max(wordlist, key=<span class="keyword">lambda</span> w: sum(char_to_count[i][char] <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(w)))</span><br><span class="line">res = master.guess(guess)</span><br><span class="line">wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line"><span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/guess-the-word/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Thi
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
      <category term="Interactive" scheme="https://shineboy2013.github.com/tags/Interactive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 833 Find And Replace in String</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-833-find-and-replace-in-string/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-833-find-and-replace-in-string/</id>
    <published>2022-02-16T23:28:45.137Z</published>
    <updated>2022-02-16T23:35:08.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> string <code>s</code> that you must perform <code>k</code> replacement operations on. The replacement operations are given as three <strong>0-indexed</strong> parallel arrays, <code>indices</code>, <code>sources</code>, and <code>targets</code>, all of length <code>k</code>.<br><br>To complete the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> replacement operation:<br><br>1.  Check if the <strong>substring</strong> <code>sources[i]</code> occurs at index <code>indices[i]</code> in the <strong>original string</strong> <code>s</code>.<br>2.  If it does not occur, <strong>do nothing</strong>.<br>3.  Otherwise if it does occur, <strong>replace</strong> that substring with <code>targets[i]</code>.<br><br>For example, if <code>s = &quot;&lt;u&gt;ab&lt;/u&gt;cd&quot;</code>, <code>indices[i] = 0</code>, <code>sources[i] = &quot;ab&quot;</code>, and <code>targets[i] = &quot;eee&quot;</code>, then the result of this replacement will be <code>&quot;&lt;u&gt;eee&lt;/u&gt;cd&quot;</code>.<br><br>All replacement operations must occur <strong>simultaneously</strong>, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will <strong>not overlap</strong>.<br><br><em>   For example, a testcase with <code>s = &quot;abc&quot;</code>, <code>indices = [0, 1]</code>, and <code>sources = [&quot;ab&quot;,&quot;bc&quot;]</code> will not be generated because the <code>&quot;ab&quot;</code> and <code>&quot;bc&quot;</code> replacements overlap.<br><br>Return <em>the <strong>resulting string</strong> after performing all replacement operations on</em> <code>s</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters in a string.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“a”, “cd”], targets = [“eee”, “ffff”]<br><strong>Output:</strong> “eeebffff”<br><strong>Explanation:</strong><br>“a” occurs at index 0 in s, so we replace it with “eee”.<br>“cd” occurs at index 2 in s, so we replace it with “ffff”.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“ab”,”ec”], targets = [“eee”,”ffff”]<br><strong>Output:</strong> “eeecd”<br><strong>Explanation:</strong><br>“ab” occurs at index 0 in s, so we replace it with “eee”.<br>“ec” does not occur at index 2 in s, so we do nothing.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length &lt;= 1000</code><br><em>   <code>k == indices.length == sources.length == targets.length</code></em>   <code>1 &lt;= k &lt;= 100</code><br><em>   <code>0 &lt;= indexes[i] &lt; s.length</code></em>   <code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code><br><em>   <code>s</code> consists of only lowercase English letters.</em>   <code>sources[i]</code> and <code>targets[i]</code> consist of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>整洁题。找到位置，然后验证，最后替换</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>i是循环外的变量，所以poplate index_dict注意不能重名</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, s: str, indices: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">index_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _i, _n <span class="keyword">in</span> enumerate(indices):</span><br><span class="line">index_dict[_n] = _i <span class="comment"># 0 -&gt; 0, 2 -&gt; 1</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(s):</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> index_dict <span class="keyword">and</span> s[i:i + len(sources[index_dict[i]])] == sources[index_dict[i]]:</span><br><span class="line">res += targets[index_dict[i]]</span><br><span class="line">i += len(sources[index_dict[i]])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += s[i]</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-and-replace-in-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2007 Find Original Array From Doubled Array</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/</id>
    <published>2022-02-16T20:54:39.600Z</published>
    <updated>2022-02-16T20:59:32.115Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-original-array-from-doubled-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>An integer array <code>original</code> is transformed into a <strong>doubled</strong> array <code>changed</code> by appending <strong>twice the value</strong> of every element in <code>original</code>, and then randomly <strong>shuffling</strong> the resulting array.<br><br>Given an array <code>changed</code>, return <code>original</code> <em>if</em> <code>changed</code> <em>is a <strong>doubled</strong> array. If</em> <code>changed</code> <em>is not a <strong>doubled</strong> array, return an empty array. The elements in</em> <code>original</code> <em>may be returned in <strong>any</strong> order</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> changed = [1,3,4,2,6,8]<br><strong>Output:</strong> [1,3,4]<br><strong>Explanation:</strong> One possible original array could be [1,3,4]:<br>- Twice the value of 1 is 1 <em> 2 = 2.<br>- Twice the value of 3 is 3 </em> 2 = 6.<br>- Twice the value of 4 is 4 <em> 2 = 8.<br>Other original arrays could be [4,3,1] or [3,1,4].<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> changed = [6,3,0,1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> changed = [1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Constraints:</strong>   <code>1 &lt;= changed.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= changed[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，求这个数组是否可以分成两部分，后一部分的每个元素是否前一部分某元素的两倍</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由最大值容易确定它的一半是否在数组中。所以排序后由大到小遍历。注意数组元素可能相等，所以不能用visited set来记录已用过的数，val_to_index也不支持重复，只有val_to_count支持</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用val_to_count，注意遍历时候就要减去，不要进入if才减去</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOriginalArray</span><span class="params">(self, changed: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> len(changed) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">changed.sort()</span><br><span class="line">res = []</span><br><span class="line">val_to_count = collections.Counter(changed)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(changed))):</span><br><span class="line"><span class="keyword">if</span> val_to_count[changed[i]] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">val_to_count[changed[i]] -= <span class="number">1</span> <span class="comment"># not in  if statement</span></span><br><span class="line"><span class="keyword">if</span> changed[i] / <span class="number">2</span> <span class="keyword">in</span> val_to_count <span class="keyword">and</span> val_to_count[changed[i] / <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">val_to_count[changed[i] / <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">res.append(int(changed[i] / <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> [] <span class="keyword">if</span> len(res) * <span class="number">2</span> != len(changed) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-original-array-from-doubled-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stro
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1146 Snapshot Array</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1146-snapshot-array/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1146-snapshot-array/</id>
    <published>2022-02-16T19:20:59.715Z</published>
    <updated>2022-02-16T19:55:55.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/snapshot-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement a SnapshotArray that supports the following interface:<br><br><em>   <code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length.  <strong>Initially, each element equals 0</strong>.</em>   <code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.<br><em>   <code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.</em>   <code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> [“SnapshotArray”,”set”,”snap”,”set”,”get”]<br>[[3],[0,5],[],[0,6],[0,0]]<br><strong>Output:</strong> [null,null,0,null,5]<br><strong>Explanation:</strong><br>SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3<br>snapshotArr.set(0,5);  // Set array[0] = 5<br>snapshotArr.snap();  // Take a snapshot, return snap_id = 0<br>snapshotArr.set(0,6);<br>snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= length &lt;= 50000</code></em>   At most <code>50000</code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.<br><em>   <code>0 &lt;= index &lt; length</code></em>   <code>0 &lt;= snap_id &lt;</code>(the total number of times we call <code>snap()</code>)<br>*   <code>0 &lt;= val &lt;= 10^9</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个数据结构支持数组的快照</p><h3 id="Binary-Search解题思路-推荐-："><a href="#Binary-Search解题思路-推荐-：" class="headerlink" title="Binary Search解题思路(推荐)："></a><strong>Binary Search解题思路(推荐)：</strong></h3><p>暴力法是每次快照时候，将当时的数组的所有值存入dict中，key为(snap_id, index), value为数组值，得到MLE<br>后来考虑用二分法优化snap，将数值跟前值不同才存入历史记录，但得到TLE，应该是因为snap时间太长，因为要遍历整个数组<br>所以应该将存入历史这一步放在set中，每次值改变才存入历史记录，虽然一个snap_id可能会存入多值，大部分是不需要，因为同一个snap_id应该取最新值，但这样设计费了空间，省了时间。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>历史记录为3d数组，第一维为数组index, 第二维为所有历史记录，第三维为每一个记录为[snap_id, value]。由于数组初始值为0，所以初始历史记录为[-1, 0]</li><li>snap_id和题目要求的id差1，比如第一次call snap为0，但是之前的snap应该为-1</li><li>最容易错的在于二分法，要先将snap_id + 1，比如[-1, 0], [0, 5], [0, 6], [0, 2], [1, 1], [1, 4]…找snap_id = 0的值也就是要找最后的，所以先加1，找到[1, 1]再下标减1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">        self.snap_id = <span class="number">0</span></span><br><span class="line">        self.history = [[[<span class="number">-1</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.history[index].append([self.snap_id, val])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        self.snap_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.snap_id - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line">        last_snap_id = bisect.bisect(self.history[index], [snap_id + <span class="number">1</span>]) - <span class="number">1</span> <span class="comment"># remember snap + 1</span></span><br><span class="line">        <span class="keyword">return</span> self.history[index][last_snap_id][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>get时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>, 数组某值n更改次数  </p><hr><h3 id="暴力法算法II解题思路-不推荐-："><a href="#暴力法算法II解题思路-不推荐-：" class="headerlink" title="暴力法算法II解题思路(不推荐)："></a><strong>暴力法算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">self.ary = [<span class="number">0</span>] * length</span><br><span class="line">self.snap_id = <span class="number">-1</span></span><br><span class="line">self.idx_snap_to_val = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">self.ary[index] = val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">self.snap_id += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(self.ary):</span><br><span class="line">self.idx_snap_to_val[(i, self.snap_id)] = self.ary[i]</span><br><span class="line"><span class="keyword">return</span> self.snap_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.idx_snap_to_val[(index, snap_id)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/snapshot-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Imp
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1937 Maximum Number of Points with Cost</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1937-maximum-number-of-points-with-cost/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1937-maximum-number-of-points-with-cost/</id>
    <published>2022-02-16T18:08:59.144Z</published>
    <updated>2022-02-16T18:23:03.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-number-of-points-with-cost/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> integer matrix <code>points</code> (<strong>0-indexed</strong>). Starting with <code>0</code> points, you want to <strong>maximize</strong> the number of points you can get from the matrix.<br><br>To gain points, you must pick one cell in <strong>each row</strong>. Picking the cell at coordinates <code>(r, c)</code> will <strong>add</strong> <code>points[r][c]</code> to your score.<br><br>However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows <code>r</code> and <code>r + 1</code> (where <code>0 &lt;= r &lt; m - 1</code>), picking cells at coordinates <code>(r, c&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(r + 1, c&lt;sub&gt;2&lt;/sub&gt;)</code> will <strong>subtract</strong> <code>abs(c&lt;sub&gt;1&lt;/sub&gt; - c&lt;sub&gt;2&lt;/sub&gt;)</code> from your score.<br><br>Return <em>the <strong>maximum</strong> number of points you can achieve</em>.<br><br><code>abs(x)</code> is defined as:<br><br><em>   <code>x</code> for <code>x &gt;= 0</code>.</em>   <code>-x</code> for <code>x &lt; 0</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,2,3],[1,5,1],[3,1,1]]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).<br>You add 3 + 5 + 3 = 11 to your score.<br>However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.<br>Your final score is 11 - 2 = 9.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,5],[2,3],[4,2]]<br><strong>Output:</strong> 11<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).<br>You add 5 + 3 + 4 = 12 to your score.<br>However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.<br>Your final score is 12 - 1 = 11.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == points.length</code></em>   <code>n == points[r].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= points[r][c] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中含点数，每行取一个cell上的点数，但若两行之间的cell的列不同，要扣去列下标差，求最大点数</p><h3 id="优化DP解题思路-推荐-："><a href="#优化DP解题思路-推荐-：" class="headerlink" title="优化DP解题思路(推荐)："></a><strong>优化DP解题思路(推荐)：</strong></h3><p>求数值的最大值，容易想到用DP，dp[i][j]定义为每个cell的累计最大点数，递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][k] - abs(j - k)) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p><p>复杂度为n立方。</p><p>如果没有扣除的规则，其实就是找上一行的最大值，但要考虑下标，考虑怎么移除这个限制，若将上一个某个cell搬到跟目前列，就是dp[i - 1][k] - (j - k), 所以可以提前计算，<br>而且有绝对值，所以类似于LeetCode 042 Trapping Rain Water拆分为向左向右最大值：<br>left[i]是该行第i个cell，上一行在该列左边的cell的累计最大点数(已扣除)，同理<br>right[i]是该行第i个cell，上一行在该列右边的cell的累计最大点数(已扣除)</p><p>最后，上一行的最大值只能在左边或右边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(left[j], right[j]) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>left[j], right[j]的引入</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">m, n = len(points), len(points[<span class="number">0</span>])</span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">left[<span class="number">0</span>], right[<span class="number">-1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">left[j] = max(dp[i - <span class="number">1</span>][j], left[j - <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">right[j] = max(dp[i - <span class="number">1</span>][j], right[j + <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">dp[i][j] = points[i][j] + max(left[j], right[j])</span><br><span class="line"><span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><hr><h3 id="暴力DP算法II解题思路-不推荐-："><a href="#暴力DP算法II解题思路-不推荐-：" class="headerlink" title="暴力DP算法II解题思路(不推荐)："></a><strong>暴力DP算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints2</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points))]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][k] + points[i][j] - abs(j - k))</span><br><span class="line"><span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-number-of-points-with-cost/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1293 Shortest Path in a Grid with Obstacles Elimination</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1293-shortest-path-in-a-grid-with-obstacles-elimination/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1293-shortest-path-in-a-grid-with-obstacles-elimination/</id>
    <published>2022-02-16T09:26:58.956Z</published>
    <updated>2022-02-16T09:40:07.171Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.<br><br>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner</em> <code>(0, 0)</code> <em>to the lower right corner</em> <code>(m - 1, n - 1)</code> <em>given that you can eliminate <strong>at most</strong></em> <code>k</code> <em>obstacles</em>. If it is not possible to find such walk return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1<br><strong>Output:</strong> 6<br><strong>Explanation:</strong><br>The shortest path without eliminating any obstacle is 10.<br>The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 40</code></em>   <code>1 &lt;= k &lt;= m * n</code><br><em>   <code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</em>   <code>grid[0][0] == grid[m - 1][n - 1] == 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵从左上走到右下，但含障碍，现在可以移除k个，使得路径最短，求最短路径</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最短路径用BFS，但此题难点在于distance跟路径有关，比如某一格可能属于不同的路径，此时它的distance会不同，所以distance不能global，必须作为state传到下一个迭代<br>同样的情况也在visited中存在，visited跟路径相关，而这一格跟k相关，这一格可以被属于不同的k的路径访问，所以visited应该加入k</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>visited是(x, y, k), queue是(x, y, k, dis)</li><li>(x, y, k - 1)跟visited比较，而不是(x, y, k)。下一个节点的条件为eleminatios &gt;= 0</li><li>若k过多会LTE, 因为广度会过大。这是用曼哈顿距离来剪枝。左上到右下距离为m - n + 2这肯定是最短距离，若k大于等于这个数，也就是可以移除曼哈顿路径上的所有障碍。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, grid: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> k &gt;= m + n - <span class="number">2</span>: <span class="comment"># TLE</span></span><br><span class="line"><span class="keyword">return</span> m + n - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">queue = collections.deque([(<span class="number">0</span>, <span class="number">0</span>, k, <span class="number">0</span>)]) <span class="comment"># x, y, k, distance</span></span><br><span class="line">visited = set([(<span class="number">0</span>, <span class="number">0</span>, k)]) <span class="comment"># include k</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">_x, _y, _k, _dis = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> _x == m - <span class="number">1</span> <span class="keyword">and</span> _y == n - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> _dis</span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">x, y = _x + _dx, _y + _dy</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">eliminations = _k - <span class="number">1</span> <span class="keyword">if</span> grid[x][y] == <span class="number">1</span> <span class="keyword">else</span> _k</span><br><span class="line"><span class="keyword">if</span> (x, y, eliminations) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> eliminations &gt;= <span class="number">0</span>:</span><br><span class="line">queue.append((x, y, eliminations, _dis + <span class="number">1</span>))</span><br><span class="line">visited.add((x, y, eliminations))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmk)</code>，空间复杂度<code>O(mnk)</code>, 某个cell都可能被访问k次，因为最多有k条路径  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCo
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 670 Maximum Swap</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-670-maximum-swap/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-670-maximum-swap/</id>
    <published>2022-02-16T03:20:03.290Z</published>
    <updated>2022-02-16T03:39:03.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-swap/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer <code>num</code>. You can swap two digits at most once to get the maximum valued number.<br><br>Return <em>the maximum valued number you can get</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = 2736<br><strong>Output:</strong> 7236<br><strong>Explanation:</strong> Swap the number 2 and the number 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = 9973<br><strong>Output:</strong> 9973<br><strong>Explanation:</strong> No swap.<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>0 &lt;= num &lt;= 10&lt;sup&gt;8&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数，最多交换一位，使得这个数尽可能最大</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 854 K-Similar Strings, 如2736， 求2后面最大的数为7，和7交换即为所求。这里有两个问题：</p><ol><li>第一位可能已经是最大的数位，这样需要遍历每个数位，找到能交换的数位，若这个位在倒序排序后位置一样，表明此位不能交换。所以排序法的算法复杂度为n平方</li><li>若要优化就要采用bucket sort，因为数位是有限的。若后续数位有一个数比自己大，表示可交换。所以只要记录每个数位的位置，贪心法从9(最大)遍历到自己，若该位位置在自己之后，可交换</li><li>若不同数位上数值相同，应该记录其最后的位置，因为交换时候将小的尽量往后交换，越好越不重要，如2949, 2和最后的9交换得到最大的数</li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>内循环从9遍历到该位数值(不包括)</li><li>buckets的key为字符串，注意整数和字符串互换，如buckets[str(j)], int(digits[i])</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">digits, buckets = str(num), collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i, digit <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">buckets[digit] = i <span class="comment"># use last position for same char</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>, int(digits[i]), <span class="number">-1</span>): <span class="comment"># remember to use int(digits[i]) not i</span></span><br><span class="line"><span class="keyword">if</span> buckets[str(j)] &gt; i: <span class="comment"># 2736, i = (2), j = (7) # remember to use str j</span></span><br><span class="line"><span class="keyword">return</span> int(digits[:i] + digits[buckets[str(j)]] + digits[i + <span class="number">1</span>:buckets[str(j)]] + digits[i] + digits[buckets[str(j)] + <span class="number">1</span>:])</span><br><span class="line"><span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(9n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You a
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 567 Permutation in String</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-567-permutation-in-string/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-567-permutation-in-string/</id>
    <published>2022-02-16T01:57:13.034Z</published>
    <updated>2022-02-16T02:00:06.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> <em>if</em> <code>s2</code> <em>contains a permutation of</em> <code>s1</code><em>, or</em> <code>false</code> <em>otherwise</em>.<br><br>In other words, return <code>true</code> if one of <code>s1</code>‘s permutations is the substring of <code>s2</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidbaooo”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> s2 contains one permutation of s1 (“ba”).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidboaoo”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length, s2.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>s1</code> and <code>s2</code> consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s2中是否含s1的anagram</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 438 Find All Anagrams in a String, 唯一区别是substr_win == char_to_count_p时返回而不是加入到res</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count_p = collections.Counter(s1)</span><br><span class="line">substr_win = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s2):</span><br><span class="line">substr_win[s2[i]] += <span class="number">1</span></span><br><span class="line"><span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= len(s1):</span><br><span class="line">substr_win[s2[i - len(s1)]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> substr_win[s2[i - len(s1)]] == <span class="number">0</span>:</span><br><span class="line">substr_win.pop(s2[i - len(s1)])</span><br><span class="line"><span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/permutation-in-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 438 Find All Anagrams in a String</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/</id>
    <published>2022-02-16T01:52:25.222Z</published>
    <updated>2022-02-16T01:57:00.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of</em> <code>p</code><em>‘s anagrams in</em> <code>s</code>. You may return the answer in <strong>any order</strong>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “cbaebabacd”, p = “abc”<br><strong>Output:</strong> [0,6]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abab”, p = “ab”<br><strong>Output:</strong> [0,1,2]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, p.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>s<code>and</code>p` consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s中含p的anagram的所有初始下标</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求某子串的频率统计，第一时间想到滑动窗口。此题较特殊，属于固定大小窗口的滑动窗口，因为p的大小是固定的，窗口大小必须和p长度一样。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">char_to_count_p = collections.Counter(p)</span><br><span class="line">substr_win = collections.defaultdict(int)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">substr_win[s[i]] += <span class="number">1</span></span><br><span class="line"><span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= len(p):</span><br><span class="line">substr_win[s[i - len(p)]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> substr_win[s[i - len(p)]] == <span class="number">0</span>:</span><br><span class="line">substr_win.pop(s[i - len(p)])</span><br><span class="line"><span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line">res.append(i - len(p) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-all-anagrams-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Mock 001 Count changes for two N-trees</title>
    <link href="https://shineboy2013.github.com/2022/02/15/mock-001/"/>
    <id>https://shineboy2013.github.com/2022/02/15/mock-001/</id>
    <published>2022-02-15T21:10:39.391Z</published>
    <updated>2022-02-15T21:15:38.880Z</updated>
    
    <content type="html"><![CDATA[<p>A change for two N-children tree contains:</p><ol><li>key is different</li><li>value is different</li><li>delete a node</li><li>add a node</li></ol><p>Problem: how many changes to convert tree A to tree B</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>DD的面经题，多少个改动可以使得existingTree变成newTree</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS, 比较children，三种情况。若其中一方没有节点，就是计算节点数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较children，三种情况。若其中一方没有节点，就是计算节点数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeNodes</span><span class="params">(self, existingTree, newTree)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">and</span> <span class="keyword">not</span> newTree:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">or</span> <span class="keyword">not</span> newTree:</span><br><span class="line"><span class="keyword">return</span> self.count(existingTree) + self.count(newTree)</span><br><span class="line">res = <span class="number">0</span> <span class="keyword">if</span> existingTree.key == newTree.key <span class="keyword">and</span> existingTree.val == newTree.val <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">existing_children_dict = self.get_children_dict(existingTree.children)</span><br><span class="line">new_tree_children_dict = self.get_children_dict(newTree.children)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() &amp; new_tree_children_dict.keys(): <span class="comment"># in both</span></span><br><span class="line">res += self.changeNodes(existing_children_dict[key], new_tree_children_dict[key])</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() - new_tree_children_dict.keys(): <span class="comment"># in existing tree not in new tree</span></span><br><span class="line">res += self.count(existing_children_dict[key])</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> new_tree_children_dict.keys() - existing_children_dict.keys():  <span class="comment"># in new tree not in existing tree</span></span><br><span class="line">res += self.count(new_tree_children_dict[key])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">res += self.count(child)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_children_dict</span><span class="params">(self, children)</span>:</span></span><br><span class="line">key_to_node = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">key_to_node[child.key] = child</span><br><span class="line"><span class="keyword">return</span> key_to_node</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A change for two N-children tree contains:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;key is different&lt;/li&gt;
&lt;li&gt;value is different&lt;/li&gt;
&lt;li&gt;delete a node&lt;/li&gt;
&lt;li&gt;add 
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1166 Design File System</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/</id>
    <published>2022-02-15T18:13:22.294Z</published>
    <updated>2022-02-15T18:21:19.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are asked to design a file system that allows you to create new paths and associate them with different values.<br><br>The format of a path is one or more concatenated strings of the form: <code>/</code> followed by one or more lowercase English letters. For example, “<code>/leetcode&quot;</code> and “<code>/leetcode/problems&quot;</code> are valid paths while an empty string <code>&quot;&quot;</code> and <code>&quot;/&quot;</code> are not.<br><br>Implement the <code>FileSystem</code> class:<br><br><em>   <code>bool createPath(string path, int value)</code> Creates a new <code>path</code> and associates a <code>value</code> to it if possible and returns <code>true</code>. Returns <code>false</code> if the path <strong>already exists</strong> or its parent path <strong>doesn’t exist</strong>.</em>   <code>int get(string path)</code> Returns the value associated with <code>path</code> or returns <code>-1</code> if the path doesn’t exist.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”get”]<br>[[],[“/a”,1],[“/a”]]<br><strong>Output:</strong><br>[null,true,1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/a”, 1); // return true<br>fileSystem.get(“/a”); // return 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”createPath”,”get”,”createPath”,”get”]<br>[[],[“/leet”,1],[“/leet/code”,2],[“/leet/code”],[“/c/d”,1],[“/c”]]<br><strong>Output:</strong><br>[null,true,true,2,false,-1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/leet”, 1); // return true<br>fileSystem.createPath(“/leet/code”, 2); // return true<br>fileSystem.get(“/leet/code”); // return 2<br>fileSystem.createPath(“/c/d”, 1); // return false because the parent path “/c” doesn’t exist.<br>fileSystem.get(“/c”); // return -1 because this path doesn’t exist.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of calls to the two functions is less than or equal to <code>10&lt;sup&gt;4&lt;/sup&gt;</code> in total.</em>   <code>2 &lt;= path.length &lt;= 100</code><br>*   <code>1 &lt;= value &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统，支持创建路径，路径含key, value</p><h3 id="Trie解题思路："><a href="#Trie解题思路：" class="headerlink" title="Trie解题思路："></a><strong>Trie解题思路：</strong></h3><p>用Trie, is_end变成key, value</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>遍历用1开始，因为首个/前面是空字符串</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">if</span> i == len(segments) - <span class="number">1</span>: <span class="comment"># match all the previous segments</span></span><br><span class="line">                    it.children[segment] = TrieNode(segment)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">if</span> it.value != <span class="number">-1</span>: <span class="comment"># exists</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">return</span> it.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.value = <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="算法II-HashMap解题思路："><a href="#算法II-HashMap解题思路：" class="headerlink" title="算法II HashMap解题思路："></a><strong>算法II HashMap解题思路：</strong></h3><p>用前缀法</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem2</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.path_to_val = defaultdict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">"/"</span> <span class="keyword">or</span> len(path) == <span class="number">0</span> <span class="keyword">or</span> path <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search from the right</span></span><br><span class="line">        parent = path[:path.rfind(<span class="string">'/'</span>)]</span><br><span class="line">        <span class="keyword">if</span> len(parent) &gt; <span class="number">1</span> <span class="keyword">and</span> parent <span class="keyword">not</span> <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        self.path_to_val[path] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.path_to_val.get(path, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-file-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 839 Similar String Groups</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/</id>
    <published>2022-02-15T17:23:01.070Z</published>
    <updated>2022-02-15T17:28:06.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/similar-string-groups/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>. Also two strings <code>X</code> and <code>Y</code> are similar if they are equal.<br><br>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.<br><br>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.<br><br>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“tars”,”rats”,”arts”,”star”]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“omv”,”ovm”]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 300</code></em>   <code>1 &lt;= strs[i].length &lt;= 300</code><br><em>   <code>strs[i]</code> consists of lowercase letters only.</em>   All words in <code>strs</code> have the same length and are anagrams of each other.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>单词列表中，可以分成多少组，每组里面的单词互相之间至少有一对可以通过交换一个位置变成另一个单词</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>典型求连通集个数，类似于Num of island，用BFS。难点在于怎么找到neighbor，用遍历每一个单词的方式</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点在于怎么找到neighbor，用遍历每一个单词的方式，判断是否buddyStrings Leetcode 0859</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, strs: List[str])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">visited, groups, word_set = set(), <span class="number">0</span>, set(strs)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">self.bfs(word_set, s, visited)</span><br><span class="line">groups += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> groups</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word_set, start, visited)</span>:</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> word_set:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node == s <span class="keyword">or</span> <span class="keyword">not</span> self.buddyStrings(node, s):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(s)</span><br><span class="line">visited.add(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal):  <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/similar-string-groups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1347 Minimum Number of Steps to Make Two Strings Anagram</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/</id>
    <published>2022-02-15T16:48:02.381Z</published>
    <updated>2022-02-15T16:51:30.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.<br><br>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.<br><br>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bab”, t = “aba”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Replace the first ‘a’ in t with b, t = “bba” which is anagram of s.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, t = “practice”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Replace ‘p’, ‘r’, ‘a’, ‘i’ and ‘c’ from t with proper characters to make t anagram of s.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “mangaar”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “anagram” and “mangaar” are anagrams.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s.length == t.length<code>*</code>s<code>and</code>t` consist of lowercase English letters only.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过替换字母使得两字符为同位词Anagram</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计某一个词的词频，遍历另一个单词，减去词频，若不够减(小于0)，就加步数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count_t = collections.Counter(t)</span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> char_to_count_t <span class="keyword">and</span> char_to_count_t[char] &gt; <span class="number">0</span>:</span><br><span class="line">char_to_count_t[char] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">steps += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetC
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 854 K-Similar Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/</id>
    <published>2022-02-15T10:00:31.027Z</published>
    <updated>2022-02-15T10:07:52.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/k-similar-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Strings <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong> (for some non-negative integer <code>k</code>) if we can swap the positions of two letters in <code>s1</code> exactly <code>k</code> times so that the resulting string equals <code>s2</code>.<br><br>Given two anagrams <code>s1</code> and <code>s2</code>, return the smallest <code>k</code> for which <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “ba”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “abc”, s2 = “bca”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length &lt;= 20</code></em>   <code>s2.length == s1.length</code><br><em>   <code>s1</code> and <code>s2</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>.</em>   <code>s2</code> is an anagram of <code>s1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两字符，交换两个位置，使得他们相等，求最小交换次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值考虑用BFS，难点在于生成neighbor，见注意事项</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用例子写程序node = abc s2 = cba, 先找到第一个不同位i，然后找下一个不同位j，这个不同位node[j]需要与目标s2[i]相同，贪心法</li><li>倒数第二行要break，否则TLE，因为只要找到一位可以交换这一层的BFS算是结束</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque([s1])</span><br><span class="line">visited = set([s1])</span><br><span class="line">distance = &#123;s1: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == s2:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)): <span class="comment"># abc, cba</span></span><br><span class="line"><span class="keyword">if</span> node[i] == s2[i]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(node)):</span><br><span class="line"><span class="keyword">if</span> node[j] == s2[j]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node[j] == s2[i]:</span><br><span class="line">ss = node[:i] + node[j] + node[i + <span class="number">1</span>:j] + node[i] + node[j + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> ss <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(ss)</span><br><span class="line">visited.add(ss)</span><br><span class="line">distance[ss] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/k-similar-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Buddy Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/</id>
    <published>2022-02-15T09:35:36.737Z</published>
    <updated>2022-02-15T09:38:45.215Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/buddy-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> <em>if you can swap two letters in</em> <code>s</code> <em>so the result is equal to</em> <code>goal</code><em>, otherwise, return</em> <code>false</code><em>.</em><br><br>Swapping letters is defined as taking two indices <code>i</code> and <code>j</code> (0-indexed) such that <code>i != j</code> and swapping the characters at <code>s[i]</code> and <code>s[j]</code>.<br><br><em>   For example, swapping at indices <code>0</code> and <code>2</code> in <code>&quot;abcd&quot;</code> results in <code>&quot;cbad&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ba”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘b’ to get “ba”, which is equal to goal.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ab”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The only letters you can swap are s[0] = ‘a’ and s[1] = ‘b’, which results in “ba” != goal.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aa”, goal = “aa”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘a’ to get “aa”, which is equal to goal.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length, goal.length &lt;= 2 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> and <code>goal</code> consist of lowercase letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两字符串，交换一次使得他们相等</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况： 长度不等，完全相等（若至少有一个重复，即满足题意），两次不同</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种情况： 长度不等，完全相等，两次不同</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal): <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/buddy-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 351 Android Unlock Patterns</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/</id>
    <published>2022-02-14T03:49:42.062Z</published>
    <updated>2022-02-14T04:07:52.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/android-unlock-patterns" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Android devices have a special lock screen with a <code>3 x 3</code> grid of dots. Users can set an “unlock pattern” by connecting the dots in a specific sequence, forming a series of joined line segments where each segment’s endpoints are two consecutive dots in the sequence. A sequence of <code>k</code> dots is a <strong>valid</strong> unlock pattern if both of the following are true:<br><br><em>   All the dots in the sequence are <strong>distinct</strong>.</em>   If the line segment connecting two consecutive dots in the sequence passes through the <strong>center</strong> of any other dot, the other dot <strong>must have previously appeared</strong> in the sequence. No jumps through the center non-selected dots are allowed.<br>    <em>   For example, connecting dots <code>2</code> and <code>9</code> without dots <code>5</code> or <code>6</code> appearing beforehand is valid because the line from dot <code>2</code> to dot <code>9</code> does not pass through the center of either dot <code>5</code> or <code>6</code>.    </em>   However, connecting dots <code>1</code> and <code>3</code> without dot <code>2</code> appearing beforehand is invalid because the line from dot <code>1</code> to dot <code>3</code> passes through the center of dot <code>2</code>.<br><br>Here are some example valid and invalid unlock patterns:<br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png" alt=""><br><br><em>   The 1st pattern <code>[4,1,3,6]</code> is invalid because the line connecting dots <code>1</code> and <code>3</code> pass through dot <code>2</code>, but dot <code>2</code> did not previously appear in the sequence.</em>   The 2nd pattern <code>[4,1,9,2]</code> is invalid because the line connecting dots <code>1</code> and <code>9</code> pass through dot <code>5</code>, but dot <code>5</code> did not previously appear in the sequence.<br><em>   The 3rd pattern <code>[2,4,1,3,6]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>3</code> meets the condition because dot <code>2</code> previously appeared in the sequence.</em>   The 4th pattern <code>[6,5,4,1,9,2]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>9</code> meets the condition because dot <code>5</code> previously appeared in the sequence.<br><br>Given two integers <code>m</code> and <code>n</code>, return <em>the <strong>number of unique and valid unlock patterns</strong> of the Android grid lock screen that consist of <strong>at least</strong></em> <code>m</code> <em>keys and <strong>at most</strong></em> <code>n</code> <em>keys.</em><br><br>Two unlock patterns are considered <strong>unique</strong> if there is a dot in one sequence that is not in the other, or the order of the dots is different.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 1<br><strong>Output:</strong> 9<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 2<br><strong>Output:</strong> 65<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= m, n &lt;= 9</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>安卓开屏密码解锁种数。给定m, n是安卓的密码长度范围，求这个范围内的解码种数。1可以跳到2和4, 5, 6, 8(斜线没有通过其他数字)，但不能跳到3, 7, 9因为前提条件是这条线通过的数如2, 4, 5必须已经用过了。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题属于填位法，带条件的，条件在于map中，类似于LeetCode 248 Strobogrammatic Number III<br>难点是理解jump keys，有16种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skip[1][3] = skip[3][1] = 2;</span><br><span class="line">skip[1][7] = skip[7][1] = 4;</span><br><span class="line">skip[3][9] = skip[9][3] = 6;</span><br><span class="line">skip[7][9] = skip[9][7] = 8;</span><br><span class="line">skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>用DFS模板: def dfs(self, graph, start, visited, res), start = num</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 9有return，所以要去掉刚加入的visited的num</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JUMP_KEYS = &#123;(<span class="number">1</span>,<span class="number">3</span>):<span class="number">2</span>, (<span class="number">1</span>,<span class="number">7</span>):<span class="number">4</span>, (<span class="number">1</span>,<span class="number">9</span>):<span class="number">5</span>, (<span class="number">2</span>,<span class="number">8</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">7</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">1</span>):<span class="number">2</span>, (<span class="number">3</span>,<span class="number">9</span>):<span class="number">6</span>, (<span class="number">4</span>,<span class="number">6</span>):<span class="number">5</span>, (<span class="number">6</span>,<span class="number">4</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">1</span>):<span class="number">4</span>, (<span class="number">7</span>,<span class="number">3</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">9</span>):<span class="number">8</span>, (<span class="number">8</span>,<span class="number">2</span>):<span class="number">5</span>, (<span class="number">9</span>,<span class="number">7</span>):<span class="number">8</span>, (<span class="number">9</span>,<span class="number">3</span>):<span class="number">6</span>, (<span class="number">9</span>,<span class="number">1</span>):<span class="number">5</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, m, n, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited.add(num)</span><br><span class="line">        <span class="keyword">if</span> len(visited) == n:</span><br><span class="line">            visited.remove(num) <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) &gt;= m:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> next_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> (num, next_num) <span class="keyword">in</span> JUMP_KEYS <span class="keyword">and</span> JUMP_KEYS[(num, next_num)] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += self.dfs(next_num, m, n, visited)</span><br><span class="line">        visited.remove(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 因为最多是9乘以8乘以7…  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/android-unlock-patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
</feed>
