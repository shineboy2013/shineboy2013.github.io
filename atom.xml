<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-02-17T03:26:03.012Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 2128 Remove All Ones With Row and Column Flips</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/</id>
    <published>2022-02-17T03:23:00.458Z</published>
    <updated>2022-02-17T03:26:03.012Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> binary matrix <code>grid</code>.<br><br>In one operation, you can choose <strong>any</strong> row or column and flip each value in that row or column (i.e., changing all <code>0</code>‘s to <code>1</code>‘s, and all <code>1</code>‘s to <code>0</code>‘s).<br><br>Return <code>true</code> <em>if it is possible to remove all</em> <code>1</code><em>‘s from</em> <code>grid</code> using <strong>any</strong> number of operations or <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103191300-1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way to remove all 1’s from grid is to:<br>- Flip the middle row<br>- Flip the middle column<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181204-7.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,0],[0,0,0],[0,0,0]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> It is impossible to remove all 1’s from grid.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181224-8.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are no 1’s in grid.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code></em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个矩阵，每次可以flip一行或一列，求是否可以令矩阵变成全0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从例子找规律，<br>010和010属于一种类型<br>010和101也是同一种，每一行必须符合任何一种类型才是解</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">row_patten, row_pattern_invert = grid[<span class="number">0</span>], [<span class="number">1</span> - n <span class="keyword">for</span> n <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line"><span class="keyword">if</span> grid[i] != row_patten <span class="keyword">and</span> grid[i] != row_pattern_invert:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/s
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 843 Guess the Word</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-843-guess-the-word/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-843-guess-the-word/</id>
    <published>2022-02-17T02:54:15.165Z</published>
    <updated>2022-02-17T03:04:48.287Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>This is an <strong><em>interactive problem</em></strong>.<br><br>You are given an array of <strong>unique</strong> strings <code>wordlist</code> where <code>wordlist[i]</code> is <code>6</code> letters long, and one word in this list is chosen as <code>secret</code>.<br><br>You may call <code>Master.guess(word)</code> to guess a word. The guessed word should have type <code>string</code> and must be from the original list with <code>6</code> lowercase letters.<br><br>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <code>secret</code> word. Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.<br><br>For each test case, you have exactly <code>10</code> guesses to guess the word. At the end of any number of calls, if you have made <code>10</code> or fewer calls to <code>Master.guess</code> and at least one of these guesses was <code>secret</code>, then you pass the test case.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br><strong>Explanation:</strong><br>master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>We made 5 calls to master.guess and one of them was the secret, so we pass the test case.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> secret = “hamada”, wordlist = [“hamada”,”khaled”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= wordlist.length &lt;= 100</code></em>   <code>wordlist[i].length == 6</code><br><em>   <code>wordlist[i]</code> consist of lowercase English letters.</em>   All the strings of <code>wordlist</code> are <strong>unique</strong>.<br><em>   <code>secret</code> exists in <code>wordlist</code>.</em>   <code>numguesses == 10</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定单词列表，每个单词长度为6， 其中一个为答案，每次猜一个单词。给一个API会告诉你猜的单词有多少位命中(位置,数值), 求是否可以10次内猜对</p><h3 id="暴力法解题思路："><a href="#暴力法解题思路：" class="headerlink" title="暴力法解题思路："></a><strong>暴力法解题思路：</strong></h3><p>较直观的解法是抽第一个单词出来，然后call API, 然后再filter wordlist使得新的单词列表里的单词的命中位数也是一样的。每轮缩少范围。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord2</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">guess = wordlist[<span class="number">0</span>]</span><br><span class="line">res = master.guess(guess)</span><br><span class="line">wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line"><span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="统计频率算法II解题思路-推荐-："><a href="#统计频率算法II解题思路-推荐-：" class="headerlink" title="统计频率算法II解题思路(推荐)："></a><strong>统计频率算法II解题思路(推荐)：</strong></h3><p>上述方法跟单词个数有关，如果很多的话，就会超过10次。考虑单词长度为6，而可以猜10次。考虑用26字母存储法，也就是统计频率。统计每位的频率，然后将频率作为这一位的分数，求每个单词的总分。<br>一定要选择单词列表中的某个单词去猜，如果不在列表中返回为-1，这个信息没有任何作用。<br>选择总分最高的去猜，原理是它最具代表性，这样可以快速排除很多单词，有点类似于二分法。反之，若用频率低的单词，也就只能排除一个单词。</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">char_to_count = [collections.Counter(w[i] <span class="keyword">for</span> w <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">guess = max(wordlist, key=<span class="keyword">lambda</span> w: sum(char_to_count[i][char] <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(w)))</span><br><span class="line">res = master.guess(guess)</span><br><span class="line">wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line"><span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/guess-the-word/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Thi
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
      <category term="Interactive" scheme="https://shineboy2013.github.com/tags/Interactive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 833 Find And Replace in String</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-833-find-and-replace-in-string/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-833-find-and-replace-in-string/</id>
    <published>2022-02-16T23:28:45.137Z</published>
    <updated>2022-02-16T23:35:08.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> string <code>s</code> that you must perform <code>k</code> replacement operations on. The replacement operations are given as three <strong>0-indexed</strong> parallel arrays, <code>indices</code>, <code>sources</code>, and <code>targets</code>, all of length <code>k</code>.<br><br>To complete the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> replacement operation:<br><br>1.  Check if the <strong>substring</strong> <code>sources[i]</code> occurs at index <code>indices[i]</code> in the <strong>original string</strong> <code>s</code>.<br>2.  If it does not occur, <strong>do nothing</strong>.<br>3.  Otherwise if it does occur, <strong>replace</strong> that substring with <code>targets[i]</code>.<br><br>For example, if <code>s = &quot;&lt;u&gt;ab&lt;/u&gt;cd&quot;</code>, <code>indices[i] = 0</code>, <code>sources[i] = &quot;ab&quot;</code>, and <code>targets[i] = &quot;eee&quot;</code>, then the result of this replacement will be <code>&quot;&lt;u&gt;eee&lt;/u&gt;cd&quot;</code>.<br><br>All replacement operations must occur <strong>simultaneously</strong>, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will <strong>not overlap</strong>.<br><br><em>   For example, a testcase with <code>s = &quot;abc&quot;</code>, <code>indices = [0, 1]</code>, and <code>sources = [&quot;ab&quot;,&quot;bc&quot;]</code> will not be generated because the <code>&quot;ab&quot;</code> and <code>&quot;bc&quot;</code> replacements overlap.<br><br>Return <em>the <strong>resulting string</strong> after performing all replacement operations on</em> <code>s</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters in a string.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“a”, “cd”], targets = [“eee”, “ffff”]<br><strong>Output:</strong> “eeebffff”<br><strong>Explanation:</strong><br>“a” occurs at index 0 in s, so we replace it with “eee”.<br>“cd” occurs at index 2 in s, so we replace it with “ffff”.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“ab”,”ec”], targets = [“eee”,”ffff”]<br><strong>Output:</strong> “eeecd”<br><strong>Explanation:</strong><br>“ab” occurs at index 0 in s, so we replace it with “eee”.<br>“ec” does not occur at index 2 in s, so we do nothing.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length &lt;= 1000</code><br><em>   <code>k == indices.length == sources.length == targets.length</code></em>   <code>1 &lt;= k &lt;= 100</code><br><em>   <code>0 &lt;= indexes[i] &lt; s.length</code></em>   <code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code><br><em>   <code>s</code> consists of only lowercase English letters.</em>   <code>sources[i]</code> and <code>targets[i]</code> consist of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>整洁题。找到位置，然后验证，最后替换</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>i是循环外的变量，所以poplate index_dict注意不能重名</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, s: str, indices: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">index_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _i, _n <span class="keyword">in</span> enumerate(indices):</span><br><span class="line">index_dict[_n] = _i <span class="comment"># 0 -&gt; 0, 2 -&gt; 1</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(s):</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> index_dict <span class="keyword">and</span> s[i:i + len(sources[index_dict[i]])] == sources[index_dict[i]]:</span><br><span class="line">res += targets[index_dict[i]]</span><br><span class="line">i += len(sources[index_dict[i]])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += s[i]</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-and-replace-in-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2007 Find Original Array From Doubled Array</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/</id>
    <published>2022-02-16T20:54:39.600Z</published>
    <updated>2022-02-16T20:59:32.115Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-original-array-from-doubled-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>An integer array <code>original</code> is transformed into a <strong>doubled</strong> array <code>changed</code> by appending <strong>twice the value</strong> of every element in <code>original</code>, and then randomly <strong>shuffling</strong> the resulting array.<br><br>Given an array <code>changed</code>, return <code>original</code> <em>if</em> <code>changed</code> <em>is a <strong>doubled</strong> array. If</em> <code>changed</code> <em>is not a <strong>doubled</strong> array, return an empty array. The elements in</em> <code>original</code> <em>may be returned in <strong>any</strong> order</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> changed = [1,3,4,2,6,8]<br><strong>Output:</strong> [1,3,4]<br><strong>Explanation:</strong> One possible original array could be [1,3,4]:<br>- Twice the value of 1 is 1 <em> 2 = 2.<br>- Twice the value of 3 is 3 </em> 2 = 6.<br>- Twice the value of 4 is 4 <em> 2 = 8.<br>Other original arrays could be [4,3,1] or [3,1,4].<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> changed = [6,3,0,1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> changed = [1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Constraints:</strong>   <code>1 &lt;= changed.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= changed[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，求这个数组是否可以分成两部分，后一部分的每个元素是否前一部分某元素的两倍</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由最大值容易确定它的一半是否在数组中。所以排序后由大到小遍历。注意数组元素可能相等，所以不能用visited set来记录已用过的数，val_to_index也不支持重复，只有val_to_count支持</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用val_to_count，注意遍历时候就要减去，不要进入if才减去</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOriginalArray</span><span class="params">(self, changed: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> len(changed) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">changed.sort()</span><br><span class="line">res = []</span><br><span class="line">val_to_count = collections.Counter(changed)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(changed))):</span><br><span class="line"><span class="keyword">if</span> val_to_count[changed[i]] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">val_to_count[changed[i]] -= <span class="number">1</span> <span class="comment"># not in  if statement</span></span><br><span class="line"><span class="keyword">if</span> changed[i] / <span class="number">2</span> <span class="keyword">in</span> val_to_count <span class="keyword">and</span> val_to_count[changed[i] / <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">val_to_count[changed[i] / <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">res.append(int(changed[i] / <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> [] <span class="keyword">if</span> len(res) * <span class="number">2</span> != len(changed) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-original-array-from-doubled-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stro
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1146 Snapshot Array</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1146-snapshot-array/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1146-snapshot-array/</id>
    <published>2022-02-16T19:20:59.715Z</published>
    <updated>2022-02-16T19:55:55.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/snapshot-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement a SnapshotArray that supports the following interface:<br><br><em>   <code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length.  <strong>Initially, each element equals 0</strong>.</em>   <code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.<br><em>   <code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.</em>   <code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> [“SnapshotArray”,”set”,”snap”,”set”,”get”]<br>[[3],[0,5],[],[0,6],[0,0]]<br><strong>Output:</strong> [null,null,0,null,5]<br><strong>Explanation:</strong><br>SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3<br>snapshotArr.set(0,5);  // Set array[0] = 5<br>snapshotArr.snap();  // Take a snapshot, return snap_id = 0<br>snapshotArr.set(0,6);<br>snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= length &lt;= 50000</code></em>   At most <code>50000</code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.<br><em>   <code>0 &lt;= index &lt; length</code></em>   <code>0 &lt;= snap_id &lt;</code>(the total number of times we call <code>snap()</code>)<br>*   <code>0 &lt;= val &lt;= 10^9</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个数据结构支持数组的快照</p><h3 id="Binary-Search解题思路-推荐-："><a href="#Binary-Search解题思路-推荐-：" class="headerlink" title="Binary Search解题思路(推荐)："></a><strong>Binary Search解题思路(推荐)：</strong></h3><p>暴力法是每次快照时候，将当时的数组的所有值存入dict中，key为(snap_id, index), value为数组值，得到MLE<br>后来考虑用二分法优化snap，将数值跟前值不同才存入历史记录，但得到TLE，应该是因为snap时间太长，因为要遍历整个数组<br>所以应该将存入历史这一步放在set中，每次值改变才存入历史记录，虽然一个snap_id可能会存入多值，大部分是不需要，因为同一个snap_id应该取最新值，但这样设计费了空间，省了时间。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>历史记录为3d数组，第一维为数组index, 第二维为所有历史记录，第三维为每一个记录为[snap_id, value]。由于数组初始值为0，所以初始历史记录为[-1, 0]</li><li>snap_id和题目要求的id差1，比如第一次call snap为0，但是之前的snap应该为-1</li><li>最容易错的在于二分法，要先将snap_id + 1，比如[-1, 0], [0, 5], [0, 6], [0, 2], [1, 1], [1, 4]…找snap_id = 0的值也就是要找最后的，所以先加1，找到[1, 1]再下标减1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">        self.snap_id = <span class="number">0</span></span><br><span class="line">        self.history = [[[<span class="number">-1</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.history[index].append([self.snap_id, val])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        self.snap_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.snap_id - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line">        last_snap_id = bisect.bisect(self.history[index], [snap_id + <span class="number">1</span>]) - <span class="number">1</span> <span class="comment"># remember snap + 1</span></span><br><span class="line">        <span class="keyword">return</span> self.history[index][last_snap_id][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>get时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>, 数组某值n更改次数  </p><hr><h3 id="暴力法算法II解题思路-不推荐-："><a href="#暴力法算法II解题思路-不推荐-：" class="headerlink" title="暴力法算法II解题思路(不推荐)："></a><strong>暴力法算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length: int)</span>:</span></span><br><span class="line">self.ary = [<span class="number">0</span>] * length</span><br><span class="line">self.snap_id = <span class="number">-1</span></span><br><span class="line">self.idx_snap_to_val = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">self.ary[index] = val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snap</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">self.snap_id += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(self.ary):</span><br><span class="line">self.idx_snap_to_val[(i, self.snap_id)] = self.ary[i]</span><br><span class="line"><span class="keyword">return</span> self.snap_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int, snap_id: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.idx_snap_to_val[(index, snap_id)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/snapshot-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Imp
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1937 Maximum Number of Points with Cost</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1937-maximum-number-of-points-with-cost/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1937-maximum-number-of-points-with-cost/</id>
    <published>2022-02-16T18:08:59.144Z</published>
    <updated>2022-02-16T18:23:03.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-number-of-points-with-cost/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> integer matrix <code>points</code> (<strong>0-indexed</strong>). Starting with <code>0</code> points, you want to <strong>maximize</strong> the number of points you can get from the matrix.<br><br>To gain points, you must pick one cell in <strong>each row</strong>. Picking the cell at coordinates <code>(r, c)</code> will <strong>add</strong> <code>points[r][c]</code> to your score.<br><br>However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows <code>r</code> and <code>r + 1</code> (where <code>0 &lt;= r &lt; m - 1</code>), picking cells at coordinates <code>(r, c&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(r + 1, c&lt;sub&gt;2&lt;/sub&gt;)</code> will <strong>subtract</strong> <code>abs(c&lt;sub&gt;1&lt;/sub&gt; - c&lt;sub&gt;2&lt;/sub&gt;)</code> from your score.<br><br>Return <em>the <strong>maximum</strong> number of points you can achieve</em>.<br><br><code>abs(x)</code> is defined as:<br><br><em>   <code>x</code> for <code>x &gt;= 0</code>.</em>   <code>-x</code> for <code>x &lt; 0</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,2,3],[1,5,1],[3,1,1]]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).<br>You add 3 + 5 + 3 = 11 to your score.<br>However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.<br>Your final score is 11 - 2 = 9.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" alt=""><br><br><pre><strong>Input:</strong> points = [[1,5],[2,3],[4,2]]<br><strong>Output:</strong> 11<br><strong>Explanation:</strong><br>The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).<br>You add 5 + 3 + 4 = 12 to your score.<br>However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.<br>Your final score is 12 - 1 = 11.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == points.length</code></em>   <code>n == points[r].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= points[r][c] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中含点数，每行取一个cell上的点数，但若两行之间的cell的列不同，要扣去列下标差，求最大点数</p><h3 id="优化DP解题思路-推荐-："><a href="#优化DP解题思路-推荐-：" class="headerlink" title="优化DP解题思路(推荐)："></a><strong>优化DP解题思路(推荐)：</strong></h3><p>求数值的最大值，容易想到用DP，dp[i][j]定义为每个cell的累计最大点数，递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][k] - abs(j - k)) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p><p>复杂度为n立方。</p><p>如果没有扣除的规则，其实就是找上一行的最大值，但要考虑下标，考虑怎么移除这个限制，若将上一个某个cell搬到跟目前列，就是dp[i - 1][k] - (j - k), 所以可以提前计算，<br>而且有绝对值，所以类似于LeetCode 042 Trapping Rain Water拆分为向左向右最大值：<br>left[i]是该行第i个cell，上一行在该列左边的cell的累计最大点数(已扣除)，同理<br>right[i]是该行第i个cell，上一行在该列右边的cell的累计最大点数(已扣除)</p><p>最后，上一行的最大值只能在左边或右边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(left[j], right[j]) + points[i][j], k = 0..len(dp[0])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>left[j], right[j]的引入</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">m, n = len(points), len(points[<span class="number">0</span>])</span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">left[<span class="number">0</span>], right[<span class="number">-1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">left[j] = max(dp[i - <span class="number">1</span>][j], left[j - <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">right[j] = max(dp[i - <span class="number">1</span>][j], right[j + <span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">dp[i][j] = points[i][j] + max(left[j], right[j])</span><br><span class="line"><span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><hr><h3 id="暴力DP算法II解题思路-不推荐-："><a href="#暴力DP算法II解题思路-不推荐-：" class="headerlink" title="暴力DP算法II解题思路(不推荐)："></a><strong>暴力DP算法II解题思路(不推荐)：</strong></h3><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints2</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(points))]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][k] + points[i][j] - abs(j - k))</span><br><span class="line"><span class="keyword">return</span> max(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-number-of-points-with-cost/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1293 Shortest Path in a Grid with Obstacles Elimination</title>
    <link href="https://shineboy2013.github.com/2022/02/16/leetcode-1293-shortest-path-in-a-grid-with-obstacles-elimination/"/>
    <id>https://shineboy2013.github.com/2022/02/16/leetcode-1293-shortest-path-in-a-grid-with-obstacles-elimination/</id>
    <published>2022-02-16T09:26:58.956Z</published>
    <updated>2022-02-16T09:40:07.171Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.<br><br>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner</em> <code>(0, 0)</code> <em>to the lower right corner</em> <code>(m - 1, n - 1)</code> <em>given that you can eliminate <strong>at most</strong></em> <code>k</code> <em>obstacles</em>. If it is not possible to find such walk return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1<br><strong>Output:</strong> 6<br><strong>Explanation:</strong><br>The shortest path without eliminating any obstacle is 10.<br>The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code></em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 40</code></em>   <code>1 &lt;= k &lt;= m * n</code><br><em>   <code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</em>   <code>grid[0][0] == grid[m - 1][n - 1] == 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵从左上走到右下，但含障碍，现在可以移除k个，使得路径最短，求最短路径</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最短路径用BFS，但此题难点在于distance跟路径有关，比如某一格可能属于不同的路径，此时它的distance会不同，所以distance不能global，必须作为state传到下一个迭代<br>同样的情况也在visited中存在，visited跟路径相关，而这一格跟k相关，这一格可以被属于不同的k的路径访问，所以visited应该加入k</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>visited是(x, y, k), queue是(x, y, k, dis)</li><li>(x, y, k - 1)跟visited比较，而不是(x, y, k)。下一个节点的条件为eleminatios &gt;= 0</li><li>若k过多会LTE, 因为广度会过大。这是用曼哈顿距离来剪枝。左上到右下距离为m - n + 2这肯定是最短距离，若k大于等于这个数，也就是可以移除曼哈顿路径上的所有障碍。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, grid: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> k &gt;= m + n - <span class="number">2</span>: <span class="comment"># TLE</span></span><br><span class="line"><span class="keyword">return</span> m + n - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">queue = collections.deque([(<span class="number">0</span>, <span class="number">0</span>, k, <span class="number">0</span>)]) <span class="comment"># x, y, k, distance</span></span><br><span class="line">visited = set([(<span class="number">0</span>, <span class="number">0</span>, k)]) <span class="comment"># include k</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">_x, _y, _k, _dis = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> _x == m - <span class="number">1</span> <span class="keyword">and</span> _y == n - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> _dis</span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">x, y = _x + _dx, _y + _dy</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">eliminations = _k - <span class="number">1</span> <span class="keyword">if</span> grid[x][y] == <span class="number">1</span> <span class="keyword">else</span> _k</span><br><span class="line"><span class="keyword">if</span> (x, y, eliminations) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> eliminations &gt;= <span class="number">0</span>:</span><br><span class="line">queue.append((x, y, eliminations, _dis + <span class="number">1</span>))</span><br><span class="line">visited.add((x, y, eliminations))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmk)</code>，空间复杂度<code>O(mnk)</code>, 某个cell都可能被访问k次，因为最多有k条路径  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCo
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 670 Maximum Swap</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-670-maximum-swap/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-670-maximum-swap/</id>
    <published>2022-02-16T03:20:03.290Z</published>
    <updated>2022-02-16T03:39:03.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-swap/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer <code>num</code>. You can swap two digits at most once to get the maximum valued number.<br><br>Return <em>the maximum valued number you can get</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = 2736<br><strong>Output:</strong> 7236<br><strong>Explanation:</strong> Swap the number 2 and the number 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = 9973<br><strong>Output:</strong> 9973<br><strong>Explanation:</strong> No swap.<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>0 &lt;= num &lt;= 10&lt;sup&gt;8&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数，最多交换一位，使得这个数尽可能最大</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 854 K-Similar Strings, 如2736， 求2后面最大的数为7，和7交换即为所求。这里有两个问题：</p><ol><li>第一位可能已经是最大的数位，这样需要遍历每个数位，找到能交换的数位，若这个位在倒序排序后位置一样，表明此位不能交换。所以排序法的算法复杂度为n平方</li><li>若要优化就要采用bucket sort，因为数位是有限的。若后续数位有一个数比自己大，表示可交换。所以只要记录每个数位的位置，贪心法从9(最大)遍历到自己，若该位位置在自己之后，可交换</li><li>若不同数位上数值相同，应该记录其最后的位置，因为交换时候将小的尽量往后交换，越好越不重要，如2949, 2和最后的9交换得到最大的数</li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>内循环从9遍历到该位数值(不包括)</li><li>buckets的key为字符串，注意整数和字符串互换，如buckets[str(j)], int(digits[i])</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">digits, buckets = str(num), collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i, digit <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">buckets[digit] = i <span class="comment"># use last position for same char</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>, int(digits[i]), <span class="number">-1</span>): <span class="comment"># remember to use int(digits[i]) not i</span></span><br><span class="line"><span class="keyword">if</span> buckets[str(j)] &gt; i: <span class="comment"># 2736, i = (2), j = (7) # remember to use str j</span></span><br><span class="line"><span class="keyword">return</span> int(digits[:i] + digits[buckets[str(j)]] + digits[i + <span class="number">1</span>:buckets[str(j)]] + digits[i] + digits[buckets[str(j)] + <span class="number">1</span>:])</span><br><span class="line"><span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(9n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You a
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 567 Permutation in String</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-567-permutation-in-string/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-567-permutation-in-string/</id>
    <published>2022-02-16T01:57:13.034Z</published>
    <updated>2022-02-16T02:00:06.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> <em>if</em> <code>s2</code> <em>contains a permutation of</em> <code>s1</code><em>, or</em> <code>false</code> <em>otherwise</em>.<br><br>In other words, return <code>true</code> if one of <code>s1</code>‘s permutations is the substring of <code>s2</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidbaooo”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> s2 contains one permutation of s1 (“ba”).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “eidboaoo”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length, s2.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>s1</code> and <code>s2</code> consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s2中是否含s1的anagram</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 438 Find All Anagrams in a String, 唯一区别是substr_win == char_to_count_p时返回而不是加入到res</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count_p = collections.Counter(s1)</span><br><span class="line">substr_win = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s2):</span><br><span class="line">substr_win[s2[i]] += <span class="number">1</span></span><br><span class="line"><span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= len(s1):</span><br><span class="line">substr_win[s2[i - len(s1)]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> substr_win[s2[i - len(s1)]] == <span class="number">0</span>:</span><br><span class="line">substr_win.pop(s2[i - len(s1)])</span><br><span class="line"><span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/permutation-in-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 438 Find All Anagrams in a String</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-438-find-all-anagrams-in-a-string/</id>
    <published>2022-02-16T01:52:25.222Z</published>
    <updated>2022-02-16T01:57:00.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of</em> <code>p</code><em>‘s anagrams in</em> <code>s</code>. You may return the answer in <strong>any order</strong>.<br><br>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “cbaebabacd”, p = “abc”<br><strong>Output:</strong> [0,6]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abab”, p = “ab”<br><strong>Output:</strong> [0,1,2]<br><strong>Explanation:</strong><br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length, p.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>s<code>and</code>p` consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串s中含p的anagram的所有初始下标</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求某子串的频率统计，第一时间想到滑动窗口。此题较特殊，属于固定大小窗口的滑动窗口，因为p的大小是固定的，窗口大小必须和p长度一样。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">char_to_count_p = collections.Counter(p)</span><br><span class="line">substr_win = collections.defaultdict(int)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">substr_win[s[i]] += <span class="number">1</span></span><br><span class="line"><span class="comment"># window: [i - len(p) + 1, i]</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= len(p):</span><br><span class="line">substr_win[s[i - len(p)]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> substr_win[s[i - len(p)]] == <span class="number">0</span>:</span><br><span class="line">substr_win.pop(s[i - len(p)])</span><br><span class="line"><span class="keyword">if</span> substr_win == char_to_count_p:</span><br><span class="line">res.append(i - len(p) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-all-anagrams-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Mock 001 Count changes for two N-trees</title>
    <link href="https://shineboy2013.github.com/2022/02/15/mock-001/"/>
    <id>https://shineboy2013.github.com/2022/02/15/mock-001/</id>
    <published>2022-02-15T21:10:39.391Z</published>
    <updated>2022-02-15T21:15:38.880Z</updated>
    
    <content type="html"><![CDATA[<p>A change for two N-children tree contains:</p><ol><li>key is different</li><li>value is different</li><li>delete a node</li><li>add a node</li></ol><p>Problem: how many changes to convert tree A to tree B</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>DD的面经题，多少个改动可以使得existingTree变成newTree</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS, 比较children，三种情况。若其中一方没有节点，就是计算节点数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较children，三种情况。若其中一方没有节点，就是计算节点数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeNodes</span><span class="params">(self, existingTree, newTree)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">and</span> <span class="keyword">not</span> newTree:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> existingTree <span class="keyword">or</span> <span class="keyword">not</span> newTree:</span><br><span class="line"><span class="keyword">return</span> self.count(existingTree) + self.count(newTree)</span><br><span class="line">res = <span class="number">0</span> <span class="keyword">if</span> existingTree.key == newTree.key <span class="keyword">and</span> existingTree.val == newTree.val <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">existing_children_dict = self.get_children_dict(existingTree.children)</span><br><span class="line">new_tree_children_dict = self.get_children_dict(newTree.children)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() &amp; new_tree_children_dict.keys(): <span class="comment"># in both</span></span><br><span class="line">res += self.changeNodes(existing_children_dict[key], new_tree_children_dict[key])</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> existing_children_dict.keys() - new_tree_children_dict.keys(): <span class="comment"># in existing tree not in new tree</span></span><br><span class="line">res += self.count(existing_children_dict[key])</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> new_tree_children_dict.keys() - existing_children_dict.keys():  <span class="comment"># in new tree not in existing tree</span></span><br><span class="line">res += self.count(new_tree_children_dict[key])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">res += self.count(child)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_children_dict</span><span class="params">(self, children)</span>:</span></span><br><span class="line">key_to_node = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> children:</span><br><span class="line">key_to_node[child.key] = child</span><br><span class="line"><span class="keyword">return</span> key_to_node</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A change for two N-children tree contains:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;key is different&lt;/li&gt;
&lt;li&gt;value is different&lt;/li&gt;
&lt;li&gt;delete a node&lt;/li&gt;
&lt;li&gt;add 
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1166 Design File System</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/</id>
    <published>2022-02-15T18:13:22.294Z</published>
    <updated>2022-02-15T18:21:19.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are asked to design a file system that allows you to create new paths and associate them with different values.<br><br>The format of a path is one or more concatenated strings of the form: <code>/</code> followed by one or more lowercase English letters. For example, “<code>/leetcode&quot;</code> and “<code>/leetcode/problems&quot;</code> are valid paths while an empty string <code>&quot;&quot;</code> and <code>&quot;/&quot;</code> are not.<br><br>Implement the <code>FileSystem</code> class:<br><br><em>   <code>bool createPath(string path, int value)</code> Creates a new <code>path</code> and associates a <code>value</code> to it if possible and returns <code>true</code>. Returns <code>false</code> if the path <strong>already exists</strong> or its parent path <strong>doesn’t exist</strong>.</em>   <code>int get(string path)</code> Returns the value associated with <code>path</code> or returns <code>-1</code> if the path doesn’t exist.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”get”]<br>[[],[“/a”,1],[“/a”]]<br><strong>Output:</strong><br>[null,true,1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/a”, 1); // return true<br>fileSystem.get(“/a”); // return 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”createPath”,”get”,”createPath”,”get”]<br>[[],[“/leet”,1],[“/leet/code”,2],[“/leet/code”],[“/c/d”,1],[“/c”]]<br><strong>Output:</strong><br>[null,true,true,2,false,-1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/leet”, 1); // return true<br>fileSystem.createPath(“/leet/code”, 2); // return true<br>fileSystem.get(“/leet/code”); // return 2<br>fileSystem.createPath(“/c/d”, 1); // return false because the parent path “/c” doesn’t exist.<br>fileSystem.get(“/c”); // return -1 because this path doesn’t exist.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of calls to the two functions is less than or equal to <code>10&lt;sup&gt;4&lt;/sup&gt;</code> in total.</em>   <code>2 &lt;= path.length &lt;= 100</code><br>*   <code>1 &lt;= value &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统，支持创建路径，路径含key, value</p><h3 id="Trie解题思路："><a href="#Trie解题思路：" class="headerlink" title="Trie解题思路："></a><strong>Trie解题思路：</strong></h3><p>用Trie, is_end变成key, value</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>遍历用1开始，因为首个/前面是空字符串</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">if</span> i == len(segments) - <span class="number">1</span>: <span class="comment"># match all the previous segments</span></span><br><span class="line">                    it.children[segment] = TrieNode(segment)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">if</span> it.value != <span class="number">-1</span>: <span class="comment"># exists</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">return</span> it.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.value = <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="算法II-HashMap解题思路："><a href="#算法II-HashMap解题思路：" class="headerlink" title="算法II HashMap解题思路："></a><strong>算法II HashMap解题思路：</strong></h3><p>用前缀法</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem2</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.path_to_val = defaultdict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">"/"</span> <span class="keyword">or</span> len(path) == <span class="number">0</span> <span class="keyword">or</span> path <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search from the right</span></span><br><span class="line">        parent = path[:path.rfind(<span class="string">'/'</span>)]</span><br><span class="line">        <span class="keyword">if</span> len(parent) &gt; <span class="number">1</span> <span class="keyword">and</span> parent <span class="keyword">not</span> <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        self.path_to_val[path] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.path_to_val.get(path, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-file-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 839 Similar String Groups</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/</id>
    <published>2022-02-15T17:23:01.070Z</published>
    <updated>2022-02-15T17:28:06.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/similar-string-groups/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>. Also two strings <code>X</code> and <code>Y</code> are similar if they are equal.<br><br>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.<br><br>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.<br><br>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“tars”,”rats”,”arts”,”star”]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“omv”,”ovm”]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 300</code></em>   <code>1 &lt;= strs[i].length &lt;= 300</code><br><em>   <code>strs[i]</code> consists of lowercase letters only.</em>   All words in <code>strs</code> have the same length and are anagrams of each other.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>单词列表中，可以分成多少组，每组里面的单词互相之间至少有一对可以通过交换一个位置变成另一个单词</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>典型求连通集个数，类似于Num of island，用BFS。难点在于怎么找到neighbor，用遍历每一个单词的方式</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点在于怎么找到neighbor，用遍历每一个单词的方式，判断是否buddyStrings Leetcode 0859</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, strs: List[str])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">visited, groups, word_set = set(), <span class="number">0</span>, set(strs)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">self.bfs(word_set, s, visited)</span><br><span class="line">groups += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> groups</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word_set, start, visited)</span>:</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> word_set:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node == s <span class="keyword">or</span> <span class="keyword">not</span> self.buddyStrings(node, s):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(s)</span><br><span class="line">visited.add(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal):  <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/similar-string-groups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1347 Minimum Number of Steps to Make Two Strings Anagram</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/</id>
    <published>2022-02-15T16:48:02.381Z</published>
    <updated>2022-02-15T16:51:30.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.<br><br>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.<br><br>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bab”, t = “aba”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Replace the first ‘a’ in t with b, t = “bba” which is anagram of s.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, t = “practice”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Replace ‘p’, ‘r’, ‘a’, ‘i’ and ‘c’ from t with proper characters to make t anagram of s.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “mangaar”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “anagram” and “mangaar” are anagrams.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s.length == t.length<code>*</code>s<code>and</code>t` consist of lowercase English letters only.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过替换字母使得两字符为同位词Anagram</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计某一个词的词频，遍历另一个单词，减去词频，若不够减(小于0)，就加步数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count_t = collections.Counter(t)</span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> char_to_count_t <span class="keyword">and</span> char_to_count_t[char] &gt; <span class="number">0</span>:</span><br><span class="line">char_to_count_t[char] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">steps += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetC
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 854 K-Similar Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/</id>
    <published>2022-02-15T10:00:31.027Z</published>
    <updated>2022-02-15T10:07:52.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/k-similar-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Strings <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong> (for some non-negative integer <code>k</code>) if we can swap the positions of two letters in <code>s1</code> exactly <code>k</code> times so that the resulting string equals <code>s2</code>.<br><br>Given two anagrams <code>s1</code> and <code>s2</code>, return the smallest <code>k</code> for which <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “ba”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “abc”, s2 = “bca”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length &lt;= 20</code></em>   <code>s2.length == s1.length</code><br><em>   <code>s1</code> and <code>s2</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>.</em>   <code>s2</code> is an anagram of <code>s1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两字符，交换两个位置，使得他们相等，求最小交换次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值考虑用BFS，难点在于生成neighbor，见注意事项</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用例子写程序node = abc s2 = cba, 先找到第一个不同位i，然后找下一个不同位j，这个不同位node[j]需要与目标s2[i]相同，贪心法</li><li>倒数第二行要break，否则TLE，因为只要找到一位可以交换这一层的BFS算是结束</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque([s1])</span><br><span class="line">visited = set([s1])</span><br><span class="line">distance = &#123;s1: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == s2:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)): <span class="comment"># abc, cba</span></span><br><span class="line"><span class="keyword">if</span> node[i] == s2[i]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(node)):</span><br><span class="line"><span class="keyword">if</span> node[j] == s2[j]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node[j] == s2[i]:</span><br><span class="line">ss = node[:i] + node[j] + node[i + <span class="number">1</span>:j] + node[i] + node[j + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> ss <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(ss)</span><br><span class="line">visited.add(ss)</span><br><span class="line">distance[ss] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/k-similar-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Buddy Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/</id>
    <published>2022-02-15T09:35:36.737Z</published>
    <updated>2022-02-15T09:38:45.215Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/buddy-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> <em>if you can swap two letters in</em> <code>s</code> <em>so the result is equal to</em> <code>goal</code><em>, otherwise, return</em> <code>false</code><em>.</em><br><br>Swapping letters is defined as taking two indices <code>i</code> and <code>j</code> (0-indexed) such that <code>i != j</code> and swapping the characters at <code>s[i]</code> and <code>s[j]</code>.<br><br><em>   For example, swapping at indices <code>0</code> and <code>2</code> in <code>&quot;abcd&quot;</code> results in <code>&quot;cbad&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ba”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘b’ to get “ba”, which is equal to goal.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ab”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The only letters you can swap are s[0] = ‘a’ and s[1] = ‘b’, which results in “ba” != goal.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aa”, goal = “aa”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘a’ to get “aa”, which is equal to goal.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length, goal.length &lt;= 2 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> and <code>goal</code> consist of lowercase letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两字符串，交换一次使得他们相等</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况： 长度不等，完全相等（若至少有一个重复，即满足题意），两次不同</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种情况： 长度不等，完全相等，两次不同</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal): <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/buddy-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 351 Android Unlock Patterns</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/</id>
    <published>2022-02-14T03:49:42.062Z</published>
    <updated>2022-02-14T04:07:52.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/android-unlock-patterns" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Android devices have a special lock screen with a <code>3 x 3</code> grid of dots. Users can set an “unlock pattern” by connecting the dots in a specific sequence, forming a series of joined line segments where each segment’s endpoints are two consecutive dots in the sequence. A sequence of <code>k</code> dots is a <strong>valid</strong> unlock pattern if both of the following are true:<br><br><em>   All the dots in the sequence are <strong>distinct</strong>.</em>   If the line segment connecting two consecutive dots in the sequence passes through the <strong>center</strong> of any other dot, the other dot <strong>must have previously appeared</strong> in the sequence. No jumps through the center non-selected dots are allowed.<br>    <em>   For example, connecting dots <code>2</code> and <code>9</code> without dots <code>5</code> or <code>6</code> appearing beforehand is valid because the line from dot <code>2</code> to dot <code>9</code> does not pass through the center of either dot <code>5</code> or <code>6</code>.    </em>   However, connecting dots <code>1</code> and <code>3</code> without dot <code>2</code> appearing beforehand is invalid because the line from dot <code>1</code> to dot <code>3</code> passes through the center of dot <code>2</code>.<br><br>Here are some example valid and invalid unlock patterns:<br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png" alt=""><br><br><em>   The 1st pattern <code>[4,1,3,6]</code> is invalid because the line connecting dots <code>1</code> and <code>3</code> pass through dot <code>2</code>, but dot <code>2</code> did not previously appear in the sequence.</em>   The 2nd pattern <code>[4,1,9,2]</code> is invalid because the line connecting dots <code>1</code> and <code>9</code> pass through dot <code>5</code>, but dot <code>5</code> did not previously appear in the sequence.<br><em>   The 3rd pattern <code>[2,4,1,3,6]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>3</code> meets the condition because dot <code>2</code> previously appeared in the sequence.</em>   The 4th pattern <code>[6,5,4,1,9,2]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>9</code> meets the condition because dot <code>5</code> previously appeared in the sequence.<br><br>Given two integers <code>m</code> and <code>n</code>, return <em>the <strong>number of unique and valid unlock patterns</strong> of the Android grid lock screen that consist of <strong>at least</strong></em> <code>m</code> <em>keys and <strong>at most</strong></em> <code>n</code> <em>keys.</em><br><br>Two unlock patterns are considered <strong>unique</strong> if there is a dot in one sequence that is not in the other, or the order of the dots is different.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 1<br><strong>Output:</strong> 9<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 2<br><strong>Output:</strong> 65<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= m, n &lt;= 9</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>安卓开屏密码解锁种数。给定m, n是安卓的密码长度范围，求这个范围内的解码种数。1可以跳到2和4, 5, 6, 8(斜线没有通过其他数字)，但不能跳到3, 7, 9因为前提条件是这条线通过的数如2, 4, 5必须已经用过了。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题属于填位法，带条件的，条件在于map中，类似于LeetCode 248 Strobogrammatic Number III<br>难点是理解jump keys，有16种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skip[1][3] = skip[3][1] = 2;</span><br><span class="line">skip[1][7] = skip[7][1] = 4;</span><br><span class="line">skip[3][9] = skip[9][3] = 6;</span><br><span class="line">skip[7][9] = skip[9][7] = 8;</span><br><span class="line">skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>用DFS模板: def dfs(self, graph, start, visited, res), start = num</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 9有return，所以要去掉刚加入的visited的num</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JUMP_KEYS = &#123;(<span class="number">1</span>,<span class="number">3</span>):<span class="number">2</span>, (<span class="number">1</span>,<span class="number">7</span>):<span class="number">4</span>, (<span class="number">1</span>,<span class="number">9</span>):<span class="number">5</span>, (<span class="number">2</span>,<span class="number">8</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">7</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">1</span>):<span class="number">2</span>, (<span class="number">3</span>,<span class="number">9</span>):<span class="number">6</span>, (<span class="number">4</span>,<span class="number">6</span>):<span class="number">5</span>, (<span class="number">6</span>,<span class="number">4</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">1</span>):<span class="number">4</span>, (<span class="number">7</span>,<span class="number">3</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">9</span>):<span class="number">8</span>, (<span class="number">8</span>,<span class="number">2</span>):<span class="number">5</span>, (<span class="number">9</span>,<span class="number">7</span>):<span class="number">8</span>, (<span class="number">9</span>,<span class="number">3</span>):<span class="number">6</span>, (<span class="number">9</span>,<span class="number">1</span>):<span class="number">5</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, m, n, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited.add(num)</span><br><span class="line">        <span class="keyword">if</span> len(visited) == n:</span><br><span class="line">            visited.remove(num) <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) &gt;= m:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> next_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> (num, next_num) <span class="keyword">in</span> JUMP_KEYS <span class="keyword">and</span> JUMP_KEYS[(num, next_num)] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += self.dfs(next_num, m, n, visited)</span><br><span class="line">        visited.remove(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 因为最多是9乘以8乘以7…  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/android-unlock-patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 158 Read N Characters Given read4 II - Call Multiple Times</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-158-read-n-characters-given-read4/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-158-read-n-characters-given-read4/</id>
    <published>2022-02-13T10:32:10.048Z</published>
    <updated>2022-02-13T10:55:34.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method <code>read</code> to read <code>n</code> characters. Your method <code>read</code> may be <strong>called multiple times</strong>.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;char[] buf4 = new char[4]; // Create buffer with enough space to store charactersread4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of fileread4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.</em>   The read function may be <strong>called multiple times</strong>.<br><em>   Please remember to <strong>RESET</strong> your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/" target="_blank" rel="noopener">here</a> for more details.</em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><em>   It is guaranteed that in a given test case the same buffer <code>buf</code> is called by <code>read</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [1,2,1]<br><strong>Output:</strong> [1,2,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 1); // After calling your read method, buf should contain “a”. We read a total of 1 character from the file, so return 1.<br>sol.read(buf, 2); // Now buf should contain “bc”. We read a total of 2 characters from the file, so return 2.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br>Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [4,1]<br><strong>Output:</strong> [3,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 4); // After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.</em>   <code>1 &lt;= queries.length &lt;= 10</code><br>*   <code>1 &lt;= queries[i] &lt;= 500</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>题意类似于LeetCode 157 Read N Characters Given Read4，但此题唯一的区别是这个新的API: def read(self, buf, n)会被调用多次</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为read调用多次，所以调用read4多读了几个字符在n以外的，需要保留下来让下一次read返回到结果中，所以用queue来保存中间结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先将read4的结果保存在self.queue中，然后再填充到buf中，这里用到了quicksort里面partition的方法，while中只有当填充buf时i才移动，而read4时候不移动</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.queue = collections.deque()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line"><span class="keyword">if</span> self.queue:</span><br><span class="line">buf[i] = self.queue.popleft()</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">count = read4(buf4)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">self.queue.extend(buf4[:count])</span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leet
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 157 Read N Characters Given Read4</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-157-read-n-characters-given-read4/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-157-read-n-characters-given-read4/</id>
    <published>2022-02-13T09:46:16.876Z</published>
    <updated>2022-02-13T10:46:58.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method to read <code>n</code> characters.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;char[] buf4 = new char[4]; // Create buffer with enough space to store charactersread4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of fileread4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.</em>   The <code>read</code> function will only be called once for each test case.<br><em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, n = 4<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>Note that “abc” is the file’s content, not buf. buf is the destination buffer that you will have to write the results to.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abcde”, n = 5<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcde”. We read a total of 5 characters from the file, so return 5.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> file = “abcdABCD1234”, n = 12<br><strong>Output:</strong> 12<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcdABCD1234”. We read a total of 12 characters from the file, so return 12.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.</em>   <code>1 &lt;= n &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Karat题，有一个函数read4,如此调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf4 = [&apos; &apos;] * 4</span><br><span class="line">count = read4(buf4)</span><br></pre></td></tr></table></figure><p>buf4是填充后的结果，是一个大小为4的char list<br>count是buf4的有数据的实际大小(4或更小，取决于是否文件最后一段是否不够4)</p><p>现在要实现这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def read(self, buf, n)</span><br></pre></td></tr></table></figure></p><p>buf是字符列表，n是想要读取文件的大小，返回值为n或者更小，取决于是否文件大小是否小于n</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>若count为0，跳出循环</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">count = read4(buf4)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">count = min(count, n - i)</span><br><span class="line">buf[i:] = buf4</span><br><span class="line">i += count</span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/read-n-characters-given-read4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>Karat 004 Ads Conversion</title>
    <link href="https://shineboy2013.github.com/2022/02/12/karat-004/"/>
    <id>https://shineboy2013.github.com/2022/02/12/karat-004/</id>
    <published>2022-02-13T03:47:43.099Z</published>
    <updated>2022-02-13T10:58:18.098Z</updated>
    
    <content type="html"><![CDATA[<p>A list of user ids + IPs, a list of user ids who have made purchases, a list of advertisement<br>clicks with user IPs.<br>Each user id has at most 1 IP.</p><p>Output: for each ad, output the number of clicks and the number of purchases.</p><pre>completed_purchase_user_ids = ["123"]ad_clicks = [    #"IP_Address,Time,Ad_Text",    "127.0.0.1,2011-01-03 09:21:22,black pen"]all_user_ips = [    #"User_ID,IP_Address",        "123,127.0.0.1"]</pre><p>输出:<br>black pen, 1 click, 1 purchase</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定购买记录，click记录，ip地址。求每个产品点击数和购买次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题比较直观，点击数直接可以从click记录中获得，购买次数就是将三个表格join一起获得</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m + p)</code>，空间复杂度<code>O(n + m + p)</code>, n, m, p分别每个表的大小  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A list of user ids + IPs, a list of user ids who have made purchases, a list of advertisement&lt;br&gt;clicks with user IPs.&lt;br&gt;Each user id ha
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
</feed>
