<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-05T04:18:31.303Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 427 Construct Quad Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-427/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-427/</id>
    <published>2022-01-05T04:03:21.417Z</published>
    <updated>2022-01-05T04:18:31.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/construct-quad-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>n * n</code> matrix <code>grid</code> of <code>0&#39;s</code> and <code>1&#39;s</code> only. We want to represent the <code>grid</code> with a Quad-Tree.<br><br>Return <em>the root of the Quad-Tree</em> representing the <code>grid</code>.<br><br>Notice that you can assign the value of a node to <strong>True</strong> or <strong>False</strong> when <code>isLeaf</code> is <strong>False</strong>, and both are <strong>accepted</strong> in the answer.<br><br>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:<br><br><em>   <code>val</code>: True if the node represents a grid of 1’s or False if the node represents a grid of 0’s.</em>   <code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.<br><br><pre>class Node {<br>    public boolean val;<br>    public boolean isLeaf;<br>    public Node topLeft;<br>    public Node topRight;<br>    public Node bottomLeft;<br>    public Node bottomRight;<br>}</pre><br><br>We can construct a Quad-Tree from a two-dimensional area using the following steps:<br><br>1.  If the current grid has the same value (i.e all <code>1&#39;s</code> or all <code>0&#39;s</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.<br>2.  If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.<br>3.  Recurse for each of the children with the proper sub-grid.<br><br><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt=""><br><br>If you want to know more about the Quad-Tree, you can refer to the <a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank" rel="noopener">wiki</a>.<br><br><strong>Quad-Tree format:</strong><br><br>The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.<br><br>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.<br><br>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1],[1,0]]<br><strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]<br><strong>Explanation:</strong> The explanation of this example is shown below:<br>Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.<br><img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt=""><br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]<br><strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]<br><strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.<br>The topLeft, bottomLeft and bottomRight each has the same value.<br>The topRight have different values so we divide it into 4 sub-grids where each has the same value.<br>Explanation is shown in the photo below:<br><img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt=""><br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == grid.length == grid[i].length</code></em>   <code>n == 2&lt;sup&gt;x&lt;/sup&gt;</code> where <code>0 &lt;= x &lt;= 6</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>由矩阵建四叉树。矩阵有0和1组成。按以下步骤：若子矩阵(变成为2的幂)只含1或0，生成一个叶子节点，值为该值；子矩阵含0和1混合，值为0或1(均为答案)，非叶子节点，递归四个同样大小的矩阵生成相应节点。<br>矩阵大小为2的幂，最小长度为1.  </p><h3 id="presum解题思路-推荐-："><a href="#presum解题思路-推荐-：" class="headerlink" title="presum解题思路(推荐)："></a><strong>presum解题思路(推荐)：</strong></h3><p>这是我的方法，按照定义求解，定义是递归的，所以用DFS。而统计子矩阵和用presum提高效率。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>子矩阵presum用模板</li><li>终止条件为子矩阵sum是0或n平方</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(self, grid: List[List[int]])</span> -&gt; 'Node':</span></span><br><span class="line">presum = self.get_presum(grid)</span><br><span class="line"><span class="keyword">return</span> self.dfs(grid, (<span class="number">0</span>, <span class="number">0</span>), (len(grid) - <span class="number">1</span>, len(grid[<span class="number">0</span>]) - <span class="number">1</span>), presum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">grim_sum = self.get_grid_sum(top_left, bottom_right, presum)</span><br><span class="line"><span class="keyword">if</span> grim_sum == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">0</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">if</span> grim_sum == (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>) * (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">1</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">node = Node(<span class="number">1</span>, <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">row_mid = top_left[<span class="number">0</span>] + (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">col_mid = top_left[<span class="number">1</span>] + (bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]) // <span class="number">2</span></span><br><span class="line">node.topLeft = self.dfs(grid, top_left, (row_mid, col_mid), presum)</span><br><span class="line">node.topRight = self.dfs(grid, (top_left[<span class="number">0</span>], col_mid + <span class="number">1</span>), (row_mid, bottom_right[<span class="number">1</span>]), presum)</span><br><span class="line">node.bottomLeft = self.dfs(grid, (row_mid + <span class="number">1</span>, top_left[<span class="number">1</span>]), (bottom_right[<span class="number">0</span>], col_mid), presum)</span><br><span class="line">node.bottomRight = self.dfs(grid, (row_mid + <span class="number">1</span>, col_mid + <span class="number">1</span>), bottom_right, presum)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grid_sum</span><span class="params">(self, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">left = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[bottom_right[<span class="number">0</span>]][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">top = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][bottom_right[<span class="number">1</span>]]</span><br><span class="line">diag = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">or</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> presum[bottom_right[<span class="number">0</span>]][bottom_right[<span class="number">1</span>]] - left - top + diag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_presum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">presum = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">row_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">row_sum += grid[i][j]</span><br><span class="line">presum[i][j] = row_sum + (presum[i - <span class="number">1</span>][j] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> presum</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>`，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><hr><h3 id="单格DFS算法II解题思路："><a href="#单格DFS算法II解题思路：" class="headerlink" title="单格DFS算法II解题思路："></a><strong>单格DFS算法II解题思路：</strong></h3><p>也是DFS，但递归终止条件为长度1，也就是每个cell都是叶子节点，先递归然后再归纳，若四个儿子节点都是叶子节点且值都相等，合并为一个叶子节点。否则为非叶子节点。<br>此算法实现更简单，但比较难想出。上述方法思想是按照题意。</p><p><a href="https://leetcode.com/problems/construct-quad-tree/discuss/154565/Java-recursive-solution" target="_blank" rel="noopener">Ref</a></p><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>`，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-quad-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Uber" scheme="https://shineboy2013.github.com/tags/Uber/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 387 First Unique Character in a String</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-387/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-387/</id>
    <published>2022-01-04T10:44:05.118Z</published>
    <updated>2022-01-04T10:46:37.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “loveleetcode”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aabb”<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> consists of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串中第一个唯一的字符下标</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题。先统计频率，然后再遍历一次字符串找到频率为1的字符</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> char_to_count[s[i]] == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>, 26个字母为常量空间  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/first-unique-character-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 339 Nested List Weight Sum</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-339/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-339/</id>
    <published>2022-01-04T10:14:00.356Z</published>
    <updated>2022-01-04T10:20:24.285Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.<br><br>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer’s value set to its <strong>depth</strong>.<br><br>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>depth</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex1.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Four 1’s at depth 2, one 2 at depth 1. 1<em>2 + 1</em>2 + 2<em>1 + 1</em>2 + 1<em>2 = 10.<br></em></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex2.png" alt=""><br><br><pre><strong>Input:</strong> nestedList = [1,[4,[6]]]<br><strong>Output:</strong> 27<br><strong>Explanation:</strong> One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 11 + 4<em>2 + 6</em>3 = 27.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nestedList = [0]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nestedList.length &lt;= 50</code></em>   The values of the integers in the nested list is in the range <code>[-100, 100]</code>.<br><em>   The maximum <em>*depth</em></em> of any integer is less than or equal to <code>50</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求NestedInteger的和。越深，权重越高</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS按层遍历</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 9中，需要将NestedInteger展开，里面的所有的NestedInteger入列。Python中，用extend来加入list中所有元素到另一个list，而不是append</li><li>按层遍历模板中，不需要level变量，for可以达到。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque(nestedList)</span><br><span class="line">res, layer = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">level_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node.isInteger():</span><br><span class="line">queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">level_sum += node.getInteger()</span><br><span class="line">res += level_sum * layer</span><br><span class="line">layer += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/nested-list-weight-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 074 Search a 2D Matrix</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-074/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-074/</id>
    <published>2022-01-04T09:27:06.283Z</published>
    <updated>2022-01-04T09:26:58.167Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:<br><br><em>   Integers in each row are sorted from left to right.</em>   The first integer of each row is greater than the last integer of the previous row.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code></em>   <code>n == matrix[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 100</code></em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= matrix[i][j], target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>矩阵中每一行有序，下一行的首元素大于上一行的尾元素。求target是否在矩阵中</p><h3 id="列-行搜索解题思路："><a href="#列-行搜索解题思路：" class="headerlink" title="列+行搜索解题思路："></a><strong>列+行搜索解题思路：</strong></h3><p>先对列做二分搜索，再对行</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">col = [matrix[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">row_idx = bisect.bisect(col, target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> row_idx &lt; <span class="number">0</span> <span class="keyword">or</span> row_idx &gt;= len(matrix):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> matrix[row_idx][<span class="number">0</span>] == target:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">col_idx = bisect.bisect(matrix[row_idx], target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> col_idx &lt; <span class="number">0</span> <span class="keyword">or</span> col_idx &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> matrix[row_idx][col_idx] == target <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(n)</code>, 可以写一个二分法来做列搜索，这样空间为常量。  </p><hr><h3 id="全矩阵搜索算法II解题思路："><a href="#全矩阵搜索算法II解题思路：" class="headerlink" title="全矩阵搜索算法II解题思路："></a><strong>全矩阵搜索算法II解题思路：</strong></h3><p>对矩阵的左上，右下元素作为start, end得到mid转化成(i, j)找到矩阵位置。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi = matrix.length*matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line"><span class="comment">// Key is in a[lo..hi] or not present.</span></span><br><span class="line"><span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> x = mid/matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> y = mid%matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">if</span> (target &lt; matrix[x][y])</span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[x][y])</span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(1)</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 008 String to Integer (atoi)</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-008/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-008/</id>
    <published>2022-01-04T08:58:32.853Z</published>
    <updated>2022-01-04T09:03:01.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).<br><br>The algorithm for <code>myAtoi(string s)</code> is as follows:<br><br>1.  Read in and ignore any leading whitespace.<br>2.  Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.<br>3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.<br>4.  Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).<br>5.  If the integer is out of the 32-bit signed integer range <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2&lt;sup&gt;31&lt;/sup&gt;</code> should be clamped to <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>, and integers greater than <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code> should be clamped to <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br>6.  Return the integer as the final result.<br><br><strong>Note:</strong><br><br><em>   Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</em>   <strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “42”<br><strong>Output:</strong> 42<br><strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.<br>Step 1: “42” (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: “42” (no characters read because there is neither a ‘-‘ nor ‘+’)<br>         ^<br>Step 3: “<u>42</u>“ (“42” is read in)<br>           ^<br>The parsed integer is 42.<br>Since 42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 42.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “   -42”<br><strong>Output:</strong> -42<br><strong>Explanation:</strong><br>Step 1: “-42” (leading whitespace is read and ignored)<br>            ^<br>Step 2: “   <u>-</u>42” (‘-‘ is read, so the result should be negative)<br>             ^<br>Step 3: “   -<u>42</u>“ (“42” is read in)<br>               ^<br>The parsed integer is -42.<br>Since -42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is -42.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “4193 with words”<br><strong>Output:</strong> 4193<br><strong>Explanation:</strong><br>Step 1: “4193 with words” (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: “4193 with words” (no characters read because there is neither a ‘-‘ nor ‘+’)<br>         ^<br>Step 3: “<u>4193</u> with words” (“4193” is read in; reading stops because the next character is a non-digit)<br>             ^<br>The parsed integer is 4193.<br>Since 4193 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 4193.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= s.length &lt;= 200</code></em>   <code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串转整数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>空字符或全空格返回0</li><li>若有符号只能第一位是符号，连续是符号不合法返回0，如-+12, <strong>将符号处理放在循环外</strong></li><li>除符号外，若第一位为非数字，不合法，返回0</li><li>循环内，若出现非数字，跳出循环</li><li>计算符号，然后检查数字范围</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">s = s.strip()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> s[<span class="number">0</span>].isdigit():</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res, start_read_flag = <span class="number">0</span>, <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">res = res * <span class="number">10</span> + ord(char) - ord(<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res *= sign</span><br><span class="line"><span class="keyword">if</span> res &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line"><span class="keyword">return</span> -pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 016 3Sum Closest</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-016/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-016/</id>
    <published>2022-01-04T08:20:04.305Z</published>
    <updated>2022-01-04T08:22:15.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.<br><br>Return <em>the sum of the three integers</em>.<br><br>You may assume that each input would have exactly one solution.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-1,2,1,-4], target = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,0,0], target = 1<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>3 &lt;= nums.length &lt;= 1000</code></em>   <code>-1000 &lt;= nums[i] &lt;= 1000</code><br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>三数和最接近target</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>此题不需去重，若等于target可直接返回 </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">temp = nums[i] + nums[left] + nums[right]</span><br><span class="line"><span class="keyword">if</span> abs(temp - target) &lt; abs(res - target):</span><br><span class="line">res = temp</span><br><span class="line"><span class="keyword">if</span> temp &lt; target:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> temp &gt; target:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 088 Merge Sorted Array</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-088/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-088/</id>
    <published>2022-01-04T07:58:40.595Z</published>
    <updated>2022-01-04T08:01:29.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.<br><br><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.<br><br>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br><strong>Output:</strong> [1,2,2,3,5,6]<br><strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0<br><strong>Output:</strong> [1]<br><strong>Explanation:</strong> The arrays we are merging are [1] and [].<br>The result of the merge is [1].<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1<br><strong>Output:</strong> [1]<br><strong>Explanation:</strong> The arrays we are merging are [] and [1].<br>The result of the merge is [1].<br>Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>nums1.length == m + n</code></em>   <code>nums2.length == n</code><br><em>   <code>0 &lt;= m, n &lt;= 200</code></em>   <code>1 &lt;= m + n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums1[i], nums2[j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br><em>*Follow up:</em></em> Can you come up with an algorithm that runs in <code>O(m + n)</code> time?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>合并两有序数组，最后结果储存在第一个数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从后往前合并</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>i从m - 1而不是len(nums1) - 1开始，m和n是数组实际长度。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, len(nums1) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-034/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-034/</id>
    <published>2022-01-04T07:29:57.188Z</published>
    <updated>2022-01-04T07:32:22.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求有序数列中元素等于target的第一个和最后一个下标</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用模板</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组为空的情况要返回-1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">first = self.first_position(nums, target)</span><br><span class="line">last = self.last_position(nums, target)</span><br><span class="line"><span class="keyword">return</span> [first, last]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start+ (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 787 Cheapest Flights Within K Stops</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-787/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-787/</id>
    <published>2022-01-04T05:15:53.988Z</published>
    <updated>2022-01-04T05:31:17.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt;, price&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is a flight from city <code>from&lt;sub&gt;i&lt;/sub&gt;</code> to city <code>to&lt;sub&gt;i&lt;/sub&gt;</code> with cost <code>price&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from</em> <code>src</code> <em>to</em> <code>dst</code> <em>with at most</em> <code>k</code> <em>stops.</em> If there is no such route, return<code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""><br><br><pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1<br><strong>Output:</strong> 200<br><strong>Explanation:</strong> The graph is shown.<br>The cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt=""><br><br><pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0<br><strong>Output:</strong> 500<br><strong>Explanation:</strong> The graph is shown.<br>The cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 100</code></em>   <code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code><br><em>   <code>flights[i].length == 3</code></em>   <code>0 &lt;= from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt; &lt; n</code><br><em>   <code>from&lt;sub&gt;i&lt;/sub&gt; != to&lt;sub&gt;i&lt;/sub&gt;</code></em>   <code>1 &lt;= price&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   There will not be any multiple flights between two cities.</em>   <code>0 &lt;= src, dst, k &lt; n</code><br>*   <code>src != dst</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求只允许停k个站情况下，最便宜机票价格</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS + Heap<br>这是单源最短路径的典型应用。可以用Dijkstra，机票价格相当于单源最短路径问题中的路径大小。一开始我用BFS，但得到TLE，因为存在循环，导致节点被重复访问(同一路径)。但一个节点的确可以被用不同路径访问。所以引入visited[node] = dis </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>node需要被多次访问，所以跟模板不同，visited的检测要放在neighbor循环之外且用node且初始化为空。visited不再是set，它需要记录node离src的距离。一方面用于循环检测，因为如果存在循环，会出现dist &gt;= visited[node]。若该节点的当前距离小于之前的最小距离，此时也要加入到heap，因为贪婪法，虽然此路径费用较高，但它距离更近，当k限制比较小时，此路径可能满足要求。这就是为什么一个节点会被多次访问的原因。</li><li><strong>若路径不存在返回-1</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, k: int)</span> -&gt; int:</span></span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> flights:</span><br><span class="line">graph[pair[<span class="number">0</span>]].append((pair[<span class="number">1</span>], pair[<span class="number">2</span>]))</span><br><span class="line">heap = ([(<span class="number">0</span>, src, <span class="number">0</span>)])</span><br><span class="line">visited = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">p, node, dist = heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> node == dst <span class="keyword">and</span> dist &lt;= k + <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> visited <span class="keyword">and</span> dist &gt;= visited[node]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">visited[node] = dist</span><br><span class="line"><span class="keyword">for</span> neighbor, _price <span class="keyword">in</span> graph[node]:</span><br><span class="line">heapq.heappush(heap, (p + _price, neighbor, dist + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(VlogV)</code>，空间复杂度<code>O(V)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/cheapest-flights-within-k-stops&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 166 Fraction to Recurring Decimal</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-166/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-166/</id>
    <published>2022-01-04T01:30:18.321Z</published>
    <updated>2022-01-04T02:21:37.543Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.<br><br>If the fractional part is repeating, enclose the repeating part in parentheses.<br><br>If multiple answers are possible, return <strong>any of them</strong>.<br><br>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10&lt;sup&gt;4&lt;/sup&gt;</code> for all the given inputs.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numerator = 1, denominator = 2<br><strong>Output:</strong> “0.5”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numerator = 2, denominator = 1<br><strong>Output:</strong> “2”<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> numerator = 4, denominator = 333<br><strong>Output:</strong> “0.(012)”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= numerator, denominator &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></em>   <code>denominator != 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体<br><img src="/images/L166.png" alt=""> </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>小学定理为若余数重复则前重复对应的结果到目前位置的前一位为循环体</strong>，并不是digit一样，而是余数。类似于L003 Longest Substring Without Repeating Characters，记录余数到商下标。循环中顺序很重要，与长除法一致(上图)。分子为remainder，查看remainder是否重复，若否，<strong>加入到map</strong>，乘以10，求商和新余数，进入下一轮迭代。</li><li>输入均为负数或其一为负数的情况，计算结果符号，分子分母分别转成正数</li><li>分子大于分母或分子小于分母的情况都归结为用分子除以分母，加入到结果，若有余数，再加小数点</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span><span class="params">(self, numerator: int, denominator: int)</span> -&gt; str:</span></span><br><span class="line">res, remainder_to_pos = <span class="string">''</span>, collections.defaultdict(int)</span><br><span class="line">is_negative, remainder = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> numerator / denominator &lt; <span class="number">0</span>:</span><br><span class="line">is_negative = <span class="number">-1</span></span><br><span class="line">numerator = abs(numerator)</span><br><span class="line">denominator = abs(denominator)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">if numerator &lt; denominator:</span></span><br><span class="line"><span class="string">res = '0.'</span></span><br><span class="line"><span class="string">remainder = numerator</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">res = str(numerator // denominator)</span></span><br><span class="line"><span class="string">remainder = numerator % denominator</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">res = str(numerator // denominator)</span><br><span class="line">remainder = numerator % denominator</span><br><span class="line"><span class="keyword">if</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line">res += <span class="string">'.'</span></span><br><span class="line"><span class="keyword">while</span> remainder &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> remainder <span class="keyword">in</span> remainder_to_pos:</span><br><span class="line">res = res[:remainder_to_pos[remainder]] + <span class="string">'('</span> + res[remainder_to_pos[remainder]:] + <span class="string">')'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">remainder_to_pos[remainder] = len(res)  <span class="comment"># remember</span></span><br><span class="line">remainder *= <span class="number">10</span> <span class="comment"># remember not numerator * 10 // denominator</span></span><br><span class="line">res += str(remainder // denominator)</span><br><span class="line">remainder %= denominator</span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">if</span> is_negative == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'-'</span> + res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/fraction-to-recurring-decimal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Airbnb" scheme="https://shineboy2013.github.com/tags/Airbnb/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 281 Zigzag Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-281/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-281/</id>
    <published>2022-01-04T00:10:33.027Z</published>
    <updated>2022-01-04T00:15:20.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/zigzag-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two vectors of integers <code>v1</code> and <code>v2</code>, implement an iterator to return their elements alternately.<br><br>Implement the <code>ZigzagIterator</code> class:<br><br><em>   <code>ZigzagIterator(List&lt;int&gt; v1, List&lt;int&gt; v2)</code> initializes the object with the two vectors <code>v1</code> and <code>v2</code>.</em>   <code>boolean hasNext()</code> returns <code>true</code> if the iterator still has elements, and <code>false</code> otherwise.<br><em>   <code>int next()</code> returns the current element of the iterator and moves the iterator to the next element.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> v1 = [1,2], v2 = [3,4,5,6]<br><strong>Output:</strong> [1,3,2,4,5,6]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> v1 = [1], v2 = []<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> v1 = [], v2 = [1]<br><strong>Output:</strong> [1]<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= v1.length, v2.length &lt;= 1000</code><br><em>   <code>1 &lt;= v1.length + v2.length &lt;= 2000</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= v1[i], v2[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> What if you are given <code>k</code> vectors? How well can your code be extended to such cases?<br><br><strong>Clarification for the follow-up question:</strong><br><br>The “Zigzag” order is not clearly defined and is ambiguous for <code>k &gt; 2</code> cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”.<br><br><strong>Follow-up Example:</strong><br><br><pre><strong>Input:</strong> v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]<br><strong>Output:</strong> [1,4,8,2,5,9,3,6,7]<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两数组轮替取值的Iterator</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>将数组和数组下标分别存于新数组中。用一个list_index来记录要取哪个数组</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Iterator模板，hasNext也是找到下一个元素为止，由于只有两个数组，所以不用循环。取值是一个<strong>二维数组</strong>val = self.input[self.list_index][self.index[self.list_index]]</li><li>next中取值后指针要后移。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Gi
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 284 Peeking Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-284/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-284/</id>
    <published>2022-01-03T23:45:41.427Z</published>
    <updated>2022-01-03T23:48:01.503Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/peeking-iterator/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.<br><br>Implement the <code>PeekingIterator</code> class:<br><br><em>   <code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</em>   <code>int next()</code> Returns the next element in the array and moves the pointer to the next element.<br><em>   <code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</em>   <code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.<br><br><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“PeekingIterator”, “next”, “peek”, “next”, “next”, “hasNext”]<br>[[[1, 2, 3]], [], [], [], [], []]<br><strong>Output</strong><br>[null, 1, 2, 2, 3, false]<br><br><strong>Explanation</strong><br>PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]<br>peekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].<br>peekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].<br>peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]<br>peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]<br>peekingIterator.hasNext(); // return False<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code></em>   <code>1 &lt;= nums[i] &lt;= 1000</code><br><em>   All the calls to <code>next</code> and <code>peek</code> are valid.</em>   At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.<br><br><strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现数组的peeking Iterator。数组的Iterator是给定的。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>预读一个数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>预读一个next数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterator)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.iterator = iterator</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = self.num</span><br><span class="line">        <span class="keyword">if</span> self.iterator.hasNext():</span><br><span class="line">            self.num = self.iterator.next()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.num <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/peeking-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;D
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/iterator/"/>
    <id>https://shineboy2013.github.com/2022/01/03/iterator/</id>
    <published>2022-01-03T21:46:50.282Z</published>
    <updated>2022-01-04T00:24:05.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>hasNext, next都涉及计算下一个元素，大部分题目是先计算再返回。只有BST是先返回再计算，因为BST的下一个节点取决于要返回的节点，若返回了，就无法知道下一个节点。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>hasNext中，while循环找到下一个符合条件的元素</li><li>next中取值后<strong>指针要后移</strong>。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.stack = []</span><br><span class="line">&lt;add to stack&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> self.hasNext():</span><br><span class="line"><span class="keyword">return</span> self.stack.pop()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">while</span> &lt;until find the next element&gt;:</span><br><span class="line">   &lt;calculate&gt;</span><br><span class="line"><span class="keyword">return</span> &lt;next element&gt;</span><br></pre></td></tr></table></figure><h3 id="应用题型："><a href="#应用题型：" class="headerlink" title="应用题型："></a><strong>应用题型：</strong></h3><p><a href="https://shineboy2013.github.io/2022/01/03/lee-251/" target="_blank" rel="noopener">LeetCode 251 Flatten 2D Vector</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-281/" target="_blank" rel="noopener">LeetCode 281 Zigzag Iterator</a><br><a href="https://shineboy2013.github.io/2022/01/03/lee-341/" target="_blank" rel="noopener">LeetCode 341 Flatten Nested List Iterator</a><br><a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></p><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(N + V)/N</code>或<code>O(1)</code>，N为所有数，V为复合结构数 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;hasNext, next都涉及计算下一个元素，大部分题目是先计算再返回。只有BS
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 341 Flatten Nested List Iterator</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-341/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-341/</id>
    <published>2022-01-03T20:55:59.417Z</published>
    <updated>2022-01-03T21:20:27.310Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-nested-list-iterator" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.<br><br>Implement the <code>NestedIterator</code> class:<br><br><em>   <code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</em>   <code>int next()</code> Returns the next integer in the nested list.<br><em>   <code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.<br><br>Your code will be tested with the following pseudocode:<br><br><pre>initialize iterator with nestedList<br>res = []<br>while iterator.hasNext()<br>    append iterator.next() to the end of res<br>return res<br></pre><br><br>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<br><strong>Output:</strong> [1,1,2,1,1]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nestedList = [1,[4,[6]]]<br><strong>Output:</strong> [1,4,6]<br><strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= nestedList.length &lt;= 500</code><br>*   The values of the integers in the nested list is in the range <code>[-10&lt;sup&gt;6&lt;/sup&gt;, 10&lt;sup&gt;6&lt;/sup&gt;]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现Nested List的Iterator。Nested List是NestedInteger的数组，NestedInteger可以是int，也可以是Nested List</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>有点似括号题但区别是从前往后读取。用Queue或Stack都可以，插入或删除其一需要反序，删除nestedinteger(=list)后要将它里面所有nestedinteger加入。Queue要从队首加入和删除，Stack要从栈顶加入和删除，用Stack比较方便。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Stack，<strong>逆序将nestedList中nestedinteger加入到stack，直到栈顶元素为int，hasNext才算结束</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop().getInteger()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> <span class="keyword">not</span> self.stack[<span class="number">-1</span>].isInteger():</span><br><span class="line">            nestedList = self.stack.pop().getList()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nestedList))):</span><br><span class="line">                self.stack.append(nestedList[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(L + N)</code>, N为所有数，V为nested list数，O(N + V)/N. O(1)如果不存在nested list </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flatten-nested-list-iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;di
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 251 Flatten 2D Vector</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-251/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-251/</id>
    <published>2022-01-03T18:21:06.327Z</published>
    <updated>2022-01-03T21:16:28.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/flatten-2d-vector/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Design an iterator to flatten a 2D vector. It should support the <code>next</code> and <code>hasNext</code> operations.<br><br>Implement the <code>Vector2D</code> class:<br><br><em>   <code>Vector2D(int[][] vec)</code> initializes the object with the 2D vector <code>vec</code>.</em>   <code>next()</code> returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to <code>next</code> are valid.<br><em>   <code>hasNext()</code> returns <code>true</code> if there are still some elements in the vector, and <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Vector2D”, “next”, “next”, “next”, “hasNext”, “hasNext”, “next”, “hasNext”]<br>[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]<br><strong>Output</strong><br>[null, 1, 2, 3, true, true, 4, false]<br><br><strong>Explanation</strong><br>Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]);<br>vector2D.next();    // return 1<br>vector2D.next();    // return 2<br>vector2D.next();    // return 3<br>vector2D.hasNext(); // return True<br>vector2D.hasNext(); // return True<br>vector2D.next();    // return 4<br>vector2D.hasNext(); // return False<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= vec.length &lt;= 200</code><br><em>   <code>0 &lt;= vec[i].length &lt;= 500</code></em>   <code>-500 &lt;= vec[i][j] &lt;= 500</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made to <code>next</code> and <code>hasNext</code>.<br><br><em>*Follow up:</em></em> As an added challenge, try to code it using only <a href="http://www.cplusplus.com/reference/iterator/iterator/" target="_blank" rel="noopener">iterators in C++</a> or <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">iterators in Java</a>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现二维Vector的Iterator</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用两个指针</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>单一Vector可以是空，所以next要循环找到非空的vector</li><li>next要col_id加一</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vec: List[List[int]])</span>:</span></span><br><span class="line">        self.vec = vec</span><br><span class="line">        self.row_id = <span class="number">0</span></span><br><span class="line">        self.col_id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            val = self.vec[self.row_id][self.col_id]</span><br><span class="line">            self.col_id += <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> self.row_id &lt; len(self.vec) <span class="keyword">and</span> self.col_id == len(self.vec[self.row_id]): <span class="comment"># remember while coz []</span></span><br><span class="line">            self.row_id += <span class="number">1</span></span><br><span class="line">            self.col_id = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.row_id == len(self.vec):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>每个操作时间复杂度为<code>O(V/N)</code>或<code>O(1)</code>，空间复杂度<code>O(1)</code>, N为所有数，V为vector数，O(N + V)/N. O(1)如果vector都不会空</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/flatten-2d-vector/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Iterator" scheme="https://shineboy2013.github.com/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 036 Valid Sudoku</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-036/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-036/</id>
    <published>2022-01-03T10:40:17.720Z</published>
    <updated>2022-01-03T10:43:56.931Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Write a program to solve a Sudoku puzzle by filling the empty cells.<br><br>A sudoku solution must satisfy <strong>all of the following rules</strong>:<br><br>1.  Each of the digits <code>1-9</code> must occur exactly once in each row.<br>2.  Each of the digits <code>1-9</code> must occur exactly once in each column.<br>3.  Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.<br><br>The <code>&#39;.&#39;</code> character indicates empty cells.<br><br><strong>Example 1:</strong><br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""><br><br><pre><strong>Input:</strong> board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br><strong>Output:</strong> [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br><strong>Explanation:</strong> The input board is shown above and the only valid solution is shown below:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt=""><br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>board.length == 9</code></em>   <code>board[i].length == 9</code><br><em>   <code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</em>   It is <strong>guaranteed</strong> that the input board has only one solution.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断Sudoku是否合法</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 037，用3个global的dict</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>此题和L37有点不同，可以当版上的数是一个个填上的，所以无需初始化将数直接加入到dict中。而是每一位判断是否合法再加入。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">row_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">col_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">box_dict = [collections.defaultdict(int) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.is_valid(i, j, board[i][j], row_dict, col_dict, box_dict):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">row_dict[i][board[i][j]] = <span class="number">1</span></span><br><span class="line">col_dict[j][board[i][j]] = <span class="number">1</span></span><br><span class="line">box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][board[i][j]] = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self, i, j, val, row_dict, col_dict, box_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> val <span class="keyword">in</span> row_dict[i] <span class="keyword">or</span> val <span class="keyword">in</span> col_dict[j] <span class="keyword">or</span> val <span class="keyword">in</span> box_dict[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Writ
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 043 Multiply Strings</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-043/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-043/</id>
    <published>2022-01-03T08:43:09.176Z</published>
    <updated>2022-01-03T08:42:57.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.<br><br><strong>Note:</strong> You must not use any built-in BigInteger library or convert the inputs to integer directly.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num1 = “2”, num2 = “3”<br><strong>Output:</strong> “6”<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num1 = “123”, num2 = “456”<br><strong>Output:</strong> “56088”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num1.length, num2.length &lt;= 200</code></em>   <code>num1</code> and <code>num2</code> consist of digits only.<br>*   Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number <code>0</code> itself.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求字符串乘法结果</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>模拟小学乘法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>模拟小学乘法，开一个大小为len(num1) + len(num2)的整数数组，内外循环计算每位结果。这位可能是大于20的数，如20, 30..。计算前先反转输入，得到最后结果后也反转。</li><li>结果要消除前缀0，但注意<strong>0乘以0的情况会返回空</strong>，所以要特别处理。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">digits = [<span class="number">0</span>] * (len(num1) + len(num2))</span><br><span class="line">num1, num2 = num1[::<span class="number">-1</span>], num2[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">digits[i + j] += int(num1[i]) * int(num2[j])</span><br><span class="line">carry, res = <span class="number">0</span>, <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)):</span><br><span class="line">n = digits[i] + carry</span><br><span class="line">carry = n // <span class="number">10</span></span><br><span class="line">res += str(n % <span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0'</span> <span class="keyword">if</span> res[::<span class="number">-1</span>].lstrip(<span class="string">'0'</span>) == <span class="string">''</span> <span class="keyword">else</span> res[::<span class="number">-1</span>].lstrip(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/multiply-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;G
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 048 Rotate Image</title>
    <link href="https://shineboy2013.github.com/2022/01/02/lee-048/"/>
    <id>https://shineboy2013.github.com/2022/01/02/lee-048/</id>
    <published>2022-01-03T07:32:48.043Z</published>
    <updated>2022-01-03T07:35:45.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).<br><br>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]<br><strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == matrix.length == matrix[i].length</code></em>   <code>1 &lt;= n &lt;= 20</code><br>*   <code>-1000 &lt;= matrix[i][j] &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>顺时针循环矩阵90度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先上下对称，再沿正对角线(左上到右下)对称。正对角线实现比较容易</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先上下对称，再沿正对角线(左上到右下)对称。正对角线实现比较容易</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix) // <span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[i][j], matrix[len(matrix) - <span class="number">1</span> - i][j] = matrix[len(matrix) - <span class="number">1</span> - i][j], matrix[i][j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You a
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 395 Longest Substring with At Least K Repeating Characters</title>
    <link href="https://shineboy2013.github.com/2022/01/01/lee-395/"/>
    <id>https://shineboy2013.github.com/2022/01/01/lee-395/</id>
    <published>2022-01-01T23:03:35.789Z</published>
    <updated>2022-01-01T23:18:14.903Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aaabb”, k = 3<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest substring is “aaa”, as ‘a’ is repeated 3 times.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ababbc”, k = 2<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>s</code> consists of only lowercase English letters.<br>*   <code>1 &lt;= k &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最长每种字符至少k个的子串  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L003 Longest Substring Without Repeating Characters用双指针法，难点是每种字符，用26字母存储法解决。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>按多少种不同字符来做sliding window。有1-26种。  </li><li>子函数求给定种数下的最长子串，所以满足条件在外循环不在内循环，还需进一步统计每种字符是否符合k个。内循环为不满足条件的情况unique_count == n + 1   </li><li>char_count[26]记录每种字符个数, unique_count是子串[left, i]之间多少种。   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestSubstring</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">res = max(res, self.longest_substring(s, k, i))</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_substring</span><span class="params">(self, s, k, n)</span> -&gt; int:</span></span><br><span class="line">left, char_count = <span class="number">0</span>, [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">res, unique_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">char_count[ord(s[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char_count[ord(s[i]) - ord(<span class="string">'a'</span>)] == <span class="number">1</span>:</span><br><span class="line">unique_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unique_count == n + <span class="number">1</span>:</span><br><span class="line">char_count[ord(s[left]) - ord(<span class="string">'a'</span>)] -= <span class="number">1</span> <span class="comment"># use left not i</span></span><br><span class="line"><span class="keyword">if</span> char_count[ord(s[left]) - ord(<span class="string">'a'</span>)] == <span class="number">0</span>:</span><br><span class="line">unique_count -= <span class="number">1</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">valid_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line"><span class="keyword">if</span> char_count[j] &gt; <span class="number">0</span> <span class="keyword">and</span> char_count[j] &gt;= k:</span><br><span class="line">valid_count += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> unique_count == valid_count:</span><br><span class="line">res = max(res, i - left + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(26*26n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 101 Symmetric Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/30/lee-101/"/>
    <id>https://shineboy2013.github.com/2021/12/30/lee-101/</id>
    <published>2021-12-30T09:48:56.828Z</published>
    <updated>2022-01-01T03:25:52.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt=""></p><pre>**Input:** root = [1,2,2,3,4,4,3]**Output:** true</pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt=""></p><pre>**Input:** root = [1,2,2,null,3,null,3]**Output:** false</pre><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断二叉树是否对称</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，但难点是转化成比较两棵树是否对称</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点是转化成比较两棵树是否对称    </li><li>还要比较值相等，root.val == root2.val</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> self.is_symmetric(root.left, root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetric</span><span class="params">(self, root, root2)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> root.val == root2.val <span class="keyword">and</span> self.is_symmetric(root.left, root2.right) <span class="keyword">and</span> self.is_symmetric(root.right, root2.left)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/symmetric-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given the &lt;co
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
</feed>
