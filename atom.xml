<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-17T07:51:14.592Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 142 Linked List Cycle II</title>
    <link href="https://shineboy2013.github.com/2022/01/16/leetcode-142-linked-list-cycle-ii/"/>
    <id>https://shineboy2013.github.com/2022/01/16/leetcode-142-linked-list-cycle-ii/</id>
    <published>2022-01-17T07:37:27.907Z</published>
    <updated>2022-01-17T07:51:14.592Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.<br><br>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.<br><br><strong>Do not modify</strong> the linked list.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""><br><br><pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1<br><strong>Output:</strong> tail connects to node index 1<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""><br><br><pre><strong>Input:</strong> head = [1,2], pos = 0<br><strong>Output:</strong> tail connects to node index 0<br><strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""><br><br><pre><strong>Input:</strong> head = [1], pos = -1<br><strong>Output:</strong> no cycle<br><strong>Explanation:</strong> There is no cycle in the linked list.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of the nodes in the list is in the range <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.<br><br><em>*Follow up:</em></em> Can you solve it using <code>O(1)</code> (i.e. constant) memory?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求LL是否存在循环，若存在返回循环起点</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先用快慢指针找到相遇点，然后将slow指针移回fake_head起点，同速度移动直到相遇即为所求</p><p>证明：<br><img src="/images/L042-3.png" alt=""><br>A为起点，B为快慢指针相遇点，假设长度分别为z, y, x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fast在相遇时走过的距离为: z + x + y + y, 比slow多走一圈  </span><br><span class="line">slow在相遇时走过的距离为: z + y  </span><br><span class="line">由于fast速度是slow的两倍，所以相遇时，同一时间内，走过的距离也是两倍。</span><br><span class="line">z + x + y + y = 2 * (z + y)</span><br><span class="line">x = z得证</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>循环可能不存在，此时返回None</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">fake_head.next = head</span><br><span class="line">fast, slow = fake_head, fake_head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line"><span class="keyword">if</span> fast != fake_head <span class="keyword">and</span> fast == slow:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span> <span class="comment"># remember</span></span><br><span class="line">slow = fake_head</span><br><span class="line"><span class="keyword">while</span> fast != slow:</span><br><span class="line">fast, slow = fast.next, slow.next</span><br><span class="line"><span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 141 Linked List Cycle</title>
    <link href="https://shineboy2013.github.com/2022/01/16/leetcode-141-linked-list-cycle/"/>
    <id>https://shineboy2013.github.com/2022/01/16/leetcode-141-linked-list-cycle/</id>
    <published>2022-01-17T05:38:38.947Z</published>
    <updated>2022-01-17T05:48:50.514Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.<br><br>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.<br><br>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""><br><br><pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""><br><br><pre><strong>Input:</strong> head = [1,2], pos = 0<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""><br><br><pre><strong>Input:</strong> head = [1], pos = -1<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no cycle in the linked list.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of the nodes in the list is in the range <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.<br><br><em>*Follow up:</em></em> Can you solve it using <code>O(1)</code> (i.e. constant) memory?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求LL是否存在循环</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>快慢指针。若存在循环就一定会相遇，这是显然的。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>一开始快慢指针指向fake_head节点，进入循环再次相等(不等于fake_head)即存在循环</li><li><strong>要引入fake_head</strong>，否则若一开始指向首节点，下次相等可能仍在首节点(如两个节点循环)，这样不能区别是否再次相等</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">fake_head.next = head</span><br><span class="line">fast, slow = fake_head, fake_head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line"><span class="keyword">if</span> fast != fake_head <span class="keyword">and</span> fast == slow: <span class="comment"># remember to move first then judge</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">fast, slow = fast.next.next, slow.next</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 136 Single Number</title>
    <link href="https://shineboy2013.github.com/2022/01/16/leetcode-136-single-number/"/>
    <id>https://shineboy2013.github.com/2022/01/16/leetcode-136-single-number/</id>
    <published>2022-01-17T03:43:56.937Z</published>
    <updated>2022-01-17T03:50:48.273Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.<br><br>You must implement a solution with a linear runtime complexity and use only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,2,1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [4,1,2,1,2]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 3 </em> 10<sup>4</sup><code>*</code>-3 <em> 10<sup>4</sup> &lt;= nums[i] &lt;= 3 </em> 10<sup>4</sup>`<br>*   Each element in the array appears twice except for one element which appears only once.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数列中，所有数都出现两次除了一个数，求这一个数</p><h3 id="异或解题思路-推荐-："><a href="#异或解题思路-推荐-：" class="headerlink" title="异或解题思路(推荐)："></a><strong>异或解题思路(推荐)：</strong></h3><p>Easy题</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">res ^= n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="HashMap算法II解题思路："><a href="#HashMap算法II解题思路：" class="headerlink" title="HashMap算法II解题思路："></a><strong>HashMap算法II解题思路：</strong></h3><p>记录频数，最直观解法</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">num_to_count = collections.Counter(nums)</span><br><span class="line"><span class="keyword">return</span> [n <span class="keyword">for</span> n, count <span class="keyword">in</span> num_to_count.items() <span class="keyword">if</span> count == <span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="Math算法III解题思路："><a href="#Math算法III解题思路：" class="headerlink" title="Math算法III解题思路："></a><strong>Math算法III解题思路：</strong></h3><p>用set求单一元素和乘以2减去原数组的和</p><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * sum(set(nums)) - sum(nums)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="https://shineboy2013.github.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 129 Sum Root to Leaf Numbers</title>
    <link href="https://shineboy2013.github.com/2022/01/16/leetcode-129-sum-root-to-leaf-numbers/"/>
    <id>https://shineboy2013.github.com/2022/01/16/leetcode-129-sum-root-to-leaf-numbers/</id>
    <published>2022-01-17T03:19:03.139Z</published>
    <updated>2022-01-17T03:24:10.229Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.<br><br>Each root-to-leaf path in the tree represents a number.<br><br><em>   For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.<br><br>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.<br><br>A <strong>leaf</strong> node is a node with no children.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 25<br><strong>Explanation:</strong><br>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.<br>Therefore, sum = 12 + 13 = <code>25</code>.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,9,0,5,1]<br><strong>Output:</strong> 1026<br><strong>Explanation:</strong><br>The root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.<br>The root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.<br>The root-to-leaf path <code>4-&gt;0</code> represents the number 40.<br>Therefore, sum = 495 + 491 + 40 = <code>1026</code>.<br></pre><br><br><strong>Constraints:</strong></em>   The number of nodes in the tree is in the range <code>[1, 1000]</code>.<br><em>   <code>0 &lt;= Node.val &lt;= 9</code></em>   The depth of the tree will not exceed <code>10</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>由root到叶子节点的数字组成多位数的数，求这些数的总和</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>题目提到叶子节点，所以DFS中要含叶子节点的情况</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目提到叶子节点，所以DFS中要含叶子节点的情况。当然还要有root为空的情况，这样root.left和root.right不用非空检查，代码更简洁</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">current = path * <span class="number">10</span> + root.val</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line"><span class="keyword">return</span> current</span><br><span class="line"><span class="comment">#if root.left #if root.right:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(root.left, current) + self.dfs(root.right, current)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/sum-root-to-leaf-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 125 Valid Palindrome</title>
    <link href="https://shineboy2013.github.com/2022/01/16/lee-125-valid-palindrome/"/>
    <id>https://shineboy2013.github.com/2022/01/16/lee-125-valid-palindrome/</id>
    <published>2022-01-17T01:12:52.915Z</published>
    <updated>2022-01-17T01:24:20.982Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-palindrome" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “A man, a plan, a canal: Panama”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “amanaplanacanalpanama” is a palindrome.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “race a car”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “raceacar” is not a palindrome.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ “<br><strong>Output:</strong> true<br><strong>Explanation:</strong> s is an empty string “” after removing non-alphanumeric characters.<br>Since an empty string reads the same forward and backward, it is a palindrome.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 2 </em> 10<sup>5</sup><code>*</code>s` consists only of printable ASCII characters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求含非字母数字的字符串是否回文，字符串含空格，冒号等. Easy题</p><h3 id="双指针解题思路-推荐-："><a href="#双指针解题思路-推荐-：" class="headerlink" title="双指针解题思路(推荐)："></a><strong>双指针解题思路(推荐)：</strong></h3><p>回文首先考虑用相向双指针</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较时，要转换成小写</li><li>外循环left &lt; right条件要复制到内循环中</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">left, right = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[left].lower() != s[right].lower():</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="reverse法算法II解题思路："><a href="#reverse法算法II解题思路：" class="headerlink" title="reverse法算法II解题思路："></a><strong>reverse法算法II解题思路：</strong></h3><p>reverse字符串比较</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较时，要转换成小写</li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome2</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char.isalpha() <span class="keyword">or</span> char.isdigit():</span><br><span class="line">res += char.lower()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> res == res[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-palindrome&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;A 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 118 Pascal&#39;s Triangle</title>
    <link href="https://shineboy2013.github.com/2022/01/16/lee-118-pascals-triangle/"/>
    <id>https://shineboy2013.github.com/2022/01/16/lee-118-pascals-triangle/</id>
    <published>2022-01-17T00:37:47.840Z</published>
    <updated>2022-01-17T00:42:16.335Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/pascals-triangle" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.<br><br>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:<br><br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> numRows = 5<br><strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> numRows = 1<br><strong>Output:</strong> [[1]]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= numRows &lt;= 30</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n行，产生n行的杨辉三角</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用DP按照定义生成，其实类似于Fibonacci数列，不过是二维的，而不是一维。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>初始值为[1]</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">path, res = [<span class="number">1</span>], []</span><br><span class="line">res.append(path)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, numRows):</span><br><span class="line">next_level = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(path)):</span><br><span class="line">next_level.append(path[j - <span class="number">1</span>] + path[j])</span><br><span class="line">next_level.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">next_level.append(<span class="number">1</span>)</span><br><span class="line">path = next_level</span><br><span class="line">res.append(list(path))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(numRows<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/pascals-triangle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Gi
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 100 Same Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/16/lee-100/"/>
    <id>https://shineboy2013.github.com/2022/01/16/lee-100/</id>
    <published>2022-01-16T22:24:14.351Z</published>
    <updated>2022-01-16T22:26:49.846Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.<br><br>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2,3], q = [1,2,3]<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2], q = [1,null,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt=""><br><br><pre><strong>Input:</strong> p = [1,2,1], q = [1,1,2]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in both trees is in the range <code>[0, 100]</code>.</em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断二叉树是否相等</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 101 Symmetric Tree但稍简单, easy题</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/same-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given th
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 093 Restore IP Addresses</title>
    <link href="https://shineboy2013.github.com/2022/01/16/lee-093/"/>
    <id>https://shineboy2013.github.com/2022/01/16/lee-093/</id>
    <published>2022-01-16T21:34:16.689Z</published>
    <updated>2022-01-16T22:16:08.858Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.<br><br><em>   For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.<br><br>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “25525511135”<br><strong>Output:</strong> [“255.255.11.135”,”255.255.111.35”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “0000”<br><strong>Output:</strong> [“0.0.0.0”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “101023”<br><strong>Output:</strong> [“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= s.length &lt;= 20</code><br>*   <code>s</code> consists of digits only.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数字字符串，求以分解成合法IP的所有解。IP每段范围是0-255且不能有前缀0，如06</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有解，所以用DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用DFS模板，属于结果分组型DFS，dfs函数有k。</li><li>两个限制条件，不能含leading zero和数字范围在255内</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(s, <span class="number">0</span>, [], res, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, st, path, res, k)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(s) <span class="keyword">and</span> k == <span class="number">0</span>:</span><br><span class="line">res.append(<span class="string">'.'</span>.join(path))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> st == len(s) <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, min(st + <span class="number">3</span>, len(s))):</span><br><span class="line">segment = s[st:i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> len(segment) &gt; <span class="number">1</span> <span class="keyword">and</span> segment[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment"># no leading 0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> int(segment) &gt; <span class="number">255</span>: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">path.append(segment)</span><br><span class="line">self.dfs(s, i + <span class="number">1</span>, path, res, k - <span class="number">1</span>)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 由于IP固定是4个部分，每个部分最多3位，所以乘法原理第一个dot的选择有三个位置，其他两个dot如此类推，3x3x3=27  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/restore-ip-addresses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 091 Decode Ways</title>
    <link href="https://shineboy2013.github.com/2022/01/16/lee-091/"/>
    <id>https://shineboy2013.github.com/2022/01/16/lee-091/</id>
    <published>2022-01-16T19:56:46.663Z</published>
    <updated>2022-01-16T21:00:35.177Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:<br><br><pre>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br></pre><br><br>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:<br><br><em>   <code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></em>   <code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code><br><br>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.<br><br>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.<br><br>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “12”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> “12” could be decoded as “AB” (1 2) or “L” (12).<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “226”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> “226” could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “06”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “06” cannot be mapped to “F” because of the leading zero (“6” is different from “06”).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 100</code></em>   <code>s</code> contains only digits and may contain leading zero(s).<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数字1-26可以解码成A-Z字母。给定一串数字，求解码方法数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求种数是DP和DFS，这题有递归关系，所以考虑用DP。类似于Fibonacci数列和LeetCode 070 Climbing Stairs，但此题带限制条件</p><p>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>利用DP五点注意事项</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不合法的情况为空字符和含0. 这是求个数，根据DP知识点(数值到个数DP模板)，dp[0] = 1, 但这与题目空字符要求不同，所以特别处理。至于单个含0在循环中处理’0’ &lt; s[i - 1] &lt;= ‘9’</li><li>验证单位范围[1, 9], 双位范围[10, 26]才加入到结果中。由于dp长度只多了一位而递归式含两个前状态，所以要验证i &gt;= 2</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">if</span> <span class="string">'0'</span> &lt; s[i - <span class="number">1</span>] &lt;= <span class="string">'9'</span>:</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="string">'10'</span> &lt;= s[i - <span class="number">2</span>: i] &lt;= <span class="string">'26'</span>:</span><br><span class="line">dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="O-1-空间算法II解题思路："><a href="#O-1-空间算法II解题思路：" class="headerlink" title="O(1)空间算法II解题思路："></a><strong>O(1)空间算法II解题思路：</strong></h3><p>类似于Fibonacci数列和LeetCode 070 Climbing Stairs，由于涉及到两个前状态，所以用两个变量来节省空间</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[i-1] + dp[i-2] if 0 &lt; s[i-1] &lt;= 9, 10 &lt;= s[i-2:i] &lt;= 26</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">first, second = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'0'</span> &lt; s[i - <span class="number">1</span>] &lt;= <span class="string">'9'</span>:</span><br><span class="line">res = second</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="string">'10'</span> &lt;= s[i - <span class="number">2</span>: i] &lt;= <span class="string">'26'</span>:</span><br><span class="line">res += first</span><br><span class="line">first, second = second, res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;A mess
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 092 Reverse Linked List II</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-092/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-092/</id>
    <published>2022-01-16T07:57:48.833Z</published>
    <updated>2022-01-16T08:05:24.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4<br><strong>Output:</strong> [1,4,3,2,5]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> head = [5], left = 1, right = 1<br><strong>Output:</strong> [5]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the list is <code>n</code>.</em>   <code>1 &lt;= n &lt;= 500</code><br><em>   <code>-500 &lt;= Node.val &lt;= 500</code></em>   <code>1 &lt;= left &lt;= right &lt;= n</code><br><br><strong>Follow up:</strong> Could you do it in one pass?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>反转链表中的子链表[left, right]，start和end是1-index位置, inclusive</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>锁定start和end节点，将end的后续节点一个个加到start直接后续</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>经典题，见LeetCode 2074 Reverse Nodes in Even Length Groups。 思路是<strong>锁定start和end节点，将end的后续节点一个个加到start直接后续</strong></li><li>第二个循环中，right要记得减一，否则死循环</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span></span><br><span class="line">left, right = left - <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">fake_head.next = head</span><br><span class="line">it = fake_head</span><br><span class="line"><span class="keyword">while</span> left &gt; <span class="number">0</span>:</span><br><span class="line">it = it.next</span><br><span class="line">left -= <span class="number">1</span></span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line">start, end = it, it.next</span><br><span class="line"><span class="keyword">while</span> right &gt; <span class="number">0</span>:</span><br><span class="line">moved_node, end.next = end.next, end.next.next <span class="comment"># delete a node</span></span><br><span class="line">start.next, moved_node.next = moved_node, start.next <span class="comment"># insert a node</span></span><br><span class="line">right -= <span class="number">1</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 090 Subsets II</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-090/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-090/</id>
    <published>2022-01-16T07:29:34.607Z</published>
    <updated>2022-01-16T07:32:35.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.<br><br>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,2]<br><strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [[],[0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10</code></em>   <code>-10 &lt;= nums[i] &lt;= 10</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集，元素可能相同，不能含相同子集</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L078 Subsets，但元素可能相同，所以排序且比较相邻元素，若相等就跳过</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>元素可能相同，所以排序且比较相邻元素，若相等就跳过</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">nums.sort()</span><br><span class="line">res = [[]]</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(nums):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line"><span class="keyword">if</span> i &gt; st <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">res.append(list(path))</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given a
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2139 Minimum Moves to Reach Target Score</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-2139/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-2139/</id>
    <published>2022-01-16T06:48:34.993Z</published>
    <updated>2022-01-16T07:02:59.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-moves-to-reach-target-score/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are playing a game with integers. You start with the integer <code>1</code> and you want to reach the integer <code>target</code>.<br><br>In one move, you can either:<br><br><em>   <strong>Increment</strong> the current integer by one (i.e., <code>x = x + 1</code>).</em>   <strong>Double</strong> the current integer (i.e., <code>x = 2 * x</code>).<br><br>You can use the <strong>increment</strong> operation <strong>any</strong> number of times, however, you can only use the <strong>double</strong> operation <strong>at most</strong> <code>maxDoubles</code> times.<br><br>Given the two integers <code>target</code> and <code>maxDoubles</code>, return <em>the minimum number of moves needed to reach</em> <code>target</code> <em>starting with</em> <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 5, maxDoubles = 0<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Keep incrementing by 1 until you reach target.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 19, maxDoubles = 2<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Initially, x = 1<br>Increment 3 times so x = 4<br>Double once so x = 8<br>Increment once so x = 9<br>Double again so x = 18<br>Increment once so x = 19<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 10, maxDoubles = 4<br><strong>Output:</strong> 4<br><strong>Explanation:</strong>Initially, x = 1<br>Increment once so x = 2<br>Double once so x = 4<br>Increment once so x = 5<br>Double again so x = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></em>   <code>0 &lt;= maxDoubles &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>加1或者乘2达到target，乘2有次数限制，求到达target的最小步数</p><h3 id="DFS解题思路-推荐-："><a href="#DFS解题思路-推荐-：" class="headerlink" title="DFS解题思路(推荐)："></a><strong>DFS解题思路(推荐)：</strong></h3><p>由于是最值，一开始用DP，但得到TLE，分析后觉得是因为加法太慢，所以用贪心法，尽量用乘法。此题类似于求幂值。改用DFS。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>若允许乘法次数为0，直接返回加法次数，而不应再用递归，否则会出现超过系统栈深度</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> maxDoubles == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> target - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> self.minMoves(target // <span class="number">2</span>, maxDoubles - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.minMoves(target - <span class="number">1</span>, maxDoubles) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>TLE</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j], dp[i // 2][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (maxDoubles + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">1</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">dp[i][j] = min(dp[i][j], dp[i // <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n x maxDoubles)</code>，空间复杂度<code>O(n x maxDoubles)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-moves-to-reach-target-score/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2140 Solving Questions With Brainpower</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-2140/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-2140/</id>
    <published>2022-01-16T06:09:46.251Z</published>
    <updated>2022-01-16T08:07:37.229Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/solving-questions-with-brainpower/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> 2D integer array <code>questions</code> where <code>questions[i] = [points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt;]</code>.<br><br>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code>0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code>i</code> will <strong>earn</strong> you <code>points&lt;sub&gt;i&lt;/sub&gt;</code> points but you will be <strong>unable</strong> to solve each of the next <code>brainpower&lt;sub&gt;i&lt;/sub&gt;</code> questions. If you skip question <code>i</code>, you get to make the decision on the next question.<br><br><em>   For example, given <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>:    </em>   If question <code>0</code> is solved, you will earn <code>3</code> points but you will be unable to solve questions <code>1</code> and <code>2</code>.<br>    <em>   If instead, question <code>0</code> is skipped and question <code>1</code> is solved, you will earn <code>4</code> points but you will be unable to solve questions <code>2</code> and <code>3</code>.<br><br>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> questions = [[3,2],[4,3],[4,4],[2,5]]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 0 and 3.<br>- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 1 and 2<br>- Solve question 3: Earn 2 points<br>Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 1 and 4.<br>- Skip question 0<br>- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 2 and 3<br>- Solve question 4: Earn 5 points<br>Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= questions.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>questions[i].length == 2</code></em>   <code>1 &lt;= points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>(points, brainpower)解决一个问题得到points分，但是接下来的brainpower个问题都不能回答。求最大分数</p><h3 id="一维DP解题思路-推荐-："><a href="#一维DP解题思路-推荐-：" class="headerlink" title="一维DP解题思路(推荐)："></a><strong>一维DP解题思路(推荐)：</strong></h3><p>类似于LeetCode 198 House Robber，但此不再是固定的相邻不能偷，而是动态多个不能偷。<br>这题求最值，且数组有序访问，暴力法是多项式复杂度，所以考虑用DP。详见解法二。考虑优化算法二<br>首先考虑用累计dp，但是即使这样，由于前n-1个问题每个不能回答的范围都不同，并不能容易由第n-1个累计DP获得dp[n]<br>巧妙地利用从后往前计算，这样dp值不能回答范围包含在了已经计算的dp值中，如计算dp[3] &lt;- dp[i + questions[3][1] + 1] + questions[3][0], 后者最大的话，当前结果也是最大，符合归纳条件。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如哈雷彗星，限制条件是向后，所以从后往前计算</li><li>用累计DP： F[i] = max(F[i + 1], f)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(questions) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">next_val = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i + questions[i][<span class="number">1</span>] + <span class="number">1</span> &lt; len(dp):</span><br><span class="line">next_val = dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>]</span><br><span class="line">dp[i] = max(dp[i + <span class="number">1</span>], questions[i][<span class="number">0</span>] + next_val)</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="二维DP算法II解题思路："><a href="#二维DP算法II解题思路：" class="headerlink" title="二维DP算法II解题思路："></a><strong>二维DP算法II解题思路：</strong></h3><p>一开始我的思路是比较直接，此算法TLE。 dp[i]为以回答了第i个问题及之前的问题所得分数。递归式为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[j] + questions[i][0]) if j + questions[j][1] &lt; i, 0 &lt;= j &lt; i</span><br></pre></td></tr></table></figure><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints2</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * len(questions)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">dp[i] = questions[i][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line"><span class="keyword">if</span> j + questions[j][<span class="number">1</span>] &lt; i:</span><br><span class="line">dp[i] = max(dp[i], dp[j] + questions[i][<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/solving-questions-with-brainpower/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 085 Maximal Rectangle</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-085/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-085/</id>
    <published>2022-01-16T02:25:25.131Z</published>
    <updated>2022-01-16T02:32:50.568Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximal-rectangle" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>rows x cols</code> binary <code>matrix</code> filled with <code>0</code>‘s and <code>1</code>‘s, find the largest rectangle containing only <code>1</code>‘s and return <em>its area</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The maximal rectangle is shown in the above picture.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> matrix = [[“0”]]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> matrix = [[“1”]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>rows == matrix.length</code></em>   <code>cols == matrix[i].length</code><br><em>   <code>1 &lt;= row, cols &lt;= 200</code></em>   <code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>0-1矩阵求全部都是1的最大的子矩阵</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 084 Largest Rectangle in Histogram，按每行生成连续1的直方图，求最大矩形面积。然后逐行调用L084的方法。 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>由于L084的方案是修改原数组，所以不能直接调用，必须修改L084的方法，copy一份数组再往首尾插入0. </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">heights, res = [<span class="number">0</span>] * len(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == <span class="string">'0'</span>:</span><br><span class="line">heights[j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">heights[j] += <span class="number">1</span></span><br><span class="line">area = self.largestRectangleArea(heights)</span><br><span class="line">res = max(res, area)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height_list: List[int])</span> -&gt; int:</span></span><br><span class="line">stack, res = [], <span class="number">0</span></span><br><span class="line">heights = list(height_list)</span><br><span class="line">heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">heights.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">index = stack.pop()</span><br><span class="line">res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(m)</code>, n, m分别为行数和列数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximal-rectangle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;G
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Mtrix" scheme="https://shineboy2013.github.com/tags/Mtrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 084 Largest Rectangle in Histogram</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-084/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-084/</id>
    <published>2022-01-16T00:53:35.662Z</published>
    <updated>2022-01-16T01:04:39.995Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,1,5,6,2,3]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> The above is a histogram where width of each bar is 1.<br>The largest rectangle is shown in the red area, which has an area = 10 units.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,4]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= heights.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= heights[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求直方图中最大的矩形面积</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L042 Trapping Rain Water的stack法，但此题水量是反的。所以仍然用Stack，但用递增栈 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比L042稍简单，不用处理最后一个bar高度和宽度计算，但是用递增栈且公式中宽度计算仍然<strong>采用i - stack[-1] - 1</strong>，因为bar并不一定连续，如212, 最后一个2入栈，栈中剩下[_, 1]第一个2已经出栈了，但是可以有水量的。</li><li>原数组头尾加入0，头0是因为公式有stack[-1]避免越界， 尾0是因为让所有留在栈中的bar出栈且计算。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">stack, res = [], <span class="number">0</span></span><br><span class="line">heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">heights.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">index = stack.pop()</span><br><span class="line">res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 072 Edit Distance</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-072/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-072/</id>
    <published>2022-01-15T23:25:41.198Z</published>
    <updated>2022-01-15T23:29:57.177Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.<br><br>You have the following three operations permitted on a word:<br><br><em>   Insert a character</em>   Delete a character<br><em>   Replace a character<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> word1 = “horse”, word2 = “ros”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong><br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> word1 = “intention”, word2 = “execution”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong><br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= word1.length, word2.length &lt;= 500</code><br>*   <code>word1</code> and <code>word2</code> consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求编辑两个字符串的最短距离。编辑操作含加删一个字符，替换一个字符。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最值且涉及到字符串考虑用DP。递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]                                   if word1[i-1] == word[j-1]  </span><br><span class="line">         = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>初始值先word2长度再word1.</li><li><strong>初始化上和左边界，表示当一个字符串为空时，另一个字符串的编辑距离是其长度。</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j-1] if word1[i-1] == word[j-1]</span></span><br><span class="line"><span class="comment">#          = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word1) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">dp[i][<span class="number">0</span>] = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[<span class="number">0</span>][j] = j</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 076 Minimum Window Substring</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-076/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-076/</id>
    <published>2022-01-15T22:12:18.658Z</published>
    <updated>2022-01-15T22:34:16.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring__, return the empty string</em> <code>&quot;&quot;</code><em>.</em><br><br>The testcases will be generated such that the answer is <strong>unique</strong>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within the string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ADOBECODEBANC”, t = “ABC”<br><strong>Output:</strong> “BANC”<br><strong>Explanation:</strong> The minimum window substring “BANC” includes ‘A’, ‘B’, and ‘C’ from string t.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “a”<br><strong>Output:</strong> “a”<br><strong>Explanation:</strong> The entire string s is the minimum window.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “aa”<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> Both ‘a’s from t must be included in the window.<br>Since the largest window of s only has one ‘a’, return empty string.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == s.length</code></em>   <code>n == t.length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.<br><br><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最短摘要：给定s和t两个字符串，求在s中包含所有t的字符的最短子串。这个结果可以包含不在t的字符，某个字符数量也可以多于t中的字符但不能少于。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>提到window substring就用滑动窗口或者同向双指针。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用同向双指针模板。<strong>用map来统计t的字符频率，用unique_count统计满足条件唯一字符个数。while的条件为unique_count达到了map的大小</strong>。 </li><li>while里面的统计与while外面的统计本质一样，但相反。若s中某字符多于s中的，map为负值，left指针右移时，负值会变回正值。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">t_char_to_count = collections.Counter(t)</span><br><span class="line">left, unique_count, min_len, res = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>), <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">t_char_to_count[s[i]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> t_char_to_count[s[i]] == <span class="number">0</span>:</span><br><span class="line">unique_count += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> unique_count == len(t_char_to_count):</span><br><span class="line"><span class="keyword">if</span> i - left + <span class="number">1</span> &lt; min_len:</span><br><span class="line">min_len = i - left + <span class="number">1</span></span><br><span class="line">res = s[left:i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> s[left] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">t_char_to_count[s[left]] += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> t_char_to_count[s[left]] &gt; <span class="number">0</span>:</span><br><span class="line">unique_count -= <span class="number">1</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(m)</code>, n和m分别为s和t的长度  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 073 Set Matrix Zeroes</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-073/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-073/</id>
    <published>2022-01-15T08:40:58.386Z</published>
    <updated>2022-01-15T08:49:25.047Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s, and return <em>the matrix</em>.<br><br>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]<br><strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br><strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code></em>   <code>n == matrix[0].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong><br><br><em>   A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</em>   A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.<br>*   Could you devise a constant space solution?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>若矩阵某元素为0，设置它所在的行和列所有元素均为0，不能用额外区间</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0。两大步骤：先统计，再根据结果设置0</li><li>第二步中，<strong>根据第0和和第0列的结果回设，均从1开始</strong>，不含左上cell，因为统计结果不保存在它上。它仅在统计第一行和第一列是否有0时用到。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="comment"># calculate</span></span><br><span class="line">is_zero_row_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> matrix[<span class="number">0</span>] <span class="keyword">if</span> n == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">is_zero_col_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)) <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">matrix[i][<span class="number">0</span>], matrix[<span class="number">0</span>][j] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># Set</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)): <span class="comment"># remember to start with 1</span></span><br><span class="line"><span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[i][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])): <span class="comment"># remember to start with 1</span></span><br><span class="line"><span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">matrix[i][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> is_zero_row_zero:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> is_zero_col_zero:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/set-matrix-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 078 Subsets</title>
    <link href="https://shineboy2013.github.com/2022/01/14/lee-078/"/>
    <id>https://shineboy2013.github.com/2022/01/14/lee-078/</id>
    <published>2022-01-15T07:51:55.350Z</published>
    <updated>2022-01-15T07:55:28.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>组合知识点</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求结果含空集</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">res = [[]]</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(nums):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">path.append(nums[i])</span><br><span class="line">res.append(list(path))</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 065 Valid Number</title>
    <link href="https://shineboy2013.github.com/2022/01/13/lee-065/"/>
    <id>https://shineboy2013.github.com/2022/01/13/lee-065/</id>
    <published>2022-01-14T00:29:29.725Z</published>
    <updated>2022-01-14T01:13:53.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A <strong>valid number</strong> can be split up into these components (in order):<br><br>1.  A <strong>decimal number</strong> or an <strong>integer</strong>.<br>2.  (Optional) An <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code>, followed by an <strong>integer</strong>.<br><br>A <strong>decimal number</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One of the following formats:<br>    1.  One or more digits, followed by a dot <code>&#39;.&#39;</code>.<br>    2.  One or more digits, followed by a dot <code>&#39;.&#39;</code>, followed by one or more digits.<br>    3.  A dot <code>&#39;.&#39;</code>, followed by one or more digits.<br><br>An <strong>integer</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One or more digits.<br><br>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code>, while the following are not valid numbers: <code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>valid number</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “0”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “e”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “.”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 20</code></em>   <code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求合法小数指数形式</p><h3 id="类括号法解题思路-推荐-："><a href="#类括号法解题思路-推荐-：" class="headerlink" title="类括号法解题思路(推荐)："></a><strong>类括号法解题思路(推荐)：</strong></h3><p>有四种symbol，要保证先后关系。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>有四种symbol： 符号，数字，dot，exp。保证先后关系。<strong>exp的前后部分是独立的，唯一区别是后部分不能有dot</strong>，如1e2.2</li><li>实现类似于括号题用if语句来分别处理每种symbol：前面不能出现什么符号(<strong>e后面不能出现小数</strong>，也就是小数前面不能出现e)，或必须出现什么符号(仅一种情况：<strong>e前面必须出现数字</strong>)，如1e2. 然后该符号赋True</li><li>for循环后检查单个字符且不含数字情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">is_sign, is_digit, is_dot, is_exp = <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line"><span class="keyword">if</span> is_sign <span class="keyword">or</span> is_digit <span class="keyword">or</span> is_dot:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">is_digit = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] == <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">if</span> is_dot <span class="keyword">or</span> is_exp: <span class="comment"># 1e2.2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line"><span class="keyword">if</span> is_exp <span class="keyword">or</span> <span class="keyword">not</span> is_digit: <span class="comment"># e2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_exp = <span class="keyword">True</span></span><br><span class="line">is_digit = <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">False</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> (is_exp <span class="keyword">or</span> is_dot <span class="keyword">or</span> is_sign) <span class="keyword">and</span> <span class="keyword">not</span> is_digit <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="DFA算法II解题思路-不推荐-："><a href="#DFA算法II解题思路-不推荐-：" class="headerlink" title="DFA算法II解题思路(不推荐)："></a><strong>DFA算法II解题思路(不推荐)：</strong></h3><p>Deterministic Finite Automaton (DFA)状态机，也就是将状态写入一个map中作为config，代码较简洁，但很难想。</p><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;A &lt;st
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
</feed>
