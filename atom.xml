<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-09T08:32:20.036Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 134 Gas Station</title>
    <link href="https://shineboy2013.github.com/2021/12/09/lee-134/"/>
    <id>https://shineboy2013.github.com/2021/12/09/lee-134/</id>
    <published>2021-12-09T08:29:30.438Z</published>
    <updated>2021-12-09T08:32:20.036Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/gas-station" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>只要总gas &gt;= 总cost，就总有一个点满足gas-cost为非负     </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先判断不合法的情况sum(gas) &lt; sum(cost)    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> sum(gas) &lt; sum(cost):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">sum_gas, sum_cost, pos = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">sum_gas += gas[i]</span><br><span class="line">sum_cost += cost[i]</span><br><span class="line"><span class="keyword">if</span> sum_gas &lt; sum_cost:</span><br><span class="line">pos = i + <span class="number">1</span></span><br><span class="line">sum_gas = <span class="number">0</span></span><br><span class="line">sum_cost = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> pos</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/gas-station&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 224 Basic Calculator</title>
    <link href="https://shineboy2013.github.com/2021/12/08/lee-224/"/>
    <id>https://shineboy2013.github.com/2021/12/08/lee-224/</id>
    <published>2021-12-09T05:38:05.304Z</published>
    <updated>2021-12-09T05:51:18.634Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减，但有括号。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>括号题优先考虑用Stack。这里Stack不能只存数，因为括号前可以是正负，所以将这个信息以+1或-1也压入栈（栈不能混合字符和数字）<br>所以用<strong>一个stack</strong>，num是一个数，res是括号内的累积结果。num在处理完每一个数都要重设，res和sign在处理完每个括号都要重设。    </p><p>代码中含五种情况：空格，运算符，数字，左右括号。左括号将res和sign入栈，右括号将res和sign出栈，计算结果存在res  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>括号前可以是正负，所以将这个信息以+1或-1也压入栈</strong>         </li><li>左括号无论前面是正负都要入栈  </li><li>num在处理完每一个数都要重设，res和sign在处理完每个括号都要重设    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">stack, sign, num, res = [], <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">s += <span class="string">'+'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">res += sign * num</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'-'</span>:</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line">num = <span class="number">0</span>  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">num = num * <span class="number">10</span> + int(char)</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'('</span>:  <span class="comment"># dont limit to minus sign == '-' and</span></span><br><span class="line">stack.append(res)</span><br><span class="line">stack.append(sign)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">sign = <span class="number">1</span>  <span class="comment"># reset everything</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">')'</span> <span class="keyword">and</span> stack:</span><br><span class="line">res += sign * num</span><br><span class="line">sign = stack.pop()</span><br><span class="line">operand = stack.pop()</span><br><span class="line">res = operand + sign * res</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 032 Longest Valid Parentheses</title>
    <link href="https://shineboy2013.github.com/2021/12/08/lee-032/"/>
    <id>https://shineboy2013.github.com/2021/12/08/lee-032/</id>
    <published>2021-12-08T10:44:45.264Z</published>
    <updated>2021-12-09T01:09:26.837Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长括号对数。</p><h3 id="Stack算法思路-推荐-："><a href="#Stack算法思路-推荐-：" class="headerlink" title="Stack算法思路(推荐)："></a><strong>Stack算法思路(推荐)：</strong></h3><p>括号题优先考虑用Stack。由于只有单种括号，只需考虑两种不合法情况。<br>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空)<br>难点： 1. <strong>用下标存于stack</strong>，方便计算长度。不合法的保留栈中，这样不合法之间的距离-1就是合法的长度 </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Stack存了左右括号，不只存左括号，所以Line 7要验证栈顶为左括号  </li><li>循环后头尾加-1和s长度，方便头尾计算    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">if</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span>:  <span class="comment"># remember</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stack.append(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ())(()) # ())</span></span><br><span class="line">stack.insert(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">stack.append(len(s))</span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> len(stack) &gt; <span class="number">1</span>:</span><br><span class="line">index = stack.pop()</span><br><span class="line">max_len = max(max_len, index - stack[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>答案用max_len    </li><li>条件s[i - 1 - dp[i - 1] - 1]和递归式dp[i - dp[i - 1] - 2]不能越界      </li><li>递归式要加dp[i - dp[i - 1] - 2]，dp[..]”(“dp..[]”)” 就是第一个递归式，容易忽略     </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = max -&gt; dp[i-2] + 2 if s[i-2:i] == ()</span></span><br><span class="line"><span class="comment">#             -&gt; dp[i-1] + 2 + dp[i-1-dp[i-1]-2] if s[i-1-dp[i-1]-1]== ( and s[i-1] == )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses2</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(s) + <span class="number">1</span>)</span><br><span class="line">max_len = <span class="number">0</span>  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">dp[i] = max(dp[i], dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="keyword">if</span> s[i - <span class="number">2</span>:i] == <span class="string">'()'</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">prev_dp = <span class="number">0</span>  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">if</span> i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">prev_dp = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>]</span><br><span class="line"><span class="comment"># remember i - 1 - dp[i - 1] - 1 &gt;= 0</span></span><br><span class="line">dp[i] = max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">2</span> + prev_dp <span class="keyword">if</span> i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] == <span class="string">')'</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">max_len = max(max_len, dp[i])</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="统计算法III解题思路："><a href="#统计算法III解题思路：" class="headerlink" title="统计算法III解题思路："></a><strong>统计算法III解题思路：</strong></h3><p>括号题另一个常用思路是用统计左右括号数。维护四个变量left, right, res, max_len<br>当左括号小于右括号数（第一个规律）：重设全部变量<br>当左括号等于右括号数（第二个规律）：满足两个条件，可以计算res。重设left，right，准备计算下一轮res。不重设res，因为可以连续如()()  </p><h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>上述情况只覆盖了()),不能覆盖((), 因为左括号数在每一位永远都不会等于右括号数。所以旋转180度再做一次。    </li></ol><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses3</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">max_len = self.get_max_len(s)</span><br><span class="line">res = []</span><br><span class="line">PARENTHESES_DICT = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">')'</span>: <span class="string">'('</span>&#125;</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">res.append(PARENTHESES_DICT[char])</span><br><span class="line">max_len = max(max_len, self.get_max_len(res[::<span class="number">-1</span>]))</span><br><span class="line"><span class="keyword">return</span> max_len</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_len</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">max_len = res = left = right = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">right += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> left &lt; right:</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> left == right:  <span class="comment"># (())), ()()</span></span><br><span class="line">res += left * <span class="number">2</span></span><br><span class="line">max_len = max(max_len, res)</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 678 Valid Parenthesis String</title>
    <link href="https://shineboy2013.github.com/2021/12/08/lee-678/"/>
    <id>https://shineboy2013.github.com/2021/12/08/lee-678/</id>
    <published>2021-12-08T08:51:34.872Z</published>
    <updated>2021-12-09T01:17:57.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求给定字符串带星号是否合法括号配对。</p><h3 id="Stack算法思路-推荐-："><a href="#Stack算法思路-推荐-：" class="headerlink" title="Stack算法思路(推荐)："></a><strong>Stack算法思路(推荐)：</strong></h3><p>括号题优先考虑用Stack。如果不带星号，回忆合法括号题，有三种不合法情况，此题只需考虑两种，不需考虑多种括号类型<br>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空)<br>难点： </p><ol><li>在于要去想<strong>多一个栈来存星号</strong>，因为星号可以作为左括号备选去match右括号。右括号在两个栈中优先配对左括号，星号可以为空。如果两个栈均为空，处理了第一种不合法情况  </li><li>循环后，如果两栈有余，分4中情况讨论：<br>1) 左括号栈有余星号栈空，正是第二种不合法情况<br>2) 左括号栈空星号栈空，合法<br>3) 左括号栈空星号栈有余，合法，星号可为空<br>4) 都有余，这是难点二。星号可以作为右括号去配对左括号，前提条件是<strong>星号在左括号之后</strong>，考虑*(，这是不合法 </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如果for循环出来后，两栈不为空，要比较先后顺序  </li><li>for loop后，L18 - Line 19记得pop，否则死循环  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">stack_left, stack_star = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">stack_left.append(i)</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">'*'</span>:</span><br><span class="line">stack_star.append(i)</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">if</span> stack_left:  <span class="comment"># match ( first rather than * because * can be empty</span></span><br><span class="line">stack_left.pop()</span><br><span class="line"><span class="keyword">elif</span> stack_star:</span><br><span class="line">stack_star.pop()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">while</span> stack_left <span class="keyword">and</span> stack_star:  <span class="comment"># use * to match (</span></span><br><span class="line"><span class="keyword">if</span> stack_left[<span class="number">-1</span>] &gt; stack_star[<span class="number">-1</span>]:  <span class="comment"># consider *(</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">stack_left.pop()</span><br><span class="line">stack_star.pop()</span><br><span class="line"><span class="keyword">return</span> len(stack_left) == <span class="number">0</span>  <span class="comment"># stack_star can be non empty</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="统计算法II解题思路："><a href="#统计算法II解题思路：" class="headerlink" title="统计算法II解题思路："></a><strong>统计算法II解题思路：</strong></h3><p>括号题另一个常用思路是用统计左右括号数。此题较难想到是用一个<strong>左括号数量范围</strong>去验证。<br>lo为左括号的最少合法个数，hi为左括号的最大合法个数，有范围是因为星号可以变成左右括号或空。<br>遇到左括号，都加1，遇到右括号，都减1，遇到星号，假设星号为右括号，所以lo减1，hi加1.<br>如果hi小于0，表示最大左括号数小于右括号数，不满足此法的规则一，不合法  </p><p>难点在于<strong>lo设为非负</strong>。因为lo是最少且合法，合法意思是lo不是单纯地将所有星号变成右括号，而是当左括号不足时，用提高下限，将星号变成空，体现在令lo为非负。<br>for循环后，lo必须为0，运用了法则二，左右括号相等。  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">lo = hi = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">lo += <span class="number">1</span></span><br><span class="line">hi += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'*'</span>:</span><br><span class="line"><span class="keyword">if</span> lo &gt; <span class="number">0</span>:  <span class="comment"># treat * as empty space</span></span><br><span class="line">lo -= <span class="number">1</span></span><br><span class="line">hi += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">if</span> lo &gt; <span class="number">0</span>:  <span class="comment"># treat the previous * as empty space</span></span><br><span class="line">lo -= <span class="number">1</span></span><br><span class="line">hi -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> hi &lt; <span class="number">0</span>:  <span class="comment"># the num of right parenthesis &gt; left ones</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> lo == <span class="number">0</span>  <span class="comment"># the num of right parenthesis should equal to left ones</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="DP算法III解题思路："><a href="#DP算法III解题思路：" class="headerlink" title="DP算法III解题思路："></a><strong>DP算法III解题思路：</strong></h3><p>基本情况为s[i], s[j] 分别在(*, )* 就合法<br>如果用单边DP，并不能确定区间内那些合法，所以只能用区间型DP<br>dp[i][j] = s[i-1] == ‘*‘ and dp[i+1][j] 星号不匹配<br>         = s[i-1] in ‘(*‘ and dp[i+1][k-1] and s[k-1] in (‘)*‘) and dp[k+1][j] 星号匹配  </p><p>具体参考leetcode答案<br>DP基本情况比较难想出来且递归是复杂，实现易错，不推荐。不过可以多了解区间型DP的模式  </p><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^3)</code>，空间复杂度<code>O(n^2)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parenthesis-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>括号题或者字符串运算题</title>
    <link href="https://shineboy2013.github.com/2021/12/07/parenthesis/"/>
    <id>https://shineboy2013.github.com/2021/12/07/parenthesis/</id>
    <published>2021-12-08T00:46:52.871Z</published>
    <updated>2021-12-09T00:03:16.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="括号题"><a href="#括号题" class="headerlink" title="括号题"></a>括号题</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li><strong>优先考虑用Stack</strong>。Stack可以将字符压入比较或者<strong>字符的下标</strong>压入比较，<em>后者信息量更大</em><br>三种情况不合法： ‘[‘ (stack有余，for后发生), ‘]’ (要匹配的时候stack为空，for中发生), ‘{]’ (不匹配，for中发生)  </li><li>DP  </li><li>1) 左括号的数量在每一位都大于等于右括号数量<br>2) 右括号的总和要等于右括号总和<br>以上两个条件都满足的话，左右括号匹配，但此法只能用于<strong>单种括号</strong>  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>括号题</li><li>字符串运算题如, 3+4, (3+4)*5</li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;括号题&quot;&gt;&lt;a href=&quot;#括号题&quot; class=&quot;headerlink&quot; title=&quot;括号题&quot;&gt;&lt;/a&gt;括号题&lt;/h2&gt;&lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1249 Minimum Remove to Make Valid Parentheses</title>
    <link href="https://shineboy2013.github.com/2021/12/07/lee-1249/"/>
    <id>https://shineboy2013.github.com/2021/12/07/lee-1249/</id>
    <published>2021-12-07T08:14:35.194Z</published>
    <updated>2021-12-07T09:19:58.912Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>去掉最小不合法括号数剩下的字符串。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>括号题优先考虑用Stack。此题将下标存于stack中，stack留下的是不合法括号下标，也就是需要删除的  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>当括号配对时才出栈 Line 6  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">stack, res = [], <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">elif</span> stack <span class="keyword">and</span> s[stack[<span class="number">-1</span>]] == <span class="string">'('</span> <span class="keyword">and</span> s[i] == <span class="string">')'</span>:  <span class="comment"># remember</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> set(stack):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">res += s[i]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/str
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 020 Valid Parentheses</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-020/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-020/</id>
    <published>2021-12-07T07:25:31.154Z</published>
    <updated>2021-12-08T10:05:06.050Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求给定字符串是否合法括号配对。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>括号题优先考虑用Stack  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种不合法情况： ‘[‘ (stack有余), ‘]’ (要匹配的时候stack为空), ‘{]’ (不匹配)    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PARENTHESES_DICT = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'([&#123;'</span>:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                left = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> PARENTHESES_DICT[left] != char:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 322 Coin Change</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-322/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-322/</id>
    <published>2021-12-07T02:58:45.149Z</published>
    <updated>2021-12-07T03:10:51.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>amount为0时候，返回0，表示不用coin也能满足，属于合法情况, dp[0] = 0  </li><li>返回值，若dp[-1]为初始值，表示无解，返回-1  </li><li>dp数组引用的边界情况： 代码调转i和j的遍历顺序，可以避免边界检查，且i=[j, len(dp)]，i包含j，表示dp[0], 包含了初始化dp[for coin in coins] = 1的情况  </li><li>实现中dp[i] = min(dp[i], dp[i - j] + 1), +1在min内而不是min外。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">dp = [sys.maxsize] * (amount + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> coins:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(j, len(dp)):  <span class="comment"># i = [1..3]</span></span><br><span class="line">dp[i] = min(dp[i], dp[i - j] + <span class="number">1</span>)  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] &lt; sys.maxsize <span class="keyword">else</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br></pre></td></tr></table></figure><p>我的实现，要注意dp[i]边界检查, Line 7 - 8, 12<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[n] = min(dp[n-coins[j]]) + 1, 0 &lt;= j &lt;= len(coins)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> amount == <span class="number">0</span>:  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">dp = [sys.maxsize] * (amount + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> coins:</span><br><span class="line"><span class="keyword">if</span> i &lt; len(dp):  <span class="comment"># remember</span></span><br><span class="line">dp[i] = <span class="number">1</span></span><br><span class="line"><span class="comment"># [3], amount = 3, dp[3] = 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):  <span class="comment"># i = [1..3]</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> coins:</span><br><span class="line"><span class="keyword">if</span> i &gt; j:  <span class="comment"># remember</span></span><br><span class="line">dp[i] = min(dp[i], dp[i - j] + <span class="number">1</span>)  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] &lt; sys.maxsize <span class="keyword">else</span> <span class="number">-1</span>  <span class="comment"># remember</span></span><br></pre></td></tr></table></figure></p><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A&lt;/p&gt;
&lt;h3 id=&quot;解题思路：&quot;&gt;&lt;a href=&quot;#解题思路：&quot; c
      
    
    </summary>
    
    
      <category term="Python KB" scheme="https://shineboy2013.github.com/tags/Python-KB/"/>
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 239 Sliding Window Maximum</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-239/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-239/</id>
    <published>2021-12-06T19:57:45.766Z</published>
    <updated>2021-12-06T19:58:28.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>LL + 递减栈</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;LL + 递减栈&lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 863 All Nodes Distance K in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-863/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-863/</id>
    <published>2021-12-06T19:49:23.856Z</published>
    <updated>2021-12-09T08:10:07.581Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>有三种情况，都容易忽略： 1. 儿子节点 2. 所有父节点路劲上 3. 兄弟节点路径上。而第三种情况要搜另一边的儿子节点（左右不确定）要用visited记录，而且不一定是父亲的兄弟节点，可能爷爷的非父亲的儿子节点。<br>既然不是单向搜索，不妨转换为图，然后用计算距离BFS模板，只要用map来记录某节点的父亲节点或者增加一个域。BFS中for neighbor in [node.left, node, right, node.parent]  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>root的parent是None，所以从root去赋值parent，而不是从parent root给儿子赋parent  </li><li>Line 13 node.left, node.right, node.parent都可能为None，所以Line14要加not neighbor      </li><li>BFS从target开始而不是root</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root: TreeNode, target: TreeNode, k: int)</span> -&gt; List[int]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">self.dfs(root, <span class="keyword">None</span>)</span><br><span class="line">queue, visited, distance_to_tgt,  = collections.deque([target]), set([target]), collections.defaultdict(int)</span><br><span class="line">distance_to_tgt[target], res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> distance_to_tgt[node] == k:</span><br><span class="line">res.append(node.val)</span><br><span class="line"><span class="keyword">if</span> distance_to_tgt[node] &gt; k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> [node.left, node.right, node.parent]:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> neighbor <span class="keyword">or</span> neighbor <span class="keyword">in</span> visited:  <span class="comment"># remember not neighbor</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">distance_to_tgt[neighbor] = distance_to_tgt[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, parent)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">root.parent = parent</span><br><span class="line"><span class="string">'''if root.left:</span></span><br><span class="line"><span class="string">root.left.parent = root</span></span><br><span class="line"><span class="string">if root.right:</span></span><br><span class="line"><span class="string">root.right.parent = root'''</span></span><br><span class="line">self.dfs(root.left, root)  <span class="comment"># remember to pass parent</span></span><br><span class="line">self.dfs(root.right, root)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
      <category term="Breadth-First Search" scheme="https://shineboy2013.github.com/tags/Breadth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 295 Find Median from Data Stream</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-295/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-295/</id>
    <published>2021-12-06T17:48:27.935Z</published>
    <updated>2021-12-06T17:56:43.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>用max_heap, min_heap, 保证min_heap个数永远等于max_heap或多一个。插入元素先进max_heap, 再heappop将堆顶元素加入min_heap, 若此时比max_heap多2个，就再heappop加入到max_heap. </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;用max_heap, min_heap, 保证min_heap个数永远等于max_
      
    
    </summary>
    
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 227 Basic Calculator II</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-227/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-227/</id>
    <published>2021-12-06T08:35:57.253Z</published>
    <updated>2021-12-09T05:38:40.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除，但无括号。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>逆波兰式的实现用Stack。Stack只存数，而且<strong>只存加号操作符</strong>的数，也就是说，<br>如果是减，就将-num入栈，<br>如果是乘除，立刻计算stack[-1]乘除num的结果再压入栈，因为乘除是最高优先级可以直接计算，而加减不可以。<br>所以用<strong>一个stack</strong>  </p><p>代码中含三种情况：空格，运算符，数字</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>op记录前一个运算符，char为运算符或当前字符。计算时候根据op，因为char只是第二个操作数的终结符合，此时表明操作数stack[-1], num以及操作符op均已完成，可以计算         </li><li>最容易错的是向下取整Line 17, 题目返回要求整数。14-3/2=13但程序运行得到12，因为14+(-3)/2=12, -3/2结果为-2，所以<strong>要取正数后才做除法</strong></li><li>s末尾加入加号，方便parse最后一个num  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">stack = []  <span class="comment"># for add only</span></span><br><span class="line">num, op = <span class="number">0</span>, <span class="string">'+'</span></span><br><span class="line">s += <span class="string">'+'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">num = num * <span class="number">10</span> + int(char)</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line"><span class="keyword">if</span> op <span class="keyword">in</span> <span class="string">'*/'</span>:</span><br><span class="line">operand = stack.pop()</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">'*'</span>:</span><br><span class="line">stack.append(operand * num)</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">'/'</span>:</span><br><span class="line"><span class="keyword">if</span> operand &lt; <span class="number">0</span>:</span><br><span class="line">stack.append(-(-operand // num))  <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stack.append(operand // num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">'-'</span>:</span><br><span class="line">num = -num</span><br><span class="line">stack.append(num)</span><br><span class="line">op = char</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">value = stack.pop()</span><br><span class="line">num += value</span><br><span class="line"><span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 301 Remove Invalid Parentheses</title>
    <link href="https://shineboy2013.github.com/2021/12/06/lee-301/"/>
    <id>https://shineboy2013.github.com/2021/12/06/lee-301/</id>
    <published>2021-12-06T08:01:52.622Z</published>
    <updated>2021-12-06T08:04:34.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>最值问题考虑用DP和BFS，DP难以拆分子问题。所以考虑用BFS + 括号合法性判断  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(2^n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最值问题考虑用DP和BFS，DP难以拆分子问题。所以考虑用BFS + 括号合法性判
      
    
    </summary>
    
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
      <category term="Breadth-First Search" scheme="https://shineboy2013.github.com/tags/Breadth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 516 Longest Palindromic Subsequence</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-516/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-516/</id>
    <published>2021-12-06T07:27:35.791Z</published>
    <updated>2021-12-06T07:33:22.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始看到子序列就想用DP，dp[i]表示以s[i]为结尾的最长回文子序列。但不容易推导公式，难点是没有限制左边界<br>所以应该扩展到二维dp[i][j]表示[i, j]之间的最长回文子序列。公式就简单多了<br>dp[i][j] = dp[i+1][j-1], j = start[i-1], s[i] == s[j]<br>           max(dp[i+1][j], dp[i][j-1]),  s[i] != s[j]    </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*n)</code>，空间复杂度<code>O(n*n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;一开始看到子序列就想用DP，dp[i]表示以s[i]为结尾的最长回文子序列。但不容
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 731 My Calendar II</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-731/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-731/</id>
    <published>2021-12-06T06:41:18.204Z</published>
    <updated>2021-12-06T06:49:00.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>有重复区间，考虑用meeting rooms的方法二同时差分再求和的方法。用一个map来存储endpoint包括start和end的频率，若遇到start，map[start]++, 若遇到end, map[end]–，插入一个区间后，遍历所有endpoints，若超过3就返回False  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;有重复区间，考虑用meeting rooms的方法二同时差分再求和的方法。用一个m
      
    
    </summary>
    
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
      <category term="Segment Tree" scheme="https://shineboy2013.github.com/tags/Segment-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 490 The Maze</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-729/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-729/</id>
    <published>2021-12-06T06:13:20.726Z</published>
    <updated>2021-12-06T05:52:55.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题意比较复杂但是等价于一个球从某个点向任何方向滚，因为四边都是墙，所以总会使得这个点的四个方向都能滚一次。所以是简单的BFS      </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; 
      
    
    </summary>
    
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
      <category term="Breadth-First Search" scheme="https://shineboy2013.github.com/tags/Breadth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 729 My Calendar I</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-490/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-490/</id>
    <published>2021-12-06T05:41:01.328Z</published>
    <updated>2021-12-06T06:19:44.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>题目似meeting rooms，考虑用heap，但不能online处理。考虑用start, end排序，二分法查找，只能处理单次，因为插入不方便。<br>要查找和插入都能低于O(n)，就只能用TreeMap。类似于线段树存储区间和，此题每个Node存储一个区间。新区间的end，start分别与root的start和end比较，若不重合，就递归到左右子树。此树投影为离散且不重合的区间。   </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(logn)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;题目似meeting rooms，考虑用heap，但不能online处理。考虑用s
      
    
    </summary>
    
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
      <category term="Segment Tree" scheme="https://shineboy2013.github.com/tags/Segment-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-105/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-105/</id>
    <published>2021-12-06T05:36:22.387Z</published>
    <updated>2021-12-06T05:39:44.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用递归实现，in_order字符串分左右两段递归到左右儿子，pre_order字符串每轮递归用pop原地去除首位，再递归到儿子节点  </li><li>终止条件为in_order字符串为空。    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; 
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1235 Maximum Profit in Job Scheduling</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-1235/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-1235/</id>
    <published>2021-12-06T02:18:26.508Z</published>
    <updated>2021-12-06T02:50:14.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>一开始以为类似于meeting rooms II，所以用heap，但只能计算conflicts不能计算profits，但排序思想有用。<br>看了提示用DP，所以考虑以第i-1个job为结尾的最大利润：<br>dp[i] = max -&gt; dp[j] + profits[i-1]), start[i-1]对应的结束时间下标 &lt; j &lt; i, 第j个job与第i个job没有conflicts<br>            -&gt; dp[j]                                                       第j个job与第i个job有conflicts<br>复杂度为O(n^2)<br>看了别人的解法，此题含profits，而且递归近似于0-1背包问题，执行或者不执行job<br>由于DP需要有序，如果要按结束时间排序，这样保证DP的计算顺序可以得到最大利润<br>加强命题dp[i]是累计利润，也就是并不需要计算所有dp[j…i]的值（第一式子），公式变成<br>dp[i] = max -&gt; dp[j] + profits[i-1]), j = start[i-1]对应的Endtime下标, 第j个job与第i个job没有conflicts<br>            -&gt; dp[j]                                                   第j个job与第i个job有conflicts<br>要找出这个j，就对刚才排序了的endtime数组用bisect找下标。类似于LIS, 复杂度为O(nlogn)  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p><p><a href="https://www.cnblogs.com/grandyang/p/15391606.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/15391606.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;一开始以为类似于meeting rooms II，所以用heap，但只能计算con
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="tik" scheme="https://shineboy2013.github.com/tags/tik/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1654 Minimum Jumps to Reach Home</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-1654/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-1654/</id>
    <published>2021-12-05T23:43:58.319Z</published>
    <updated>2021-12-06T00:54:33.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于Jump game，不过此题要用真的BFS，用三个元素push如queue: (point, distance, is_backward), is_backward记录是否回退两次而剪枝，distance是结果。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;类似于Jump game，不过此题要用真的BFS，用三个元素push如queue:
      
    
    </summary>
    
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="tiktok" scheme="https://shineboy2013.github.com/tags/tiktok/"/>
    
  </entry>
  
</feed>
