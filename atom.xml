<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-25T10:17:19.870Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 937 Reorder Data in Log Files</title>
    <link href="https://shineboy2013.github.com/2021/12/25/lee-937/"/>
    <id>https://shineboy2013.github.com/2021/12/25/lee-937/</id>
    <published>2021-12-25T10:03:16.769Z</published>
    <updated>2021-12-25T10:17:19.870Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/reorder-data-in-log-files/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an array of <code>logs</code>. Each log is a space-delimited string of words, where the first word is the <strong>identifier</strong>.<br><br>There are two types of logs:<br><br><em>   <strong>Letter-logs</strong>: All words (except the identifier) consist of lowercase English letters.</em>   <strong>Digit-logs</strong>: All words (except the identifier) consist of digits.<br><br>Reorder these logs so that:<br><br>1.  The <strong>letter-logs</strong> come before all <strong>digit-logs</strong>.<br>2.  The <strong>letter-logs</strong> are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.<br>3.  The <strong>digit-logs</strong> maintain their relative ordering.<br><br>Return <em>the final order of the logs</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> logs = [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br><strong>Output:</strong> [“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]<br><strong>Explanation:</strong><br>The letter-log contents are all different, so their ordering is “art can”, “art zero”, “own kit dig”.<br>The digit-logs have a relative order of “dig1 8 1 5 1”, “dig2 3 6”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> logs = [“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]<br><strong>Output:</strong> [“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= logs.length &lt;= 100</code></em>   <code>3 &lt;= logs[i].length &lt;= 100</code><br><em>   All the tokens of <code>logs[i]</code> are separated by a <strong>single</strong> space.</em>   <code>logs[i]</code> is guaranteed to have an identifier and at least one word after the identifier.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排序log file，以下顺序：字母log (内容，id), 数字log</p><h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>排序的multi key实现(0, content_str, li[0]) if is_alpha else (1, ). (1, )表示按数组顺序    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(x)</span>:</span></span><br><span class="line">li = x.split(<span class="string">' '</span>)</span><br><span class="line">content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">is_alpha = <span class="number">1</span> <span class="keyword">if</span> content_str[<span class="number">0</span>].isalpha() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>, content_str, li[<span class="number">0</span>]) <span class="keyword">if</span> is_alpha <span class="keyword">else</span> (<span class="number">1</span>, )</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sorted(logs, key=get_key)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nmlogn)</code>，空间复杂度<code>O(mn)</code>, n为log数量，m为每个log的最长长度。如mergesort中merge复杂度为nm, 每个key比较是O(m)复杂度  </p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>我的解法。本质上和上法一致，较繁琐  </p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>字母log排序不能按content_str + ‘ ‘ + li[0], 而是(content_str, li[0])作多key排序  </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles2</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">letter_logs, digit_logs = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(logs)):</span><br><span class="line"><span class="keyword">if</span> logs[i][<span class="number">-1</span>].isdigit():</span><br><span class="line">digit_logs.append(logs[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">li = logs[i].split(<span class="string">' '</span>)</span><br><span class="line">content_str = <span class="string">' '</span>.join(li[<span class="number">1</span>:])</span><br><span class="line">letter_logs.append((content_str, li[<span class="number">0</span>], i))</span><br><span class="line">letter_logs.sort()</span><br><span class="line">res = [logs[pair[<span class="number">2</span>]] <span class="keyword">for</span> pair <span class="keyword">in</span> letter_logs]</span><br><span class="line">res += digit_logs</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/reorder-data-in-log-files/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1268 Search Suggestions System</title>
    <link href="https://shineboy2013.github.com/2021/12/25/lee-1268/"/>
    <id>https://shineboy2013.github.com/2021/12/25/lee-1268/</id>
    <published>2021-12-25T09:02:37.829Z</published>
    <updated>2021-12-25T09:04:45.289Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-suggestions-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.<br><br>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums products.<br><br>Return <em>a list of lists of the suggested products after each character of</em> <code>searchWord</code> <em>is typed</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> products = [“mobile”,”mouse”,”moneypot”,”monitor”,”mousepad”], searchWord = “mouse”<br><strong>Output:</strong> [<br>[“mobile”,”moneypot”,”monitor”],<br>[“mobile”,”moneypot”,”monitor”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”],<br>[“mouse”,”mousepad”]<br>]<br><strong>Explanation:</strong> products sorted lexicographically = [“mobile”,”moneypot”,”monitor”,”mouse”,”mousepad”]<br>After typing m and mo all products match and we show user [“mobile”,”moneypot”,”monitor”]<br>After typing mou, mous and mouse the system suggests [“mouse”,”mousepad”]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> products = [“havana”], searchWord = “havana”<br><strong>Output:</strong> [[“havana”],[“havana”],[“havana”],[“havana”],[“havana”],[“havana”]]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> products = [“bags”,”baggage”,”banner”,”box”,”cloths”], searchWord = “bags”<br><strong>Output:</strong> [[“baggage”,”bags”,”banner”],[“baggage”,”bags”,”banner”],[“baggage”,”bags”],[“bags”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= products.length &lt;= 1000</code></em>   <code>1 &lt;= products[i].length &lt;= 3000</code><br><em>   `1 &lt;= sum(products[i].length) &lt;= 2 </em> 10<sup>4</sup><code>*   All the strings of</code>products<code>are **unique**.*</code>products[i]<code>consists of lowercase English letters.*</code>1 &lt;= searchWord.length &lt;= 1000<code>*</code>searchWord` consists of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现搜索结果为3个autocomplete的功能</p><h3 id="Prefix解题思路-推荐-："><a href="#Prefix解题思路-推荐-：" class="headerlink" title="Prefix解题思路(推荐)："></a><strong>Prefix解题思路(推荐)：</strong></h3><p>Prefix</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Trie，另一种思路是用prefix，此法采用prefix法，将所有单词按前缀加入到字典中     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products: List[str], searchWord: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">products.sort()</span><br><span class="line">prefix_dict = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> products:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">prefix = word[:i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> len(prefix_dict[prefix]) &lt; <span class="number">3</span>:</span><br><span class="line">prefix_dict[prefix].append(word)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(searchWord)):</span><br><span class="line">prefix = searchWord[:i + <span class="number">1</span>]</span><br><span class="line">res.append(prefix_dict[prefix])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL1 + L2)</code>，空间复杂度<code>O(nL1)</code>, L1为单词列表中最长的长度，L2为搜索单词长度，n为单词个数  </p><hr><h3 id="Trie-DFS算法II解题思路："><a href="#Trie-DFS算法II解题思路：" class="headerlink" title="Trie + DFS算法II解题思路："></a><strong>Trie + DFS算法II解题思路：</strong></h3><p>建Trie，然后根据搜索的前缀定位到Trie节点，然后对此节点做DFS找到3个单词，因为DFS和字母顺序是一致的，所以DFS可行<br>具体参考Leetcode solution</p><hr><h3 id="Two-pointers算法III解题思路-推荐-："><a href="#Two-pointers算法III解题思路-推荐-：" class="headerlink" title="Two pointers算法III解题思路(推荐)："></a><strong>Two pointers算法III解题思路(推荐)：</strong></h3><p>先排序，用双指针相向搜索，根据搜索单词的每一个字母，不断收缩搜索范围，左指针和右指针之间即为满足条件的结果。每轮将左指针往后三个结果加到结果集<br>具体参考Leetcode discussion  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-suggestions-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 735 Asteroid Collision</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-735/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-735/</id>
    <published>2021-12-25T07:52:53.889Z</published>
    <updated>2021-12-25T08:04:41.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/asteroid-collision/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>We are given an array <code>asteroids</code> of integers representing asteroids in a row.<br><br>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.<br><br>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> asteroids = [5,10,-5]<br><strong>Output:</strong> [5,10]<br><strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> asteroids = [8,-8]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> The 8 and -8 collide exploding each other.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> asteroids = [10,2,-5]<br><strong>Output:</strong> [10]<br><strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= asteroids.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-1000 &lt;= asteroids[i] &lt;= 1000</code><br>*   <code>asteroids[i] != 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>星体向左向右同速运动，符号表示方向，数值表示星体大小。若相撞，同大小想消，否则较小的消失。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>保持原有顺序且相邻元素大小关系，考虑用Stack</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>两星体可以正负，所以有四种可能：同左，同右，向左向右，向右向左。<strong>只有最后一种向右向左才会相撞。</strong>所以出栈条件为栈顶为正，遍历元素为负。    </li><li>同大小要特别处理，记录到is_same_size变量中。入栈条件为<strong>出栈条件的非以及不是is_same_size</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">is_same_size = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span> <span class="keyword">and</span> -asteroids[i] &gt;= stack[<span class="number">-1</span>]:</span><br><span class="line">stack_top = stack.pop()</span><br><span class="line"><span class="keyword">if</span> stack_top == -asteroids[i]:</span><br><span class="line">is_same_size = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>) <span class="keyword">and</span> <span class="keyword">not</span> is_same_size:</span><br><span class="line">stack.append(asteroids[i])</span><br><span class="line"><span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><p>更简洁的写法，不要要掌握while, break, else语句，如果没有break，else永远执行，若break，else不执行。若不熟悉该语法，推荐用上法。  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision2</span><span class="params">(self, asteroids: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> asteroids[i] &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> -asteroids[i] &lt; stack[<span class="number">-1</span>] <span class="keyword">or</span> stack.pop() == -asteroids[i]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stack.append(asteroids[i])</span><br><span class="line"><span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/asteroid-collision/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 314 Binary Tree Vertical Order Traversal</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-314/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-314/</id>
    <published>2021-12-25T04:10:20.140Z</published>
    <updated>2021-12-25T04:25:37.124Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em><strong>the vertical order traversal</strong> of its nodes’ values</em>. (i.e., from top to bottom, column by column).<br><br>If two nodes are in the same row and column, the order should be from <strong>left to right</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]<br><strong>Output:</strong> [[9],[3,15],[20],[7]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7]<br><strong>Output:</strong> [[4],[9],[3,0,1],[8],[7]]<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,9,8,4,0,1,7,null,null,null,2,5]<br><strong>Output:</strong> [[4],[9,5],[3,0,1],[8,2],[7]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[0, 100]</code>.</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按列顺序规律二叉树  </p><h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p><strong>从root开始从0编号，左右节点分别为-1, 1</strong>，如此类推，就可以标记所有节点，从而将这些节点加入结果集。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>BFS引入(vertical_id, root)来做计算。由于结果列表如vertical_id = -1, 1可以从左或右加入，用dict来记录vertical到list更好合理   </li><li>由于vertical_id是连续的，所以不妨用min_col, max_col来记录dict的范围，保证从dict到结果集是按顺序加入。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line">min_col, max_col = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">vertical_id, node = queue.popleft()</span><br><span class="line">min_col, max_col = min(min_col, vertical_id), max(max_col, vertical_id)</span><br><span class="line">idx_to_list[vertical_id].append(node.val)</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(min_col, max_col + <span class="number">1</span>):</span><br><span class="line">res.append(idx_to_list[i])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="BFS算法II解题思路："><a href="#BFS算法II解题思路：" class="headerlink" title="BFS算法II解题思路："></a><strong>BFS算法II解题思路：</strong></h3><p>先写了这个，优化后才得到算法I。区别在于keys需要排序  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder1_1</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">queue = collections.deque([(<span class="number">0</span>, root)])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">vertical_id, node = queue.popleft()</span><br><span class="line">idx_to_list[vertical_id].append(node.val)</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">queue.append((vertical_id - <span class="number">1</span>, node.left))</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">queue.append((vertical_id + <span class="number">1</span>, node.right))</span><br><span class="line">sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">res.append(idx_to_list[i])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="DFS算法III解题思路-不推荐-："><a href="#DFS算法III解题思路-不推荐-：" class="headerlink" title="DFS算法III解题思路(不推荐)："></a><strong>DFS算法III解题思路(不推荐)：</strong></h3><p>最开始的思路，很容易错，因为不符合题目的按层遍历的顺序。题目要求同一column的节点是从上到下，从左到右。DFS与此违反。    </p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>要将同一个column节点从上到下从左到右排序，就要记录height和左到右的顺序(height_id, len(idx_to_list[vertical_id]) - 1, root.val)</li></ol><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder2</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">idx_to_list, res = collections.defaultdict(list), []</span><br><span class="line">self.dfs(root, <span class="number">0</span>, <span class="number">0</span>, idx_to_list)</span><br><span class="line">sorted_keys = sorted(list(idx_to_list.keys()))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_keys:</span><br><span class="line">li = sorted(idx_to_list[i])</span><br><span class="line">res.append([node[<span class="number">2</span>] <span class="keyword">for</span> node <span class="keyword">in</span> li])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, height_id, vertical_id, idx_to_list)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">idx_to_list[vertical_id].append((height_id, len(idx_to_list[vertical_id]) - <span class="number">1</span>, root.val))</span><br><span class="line">self.dfs(root.left, height_id + <span class="number">1</span>, vertical_id - <span class="number">1</span>, idx_to_list)</span><br><span class="line">self.dfs(root.right, height_id + <span class="number">1</span>, vertical_id + <span class="number">1</span>, idx_to_list)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-vertical-order-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1209 Remove All Adjacent Duplicates in String II</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-1209/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-1209/</id>
    <published>2021-12-25T02:34:49.356Z</published>
    <updated>2021-12-25T02:41:16.033Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a string <code>s</code> and an integer <code>k</code>, a <code>k</code> <strong>duplicate removal</strong> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.<br><br>We repeatedly make <code>k</code> <strong>duplicate removals</strong> on <code>s</code> until we no longer can.<br><br>Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “abcd”, k = 2<br><strong>Output:</strong> “abcd”<br><strong>Explanation:</strong> There’s nothing to delete.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “deeedbbcccbdaa”, k = 3<br><strong>Output:</strong> “aa”<br><strong>Explanation:</strong> First delete “eee” and “ccc”, get “ddbbbdaa”<br>Then delete “bbb”, get “dddaa”<br>Finally delete “ddd”, get “aa”</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “pbbcggttciiippooaais”, k = 2<br><strong>Output:</strong> “ps”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>2 &lt;= k &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> only contains lower case English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串中去除连续k次的字符</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始用暴力法得到LTE。这题由于需要保持顺序，且元素之间是相等关系且类似于LeetCode 316 Remove Duplicate Letters，考虑用Stack。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Stack中存元素和该元素的连续个数，这样避免往前重新计算连续了几次。若栈顶元素等于遍历元素且栈顶连续个数为k - 1就连续出栈。此情况<strong>此遍历元素不入栈</strong>  </li><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">stack, res = [], <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i] <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i]:</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>] == s[i]:</span><br><span class="line">stack.append((s[i], stack[<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stack.append((s[i], <span class="number">1</span>))</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">pair = stack.pop()</span><br><span class="line">res += pair[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Bloomberg" scheme="https://shineboy2013.github.com/tags/Bloomberg/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 289 Game of Life</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-289/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-289/</id>
    <published>2021-12-24T22:40:09.326Z</published>
    <updated>2021-12-25T00:09:34.601Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>According to <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”<br><br>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <strong>live</strong> (represented by a <code>1</code>) or <strong>dead</strong> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank" rel="noopener">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):<br><br>1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.<br>2.  Any live cell with two or three live neighbors lives on to the next generation.<br>3.  Any live cell with more than three live neighbors dies, as if by over-population.<br>4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br><br><span>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</span><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]<br><strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" alt=""><br><br><pre><strong>Input:</strong> board = [[1,1],[1,0]]<br><strong>Output:</strong> [[1,1],[1,1]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == board.length</code></em>   <code>n == board[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 25</code></em>   <code>board[i][j]</code> is <code>0</code> or <code>1</code>.<br><br><strong>Follow up:</strong><br><br><em>   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</em>   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据临近8个细胞的情况来决定生死。若该细胞是live和临近有2-3个是live，仍然live。若该细胞是dead和临近有3个是live，复生。其他都变成dead</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>board[:] = res赋值到原数组一定要用冒号     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        res = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                live_neighbor_num = self.get_live_neighbor_num(board, i, j)</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> live_neighbor_num == <span class="number">3</span>:</span><br><span class="line">                    res[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> live_neighbor_num <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">                    res[i][j] = <span class="number">1</span></span><br><span class="line">        board[:] = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_live_neighbor_num</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            x, y = i + _dx, j + _dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[x][y] == <span class="number">1</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(8n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><hr><h3 id="算法II解题思路O-1-Space："><a href="#算法II解题思路O-1-Space：" class="headerlink" title="算法II解题思路O(1) Space："></a><strong>算法II解题思路O(1) Space：</strong></h3><p>用一个数字来记录前后状态，2表示从0到1,3表示从1到0</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不同之处有两个： Line 11不再是board[i][j]为1的情况，而是从1变成0的情况： live_neighbor_num <strong>not</strong> in [2, 3]     </li><li>最后扫一遍矩阵，将2和3变回1和0  </li><li>board[i][j] == 0和board[i][j] == 1不用改，因为从左到有从上到下扫描，到该格时，该格的值并未变，只能是0或1，它的左和上3邻居才变了。  </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife2</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># STATUS = &#123;2: (0, 1), 3: (1, 0)&#125;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                live_neighbor_num = self.get_live_neighbor_num2(board, i, j)</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> live_neighbor_num == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> live_neighbor_num <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">                    board[i][j] = <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">2</span>:</span><br><span class="line">                    board[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">3</span>:</span><br><span class="line">                    board[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_live_neighbor_num2</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            x, y = i + _dx, j + _dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[x][y] <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(8n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code></p><hr><h3 id="算法III解题思路"><a href="#算法III解题思路" class="headerlink" title="算法III解题思路"></a><strong>算法III解题思路</strong></h3><p>另外一条follow up是如果matrix无界，可以假设大部分是死细胞，先收集live细胞的list，然后计算live细胞的临近细胞即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/game-of-life/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Accor
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 362 Design Hit Counter</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-362/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-362/</id>
    <published>2021-12-24T19:08:15.516Z</published>
    <updated>2021-12-24T19:30:07.767Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-hit-counter/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Design a hit counter which counts the number of hits received in the past <code>5</code> minutes (i.e., the past <code>300</code> seconds).<br><br>Your system should accept a <code>timestamp</code> parameter (<strong>in seconds</strong> granularity), and you may assume that calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing). Several hits may arrive roughly at the same time.<br><br>Implement the <code>HitCounter</code> class:<br><br><em>   <code>HitCounter()</code> Initializes the object of the hit counter system.</em>   <code>void hit(int timestamp)</code> Records a hit that happened at <code>timestamp</code> (<strong>in seconds</strong>). Several hits may happen at the same <code>timestamp</code>.<br><em>   <code>int getHits(int timestamp)</code> Returns the number of hits in the past 5 minutes from <code>timestamp</code> (i.e., the past <code>300</code> seconds).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“HitCounter”, “hit”, “hit”, “hit”, “getHits”, “hit”, “getHits”, “getHits”]<br>[[], [1], [2], [3], [4], [300], [300], [301]]<br><strong>Output</strong><br>[null, null, null, null, 3, null, 4, 3]<br><br><strong>Explanation</strong><br>HitCounter hitCounter = new HitCounter();<br>hitCounter.hit(1);       // hit at timestamp 1.<br>hitCounter.hit(2);       // hit at timestamp 2.<br>hitCounter.hit(3);       // hit at timestamp 3.<br>hitCounter.getHits(4);   // get hits at timestamp 4, return 3.<br>hitCounter.hit(300);     // hit at timestamp 300.<br>hitCounter.getHits(300); // get hits at timestamp 300, return 4.<br>hitCounter.getHits(301); // get hits at timestamp 301, return 3.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= timestamp &lt;= 2 * 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   All the calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing).</em>   At most <code>300</code> calls will be made to <code>hit</code> and <code>getHits</code>.<br><br><strong>Follow up:</strong> What if the number of hits per second could be huge? Does your design scale?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计统计hits系统。题目要求：同一个时间可以有多个hits，hit是按时间顺序的。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用一个固定大小为300的数组来记录timestamp和对应的hits的总数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求：同一个时间可以有多个hits，hit是按时间顺序的。所以固定数组只要比较现在的timestamp是否和last_timestamp一样，不是的话reset hit。用<strong>循环数组</strong>记录   </li><li>getHist是统计300以内（<strong>不包括300</strong>）的hit数。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitCounter</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.hits = [(<span class="number">0</span>, <span class="number">0</span>)] * <span class="number">300</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hit</span><span class="params">(self, timestamp: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        last_timestamp, count = self.hits[timestamp % <span class="number">300</span>]</span><br><span class="line">        <span class="keyword">if</span> last_timestamp <span class="keyword">and</span> timestamp != last_timestamp:</span><br><span class="line">            self.hits[timestamp % <span class="number">300</span>] = (timestamp, <span class="number">0</span>)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        self.hits[timestamp % <span class="number">300</span>] = (timestamp, count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHits</span><span class="params">(self, timestamp: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t, count <span class="keyword">in</span> self.hits:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">and</span> timestamp - t &lt; <span class="number">300</span>:</span><br><span class="line">                res += count</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>hit时间复杂度为<code>O(1)</code>，getHits时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-hit-counter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Queue" scheme="https://shineboy2013.github.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 692 Top K Frequent Words</title>
    <link href="https://shineboy2013.github.com/2021/12/24/lee-692/"/>
    <id>https://shineboy2013.github.com/2021/12/24/lee-692/</id>
    <published>2021-12-24T08:05:39.130Z</published>
    <updated>2021-12-24T08:12:33.545Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/top-k-frequent-words" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent strings</em>.<br><br>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“i”,”love”,”leetcode”,”i”,”love”,”coding”], k = 2<br><strong>Output:</strong> [“i”,”love”]<br><strong>Explanation:</strong> “i” and “love” are the two most frequent words.<br>Note that “i” comes before “love” due to a lower alphabetical order.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“the”,”day”,”is”,”sunny”,”the”,”the”,”the”,”sunny”,”is”,”is”], k = 4<br><strong>Output:</strong> [“the”,”is”,”sunny”,”day”]<br><strong>Explanation:</strong> “the”, “is”, “sunny” and “day” are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= words.length &lt;= 500</code></em>   <code>1 &lt;= words[i] &lt;= 10</code><br><em>   <code>words[i]</code> consists of lowercase English letters.</em>   <code>k</code> is in the range <code>[1, The number of **unique** words[i]]</code><br><br><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求k个最高频率的单词</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>若频率一样，就按字母顺序lexicographical. 所以用大小为k的heap做比较困难。直接用排序即可   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, words: List[str], k: int)</span> -&gt; List[str]:</span></span><br><span class="line">freq_dict = collections.Counter(words)</span><br><span class="line">li = [(freq, word) <span class="keyword">for</span> word, freq <span class="keyword">in</span> freq_dict.items()]</span><br><span class="line">li.sort(key=<span class="keyword">lambda</span> x : (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">return</span> [pair[<span class="number">1</span>] <span class="keyword">for</span> pair <span class="keyword">in</span> li[:k]]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/top-k-frequent-words&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 718 Maximum Length of Repeated Subarray</title>
    <link href="https://shineboy2013.github.com/2021/12/23/lee-718/"/>
    <id>https://shineboy2013.github.com/2021/12/23/lee-718/</id>
    <published>2021-12-24T04:13:10.909Z</published>
    <updated>2021-12-24T05:06:06.220Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br><strong>Output:</strong> 5<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></em>   <code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两数组的最长相等子数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于是两数组匹配，所以是匹配性DP<br>dp[i][j]为以nums1[i-1], nums2[j-1]为结尾的最长重复数组，答案为滚动最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1 if nums1[i-1] == nums2[j-1]</span><br><span class="line">         = 0                if nums1[i-1] != nums2[j-1]</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j-1] + 1 if nums1[i-1] == nums2[j-1]</span></span><br><span class="line"><span class="comment">#          = 0                if nums1[i-1] != nums2[j-1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">max_length = <span class="number">0</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums1) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">max_length = max(max_length, dp[i][j])</span><br><span class="line"><span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-length-of-repeated-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 162 Find Peak Element</title>
    <link href="https://shineboy2013.github.com/2021/12/23/lee-162/"/>
    <id>https://shineboy2013.github.com/2021/12/23/lee-162/</id>
    <published>2021-12-24T03:34:15.541Z</published>
    <updated>2021-12-24T03:36:35.948Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A peak element is an element that is strictly greater than its neighbors.<br><br>Given an integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.<br><br>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.<br><br>You must write an algorithm that runs in <code>O(log n)</code> time.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,1,3,5,6,4]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 1000</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br>*   <code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找数组极大值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>mid - 1 &gt;= 0    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> mid &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[mid - <span class="number">1</span>] &lt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">return</span> start <span class="keyword">if</span> nums[start] &gt; nums[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-peak-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 012 Integer to Roman</title>
    <link href="https://shineboy2013.github.com/2021/12/23/lee-012/"/>
    <id>https://shineboy2013.github.com/2021/12/23/lee-012/</id>
    <published>2021-12-23T09:32:13.358Z</published>
    <updated>2021-12-24T03:12:41.981Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.<br><br><pre><strong>Symbol</strong>       <strong>Value</strong><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</pre><br><br>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:<br><br><em>   <code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </em>   <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.<br><em>   <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.<br><br>Given an integer, convert it to a roman numeral.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = 3<br><strong>Output:</strong> “III”<br><strong>Explanation:</strong> 3 is represented as 3 ones.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = 58<br><strong>Output:</strong> “LVIII”<br><strong>Explanation:</strong> L = 50, V = 5, III = 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = 1994<br><strong>Output:</strong> “MCMXCIV”<br><strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= num &lt;= 3999</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>阿拉伯数字转罗马数字</p><h3 id="解题思路-推荐-："><a href="#解题思路-推荐-：" class="headerlink" title="解题思路(推荐)："></a><strong>解题思路(推荐)：</strong></h3><p>本质上和算法二一样，但优化了代码。map的内容是一样的但变成list保证顺序，然后从大到小遍历这个map，商对应的symbol放入结果，余数进入下一轮  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>map的内容是一样的但变成list保证顺序，然后从大到小遍历这个map，商对应的symbol放入结果，余数进入下一轮   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">INT_TO_ROMAN = [(<span class="number">1000</span>, <span class="string">'M'</span>), (<span class="number">900</span>, <span class="string">'CM'</span>), (<span class="number">500</span>, <span class="string">'D'</span>), (<span class="number">400</span>, <span class="string">'CD'</span>), (<span class="number">100</span>, <span class="string">'C'</span>),</span><br><span class="line">(<span class="number">90</span>, <span class="string">'XC'</span>), (<span class="number">50</span>, <span class="string">'L'</span>), (<span class="number">40</span>, <span class="string">'XL'</span>), (<span class="number">10</span>, <span class="string">'X'</span>), (<span class="number">9</span>, <span class="string">'IX'</span>), (<span class="number">5</span>, <span class="string">'V'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">'IV'</span>), (<span class="number">1</span>, <span class="string">'I'</span>)]</span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n, symbol <span class="keyword">in</span> INT_TO_ROMAN:</span><br><span class="line">count, num = num // n, num % n</span><br><span class="line">res += symbol * count</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code></p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用int to english的递归方法，将固定值放入到Map中  </li><li>分界点为[4, 5, 9 10], [40, 50, 90, 100]进行递归     </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman2</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">INT_TO_ROMAN = &#123;</span><br><span class="line"><span class="number">0</span>: <span class="string">''</span>,</span><br><span class="line"><span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line"><span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line"><span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line"><span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line"><span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line"><span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line"><span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line"><span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line"><span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line"><span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line"><span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line"><span class="number">1000</span>: <span class="string">'M'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span> INT_TO_ROMAN:</span><br><span class="line"><span class="keyword">return</span> INT_TO_ROMAN[num]</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'I'</span> * num</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">9</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">5</span>) + self.intToRoman(num - <span class="number">5</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">40</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span> * (num // <span class="number">10</span>) + self.intToRoman(num % <span class="number">10</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">50</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">40</span>) + self.intToRoman(num - <span class="number">40</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">90</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">50</span>) + self.intToRoman(num - <span class="number">50</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">100</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">90</span>) + self.intToRoman(num % <span class="number">90</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">400</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span> * (num // <span class="number">100</span>) + self.intToRoman(num % <span class="number">100</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">500</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">400</span>) + self.intToRoman(num - <span class="number">400</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">900</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">500</span>) + self.intToRoman(num - <span class="number">500</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">1000</span>:</span><br><span class="line"><span class="keyword">return</span> self.intToRoman(<span class="number">900</span>) + self.intToRoman(num % <span class="number">900</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'M'</span> * (num // <span class="number">1000</span>) + self.intToRoman(num % <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/integer-to-roman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;R
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1710 Maximum Units on a Truck</title>
    <link href="https://shineboy2013.github.com/2021/12/23/lee-1710/"/>
    <id>https://shineboy2013.github.com/2021/12/23/lee-1710/</id>
    <published>2021-12-23T08:05:59.421Z</published>
    <updated>2021-12-23T08:12:35.354Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-units-on-a-truck" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are assigned to put some amount of boxes onto <strong>one truck</strong>. You are given a 2D array <code>boxTypes</code>, where <code>boxTypes[i] = [numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;, numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt;]</code>:<br><br><em>   <code>numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;</code> is the number of boxes of type <code>i</code>.</em>   <code>numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt;</code>is the number of units in each box of the type <code>i</code>.<br><br>You are also given an integer <code>truckSize</code>, which is the <strong>maximum</strong> number of <strong>boxes</strong> that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed <code>truckSize</code>.<br><br>Return <em>the <strong>maximum</strong> total number of <strong>units</strong> that can be put on the truck.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> There are:<br>- 1 box of the first type that contains 3 units.<br>- 2 boxes of the second type that contain 2 units each.<br>- 3 boxes of the third type that contain 1 unit each.<br>You can take all the boxes of the first and second types, and one box of the third type.<br>The total number of units will be = (1 <em> 3) + (2 </em> 2) + (1 <em> 1) = 8.<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10<br><strong>Output:</strong> 91<br></pre><br><br><strong>Constraints:</strong>   <code>1 &lt;= boxTypes.length &lt;= 1000</code><br><em>   <code>1 &lt;= numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;, numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt; &lt;= 1000</code></em>   <code>1 &lt;= truckSize &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>货车能装的最大unit数，每种类型的盒都能装一定数量的units，而每种盒子占地方一样。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由于每种盒子占地一样，所以当然是先放unit大的。贪婪法。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>按unit数倒序排序   </li><li>pair是一个数组，要加pair[i][0]  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumUnits</span><span class="params">(self, boxTypes: List[List[int]], truckSize: int)</span> -&gt; int:</span></span><br><span class="line">pairs = [(li[<span class="number">1</span>], li[<span class="number">0</span>]) <span class="keyword">for</span> li <span class="keyword">in</span> boxTypes]</span><br><span class="line">pairs.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">res, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">res += pair[<span class="number">0</span>] * min(pair[<span class="number">1</span>], truckSize)</span><br><span class="line">truckSize -= pair[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> truckSize &lt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-units-on-a-truck&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 009 Palindrome Number</title>
    <link href="https://shineboy2013.github.com/2021/12/22/lee-009/"/>
    <id>https://shineboy2013.github.com/2021/12/22/lee-009/</id>
    <published>2021-12-23T07:17:07.405Z</published>
    <updated>2021-12-23T07:22:40.899Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>x</code>, return <code>true</code> if <code>x</code> is palindrome integer.<br><br>An integer is a <strong>palindrome</strong> when it reads the same backward as forward.<br><br><em>   For example, <code>121</code> is a palindrome while <code>123</code> is not.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 121<br><strong>Output:</strong> true<br><strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = -121<br><strong>Output:</strong> false<br><strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 10<br><strong>Output:</strong> false<br><strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.<br></pre><br><br><strong>Constraints:</strong></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= x &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you solve it without converting the integer to a string?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断是否回文数字</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">return</span> str(x) == str(x)[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>Follow-up 不能用str，就求它的reversed数</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>x是用于计算过程，所以不断变化，最后一行不能用它来与reversed的结果比较  </li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome2</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">rev, original = <span class="number">0</span>, x</span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">rev = rev * <span class="number">10</span> + x % <span class="number">10</span> <span class="comment"># 121</span></span><br><span class="line">x = x // <span class="number">10</span> <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">return</span> rev == original</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 021 Merge Two Sorted Lists</title>
    <link href="https://shineboy2013.github.com/2021/12/22/lee-021/"/>
    <id>https://shineboy2013.github.com/2021/12/22/lee-021/</id>
    <published>2021-12-23T05:01:57.216Z</published>
    <updated>2021-12-23T05:05:14.796Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.<br><br>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.<br><br>Return <em>the head of the merged linked list</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""><br><br><pre><strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]<br><strong>Output:</strong> [1,1,2,3,4,4]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> list1 = [], list2 = []<br><strong>Output:</strong> []<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> list1 = [], list2 = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in both lists is in the range <code>[0, 50]</code>.</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><em>   Both <code>list1</code> and <code>list2</code> are sorted in <em>*non-decreasing</em></em> order.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>合并两个LL</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Fake Node的引入    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, list1: ListNode, list2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">fake_head = ListNode(<span class="number">0</span>)</span><br><span class="line">it, it2, it_res = list1, list2, fake_head</span><br><span class="line"><span class="keyword">while</span> it <span class="keyword">and</span> it2:</span><br><span class="line"><span class="keyword">if</span> it.val &lt;= it2.val:</span><br><span class="line">it_res.next = it</span><br><span class="line">it = it.next</span><br><span class="line">it_res = it_res.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">it_res.next = it2</span><br><span class="line">it2 = it2.next</span><br><span class="line">it_res = it_res.next</span><br><span class="line"><span class="keyword">if</span> it:</span><br><span class="line">it_res.next = it</span><br><span class="line"><span class="keyword">if</span> it2:</span><br><span class="line">it_res.next = it2</span><br><span class="line"><span class="keyword">return</span> fake_head.next</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 174 Dungeon Game</title>
    <link href="https://shineboy2013.github.com/2021/12/22/lee-174/"/>
    <id>https://shineboy2013.github.com/2021/12/22/lee-174/</id>
    <published>2021-12-22T08:17:51.841Z</published>
    <updated>2021-12-22T09:24:15.631Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.<br><br><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, wordDict = [“leet”,”code”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because “leetcode” can be segmented as “leet code”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “applepenapple”, wordDict = [“apple”,”pen”]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Return true because “applepenapple” can be segmented as “apple pen apple”.<br>Note that you are allowed to reuse a dictionary word.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “catsandog”, wordDict = [“cats”,”dog”,”sand”,”and”,”cat”]<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 300</code></em>   <code>1 &lt;= wordDict.length &lt;= 1000</code><br><em>   <code>1 &lt;= wordDict[i].length &lt;= 20</code></em>   <code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.<br><em>   All the strings of <code>wordDict</code> are <em>*unique</em></em>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>保持正数健康值从左上走到右下  </p><h3 id="DP解题思路-推荐-："><a href="#DP解题思路-推荐-：" class="headerlink" title="DP解题思路(推荐)："></a><strong>DP解题思路(推荐)：</strong></h3><p>坐标型DP。<br>dp[n][m]为通过<strong>这一格前</strong>的最小健康值，也就是题目所求，这意味着需要保证通过最后一个后的健康值为1，所以引入它相邻的两个cell为1<br>递归式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[n][m] = -dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span><br><span class="line">         = max&#123;1, min(dp[n+1][m], dp[n][m+1]) - dungeon[n][m]&#125; if dungeon[n][m] &gt; 0</span><br></pre></td></tr></table></figure></p><p>由于-dungeon[n][m] + min(dp[n+1][m]一定为正数，所以可以归并两种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n][m] = max&#123;1, min(dp[n+1][m], dp[n][m+1]) - dungeon[n][m]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>从右下走回左上倒推初始值。每一格的最小健康值在为1，而初始健康值也最小为1.  </li><li>递归式：一开始的递归式跟下和右格的极小值有关，所以DP数组(比原数组多出的)最右和最下边界初始值为正无穷；但根据公式，右下格会出现正无穷，所以需要特别处理，<strong>将右下格的相邻下右两格初始为1</strong>，可以这样理解，从右下格走出健康值必须是1    </li><li>递归式：一开始写若该格dungeon值为负数，1 - dungeon[n][m] + min(dp[n+1][m], dp[n][m+1])这个1的确保证了最小健康值为1，但其实它只要加一次，而上述右下边界已经处理，所以<strong>递归式不需要+1</strong>，如[[-2, -3]], dp[0][1]=4, 而dp[0][0]为6即可  </li><li>递归式：当dungeon为正数时，可以抵消它相邻格所要求的最低健康值，当然要保证健康值大于1，如[5, 4, -2], dp[0][0] = 1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[n][m] = 1 - dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span></span><br><span class="line"><span class="comment">#          = 1 + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &gt; 0</span></span><br><span class="line"><span class="comment"># dp[n][m] = -dungeon[n][m] + min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &lt; 0</span></span><br><span class="line"><span class="comment">#          = min(dp[n+1][m], dp[n][m+1]) if dungeon[n][m] &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(dungeon[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(dungeon) + <span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">-1</span>][<span class="number">-2</span>] = dp[<span class="number">-2</span>][<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(dungeon))):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(len(dungeon[<span class="number">0</span>]))):</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">min_neighbor = float('inf')</span></span><br><span class="line"><span class="string">if i + 1 &lt; len(dungeon):</span></span><br><span class="line"><span class="string">min_neighbor = min(min_neighbor, dp[i + 1][j])</span></span><br><span class="line"><span class="string">if j + 1 &lt; len(dungeon[0]):</span></span><br><span class="line"><span class="string">min_neighbor = min(min_neighbor, dp[i][j + 1])</span></span><br><span class="line"><span class="string">if min_neighbor == float('inf'):</span></span><br><span class="line"><span class="string">min_neighbor = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if dungeon[i][j] &lt; 0:</span></span><br><span class="line"><span class="string">dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">dp[i][j] = max(<span class="number">1</span>, min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j])</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p><hr><h3 id="Binary-select算法II解题思路："><a href="#Binary-select算法II解题思路：" class="headerlink" title="Binary select算法II解题思路："></a><strong>Binary select算法II解题思路：</strong></h3><p>Binary select + DP<br>暴力法，假设某个初始健康值，然后用从左到右从上到下计算<strong>这一格后的健康值</strong>，dp[m][n] = max{dp[m-1][n], dp[m][n-1]} + dungeon[r][c], 可以看出dp定义和递归式max都是跟上述方法相反。求最后一个是否正数<br>暴力法是O(n^2), 而用binary select试0, 1000 * (m + n) + 1，1000是cell的最大值，m+n是路径长度，1是最小健康值，二分法试每个数值  </p><p>参考<a href="https://leetcode.com/problems/dungeon-game/discuss/1498367" target="_blank" rel="noopener">https://leetcode.com/problems/dungeon-game/discuss/1498367</a>  </p><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)logn</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 013 Roman to Integer</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-013/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-013/</id>
    <published>2021-12-21T09:34:21.623Z</published>
    <updated>2021-12-21T09:46:06.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.<br><br><pre><strong>Symbol</strong>       <strong>Value</strong><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</pre><br><br>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:<br><br><em>   <code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </em>   <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.<br><em>   <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.<br><br>Given a roman numeral, convert it to an integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “III”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> III = 3.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “LVIII”<br><strong>Output:</strong> 58<br><strong>Explanation:</strong> L = 50, V= 5, III = 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “MCMXCIV”<br><strong>Output:</strong> 1994<br><strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length &lt;= 15</code><br><em>   <code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</em>   It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>罗马数组转阿拉伯数字</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按照规则累加。有一个特别规则是需要做减法如IV。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先加再减的方法。  </li><li>SYMBOL_TO_VAL的值可以哟用于判断先后顺序。     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">SYMBOL_TO_VAL = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">res, num, prev = <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> s:</span><br><span class="line">num = SYMBOL_TO_VAL[symbol]</span><br><span class="line"><span class="keyword">if</span> prev <span class="keyword">and</span> SYMBOL_TO_VAL[prev] &lt; SYMBOL_TO_VAL[symbol]:</span><br><span class="line">res -= SYMBOL_TO_VAL[prev] * <span class="number">2</span></span><br><span class="line">res += num</span><br><span class="line">prev = symbol</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;R
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1570 Dot Product of Two Sparse Vectors</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-1570/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-1570/</id>
    <published>2021-12-21T08:49:53.594Z</published>
    <updated>2021-12-21T08:58:36.300Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two sparse vectors, compute their dot product.<br><br>Implement class <code>SparseVector</code>:<br><br><em>   <code>SparseVector(nums)</code> Initializes the object with the vector <code>nums</code></em>   <code>dotProduct(vec)</code> Compute the dot product between the instance of <em>SparseVector</em> and <code>vec</code><br><br>A <strong>sparse vector</strong> is a vector that has mostly zero values, you should store the sparse vector <strong>efficiently</strong> and compute the dot product between two <em>SparseVector</em>.<br><br><strong>Follow up: </strong>What if only one of the vectors is sparse?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 1<em>0 + 0</em>3 + 0<em>0 + 2</em>4 + 3<em>0 = 8<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 00 + 1<em>0 + 0</em>0 + 0<em>0 + 0</em>2 = 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums1.length == nums2.length</code></em>   <code>1 &lt;= n &lt;= 10^5</code><br>*   <code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>稀疏数组乘法，设计类来存储且计算乘积</p><h3 id="HashMap解题思路："><a href="#HashMap解题思路：" class="headerlink" title="HashMap解题思路："></a><strong>HashMap解题思路：</strong></h3><p>类似于Two sum，也是两种方法。HashMap的方法由于hash函数计算容易冲突，所以算法复杂度不够稳定。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.idx_to_num = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.idx_to_num[i] = n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> vec.idx_to_num.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> self.idx_to_num:</span><br><span class="line">                res += self.idx_to_num[i] * n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p><hr><h3 id="Mergesort算法II解题思路："><a href="#Mergesort算法II解题思路：" class="headerlink" title="Mergesort算法II解题思路："></a><strong>Mergesort算法II解题思路：</strong></h3><p>初始化复杂度比较稳定  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.non_zero_list = []</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.non_zero_list.append((i,n))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(self.non_zero_list) - <span class="number">1</span> <span class="keyword">and</span> j &lt;= len(vec.non_zero_list) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> self.non_zero_list[i][<span class="number">0</span>] == vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                res += self.non_zero_list[i][<span class="number">1</span>] * vec.non_zero_list[j][<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> self.non_zero_list[i][<span class="number">0</span>] &lt; vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L1 + L2)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/dot-product-of-two-sparse-vectors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 050 Pow(x, n)</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-050/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-050/</id>
    <published>2021-12-21T08:03:42.776Z</published>
    <updated>2021-12-21T08:06:48.730Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x&lt;sup&gt;n&lt;/sup&gt;</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = 10<br><strong>Output:</strong> 1024.00000<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 2.10000, n = 3<br><strong>Output:</strong> 9.26100<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = -2<br><strong>Output:</strong> 0.25000<br><strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-100.0 &lt; x &lt; 100.0</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= n &lt;= 2&lt;sup&gt;31&lt;/sup&gt;-1</code><br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= x&lt;sup&gt;n&lt;/sup&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求幂</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>保存dfs(x, n/2)的临时结果，避免重复计算   </li><li>n可以是0，负数 </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs(x, n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs(<span class="number">1</span> / x, -n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">tmp = self.dfs(x, n / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> tmp * tmp</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp = self.dfs(x, (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> tmp * tmp * x</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/powx-n/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Implement &lt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Recursion" scheme="https://shineboy2013.github.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 443 String Compression</title>
    <link href="https://shineboy2013.github.com/2021/12/20/lee-443/"/>
    <id>https://shineboy2013.github.com/2021/12/20/lee-443/</id>
    <published>2021-12-21T07:37:40.086Z</published>
    <updated>2021-12-21T07:43:38.054Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-compression/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of characters <code>chars</code>, compress it using the following algorithm:<br><br>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:<br><br><em>   If the group’s length is <code>1</code>, append the character to <code>s</code>.</em>   Otherwise, append the character followed by the group’s length.<br><br>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.<br><br>After you are done <strong>modifying the input array</strong>, return <em>the new length of the array</em>.<br><br>You must write an algorithm that uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>Explanation:</strong> The groups are “aa”, “bb”, and “ccc”. This compresses to “a2b2c3”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> chars = [“a”]<br><strong>Output:</strong> Return 1, and the first character of the input array should be: [“a”]<br><strong>Explanation:</strong> The only group is “a”, which remains uncompressed since it’s a single character.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br><strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”].<br><strong>Explanation:</strong> The groups are “a” and “bbbbbbbbbbbb”. This compresses to “ab12”.</pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”a”,”b”,”b”,”a”,”a”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”3”,”b”,”2”,”a”,”2”].<br><strong>Explanation:</strong> The groups are “aaa”, “bb”, and “aa”. This compresses to “a3b2a2”. Note that each group is independent even if two groups have the same character.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= chars.length &lt;= 2000</code></em>   <code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>相邻相同字母用数字压缩</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求，如果是超过10，也要将这个数按多个字符populate到原数组，见populate_count的实现，用字符串处理  </li><li>在循环外处理最后一部分    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class="line">res, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(chars)):</span><br><span class="line"><span class="keyword">if</span> chars[i - <span class="number">1</span>] == chars[i]:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">res = self.populate_count(chars, res, count)</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">chars[res] = chars[i]</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">res = self.populate_count(chars, res, count)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">populate_count</span><span class="params">(self, chars, res, count)</span>:</span></span><br><span class="line">num_str = str(count)</span><br><span class="line">chars[res:res + len(num_str)] = [c <span class="keyword">for</span> c <span class="keyword">in</span> num_str]</span><br><span class="line">res += len(num_str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-compression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 011 Container With Most Water</title>
    <link href="https://shineboy2013.github.com/2021/12/20/lee-011/"/>
    <id>https://shineboy2013.github.com/2021/12/20/lee-011/</id>
    <published>2021-12-21T03:41:35.494Z</published>
    <updated>2021-12-21T03:44:13.071Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.<br><br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br><br>Return <em>the maximum amount of water a container can store</em>.<br><br><strong>Notice</strong> that you may not slant the container.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""><br><br><pre><strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49<br><strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> height = [1,1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == height.length</code></em>   <code>2 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= height[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两板之间的最大水量</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>贪婪法，求面积，然后移动矮的那条边</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>贪婪法，求面积，然后移动矮的那条边    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">i, j = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; j:</span><br><span class="line">res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class="line"><span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
</feed>
