<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-05T20:31:48.459Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 354 Russian Doll Envelopes</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-354/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-354/</id>
    <published>2021-12-05T20:30:23.930Z</published>
    <updated>2021-12-05T20:31:48.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>N/A</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || </span><br><span class="line">envelopes[<span class="number">0</span>] == <span class="keyword">null</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="comment">// remember for 2d array</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]; <span class="comment">// remember the reverse order for [4,5], [4,6] case must strictly increasing for width and height</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] lis = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] e : envelopes) &#123;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(lis, <span class="number">0</span>, len, e[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">index = -index - <span class="number">1</span>;</span><br><span class="line">lis[index] = e[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">lis[index] = e[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(index == len)</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>Insert时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 460 LFU Cache</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-460/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-460/</id>
    <published>2021-12-05T20:09:49.230Z</published>
    <updated>2021-12-05T20:18:23.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>在LRU基础上，ListNode引入freq域， 当频率增加时候，找到新的频率对应的末节点插入。其它基本不变。插入最差是O(n). 要提高的话，需要加入map<freq, listnodehead="">和minFreq来迅速定位下一个插入位置。第一个Map不变，但LL不再是一串，而是按频率大小的多串。          </freq,></li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">ListNode head; <span class="comment">// from most frequent to less</span></span><br><span class="line">ListNode tail;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L460LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>, Integer.MIN_VALUE);</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">moveUp(key);</span><br><span class="line"><span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(capacity == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">moveUp(key);</span><br><span class="line">map.get(key).val = value; <span class="comment">// remember to update the value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map.size() == capacity) &#123;</span><br><span class="line">map.remove(tail.prev.key);</span><br><span class="line">deleteNode(tail.prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new key</span></span><br><span class="line">ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">addNode(newNode, tail);</span><br><span class="line">map.put(key, newNode);</span><br><span class="line">moveUp(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveUp</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">ListNode curNode = map.get(key);</span><br><span class="line">curNode.addOne();</span><br><span class="line">ListNode iterNode = curNode;</span><br><span class="line"><span class="keyword">while</span>(iterNode.freq &lt;= curNode.freq)</span><br><span class="line">iterNode = iterNode.prev;</span><br><span class="line"><span class="keyword">if</span>(iterNode != curNode) &#123;</span><br><span class="line">deleteNode(curNode);</span><br><span class="line">addNode(curNode, iterNode.next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(ListNode curNode, ListNode nextNode)</span> </span>&#123;</span><br><span class="line">ListNode prevNode = nextNode.prev;</span><br><span class="line">prevNode.next = curNode;</span><br><span class="line">curNode.prev = prevNode;</span><br><span class="line">curNode.next = nextNode;</span><br><span class="line">nextNode.prev = curNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete head node and updated node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">ListNode nextNode = curNode.next;</span><br><span class="line">ListNode prevNode = curNode.prev;</span><br><span class="line">prevNode.next = nextNode;</span><br><span class="line">nextNode.prev = prevNode;</span><br><span class="line">curNode.next = <span class="keyword">null</span>;</span><br><span class="line">curNode.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> ListNode next;</span><br><span class="line"><span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val, <span class="keyword">int</span> freq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.freq = freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freq++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>Insert时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 973 K Closest Points to Origin</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-973/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-973/</id>
    <published>2021-12-05T19:53:49.138Z</published>
    <updated>2021-12-05T19:55:05.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">PriorityQueue&lt;Point&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Point&gt;(K,</span><br><span class="line"><span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> distance(o2, o1); <span class="comment">// descending</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">Point p = <span class="keyword">new</span> Point(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(maxHeap.size() &lt; K)</span><br><span class="line">maxHeap.offer(p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(distance(p, maxHeap.peek()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">maxHeap.poll();</span><br><span class="line">maxHeap.offer(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!maxHeap.isEmpty()) &#123;</span><br><span class="line">Point p = maxHeap.poll();</span><br><span class="line">res[j][<span class="number">0</span>] = p.x;</span><br><span class="line">res[j][<span class="number">1</span>] = p.y;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (o1.x * o1.x + o1.y * o1.y) - (o2.x * o2.x + o2.y * o2.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">int</span> y;</span><br><span class="line"> Point() &#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line"> Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x = a; y = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(k)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 051 N-Queens</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-051/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-051/</id>
    <published>2021-12-05T19:13:17.686Z</published>
    <updated>2021-12-05T19:14:55.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens2(<span class="keyword">int</span> n) &#123;</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">solveR(n, col, <span class="number">0</span>, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5/2/2020</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveR</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] col, <span class="keyword">int</span> st, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(st == n) &#123;</span><br><span class="line">print(col, res);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">col[st] = i;</span><br><span class="line"><span class="keyword">if</span>(isValid(col, st))</span><br><span class="line">solveR(n, col, st + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] col, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(col[i] == col[k])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(Math.abs(k - i) == Math.abs(col[k] - col[i])) <span class="comment">//use abs</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(n^2)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 015 3Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-015/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-015/</id>
    <published>2021-12-05T19:09:01.704Z</published>
    <updated>2021-12-05T19:10:01.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; re = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">twoPointers(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>, -nums[i], re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoPointers</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; re)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftOri = left, rightOri = right;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt; leftOri &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) &#123;</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right &lt; rightOri &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[left] + nums[right] == target) </span><br><span class="line">re.add(Arrays.asList(-target, nums[left++], nums[right--]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; target)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n^2)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 075 Sort Colors</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-075/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-075/</id>
    <published>2021-12-05T19:05:21.391Z</published>
    <updated>2021-12-05T19:06:23.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> middleStart = <span class="number">0</span>, middleEnd = nums.length-<span class="number">1</span>, i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=middleEnd)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]==<span class="number">2</span>)</span><br><span class="line">swap(nums,i,middleEnd--);<span class="comment">//no i++ coz 2,0,2,2, swap 2,2 and i can't +1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">swap(nums,i++,middleStart++);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 098 Validate Binary Search Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-098/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-098/</id>
    <published>2021-12-05T19:02:01.816Z</published>
    <updated>2021-12-05T19:02:54.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recommended method: use min max and devide &amp; conquer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// val can be Integer.Min so use long</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(min &gt;= root.val || max &lt;= root.val)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isValid(root.left, min, root.val) &amp;&amp; </span><br><span class="line">isValid(root.right, root.val, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method 2: use isVisited</span></span><br><span class="line">TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.left))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lastVisited!=<span class="keyword">null</span> &amp;&amp; lastVisited.val&gt;=root.val)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">lastVisited = root;<span class="comment">//in-order traversal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.right))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 230 Kth Smallest Element in a BST</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-230/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-230/</id>
    <published>2021-12-05T18:43:11.374Z</published>
    <updated>2021-12-05T18:56:16.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> kthSmallest2R(root, k).result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">kthSmallest2R</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">ResultType leftResult = kthSmallest2R(root.left, k);</span><br><span class="line"></span><br><span class="line">Integer result = leftResult.result;</span><br><span class="line"><span class="keyword">if</span>(result != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResultType(result, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(leftResult.count + <span class="number">1</span> == k)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResultType(root.val, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ResultType rightResult = kthSmallest2R(root.right, k - <span class="number">1</span> - leftResult.count);</span><br><span class="line">result = rightResult.result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResultType(result, leftResult.count + <span class="number">1</span> + rightResult.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> </span>&#123;</span><br><span class="line">Integer result;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResultType</span><span class="params">(Integer r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">result = r;</span><br><span class="line">count = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Tree" scheme="https://shineboy2013.github.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 153 Find Minimum in Rotated Sorted Array</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-153/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-153/</id>
    <published>2021-12-05T18:38:05.358Z</published>
    <updated>2021-12-05T18:38:46.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[start] &gt; nums[end]) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; nums[end])</span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = mid;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> nums[start];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[start] &lt; nums[end])</span><br><span class="line"><span class="keyword">return</span> nums[start];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> nums[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 033 Search in Rotated Sorted Array</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-033/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-033/</id>
    <published>2021-12-05T18:35:46.612Z</published>
    <updated>2021-12-05T18:36:28.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A       </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &gt; nums[start]) &#123; <span class="comment">// the left segment is increasing</span></span><br><span class="line"><span class="comment">// pay attention to equal </span></span><br><span class="line"><span class="keyword">if</span>(nums[start] &lt;= target &amp;&amp; target &lt;= nums[mid]) <span class="comment">//the [start, mid] is increasing</span></span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = mid;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) <span class="comment">// the [mid, end] is increasing</span></span><br><span class="line">start = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">end = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[start] == target)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"><span class="keyword">if</span>(nums[end] == target)</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 278 First Bad Version</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-278/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-278/</id>
    <published>2021-12-05T18:29:06.491Z</published>
    <updated>2021-12-05T18:31:18.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目是先good再bad，所以用first position模板     </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>, end = n;</span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(isBadVersion(mid)) </span><br><span class="line">end = mid;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">start = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isBadVersion(start))</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 210 Course Schedule II</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-210/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-210/</id>
    <published>2021-12-05T18:18:44.453Z</published>
    <updated>2021-12-05T18:21:09.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>N/A     </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"><span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"><span class="comment">//populate inDegree &amp; convert to graph</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line"><span class="comment">//[0,1] means 1-&gt;0</span></span><br><span class="line">inDegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">graph.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">q.offer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">Integer v = q.poll();</span><br><span class="line">res.add(v);</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line"><span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">0</span>)</span><br><span class="line">q.add(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count != numCourses)</span><br><span class="line">res.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res.stream().mapToInt(i-&gt;i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
      <category term="Topological Sort" scheme="https://shineboy2013.github.com/tags/Topological-Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 198 House Robber</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-198/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-198/</id>
    <published>2021-12-05T18:03:21.935Z</published>
    <updated>2021-12-05T18:05:15.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>循环不是模板中的1开始，而是从2开始，因为i-2&gt;=0     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Two Pointers</title>
    <link href="https://shineboy2013.github.com/2021/12/05/two-pointers/"/>
    <id>https://shineboy2013.github.com/2021/12/05/two-pointers/</id>
    <published>2021-12-05T08:05:50.056Z</published>
    <updated>2021-12-05T08:09:53.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>j is left pointer, i is right pointer</p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_pointers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &lt;meets condition&gt;:</span><br><span class="line">&lt;calculate result&gt;</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> &lt;result&gt;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;j is left pointer, i is right pointer&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 209 Minimum Size Subarray Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/05/lee-209/"/>
    <id>https://shineboy2013.github.com/2021/12/05/lee-209/</id>
    <published>2021-12-05T08:01:05.962Z</published>
    <updated>2021-12-05T08:03:52.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求最小值，所以min_len初始化最大值  </li><li>长度为i - j + 1写例子来计算     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">min_len, num_sum, j = sys.maxsize, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">num_sum += nums[i]</span><br><span class="line"><span class="keyword">while</span> num_sum &gt;= target:</span><br><span class="line">min_len = min(min_len, i - j + <span class="number">1</span>)</span><br><span class="line">num_sum -= nums[j]</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == sys.maxsize <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 373 Find K Pairs with Smallest Sums</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-373/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-373/</id>
    <published>2021-12-05T07:23:00.289Z</published>
    <updated>2021-12-05T07:26:08.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>类似于BFS模板，只不过是将queue换成heap。  </li><li>将两数和加入到heap中，而不是下标的和(粗心)  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span><span class="params">(self, nums1: List[int], nums2: List[int], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">heap, res = [(nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)], []</span><br><span class="line">visited = set([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">node = heapq.heappop(heap)</span><br><span class="line">res.append([nums1[node[<span class="number">1</span>]], nums2[node[<span class="number">2</span>]]])</span><br><span class="line"><span class="keyword">if</span> len(res) == k:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">_x, _y = node[<span class="number">1</span>] + _dx, node[<span class="number">2</span>] + _dy</span><br><span class="line"><span class="keyword">if</span> _x &lt; len(nums1) <span class="keyword">and</span> _y &lt; len(nums2) <span class="keyword">and</span> (_x, _y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">heapq.heappush(heap, (nums1[_x] + nums2[_y], _x, _y))</span><br><span class="line">visited.add((_x, _y))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(k)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; class=&quot;headerlink&quot; title=&quot;注意事项：&quot;&gt;&lt;/a&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类似于BFS模板，只不过是将queue换成heap。  &lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 236 Lowest Common Ancestor of a Binary Tree</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-236/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-236/</id>
    <published>2021-12-05T05:54:04.675Z</published>
    <updated>2021-12-05T05:55:14.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"><span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line"><span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python代码：&quot;&gt;&lt;a href=&quot;#Python代码：&quot; class=&quot;headerlink&quot; title=&quot;Python代码：&quot;&gt;&lt;/a&gt;&lt;strong&gt;Python代码：&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight pyt
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 291 Word Pattern II</title>
    <link href="https://shineboy2013.github.com/2021/12/04/lee-291/"/>
    <id>https://shineboy2013.github.com/2021/12/04/lee-291/</id>
    <published>2021-12-04T08:56:20.388Z</published>
    <updated>2021-12-04T09:19:51.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>类似于word break，但由于要存储处理过map和set，DP不能处理，所以只能用DFS    </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较映射，用Map比较A-&gt;B的映射，如已有a-&gt;dog, 另一对映射a-&gt;cat通过查找Map知道不合法。B-&gt;A的映射可通过将map的所有value存到一个set中知道。如a-&gt;dog, b-&gt;dog. b不在Map中但b对应的dog在set中，不合法。<br>DFS的API为dfs(pattern, word, pattern_to_word, used_set)  </li><li>若pattern的字母出现过，如aba，不应进入循环，更不应该加入到map和set中，应该用startswith比较word判断是否合法，若是，直接下一轮DFS(Line 11 -15)     </li><li>1中的两情况的第一种情况以及第二种情况的前半部分(b不在map中)在2中已经处理，所以只要在循环中处理第二种情况后半部分(b对应的dog在set中)即可(Line 22 - 23)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordPatternMatch</span><span class="params">(self, pattern: str, s: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> pattern <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(pattern, s, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, pattern, s, start_p, start_s, pattern_to_s, s_set)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">and</span> start_s &gt;= len(s):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> start_p &gt;= len(pattern) <span class="keyword">or</span> start_s &gt;= len(s):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">char = pattern[start_p]</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> pattern_to_s:</span><br><span class="line">word = pattern_to_s[char]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s[start_s:].startswith(word):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, start_s + len(word), pattern_to_s, s_set)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(start_s, len(s)):</span><br><span class="line">matched_word = s[start_s:j + <span class="number">1</span>]</span><br><span class="line"><span class="string">'''if char in pattern_to_s and pattern_to_s[char] != matched_word:</span></span><br><span class="line"><span class="string">continue</span></span><br><span class="line"><span class="string">if char not in pattern_to_s and matched_word in s_set:  # remembers</span></span><br><span class="line"><span class="string">continue'''</span></span><br><span class="line"><span class="keyword">if</span> matched_word <span class="keyword">in</span> s_set:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">pattern_to_s[char] = matched_word</span><br><span class="line">s_set.add(matched_word)</span><br><span class="line"><span class="keyword">if</span> self.dfs(pattern, s, start_p + <span class="number">1</span>, j + <span class="number">1</span>, pattern_to_s, s_set):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">s_set.remove(matched_word)</span><br><span class="line">pattern_to_s.pop(char)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度为<code>O(解大小)</code>。   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;类似于word break，但由于要存储处理过map和set，DP不能处理，所以只
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 212 Word Search II</title>
    <link href="https://shineboy2013.github.com/2021/12/03/lee-212/"/>
    <id>https://shineboy2013.github.com/2021/12/03/lee-212/</id>
    <published>2021-12-04T04:40:24.094Z</published>
    <updated>2021-12-04T05:35:11.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用Trie来保存单词列表，这样每次DFS的每一步都可以O(1)时间知道是否和单词吻合，而不是O(n)</li><li>难点1: Trie的接口有startswith, search, insert，仅insert可以用，其他两个不支持与DFS同步搜索。所以要写一个新函数：其实修改startsWith将for循环去掉当然DFS的API也要改，去掉word, word_index加入trie, trie_node, path, res  </li><li>TLE错误，因为比如矩阵为[abc]，单词列表为abc, abc, abc，这样abc加入到结果后就不应该再搜abc，因为结果不能重且效率大打折扣。如果找到了单词，就应该将它从Trie中去掉，避免无谓的搜索，条件是该节点children长度为0，就父节点就将key删除。如果还有儿子节点只能标记is_end为False。Line 29 - 31和35 - 36</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        trie, res = Trie(), []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(word)</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, visited, trie, trie.get_head(), <span class="string">''</span>, res)</span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, visited, trie, trie_node, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        trie_child = trie.search_one_node(board[start_x][start_y], trie_node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trie_child:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        path += board[start_x][start_y]</span><br><span class="line">        <span class="keyword">if</span> trie_child.is_end:</span><br><span class="line">            res.append(path)</span><br><span class="line">            trie_child.is_end = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">                trie_node.children.pop(board[start_x][start_y])</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            self.dfs(board, start_x + dx, start_y + dy, visited, trie, trie_child, path, res)</span><br><span class="line">        path = path[:<span class="number">-1</span>]</span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(trie_child.children) == <span class="number">0</span> <span class="keyword">and</span> board[start_x][start_y] <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            trie_node.children.pop(board[start_x][start_y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            it = it.children[word[i]]</span><br><span class="line">            <span class="keyword">if</span> i == len(word) - <span class="number">1</span>:</span><br><span class="line">                it.is_end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_one_node</span><span class="params">(self, c: str, trie_node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> trie_node.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> trie_node.children[c]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.is_end = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*4*3<sup>L-1</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向,第一个可以4个方向，其他步是3个方向    </p><p>有一个方法是不用Trie而是将单词所有prefix放入到set中，但会TLE，因为时间复杂度为<code>O(<em>n</em><sup>2</sup><em>3</em><sup>n*n</sup>)</code>，它不会剪枝，从顶点出发，最差情况是z型走完board，此时路径长度为n*n.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 079 Word Search</title>
    <link href="https://shineboy2013.github.com/2021/12/03/lee-079/"/>
    <id>https://shineboy2013.github.com/2021/12/03/lee-079/</id>
    <published>2021-12-03T22:10:46.406Z</published>
    <updated>2021-12-04T05:28:34.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>N/A  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点在于判断不合法情况的顺序，比DFS模板稍复杂。这些语句都在for循环外，按此顺序： word_index和(start_x, start_y)不合法，该点访问过(模板)，字母不等。<br>然后visited为True，循环后visited为False      </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(board))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, i, j, word, <span class="number">0</span>, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, start_x, start_y, word, word_index, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word_index &gt;= len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> start_x &lt; <span class="number">0</span> <span class="keyword">or</span> start_x &gt;= len(board) <span class="keyword">or</span> start_y &lt; <span class="number">0</span> <span class="keyword">or</span> start_y &gt;= len(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[start_x][start_y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> board[start_x][start_y] != word[word_index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board, start_x + dx, start_y + dy, word, word_index + <span class="number">1</span>, visited):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visited[start_x][start_y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>*<em>3</em><sup>L</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>, n是矩阵长度，L是最大单词长度.<br>3是因为访问过的节点不合法，也就是来的节点不能再走一次，所以只能3个方向    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;N/A  &lt;/p&gt;
&lt;h3 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
</feed>
