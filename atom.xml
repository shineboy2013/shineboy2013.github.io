<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-16T07:02:59.607Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 2139 Minimum Moves to Reach Target Score</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-2139/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-2139/</id>
    <published>2022-01-16T06:48:34.993Z</published>
    <updated>2022-01-16T07:02:59.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-moves-to-reach-target-score/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are playing a game with integers. You start with the integer <code>1</code> and you want to reach the integer <code>target</code>.<br><br>In one move, you can either:<br><br><em>   <strong>Increment</strong> the current integer by one (i.e., <code>x = x + 1</code>).</em>   <strong>Double</strong> the current integer (i.e., <code>x = 2 * x</code>).<br><br>You can use the <strong>increment</strong> operation <strong>any</strong> number of times, however, you can only use the <strong>double</strong> operation <strong>at most</strong> <code>maxDoubles</code> times.<br><br>Given the two integers <code>target</code> and <code>maxDoubles</code>, return <em>the minimum number of moves needed to reach</em> <code>target</code> <em>starting with</em> <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> target = 5, maxDoubles = 0<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Keep incrementing by 1 until you reach target.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> target = 19, maxDoubles = 2<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Initially, x = 1<br>Increment 3 times so x = 4<br>Double once so x = 8<br>Increment once so x = 9<br>Double again so x = 18<br>Increment once so x = 19<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> target = 10, maxDoubles = 4<br><strong>Output:</strong> 4<br><strong>Explanation:</strong>Initially, x = 1<br>Increment once so x = 2<br>Double once so x = 4<br>Increment once so x = 5<br>Double again so x = 10<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></em>   <code>0 &lt;= maxDoubles &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>加1或者乘2达到target，乘2有次数限制，求到达target的最小步数</p><h3 id="DFS解题思路-推荐-："><a href="#DFS解题思路-推荐-：" class="headerlink" title="DFS解题思路(推荐)："></a><strong>DFS解题思路(推荐)：</strong></h3><p>由于是最值，一开始用DP，但得到TLE，分析后觉得是因为加法太慢，所以用贪心法，尽量用乘法。此题类似于求幂值。改用DFS。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>若允许乘法次数为0，直接返回加法次数，而不应再用递归，否则会出现超过系统栈深度</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> maxDoubles == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> target - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> self.minMoves(target // <span class="number">2</span>, maxDoubles - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.minMoves(target - <span class="number">1</span>, maxDoubles) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="DP算法II解题思路："><a href="#DP算法II解题思路：" class="headerlink" title="DP算法II解题思路："></a><strong>DP算法II解题思路：</strong></h3><p>TLE</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j], dp[i // 2][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span><span class="params">(self, target: int, maxDoubles: int)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (maxDoubles + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">1</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">dp[i][j] = min(dp[i][j], dp[i // <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n x maxDoubles)</code>，空间复杂度<code>O(n x maxDoubles)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-moves-to-reach-target-score/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2140 Solving Questions With Brainpower</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-2140/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-2140/</id>
    <published>2022-01-16T06:09:46.251Z</published>
    <updated>2022-01-16T07:01:32.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/solving-questions-with-brainpower/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> 2D integer array <code>questions</code> where <code>questions[i] = [points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt;]</code>.<br><br>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code>0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code>i</code> will <strong>earn</strong> you <code>points&lt;sub&gt;i&lt;/sub&gt;</code> points but you will be <strong>unable</strong> to solve each of the next <code>brainpower&lt;sub&gt;i&lt;/sub&gt;</code> questions. If you skip question <code>i</code>, you get to make the decision on the next question.<br><br><em>   For example, given <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>:    </em>   If question <code>0</code> is solved, you will earn <code>3</code> points but you will be unable to solve questions <code>1</code> and <code>2</code>.<br>    <em>   If instead, question <code>0</code> is skipped and question <code>1</code> is solved, you will earn <code>4</code> points but you will be unable to solve questions <code>2</code> and <code>3</code>.<br><br>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> questions = [[3,2],[4,3],[4,4],[2,5]]<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 0 and 3.<br>- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 1 and 2<br>- Solve question 3: Earn 2 points<br>Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> The maximum points can be earned by solving questions 1 and 4.<br>- Skip question 0<br>- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions<br>- Unable to solve questions 2 and 3<br>- Solve question 4: Earn 5 points<br>Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= questions.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><em>   <code>questions[i].length == 2</code></em>   <code>1 &lt;= points&lt;sub&gt;i&lt;/sub&gt;, brainpower&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>(points, brainpower)解决一个问题得到points分，但是接下来的brainpower个问题都不能回答。求最大分数</p><h3 id="一维DP解题思路-推荐-："><a href="#一维DP解题思路-推荐-：" class="headerlink" title="一维DP解题思路(推荐)："></a><strong>一维DP解题思路(推荐)：</strong></h3><p>类似于LeetCode 198 House Robber，但此不再是固定的相邻不能偷，而是动态多个不能偷。<br>这题求最值，且数组有序访问，暴力法是多项式复杂度，所以考虑用DP。详见解法二。考虑优化算法二<br>首先考虑用累计dp，但是即使这样，由于前n-1个问题每个不能回答的范围都不同，并不能容易由第n-1个累计DP获得dp[n]<br>巧妙地利用从后往前计算，这样dp值不能回答范围包含在了已经计算的dp值中，如计算dp[3] &lt;- dp[i + questions[3][1] + 1] + questions[3][0], 后者最大的话，当前结果也是最大，符合归纳条件。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如哈雷彗星，限制条件是向后，所以从后往前计算</li><li>用累计DP： F[i] = max(F[i + 1], f)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(questions) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">next_val = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i + questions[i][<span class="number">1</span>] + <span class="number">1</span> &lt; len(dp):</span><br><span class="line">next_val = dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>]</span><br><span class="line">dp[i] = max(dp[i + <span class="number">1</span>], questions[i][<span class="number">0</span>] + next_val)</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="二维DP算法II解题思路："><a href="#二维DP算法II解题思路：" class="headerlink" title="二维DP算法II解题思路："></a><strong>二维DP算法II解题思路：</strong></h3><p>一开始我的思路是比较直接，此算法TLE。 dp[i]为以回答了第i个问题及之前的问题所得分数。递归式为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[j] + questions[i][0]) if j + questions[j][1] &lt; i, 0 &lt;= j &lt; i</span><br></pre></td></tr></table></figure><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mostPoints2</span><span class="params">(self, questions: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * len(questions)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">dp[i] = questions[i][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line"><span class="keyword">if</span> j + questions[j][<span class="number">1</span>] &lt; i:</span><br><span class="line">dp[i] = max(dp[i], dp[j] + questions[i][<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/solving-questions-with-brainpower/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 085 Maximal Rectangle</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-085/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-085/</id>
    <published>2022-01-16T02:25:25.131Z</published>
    <updated>2022-01-16T02:32:50.568Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximal-rectangle" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>rows x cols</code> binary <code>matrix</code> filled with <code>0</code>‘s and <code>1</code>‘s, find the largest rectangle containing only <code>1</code>‘s and return <em>its area</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> The maximal rectangle is shown in the above picture.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> matrix = [[“0”]]<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> matrix = [[“1”]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>rows == matrix.length</code></em>   <code>cols == matrix[i].length</code><br><em>   <code>1 &lt;= row, cols &lt;= 200</code></em>   <code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>0-1矩阵求全部都是1的最大的子矩阵</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 084 Largest Rectangle in Histogram，按每行生成连续1的直方图，求最大矩形面积。然后逐行调用L084的方法。 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>由于L084的方案是修改原数组，所以不能直接调用，必须修改L084的方法，copy一份数组再往首尾插入0. </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">heights, res = [<span class="number">0</span>] * len(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == <span class="string">'0'</span>:</span><br><span class="line">heights[j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">heights[j] += <span class="number">1</span></span><br><span class="line">area = self.largestRectangleArea(heights)</span><br><span class="line">res = max(res, area)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height_list: List[int])</span> -&gt; int:</span></span><br><span class="line">stack, res = [], <span class="number">0</span></span><br><span class="line">heights = list(height_list)</span><br><span class="line">heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">heights.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">index = stack.pop()</span><br><span class="line">res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(m)</code>, n, m分别为行数和列数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximal-rectangle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;G
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Mtrix" scheme="https://shineboy2013.github.com/tags/Mtrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 084 Largest Rectangle in Histogram</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-084/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-084/</id>
    <published>2022-01-16T00:53:35.662Z</published>
    <updated>2022-01-16T01:04:39.995Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,1,5,6,2,3]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> The above is a histogram where width of each bar is 1.<br>The largest rectangle is shown in the red area, which has an area = 10 units.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt=""><br><br><pre><strong>Input:</strong> heights = [2,4]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= heights.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= heights[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求直方图中最大的矩形面积</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L042 Trapping Rain Water的stack法，但此题水量是反的。所以仍然用Stack，但用递增栈 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比L042稍简单，不用处理最后一个bar高度和宽度计算，但是用递增栈且公式中宽度计算仍然<strong>采用i - stack[-1] - 1</strong>，因为bar并不一定连续，如212, 最后一个2入栈，栈中剩下[_, 1]第一个2已经出栈了，但是可以有水量的。</li><li>原数组头尾加入0，头0是因为公式有stack[-1]避免越界， 尾0是因为让所有留在栈中的bar出栈且计算。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">stack, res = [], <span class="number">0</span></span><br><span class="line">heights.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># remember</span></span><br><span class="line">heights.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">index = stack.pop()</span><br><span class="line">res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[index]) <span class="comment"># remember i - stack[-1] - 1 not i - index</span></span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 072 Edit Distance</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-072/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-072/</id>
    <published>2022-01-15T23:25:41.198Z</published>
    <updated>2022-01-15T23:29:57.177Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.<br><br>You have the following three operations permitted on a word:<br><br><em>   Insert a character</em>   Delete a character<br><em>   Replace a character<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> word1 = “horse”, word2 = “ros”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong><br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> word1 = “intention”, word2 = “execution”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong><br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= word1.length, word2.length &lt;= 500</code><br>*   <code>word1</code> and <code>word2</code> consist of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求编辑两个字符串的最短距离。编辑操作含加删一个字符，替换一个字符。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最值且涉及到字符串考虑用DP。递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]                                   if word1[i-1] == word[j-1]  </span><br><span class="line">         = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>初始值先word2长度再word1.</li><li><strong>初始化上和左边界，表示当一个字符串为空时，另一个字符串的编辑距离是其长度。</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j-1] if word1[i-1] == word[j-1]</span></span><br><span class="line"><span class="comment">#          = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1, otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(word1) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">dp[i][<span class="number">0</span>] = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[<span class="number">0</span>][j] = j</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 076 Minimum Window Substring</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-076/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-076/</id>
    <published>2022-01-15T22:12:18.658Z</published>
    <updated>2022-01-15T22:34:16.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring__, return the empty string</em> <code>&quot;&quot;</code><em>.</em><br><br>The testcases will be generated such that the answer is <strong>unique</strong>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within the string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ADOBECODEBANC”, t = “ABC”<br><strong>Output:</strong> “BANC”<br><strong>Explanation:</strong> The minimum window substring “BANC” includes ‘A’, ‘B’, and ‘C’ from string t.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “a”<br><strong>Output:</strong> “a”<br><strong>Explanation:</strong> The entire string s is the minimum window.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “a”, t = “aa”<br><strong>Output:</strong> “”<br><strong>Explanation:</strong> Both ‘a’s from t must be included in the window.<br>Since the largest window of s only has one ‘a’, return empty string.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == s.length</code></em>   <code>n == t.length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.<br><br><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最短摘要：给定s和t两个字符串，求在s中包含所有t的字符的最短子串。这个结果可以包含不在t的字符，某个字符数量也可以多于t中的字符但不能少于。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>提到window substring就用滑动窗口或者同向双指针。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用同向双指针模板。<strong>用map来统计t的字符频率，用unique_count统计满足条件唯一字符个数。while的条件为unique_count达到了map的大小</strong>。 </li><li>while里面的统计与while外面的统计本质一样，但相反。若s中某字符多于s中的，map为负值，left指针右移时，负值会变回正值。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">t_char_to_count = collections.Counter(t)</span><br><span class="line">left, unique_count, min_len, res = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>), <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">t_char_to_count[s[i]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> t_char_to_count[s[i]] == <span class="number">0</span>:</span><br><span class="line">unique_count += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> unique_count == len(t_char_to_count):</span><br><span class="line"><span class="keyword">if</span> i - left + <span class="number">1</span> &lt; min_len:</span><br><span class="line">min_len = i - left + <span class="number">1</span></span><br><span class="line">res = s[left:i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> s[left] <span class="keyword">in</span> t_char_to_count:</span><br><span class="line">t_char_to_count[s[left]] += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> t_char_to_count[s[left]] &gt; <span class="number">0</span>:</span><br><span class="line">unique_count -= <span class="number">1</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(m)</code>, n和m分别为s和t的长度  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Sliding Window" scheme="https://shineboy2013.github.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 073 Set Matrix Zeroes</title>
    <link href="https://shineboy2013.github.com/2022/01/15/lee-073/"/>
    <id>https://shineboy2013.github.com/2022/01/15/lee-073/</id>
    <published>2022-01-15T08:40:58.386Z</published>
    <updated>2022-01-15T08:49:25.047Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s, and return <em>the matrix</em>.<br><br>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]<br><strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""><br><br><pre><strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br><strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == matrix.length</code></em>   <code>n == matrix[0].length</code><br><em>   <code>1 &lt;= m, n &lt;= 200</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong><br><br><em>   A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</em>   A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.<br>*   Could you devise a constant space solution?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>若矩阵某元素为0，设置它所在的行和列所有元素均为0，不能用额外区间</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用第0行和第0列作为统计。由于第0行和第0列会被覆盖，所以先查看他们有无0。两大步骤：先统计，再根据结果设置0</li><li>第二步中，<strong>根据第0和和第0列的结果回设，均从1开始</strong>，不含左上cell，因为统计结果不保存在它上。它仅在统计第一行和第一列是否有0时用到。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="comment"># calculate</span></span><br><span class="line">is_zero_row_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> matrix[<span class="number">0</span>] <span class="keyword">if</span> n == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">is_zero_col_zero = <span class="keyword">True</span> <span class="keyword">if</span> len([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)) <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>]) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">matrix[i][<span class="number">0</span>], matrix[<span class="number">0</span>][j] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># Set</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)): <span class="comment"># remember to start with 1</span></span><br><span class="line"><span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[i][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])): <span class="comment"># remember to start with 1</span></span><br><span class="line"><span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">matrix[i][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> is_zero_row_zero:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> is_zero_col_zero:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/set-matrix-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 078 Subsets</title>
    <link href="https://shineboy2013.github.com/2022/01/14/lee-078/"/>
    <id>https://shineboy2013.github.com/2022/01/14/lee-078/</id>
    <published>2022-01-15T07:51:55.350Z</published>
    <updated>2022-01-15T07:55:28.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有子集</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>组合知识点</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求结果含空集</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">res = [[]]</span><br><span class="line">self.dfs(nums, <span class="number">0</span>, [], res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, st, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(nums):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(nums)):</span><br><span class="line">path.append(nums[i])</span><br><span class="line">res.append(list(path))</span><br><span class="line">self.dfs(nums, i + <span class="number">1</span>, path, res)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nx2<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subsets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 065 Valid Number</title>
    <link href="https://shineboy2013.github.com/2022/01/13/lee-065/"/>
    <id>https://shineboy2013.github.com/2022/01/13/lee-065/</id>
    <published>2022-01-14T00:29:29.725Z</published>
    <updated>2022-01-14T01:13:53.437Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A <strong>valid number</strong> can be split up into these components (in order):<br><br>1.  A <strong>decimal number</strong> or an <strong>integer</strong>.<br>2.  (Optional) An <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code>, followed by an <strong>integer</strong>.<br><br>A <strong>decimal number</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One of the following formats:<br>    1.  One or more digits, followed by a dot <code>&#39;.&#39;</code>.<br>    2.  One or more digits, followed by a dot <code>&#39;.&#39;</code>, followed by one or more digits.<br>    3.  A dot <code>&#39;.&#39;</code>, followed by one or more digits.<br><br>An <strong>integer</strong> can be split up into these components (in order):<br><br>1.  (Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).<br>2.  One or more digits.<br><br>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code>, while the following are not valid numbers: <code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.<br><br>Given a string <code>s</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is a <strong>valid number</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “0”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “e”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “.”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 20</code></em>   <code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求合法小数指数形式</p><h3 id="类括号法解题思路-推荐-："><a href="#类括号法解题思路-推荐-：" class="headerlink" title="类括号法解题思路(推荐)："></a><strong>类括号法解题思路(推荐)：</strong></h3><p>有四种symbol，要保证先后关系。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>有四种symbol： 符号，数字，dot，exp。保证先后关系。<strong>exp的前后部分是独立的，唯一区别是后部分不能有dot</strong>，如1e2.2</li><li>实现类似于括号题用if语句来分别处理每种symbol：前面不能出现什么符号(<strong>e后面不能出现小数</strong>，也就是小数前面不能出现e)，或必须出现什么符号(仅一种情况：<strong>e前面必须出现数字</strong>)，如1e2. 然后该符号赋True</li><li>for循环后检查单个字符且不含数字情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">is_sign, is_digit, is_dot, is_exp = <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line"><span class="keyword">if</span> is_sign <span class="keyword">or</span> is_digit <span class="keyword">or</span> is_dot:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">is_digit = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] == <span class="string">'.'</span>:</span><br><span class="line"><span class="keyword">if</span> is_dot <span class="keyword">or</span> is_exp: <span class="comment"># 1e2.2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">elif</span> s[i] <span class="keyword">in</span> <span class="string">'eE'</span>:</span><br><span class="line"><span class="keyword">if</span> is_exp <span class="keyword">or</span> <span class="keyword">not</span> is_digit: <span class="comment"># e2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">is_exp = <span class="keyword">True</span></span><br><span class="line">is_digit = <span class="keyword">False</span></span><br><span class="line">is_sign = <span class="keyword">False</span></span><br><span class="line">is_dot = <span class="keyword">False</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> (is_exp <span class="keyword">or</span> is_dot <span class="keyword">or</span> is_sign) <span class="keyword">and</span> <span class="keyword">not</span> is_digit <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="DFA算法II解题思路-不推荐-："><a href="#DFA算法II解题思路-不推荐-：" class="headerlink" title="DFA算法II解题思路(不推荐)："></a><strong>DFA算法II解题思路(不推荐)：</strong></h3><p>Deterministic Finite Automaton (DFA)状态机，也就是将状态写入一个map中作为config，代码较简洁，但很难想。</p><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;A &lt;st
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 063 Unique Paths II</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-063/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-063/</id>
    <published>2022-01-05T11:21:06.701Z</published>
    <updated>2022-01-05T11:25:12.631Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked 'Start' in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<strong>Output:</strong> 2<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]<strong>Output:</strong> 1&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵路径总数。有障碍</p><h3><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1] if obstacle[i][j-1] == 0</span><br><span class="line">         = 0                       if obstacle[i][j-1] == 1</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>obstacleGrid[i][j-1], j-1因为dp从1开始, 但i不是，因为dp不含i。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (len(obstacleGrid[<span class="number">0</span>]) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 062 Unique Paths</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-062/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-062/</id>
    <published>2022-01-05T11:14:56.806Z</published>
    <updated>2022-01-05T11:20:52.897Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10&lt;sup&gt;9&lt;/sup&gt;</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> m = 3, n = 7<strong>Output:</strong> 28&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> m = 3, n = 2<strong>Output:</strong> 3<strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Down&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵路径总数</p><h3><strong>解题思路：</strong></h3><p>求个数用DP，递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>初始值dp[1] = 1而不是dp[0] = 1因为第二行的第一格不能加左边的虚拟格=1</li><li>range(m)不是range(len(m))</li><li>优化空间用一维</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># remember not dp[0] = 1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m): <span class="comment"># remember no len(m)</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line">dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 064 Minimum Path Sum</title>
    <link href="https://shineboy2013.github.com/2022/01/05/lee-064/"/>
    <id>https://shineboy2013.github.com/2022/01/05/lee-064/</id>
    <published>2022-01-05T11:03:23.931Z</published>
    <updated>2022-01-05T11:08:16.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]<strong>Output:</strong> 7<strong>Explanation:</strong> Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]<strong>Output:</strong> 12&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求矩阵最短路径和。只能向下向右走。</p><h3><strong>解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span><br></pre></td></tr></table></figure></p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>初始值为最大值，dp[0][1] = dp[1][0] = 0确保左上格正确。</li><li>模板四点注意事项</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min&#123;dp[i-1][j], dp[i][j-1]&#125; + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid) + <span class="number">1</span>)]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 427 Construct Quad Tree</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-427/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-427/</id>
    <published>2022-01-05T04:03:21.417Z</published>
    <updated>2022-01-05T04:47:19.236Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/construct-quad-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a <code>n * n</code> matrix <code>grid</code> of <code>0's</code> and <code>1's</code> only. We want to represent the <code>grid</code> with a Quad-Tree.</p><p>Return <em>the root of the Quad-Tree</em> representing the <code>grid</code>.</p><p>Notice that you can assign the value of a node to <strong>True</strong> or <strong>False</strong> when <code>isLeaf</code> is <strong>False</strong>, and both are <strong>accepted</strong> in the answer.</p><p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p><ul><li><code>val</code>: True if the node represents a grid of 1's or False if the node represents a grid of 0's.</li><li><code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.</li></ul><p>&lt;pre&gt;class Node {public boolean val;public boolean isLeaf;public Node topLeft;public Node topRight;public Node bottomLeft;public Node bottomRight;}&lt;/pre&gt;</p><p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p><ol><li>If the current grid has the same value (i.e all <code>1's</code> or all <code>0's</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.</li><li>If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.</li><li>Recurse for each of the children with the proper sub-grid.</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt=""></p><p>If you want to know more about the Quad-Tree, you can refer to the <a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank" rel="noopener">wiki</a>.</p><p><strong>Quad-Tree format:</strong></p><p>The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.</p><p>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.</p><p>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[0,1],[1,0]]<strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]<strong>Explanation:</strong> The explanation of this example is shown below:Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.<img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt="">&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]<strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]<strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.The topLeft, bottomLeft and bottomRight each has the same value.The topRight have different values so we divide it into 4 sub-grids where each has the same value.Explanation is shown in the photo below:<img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt="">&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2&lt;sup&gt;x&lt;/sup&gt;</code> where <code>0 &lt;= x &lt;= 6</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>由矩阵建四叉树。矩阵有0和1组成。按以下步骤：若子矩阵(变成为2的幂)只含1或0，生成一个叶子节点，值为该值；子矩阵含0和1混合，值为0或1(均为答案)，非叶子节点，递归四个同样大小的矩阵生成相应节点。<br>矩阵大小为2的幂，最小长度为1.</p><h3><strong>presum解题思路(推荐)：</strong></h3><p>这是我的方法，按照定义求解，定义是递归的，所以用DFS。而统计子矩阵和用presum提高效率。</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>子矩阵presum用模板</li><li>终止条件为子矩阵sum是0或n平方</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(self, grid: List[List[int]])</span> -&gt; 'Node':</span></span><br><span class="line">presum = self.get_presum(grid)</span><br><span class="line"><span class="keyword">return</span> self.dfs(grid, (<span class="number">0</span>, <span class="number">0</span>), (len(grid) - <span class="number">1</span>, len(grid[<span class="number">0</span>]) - <span class="number">1</span>), presum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">grim_sum = self.get_grid_sum(top_left, bottom_right, presum)</span><br><span class="line"><span class="keyword">if</span> grim_sum == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">0</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">if</span> grim_sum == (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>) * (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>] + <span class="number">1</span>):</span><br><span class="line"><span class="keyword">return</span> Node(<span class="number">1</span>, <span class="keyword">True</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">node = Node(<span class="number">1</span>, <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">row_mid = top_left[<span class="number">0</span>] + (bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">col_mid = top_left[<span class="number">1</span>] + (bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]) // <span class="number">2</span></span><br><span class="line">node.topLeft = self.dfs(grid, top_left, (row_mid, col_mid), presum)</span><br><span class="line">node.topRight = self.dfs(grid, (top_left[<span class="number">0</span>], col_mid + <span class="number">1</span>), (row_mid, bottom_right[<span class="number">1</span>]), presum)</span><br><span class="line">node.bottomLeft = self.dfs(grid, (row_mid + <span class="number">1</span>, top_left[<span class="number">1</span>]), (bottom_right[<span class="number">0</span>], col_mid), presum)</span><br><span class="line">node.bottomRight = self.dfs(grid, (row_mid + <span class="number">1</span>, col_mid + <span class="number">1</span>), bottom_right, presum)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grid_sum</span><span class="params">(self, top_left, bottom_right, presum)</span>:</span></span><br><span class="line">left = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[bottom_right[<span class="number">0</span>]][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">top = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][bottom_right[<span class="number">1</span>]]</span><br><span class="line">diag = <span class="number">0</span> <span class="keyword">if</span> top_left[<span class="number">0</span>] &lt; <span class="number">1</span> <span class="keyword">or</span> top_left[<span class="number">1</span>] &lt; <span class="number">1</span> <span class="keyword">else</span> presum[top_left[<span class="number">0</span>] - <span class="number">1</span>][top_left[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> presum[bottom_right[<span class="number">0</span>]][bottom_right[<span class="number">1</span>]] - left - top + diag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_presum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">presum = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">row_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">row_sum += grid[i][j]</span><br><span class="line">presum[i][j] = row_sum + (presum[i - <span class="number">1</span>][j] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> presum</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;`，空间复杂度&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</p><hr><h3><strong>单格DFS算法II解题思路：</strong></h3><p>也是DFS，但递归终止条件为长度1，也就是每个cell都是叶子节点，先递归然后再归纳，若四个儿子节点都是叶子节点且值都相等，合并为一个叶子节点。否则为非叶子节点。此算法实现更简单，但比较难想出。上述方法思想是按照题意。</p><p><a href="https://leetcode.com/problems/construct-quad-tree/discuss/154565/Java-recursive-solution" target="_blank" rel="noopener">Ref</a></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;<code>，空间复杂度</code>O(1)`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-quad-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Uber" scheme="https://shineboy2013.github.com/tags/Uber/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 387 First Unique Character in a String</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-387/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-387/</id>
    <published>2022-01-04T10:44:05.118Z</published>
    <updated>2022-01-04T10:46:37.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;leetcode&quot;<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;loveleetcode&quot;<strong>Output:</strong> 2&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;aabb&quot;<strong>Output:</strong> -1&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>s</code> consists of only lowercase English letters.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求字符串中第一个唯一的字符下标</p><h3><strong>解题思路：</strong></h3><p>Easy题。先统计频率，然后再遍历一次字符串找到频率为1的字符</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"><span class="keyword">if</span> char_to_count[s[i]] == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>, 26个字母为常量空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/first-unique-character-in-a-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Amazon" scheme="https://shineboy2013.github.com/tags/Amazon/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 339 Nested List Weight Sum</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-339/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-339/</id>
    <published>2022-01-04T10:14:00.356Z</published>
    <updated>2022-01-04T10:20:24.285Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists.</p><p>The <strong>depth</strong> of an integer is the number of lists that it is inside of. For example, the nested list <code>[1,[2,2],[[3],2],1]</code> has each integer's value set to its <strong>depth</strong>.</p><p>Return <em>the sum of each integer in</em> <code>nestedList</code> <em>multiplied by its <strong>depth</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex1.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]<strong>Output:</strong> 10<strong>Explanation:</strong> Four 1's at depth 2, one 2 at depth 1. 1<em>2 + 1</em>2 + 2<em>1 + 1</em>2 + 1*2 = 10.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/nestedlistweightsumex2.png" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [1,[4,[6]]]<strong>Output:</strong> 27<strong>Explanation:</strong> One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1<em>1 + 4</em>2 + 6*3 = 27.&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nestedList = [0]<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nestedList.length &lt;= 50</code></li><li>The values of the integers in the nested list is in the range <code>[-100, 100]</code>.</li><li>The maximum <strong>depth</strong> of any integer is less than or equal to <code>50</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>求NestedInteger的和。越深，权重越高</p><h3><strong>解题思路：</strong></h3><p>BFS按层遍历</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>Line 9中，需要将NestedInteger展开，里面的所有的NestedInteger入列。Python中，用extend来加入list中所有元素到另一个list，而不是append</li><li>按层遍历模板中，不需要level变量，for可以达到。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque(nestedList)</span><br><span class="line">res, layer = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">level_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node.isInteger():</span><br><span class="line">queue.extend(node.getList()) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">level_sum += node.getInteger()</span><br><span class="line">res += level_sum * layer</span><br><span class="line">layer += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/nested-list-weight-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;d
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 074 Search a 2D Matrix</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-074/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-074/</id>
    <published>2022-01-04T09:27:06.283Z</published>
    <updated>2022-01-04T09:26:58.167Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3<strong>Output:</strong> true&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt=""></p><p>&lt;pre&gt;<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13<strong>Output:</strong> false&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= matrix[i][j], target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>矩阵中每一行有序，下一行的首元素大于上一行的尾元素。求target是否在矩阵中</p><h3><strong>列+行搜索解题思路：</strong></h3><p>先对列做二分搜索，再对行</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li></li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">col = [matrix[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">row_idx = bisect.bisect(col, target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> row_idx &lt; <span class="number">0</span> <span class="keyword">or</span> row_idx &gt;= len(matrix):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> matrix[row_idx][<span class="number">0</span>] == target:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">col_idx = bisect.bisect(matrix[row_idx], target) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> col_idx &lt; <span class="number">0</span> <span class="keyword">or</span> col_idx &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> matrix[row_idx][col_idx] == target <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(n)</code>, 可以写一个二分法来做列搜索，这样空间为常量。</p><hr><h3><strong>全矩阵搜索算法II解题思路：</strong></h3><p>对矩阵的左上，右下元素作为start, end得到mid转化成(i, j)找到矩阵位置。</p><h3><strong>Java代码：</strong></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi = matrix.length*matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line"><span class="comment">// Key is in a[lo..hi] or not present.</span></span><br><span class="line"><span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> x = mid/matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> y = mid%matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">if</span> (target &lt; matrix[x][y])</span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[x][y])</span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn + logm)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/search-a-2d-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;g
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 008 String to Integer (atoi)</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-008/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-008/</id>
    <published>2022-01-04T08:58:32.853Z</published>
    <updated>2022-01-14T00:42:00.932Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++'s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>'-'</code> or <code>'+'</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2&lt;sup&gt;31&lt;/sup&gt;</code> should be clamped to <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>, and integers greater than <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code> should be clamped to <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>' '</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;42&quot;<strong>Output:</strong> 42<strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)^Step 2: &quot;42&quot; (no characters read because there is neither a '-' nor '+')^Step 3: &quot;&lt;u&gt;42&lt;/u&gt;&quot; (&quot;42&quot; is read in)^The parsed integer is 42.Since 42 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is 42.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;   -42&quot;<strong>Output:</strong> -42<strong>Explanation:</strong>Step 1: &quot;-42&quot; (leading whitespace is read and ignored)^Step 2: &quot;   &lt;u&gt;-&lt;/u&gt;42&quot; ('-' is read, so the result should be negative)^Step 3: &quot;   -&lt;u&gt;42&lt;/u&gt;&quot; (&quot;42&quot; is read in)^The parsed integer is -42.Since -42 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is -42.&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> s = &quot;4193 with words&quot;<strong>Output:</strong> 4193<strong>Explanation:</strong>Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)^Step 2: &quot;4193 with words&quot; (no characters read because there is neither a '-' nor '+')^Step 3: &quot;&lt;u&gt;4193&lt;/u&gt; with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)^The parsed integer is 4193.Since 4193 is in the range [-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1], the final result is 4193.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>' '</code>, <code>'+'</code>, <code>'-'</code>, and <code>'.'</code>.</li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>字符串转整数</p><h3><strong>解题思路：</strong></h3><p>关键是第一位是否符号的判断，之后是ord函数的运用</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>空字符或全空格返回0</li><li>[key]<strong>若有符号只能第一位是符号</strong>，连续是符号不合法返回0，如-+12, <strong>将符号处理放在循环外</strong></li><li>除符号外，若第一位为非数字，不合法，返回0</li><li>循环内，若出现非数字，跳出循环</li><li>计算符号，然后检查数字范围</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">s = s.strip()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">and</span> <span class="keyword">not</span> s[<span class="number">0</span>].isdigit():</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char.isdigit():</span><br><span class="line">res = res * <span class="number">10</span> + ord(char) - ord(<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res *= sign</span><br><span class="line"><span class="keyword">if</span> res &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line"><span class="keyword">return</span> -pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">if</span> res &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;d
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 016 3Sum Closest</title>
    <link href="https://shineboy2013.github.com/2022/01/04/lee-016/"/>
    <id>https://shineboy2013.github.com/2022/01/04/lee-016/</id>
    <published>2022-01-04T08:20:04.305Z</published>
    <updated>2022-01-04T08:22:15.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p><p>Return <em>the sum of the three integers</em>.</p><p>You may assume that each input would have exactly one solution.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [-1,2,1,-4], target = 1<strong>Output:</strong> 2<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums = [0,0,0], target = 1<strong>Output:</strong> 0&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>三数和最接近target</p><h3><strong>解题思路：</strong></h3><p>N/A</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>此题不需去重，若等于target可直接返回</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">temp = nums[i] + nums[left] + nums[right]</span><br><span class="line"><span class="keyword">if</span> abs(temp - target) &lt; abs(res - target):</span><br><span class="line">res = temp</span><br><span class="line"><span class="keyword">if</span> temp &lt; target:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> temp &gt; target:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 088 Merge Sorted Array</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-088/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-088/</id>
    <published>2022-01-04T07:58:40.595Z</published>
    <updated>2022-01-04T08:01:29.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode</a></strong></p><p>&lt;div&gt;</p><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<strong>Output:</strong> [1,2,2,3,5,6]<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [&lt;u&gt;1&lt;/u&gt;,&lt;u&gt;2&lt;/u&gt;,2,&lt;u&gt;3&lt;/u&gt;,5,6] with the underlined elements coming from nums1.&lt;/pre&gt;</p><p><strong>Example 2:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0<strong>Output:</strong> [1]<strong>Explanation:</strong> The arrays we are merging are [1] and [].The result of the merge is [1].&lt;/pre&gt;</p><p><strong>Example 3:</strong></p><p>&lt;pre&gt;<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1<strong>Output:</strong> [1]<strong>Explanation:</strong> The arrays we are merging are [] and [1].The result of the merge is [1].Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.&lt;/pre&gt;</p><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums1[i], nums2[j] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li></ul><p><strong>Follow up:</strong> Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p><p>&lt;/div&gt;</p><h3><strong>题目大意：</strong></h3><p>合并两有序数组，最后结果储存在第一个数组</p><h3><strong>解题思路：</strong></h3><p>从后往前合并</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>i从m - 1而不是len(nums1) - 1开始，m和n是数组实际长度。</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, len(nums1) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums1[i]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">nums1[k] = nums2[j]</span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;g
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://shineboy2013.github.com/2022/01/03/lee-034/"/>
    <id>https://shineboy2013.github.com/2022/01/03/lee-034/</id>
    <published>2022-01-04T07:29:57.188Z</published>
    <updated>2022-01-04T07:32:22.489Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">LeetCode</a></strong></p><h3><strong>题目大意：</strong></h3><p>求有序数列中元素等于target的第一个和最后一个下标</p><h3><strong>解题思路：</strong></h3><p>用模板</p><h3><strong>解题步骤：</strong></h3><p>N/A</p><h3><strong>注意事项：</strong></h3><ol><li>数组为空的情况要返回-1</li></ol><h3><strong>Python代码：</strong></h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">first = self.first_position(nums, target)</span><br><span class="line">last = self.last_position(nums, target)</span><br><span class="line"><span class="keyword">return</span> [first, last]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_position</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">mid = start+ (end - start) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">if</span> nums[start] == target:</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line"><span class="keyword">if</span> nums[end] == target:</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h3><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
</feed>
