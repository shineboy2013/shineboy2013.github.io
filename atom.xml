<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-02-13T01:08:27.461Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 498 Diagonal Traverse</title>
    <link href="https://shineboy2013.github.com/2022/02/12/leetcode-498-diagonal-traverse/"/>
    <id>https://shineboy2013.github.com/2022/02/12/leetcode-498-diagonal-traverse/</id>
    <published>2022-02-13T00:56:43.553Z</published>
    <updated>2022-02-13T01:08:27.461Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]<br><strong>Output:</strong> [1,2,4,7,5,3,6,8,9]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> mat = [[1,2],[3,4]]<br><strong>Output:</strong> [1,2,3,4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == mat.length</code></em>   <code>n == mat[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= mat[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按类对角线梅花间竹地遍历每个元素，输出最后结果</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>边界条件很难找，而且每一层的结束点也和矩阵的长度或宽度有关。先找规律，可以看出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每层的所有元素下标和相等</span><br></pre></td></tr></table></figure></p><p>正常从左到右从上到下遍历矩阵，用一个dict来每层的每一个数，可以看出这些数的顺序都是按题目要求的，只不过是正序或逆序，所以最后按照奇偶决定是否正序或逆序加入到结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>从左到右从上到下遍历矩阵，dict[i + j]来加入每层的每一个数</li><li>dict的key的范围容易得知，按照奇偶决定是否正序或逆序加入到结果</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dict[i + j]来加入每层的每一个数</li><li>dict的key的最大值为len(mat) + len(mat[0]) - 1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, mat: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">groups = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(mat[<span class="number">0</span>])):</span><br><span class="line">groups[i + j].append(mat[i][j])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat) + len(mat[<span class="number">0</span>]) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.extend(groups[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.extend(groups[i][::<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diagonal-traverse/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/</id>
    <published>2022-02-08T10:22:03.551Z</published>
    <updated>2022-02-08T10:26:14.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two integers, <code>x</code> and <code>y</code>, which represent your current location on a Cartesian grid: <code>(x, y)</code>. You are also given an array <code>points</code> where each <code>points[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> represents that a point exists at <code>(a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;)</code>. A point is <strong>valid</strong> if it shares the same x-coordinate or the same y-coordinate as your location.<br><br>Return <em>the index <strong>(0-indexed)</strong> of the <strong>valid</strong> point with the smallest <strong>Manhattan distance</strong> from your current location</em>. If there are multiple, return <em>the valid point with the <strong>smallest</strong> index</em>. If there are no valid points, return <code>-1</code>.<br><br>The <strong>Manhattan distance</strong> between two points <code>(x&lt;sub&gt;1&lt;/sub&gt;, y&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(x&lt;sub&gt;2&lt;/sub&gt;, y&lt;sub&gt;2&lt;/sub&gt;)</code> is <code>abs(x&lt;sub&gt;1&lt;/sub&gt; - x&lt;sub&gt;2&lt;/sub&gt;) + abs(y&lt;sub&gt;1&lt;/sub&gt; - y&lt;sub&gt;2&lt;/sub&gt;)</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[3,4]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The answer is allowed to be on the same location as your current location.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[2,3]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There are no valid points.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= points.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>points[i].length == 2</code><br>*   <code>1 &lt;= x, y, a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个坐标和一堆坐标，这个坐标与某个点在同一条y轴或x轴上叫合法点，求它到这些点的最小曼哈顿距离对应的点的下标，若有多个结果，返回最小的数组下标。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，根据题意求</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearestValidPoint</span><span class="params">(self, x: int, y: int, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">min_dis = float(<span class="string">'inf'</span>)</span><br><span class="line">res = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i, (_x, _y) <span class="keyword">in</span> enumerate(points):</span><br><span class="line"><span class="keyword">if</span> x == _x <span class="keyword">or</span> y == _y:</span><br><span class="line"><span class="keyword">if</span> abs(x - _x) + abs(y - _y) &lt; min_dis:</span><br><span class="line">min_dis = abs(x - _x) + abs(y - _y)</span><br><span class="line">res = i</span><br><span class="line"><span class="keyword">elif</span> abs(x - _x) + abs(y - _y) == min_dis <span class="keyword">and</span> i &lt; res:</span><br><span class="line">res = i</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1761 Minimum Degree of a Connected Trio in a Graph</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/</id>
    <published>2022-02-08T09:49:32.723Z</published>
    <updated>2022-02-08T10:03:40.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an undirected graph. You are given an integer <code>n</code> which is the number of nodes in the graph and an array <code>edges</code>, where each <code>edges[i] = [u&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is an undirected edge between <code>u&lt;sub&gt;i&lt;/sub&gt;</code> and <code>v&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>A <strong>connected trio</strong> is a set of <strong>three</strong> nodes where there is an edge between <strong>every</strong> pair of them.<br><br>The <strong>degree of a connected trio</strong> is the number of edges where one endpoint is in the trio, and the other is not.<br><br>Return <em>the <strong>minimum</strong> degree of a connected trio in the graph, or</em> <code>-1</code> <em>if the graph has no connected trios.</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios1.png" alt=""><br><br><pre><strong>Input:</strong> n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios2.png" alt=""><br><br><pre><strong>Input:</strong> n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There are exactly three trios:<br>1) [1,4,3] with degree 0.<br>2) [2,5,6] with degree 2.<br>3) [5,6,7] with degree 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 400</code></em>   <code>edges[i].length == 2</code><br><em>   `1 &lt;= edges.length &lt;= n </em> (n-1) / 2<code>*</code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n<code>*</code>u<sub>i</sub> != v<sub>i</sub>`<br>*   There are no repeated edges.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个图，trio是三个节点直接互相相连，而度数表示连着trio的边的个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>根据定义，找出所有三个节点的组合，判断是否trio，然后根据trio的每个节点的度数总和 - 6即为所求<br>遍历所有三个节点组合时，会重复了两次。所以一个优化是，先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环。因为这个最小度数的节点已经大于等于3，trio里其他两个度数比它大的节点的度数更加会大于最小度数除以3，这样总度数肯定大于此时的最小度数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>根据定义，找出所有三个节点的组合u -&gt; v, v -&gt; w, w是否在u中，判断是否trio。先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环</li><li>邻接图用set，因为Line 13查找w是否在u中可以提高效率</li><li>min_degree / 3不是// 3</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTrioDegree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">graph = collections.defaultdict(set) <span class="comment"># use set coz if w in graph[u]</span></span><br><span class="line"><span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">graph[u].add(v)</span><br><span class="line">graph[v].add(u)</span><br><span class="line"></span><br><span class="line">min_degree = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> sorted(range(<span class="number">1</span>, n + <span class="number">1</span>), key=<span class="keyword">lambda</span> x: len(graph[x])):</span><br><span class="line"><span class="keyword">if</span> len(graph[u]) &gt;= min_degree / <span class="number">3</span>: <span class="comment"># remember / 3 not // 3</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> graph[v]:</span><br><span class="line"><span class="keyword">if</span> w <span class="keyword">in</span> graph[u]:</span><br><span class="line">min_degree = min(min_degree, len(graph[u]) + len(graph[v]) + len(graph[w]))</span><br><span class="line"><span class="keyword">return</span> min_degree - <span class="number">6</span> <span class="keyword">if</span> min_degree != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 979 Distribute Coins in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/</id>
    <published>2022-02-08T08:30:55.871Z</published>
    <updated>2022-02-08T08:53:25.280Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given the <code>root</code> of a binary tree with <code>n</code> nodes where each <code>node</code> in the tree has <code>node.val</code> coins. There are <code>n</code> coins in total throughout the whole tree.<br><br>In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.<br><br>Return <em>the <strong>minimum</strong> number of moves required to make every node have <strong>exactly</strong> one coin</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,0,0]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> From the root of the tree, we move one coin to its left child, and one coin to its right child.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" alt=""><br><br><pre><strong>Input:</strong> root = [0,3,0]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is <code>n</code>.</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= Node.val &lt;= n</code></em>   The sum of all <code>Node.val</code> is <code>n</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树某些节点含有硬币，求将这些硬币推向其他节点，使得所有节点都有一个硬币，求总移动次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先思考，若硬币都在root，也就是求所有节点的路径和。可以用每个节点的路径和求和，也可以定义dfs返回节点数，用全局变量加左右数，每轮递归都加一次，所以每个节点被加了其路径长度的次数。本算法采用后者<br>下面思考若硬币不在root，由于硬币可以从儿子给父亲，这是双向的，所以<strong>dfs定义为儿子给父亲的硬币数</strong>，若节点没有硬币，返回值会是负数，也就是父亲给儿子硬币，此时这个负数正是以此节点为root的数的总的节点数，所以与上述定义一致。<br>所以返回root.val + left + right - 1，left和right都是负数，left + right - 1是树的大小的负数，此结果为剩余硬币推给父亲的硬币数<br>res += abs(left) + abs(right)左子树和右子树所有节点一起走一条边的路径和</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>dfs定义为儿子给父亲的硬币数(若有硬币)，同时是子树的节点数的负数(若无硬币)</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> res</span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line">res += abs(left) + abs(right)</span><br><span class="line"><span class="keyword">return</span> root.val + left + right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/distribute-coins-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1448 Count Good Nodes in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/</id>
    <published>2022-02-08T07:07:29.316Z</published>
    <updated>2022-02-08T07:26:22.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named <strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.<br><br>Return the number of <strong>good</strong> nodes in the binary tree.<br><br><strong>Example 1:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.<br>Root Node (3) is always a good node.<br>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.<br>Node 5 -&gt; (3,4,5) is the maximum value in the path<br>Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,3,null,4,2]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because “3” is higher than it.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.</em>   Each node’s value is between <code>[-10^4, 10^4]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个节点是good表示该节点从root到自己的路径上，所有节点都小于等于自己。求二叉树的good节点个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计左右子树的good节点个数，最重要是引入类似于min, max验证BST，<strong>引入path_max来记录路径上的最大值</strong>，只要该节点值大于path_max就是good节点。DFS返回good节点个数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>引入path_max来记录路径上的最大值</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(root, float(<span class="string">'-inf'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path_max)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">left = self.dfs(root.left, max(root.val, path_max))</span><br><span class="line">right = self.dfs(root.right, max(root.val, path_max))</span><br><span class="line">res = left + right</span><br><span class="line"><span class="keyword">if</span> path_max &lt;= root.val:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-good-nodes-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1304 Find N Unique Integers Sum up to Zero</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/</id>
    <published>2022-02-08T07:03:16.849Z</published>
    <updated>2022-02-08T07:05:51.085Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong> integers such that they add up to <code>0</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> [-7,-1,1,3,4]<br><strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [-1,0,1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求n个数的数组使得数组和为0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，只要将相反数放入数组即可</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</span><br><span class="line">res.append(i + <span class="number">1</span>)</span><br><span class="line">res.append(-i - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 984 String Without AAA or BBB</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/</id>
    <published>2022-02-08T06:42:39.348Z</published>
    <updated>2022-02-08T06:45:10.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integers <code>a</code> and <code>b</code>, return <strong>any</strong> string <code>s</code> such that:<br><br><em>   <code>s</code> has length <code>a + b</code> and contains exactly <code>a</code> <code>&#39;a&#39;</code> letters, and exactly <code>b</code> <code>&#39;b&#39;</code> letters,</em>   The substring <code>&#39;aaa&#39;</code> does not occur in <code>s</code>, and<br><em>   The substring <code>&#39;bbb&#39;</code> does not occur in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 2<br><strong>Output:</strong> “abb”<br><strong>Explanation:</strong> “abb”, “bab” and “bba” are all correct answers.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 4, b = 1<br><strong>Output:</strong> “aabaa”<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b &lt;= 100</code><br>*   It is guaranteed such an <code>s</code> exists for the given <code>a</code> and <code>b</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个整数代表ab的个数，生成一个字符串，字符串ab频数不能超过这2个数，不能有连续的aaa, bbb, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>参考LeetCode 1405 Longest Happy String, 此题不用heap因为只有两种字符</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不能连续的处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span><span class="params">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">0</span> <span class="keyword">or</span> b &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'a'</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-without-aaa-or-bbb/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1405 Longest Happy String</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/</id>
    <published>2022-02-08T06:20:09.075Z</published>
    <updated>2022-02-08T06:32:41.593Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-happy-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>happy</strong> if it satisfies the following conditions:<br><br><em>   <code>s</code> only contains the letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</em>   <code>s</code> does not contain any of <code>&quot;aaa&quot;</code>, <code>&quot;bbb&quot;</code>, or <code>&quot;ccc&quot;</code> as a substring.<br><em>   <code>s</code> contains <strong>at most</strong> <code>a</code> occurrences of the letter <code>&#39;a&#39;</code>.</em>   <code>s</code> contains <strong>at most</strong> <code>b</code> occurrences of the letter <code>&#39;b&#39;</code>.<br><em>   <code>s</code> contains <strong>at most</strong> <code>c</code> occurrences of the letter <code>&#39;c&#39;</code>.<br><br>Given three integers <code>a</code>, <code>b</code>, and <code>c</code>, return <em>the <strong>longest possible happy</strong> string</em>. If there are multiple longest happy strings, return <em>any of them</em>. If there is no such string, return <em>the empty string</em> <code>&quot;&quot;</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within a string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 1, c = 7<br><strong>Output:</strong> “ccaccbcc”<br><strong>Explanation:</strong> “ccbccacc” would also be a correct answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 7, b = 1, c = 0<br><strong>Output:</strong> “aabaa”<br><strong>Explanation:</strong> It is the only correct answer in this case.<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b, c &lt;= 100</code><br>*   <code>a + b + c &gt; 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定三个整数代表abc的个数，生成一个字符串，字符串abc频数不能超过这3个数，不能有连续的aaa, bbb, ccc, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由第一个例子看出，先尽量用频数最多的字符，直到连续3个为止，然后再用次多的，如此反复做。这里用到最多和次多，所以考虑用Heap</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>每次选频数最高的字符，但若此字符已连续3次，选次高的，用heap。 </li><li>大于0的频数才加入到heap Line 4和Line 17</li><li>heapreplace等于heappop次高的和heappush最高的。<strong>既然要有次高，heap就不能为空</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">heapq.heappush(heap, (-a, <span class="string">'a'</span>))</span><br><span class="line"><span class="keyword">if</span> b &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-b, <span class="string">'b'</span>))</span><br><span class="line"><span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-c, <span class="string">'c'</span>))</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">count, char = heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == char:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">count, char = heapq.heapreplace(heap, (count, char))</span><br><span class="line">res += char</span><br><span class="line"><span class="keyword">if</span> count + <span class="number">1</span>:</span><br><span class="line">heapq.heappush(heap, (count + <span class="number">1</span>, char))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-happy-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1647 Minimum Deletions to Make Character Frequencies Unique</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/</id>
    <published>2022-02-08T02:42:06.875Z</published>
    <updated>2022-02-08T02:47:59.204Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.<br><br>Given a string <code>s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>s</code> <em><strong>good</strong>.</em><br><br>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>&quot;aab&quot;</code>, the <strong>frequency</strong> of <code>&#39;a&#39;</code> is <code>2</code>, while the <strong>frequency</strong> of <code>&#39;b&#39;</code> is <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> <code>s</code> is already good.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aaabbbcc”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete two ‘b’s resulting in the good string “aaabcc”.<br>Another way it to delete one ‘b’ and one ‘c’ resulting in the good string “aaabbc”.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ceabaacb”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete both ‘c’s resulting in the good string “eabaab”.<br>Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> contains only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串，求最小删除次数使得字符串的每一种字符频率不同</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解，若遇到频率相同的字符，就将其减一，也就是删除一个字符，使得它不再与其他字符频率相同直到0. 关键在用一个unique_count的set来记录频数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用一个unique_count的set来记录频数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDeletions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line">unique_count = set()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char, count <span class="keyword">in</span> char_to_count.items():</span><br><span class="line">cur_count = count</span><br><span class="line"><span class="keyword">while</span> cur_count <span class="keyword">in</span> unique_count:</span><br><span class="line">cur_count -= <span class="number">1</span></span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cur_count &gt; <span class="number">0</span>:</span><br><span class="line">unique_count.add(cur_count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>Karat 003 Nonogram</title>
    <link href="https://shineboy2013.github.com/2022/02/07/karat-003/"/>
    <id>https://shineboy2013.github.com/2022/02/07/karat-003/</id>
    <published>2022-02-07T10:16:22.375Z</published>
    <updated>2022-02-07T10:23:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>A nonogram is a logic puzzle, similar to a crossword, in which the player is given<br>a blank grid and has to color it according to some instructions. Specifically,<br>each cell can be either black or white, which we will represent as 0 for black and<br>1 for white.<br>+————+<br>| 1 1 1 1 |<br>| 0 1 1 1 |<br>| 0 1 0 0 |<br>| 1 1 0 1 |<br>| 0 0 1 1 |<br>+————+<br>For each row and column, the instructions give the lengths of contiguous runs of<br>black (0) cells. For example, the instructions for one row of [ 2, 1 ] indicate<br>that there must be a run of two black cells, followed later by another run of one<br>black cell, and the rest of the row filled with white cells.<br>These are valid solutions: [ 1, 0, 0, 1, 0 ] and [ 0, 0, 1, 1, 0 ] and also [ 0,<br>0, 1, 0, 1 ]<br>This is not valid: [ 1, 0, 1, 0, 0 ] since the runs are not in the correct order.<br>This is not valid: [ 1, 0, 0, 0, 1 ] since the two runs of 0s are not separated by<br>1s.<br>Your job is to write a function to validate a possible solution against a set of<br>instructions. Given a 2D matrix representing a player’s solution; and instructions<br>for each row along with additional instructions for each column; return True or<br>False according to whether both sets of instructions match.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Nonogram日本游戏，0表示黑子，[2, 1]表示黑子的连续数目，如棋盘状态[ 1, 0, 0, 1, 0 ]，表示连续黑子数为[2, 1]<br>[ 1, 0, 0, 0, 1 ]连续黑子数为[3]. 验证棋盘的每一行和每一列是否满足rows和cols所指定的连续黑子数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归只有一种情况</li><li>答案需求全局</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_nonogram</span><span class="params">(self, matrix, rows, cols)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(matrix[i]) != rows[i]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">col_vals = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">col_vals.append(matrix[i][j])</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(col_vals) != cols[j]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 1, 0, 0, 1, 0 ] -&gt; [2, 1], # of 0s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_consecutive_zeros</span><span class="params">(self, matrix_row)</span>:</span></span><br><span class="line">count, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> matrix_row:</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A nonogram is a logic puzzle, similar to a crossword, in which the player is given&lt;br&gt;a blank grid and has to color it according to some 
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1522 Diameter of N-Ary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/</id>
    <published>2022-02-07T09:33:44.019Z</published>
    <updated>2022-02-07T09:38:33.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-n-ary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>root</code> of an <a href="https://leetcode.com/articles/introduction-to-n-ary-trees/" target="_blank" rel="noopener">N-ary tree</a>, you need to compute the length of the diameter of the tree.<br><br>The diameter of an N-ary tree is the length of the <strong>longest</strong> path between any two nodes in the tree. This path may or may not pass through the root.<br><br>(<em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Diameter is shown in red color.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [1,null,2,null,3,4,null,5,null,6]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br><strong>Output:</strong> 7<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The depth of the n-ary tree is less than or equal to <code>1000</code>.</em>   The total number of nodes is between <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 543 Diameter of Binary Tree，但此题为N叉树</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DFS</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求数组中最大的两数和，用去掉最大值的方法得到次大值。还要注意初始值加入[1, 1]，避免没有儿子节点或只有一个的情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">path_len = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">path_len.append(dfs(child) + <span class="number">1</span>)</span><br><span class="line">largest = max(path_len)</span><br><span class="line">path_len.remove(largest)</span><br><span class="line">second_largest = max(path_len)</span><br><span class="line">total = largest + second_largest - <span class="number">1</span></span><br><span class="line">max_len = max(total, max_len)</span><br><span class="line"><span class="keyword">return</span> largest</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-n-ary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 543 Diameter of Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-543-diameter-of-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-543-diameter-of-binary-tree/</id>
    <published>2022-02-07T08:22:20.125Z</published>
    <updated>2022-02-07T08:29:16.844Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.<br><br>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.<br><br>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3,4,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1,2]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</em>   <code>-100 &lt;= Node.val &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种情况：自己+左，自己+右，左+右，不要漏掉最后一种</li><li>用nonlocal就不用定义self.max_len的全局变量</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">left = dfs(root.left) + <span class="number">1</span></span><br><span class="line">right = dfs(root.right) + <span class="number">1</span></span><br><span class="line">res = max(left, right)</span><br><span class="line">total = left + right - <span class="number">1</span></span><br><span class="line">max_len = max(res, total, max_len)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 549 Binary Tree Longest Consecutive Sequence II</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-549-binary-tree-longest-consecutive-sequence-ii/</id>
    <published>2022-02-07T07:51:56.353Z</published>
    <updated>2022-02-07T08:33:53.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive path in the tree</em>.<br><br>A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing.<br><br><em>   For example, <code>[1,2,3,4]</code> and <code>[4,3,2,1]</code> are both considered valid, but the path <code>[1,2,4,3]</code> is not valid.<br><br>On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,2,3]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The longest consecutive path is [1, 2] or [2, 1].<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec2-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,1,3]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The longest consecutive path is [1, 2, 3] or [3, 2, 1].<br></pre><br><br><strong>Constraints:</strong></em>   The number of nodes in the tree is in the range <code>[1, 3 * 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><em>   `-3 </em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求任意节点到另一个节点的最长连续数列的长度(由小到大)</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 298 Binary Tree Longest Consecutive Sequence，不过由于父亲到儿子可能递增或递减，所以DFS返回值也返回递增和递减的长度</p><p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p><p>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>DFS返回值也返回递增和递减的长度</li><li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有四种情况：自己，自己+左，自己+右，左+右</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># (increasing, decreasing) from root</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">inc = desc = <span class="number">1</span></span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:</span><br><span class="line">lpath += left[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right[<span class="number">0</span>]</span><br><span class="line">inc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val - <span class="number">1</span> == root.left.val:</span><br><span class="line">lpath += left[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val - <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right[<span class="number">1</span>]</span><br><span class="line">desc = max(<span class="number">1</span>, lpath, rpath)</span><br><span class="line"></span><br><span class="line">total = inc + desc - <span class="number">1</span></span><br><span class="line">max_len = max(inc, desc, total, max_len)</span><br><span class="line"><span class="keyword">return</span> inc, desc</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 298 Binary Tree Longest Consecutive Sequence</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-298-binary-tree-longest-consecutive-sequence/</id>
    <published>2022-02-07T07:22:19.605Z</published>
    <updated>2022-02-07T08:34:15.058Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>root</code> of a binary tree, return <em>the length of the longest consecutive sequence path</em>.<br><br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child (cannot be the reverse).<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [2,null,3,2,null,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range `[1, 3 </em> 10<sup>4</sup>]<code>.*</code>-3 <em> 10<sup>4</sup> &lt;= Node.val &lt;= 3 </em> 10<sup>4</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求从父到子的最长连续数列的长度(由小到大)</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><p>LeetCode 298 Binary Tree Longest Consecutive Sequence 父亲到儿子由小到大<br>LeetCode 549 Binary Tree Longest Consecutive Sequence II 任一节点到另一个节点由小到大</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题意是从父到儿子的有小到大数列，而不是儿子到父亲</li><li>以root为起点的最长数列，若root不符合条件，不加入left或right的长度</li><li>类似于LeetCode 124 Binary Tree Maximum Path Sum，有三种情况：自己，自己+左，自己+右</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">lpath = rpath = <span class="number">1</span></span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val + <span class="number">1</span> == root.left.val:  <span class="comment"># remember not ==</span></span><br><span class="line">lpath += left</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val + <span class="number">1</span> == root.right.val:</span><br><span class="line">rpath += right</span><br><span class="line">res = max(lpath, rpath)</span><br><span class="line">max_len = max(res, max_len)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/st
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 785 Is Graph Bipartite?</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-785-is-graph-bipartite/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-785-is-graph-bipartite/</id>
    <published>2022-02-07T06:49:11.703Z</published>
    <updated>2022-02-07T06:58:11.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:<br><br><em>   There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</em>   There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).<br><em>   If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</em>   The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.<br><br>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.<br><br>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>graph.length == n</code></em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= graph[u].length &lt; n</code></em>   <code>0 &lt;= graph[u][i] &lt;= n - 1</code><br><em>   <code>graph[u]</code> does not contain <code>u</code>.</em>   All the values of <code>graph[u]</code> are <strong>unique</strong>.<br>*   If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>无向图中是否存在一个划分，将节点分为两集合，任何一条边都连接着两个集合，也就是不存在一条边在单一集合内。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>图上色法。两种颜色，将节点上色0，儿子上色1，若某个节点已经上的色和将要上的色矛盾（来自的路径不同），即不合法</li><li>题意表示，图可能是有几个连通图，所以要从每个节点做BFS，除非节点已访问过， Line 4. node_to_color作为visited的功能</li><li>return True在两个函数中要写，否则返回None</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">node_to_color = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> node_to_color: <span class="comment"># disconnected nodes</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">node_to_color[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, i, node_to_color):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, n, node_to_color)</span>:</span></span><br><span class="line">queue = collections.deque([n])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color <span class="keyword">and</span> node_to_color[neighbor] != <span class="number">1</span> - node_to_color[node]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> node_to_color:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">node_to_color[neighbor] = <span class="number">1</span> - node_to_color[node]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(V + E)</code>，空间复杂度<code>O(V + E)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/is-graph-bipartite/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 770 Basic Calculator IV</title>
    <link href="https://shineboy2013.github.com/2022/02/06/leetcode-770-basic-calculator-iv/"/>
    <id>https://shineboy2013.github.com/2022/02/06/leetcode-770-basic-calculator-iv/</id>
    <published>2022-02-07T04:05:26.527Z</published>
    <updated>2022-02-12T10:17:33.578Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/basic-calculator-iv/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an expression such as <code>expression = &quot;e + 8 - a + 5&quot;</code> and an evaluation map such as <code>{&quot;e&quot;: 1}</code> (given in terms of <code>evalvars = [&quot;e&quot;]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>[&quot;-1*a&quot;,&quot;14&quot;]</code><br><br><em>   An expression alternates chunks and symbols, with a space separating each chunk and symbol.</em>   A chunk is either an expression in parentheses, a variable, or a non-negative integer.<br><em>   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>&quot;2x&quot;</code> or <code>&quot;-x&quot;</code>.<br><br>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.</em>   For example, <code>expression = &quot;1 + 2 * 3&quot;</code> has an answer of <code>[&quot;7&quot;]</code>.<br><br>The format of the output is as follows:<br><br><em>   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.    </em>   For example, we would never write a term like <code>&quot;b*a*c&quot;</code>, only <code>&quot;a*b*c&quot;</code>.<br><em>   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.    </em>   For example, <code>&quot;a*a*b*c&quot;</code> has degree <code>4</code>.<br><em>   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.</em>   An example of a well-formatted answer is <code>[&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]</code>.<br><em>   Terms (including constant terms) with coefficient <code>0</code> are not included.    </em>   For example, an expression of <code>&quot;0&quot;</code> has an output of <code>[]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> expression = “e + 8 - a + 5”, evalvars = [“e”], evalints = [1]<br><strong>Output:</strong> [“-1<em>a”,”14”]<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> expression = “e - 8 + temperature - pressure”, evalvars = [“e”, “temperature”], evalints = [1, 12]<br><strong>Output:</strong> [“-1pressure”,”5”]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> expression = “(e + 8) <em> (e - 8)”, evalvars = [], evalints = []<br><strong>Output:</strong> [“1</em>e<em>e”,”-64”]<br></em></pre><br><br><strong>Constraints:</strong>   <code>1 &lt;= expression.length &lt;= 250</code><br><em>   <code>expression</code> consists of lowercase English letters, digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, `’</em>‘<code>,</code>‘(‘<code>,</code>‘)’<code>,</code>‘ ‘<code>.*</code>expression<code>does not contain any leading or trailing spaces.*   All the tokens in</code>expression<code>are separated by a single space.*</code>0 &lt;= evalvars.length &lt;= 100<code>*</code>1 &lt;= evalvars[i].length &lt;= 20<code>*</code>evalvars[i]<code>consists of lowercase English letters.*</code>evalints.length == evalvars.length<code>*</code>-100 &lt;= evalints[i] &lt;= 100`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>表达式含有若干变量evalvars及其对应值evalints，且含加减乘和括号，求结果。若变量不在evalvars就简化表达式</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题<strong>不需要掌握</strong>，若考到就认命好了。之前的LeetCode 224 Basic Calculator含有括号和加法已经是Hard，此题不但有括号和加减乘，还有变量，难度不止提高一个数量级。不过不可以用eval函数的条件去掉了。所以就是考察eval。<br>如果不含变量，直接调用eval即可求解  </p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line"><span class="keyword">return</span> eval(expression)</span><br></pre></td></tr></table></figure><p>含变量且变量有值，就调用字典将变量替代掉，这里考到了regex替代函数re.sub</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line">var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">token = s.group()</span><br><span class="line">s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">converted_expr = re.sub(<span class="string">r'\w+'</span>, f, expression)</span><br><span class="line">res = eval(converted_expr)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于变量可能没有值，所以核心思路是用dict进行计算，如x + 2，用集合求和{(x,): 1} + {(): 2}得到{(‘x’,): 1, (): -2}，用dict来计算及保存结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>regex替代变量</li><li>将表达式用f包装，如(f(“x”) + f(“8”)) * (f(“x”) - f(“8”))</li><li>实现dict的加减乘</li><li>dict的计算结果转成题目所求</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicCalculatorIV</span><span class="params">(self, expression: str, evalvars: List[str], evalints: List[int])</span> -&gt; List[str]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span><span class="params">(Counter)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">self.update(other)</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">self.subtract(other)</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">product = MyCounter()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> other:</span><br><span class="line">xy = tuple(sorted(x + y))</span><br><span class="line">product[xy] += self[x] * other[y]</span><br><span class="line"><span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line">var_to_val = dict(zip(evalvars, evalints))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(s)</span>:</span></span><br><span class="line">token = s</span><br><span class="line">s = str(var_to_val[token] <span class="keyword">if</span> token <span class="keyword">in</span> var_to_val <span class="keyword">else</span> token)</span><br><span class="line"><span class="keyword">return</span> MyCounter(&#123;(s, ): <span class="number">1</span>&#125;) <span class="keyword">if</span> s.isalpha() <span class="keyword">else</span> MyCounter(&#123;(): int(s)&#125;)</span><br><span class="line"></span><br><span class="line">converted_expr = re.sub(<span class="string">r'(\w+)'</span>, <span class="string">r'f("\1")'</span>, expression)</span><br><span class="line"><span class="comment"># (f("x") + f("8")) * (f("x") - f("8"))</span></span><br><span class="line">res = eval(converted_expr) <span class="comment">#</span></span><br><span class="line"><span class="comment"># C(&#123;('x', 'x'): 1, ('x',): 0, (): -64&#125;)</span></span><br><span class="line"><span class="keyword">return</span> [<span class="string">'*'</span>.join((str(res[x]), ) + x)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> sorted(res, key=<span class="keyword">lambda</span> x: (-len(x), x))</span><br><span class="line"><span class="keyword">if</span> res[x]]</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator-iv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Karat 002 Longest Common Continuous Subarray</title>
    <link href="https://shineboy2013.github.com/2022/01/30/karat-002/"/>
    <id>https://shineboy2013.github.com/2022/01/30/karat-002/</id>
    <published>2022-01-30T09:46:41.967Z</published>
    <updated>2022-02-01T02:51:05.252Z</updated>
    
    <content type="html"><![CDATA[<p>[<br>  [“3234.html”, “xys.html”, “7hsaa.html”], // user1<br>  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2<br>]</p><p>输出两个user的最长连续且相同的访问记录。</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续最长子数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 1143先求最长公共子字符串。</p><p>LeetCode 1143 Longest Common Subsequence, 求最长公共子字符串<br>Karat 002 Longest Common Continuous Subarray 一样的题目，结果类型不同：最长长度和结果</p><p>不同之处在于： </p><ol><li>由于是连续，所以递归只有相同的情况，其他情况为0。 </li><li>答案不是最后一位，而是全局最值</li></ol><p>递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span><br><span class="line">         = 0</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归只有一种情况</li><li>答案需求全局</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = dp[i - 1][j - 1] + 1 if text1[i - 1] == text2[j - 1]</span></span><br><span class="line"><span class="comment">#          = 0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuous</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1) + <span class="number">1</span>)]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">res = max(res, dp[i][j])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>回到原题，输入是列表而不是字符串，但原理一样。还有需要输出公共结果，而不是数字</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonContinuousSubarray</span><span class="params">(self, history1, history2)</span>:</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history2) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(history1) + <span class="number">1</span>)]</span><br><span class="line">max_len, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(dp[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> history1[i - <span class="number">1</span>] == history2[j - <span class="number">1</span>]:</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">max_len = dp[i][j]</span><br><span class="line">res = history1[i - dp[i][j]:i]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[&lt;br&gt;  [“3234.html”, “xys.html”, “7hsaa.html”], // user1&lt;br&gt;  [“3234.html”, “sdhsfjdsh.html”, “xys.html”, “7hsaa.html”] // user2&lt;br&gt;]&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 518 Coin Change 2</title>
    <link href="https://shineboy2013.github.com/2022/01/30/leetcode-518-coin-change-2/"/>
    <id>https://shineboy2013.github.com/2022/01/30/leetcode-518-coin-change-2/</id>
    <published>2022-01-30T08:11:02.133Z</published>
    <updated>2022-02-02T21:07:55.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.<br><br>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.<br><br>You may assume that you have an infinite number of each kind of coin.<br><br>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> amount = 5, coins = [1,2,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> amount = 3, coins = [2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> amount = 10, coins = [10]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= coins.length &lt;= 300</code></em>   <code>1 &lt;= coins[i] &lt;= 5000</code><br><em>   All the values of <code>coins</code> are <strong>unique</strong>.</em>   <code>0 &lt;= amount &lt;= 5000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求兑换硬币的种数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 322 Coin Change，那题求最小个数，此题求总数，也是用DP。<br>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = sum(dp[j]), i = j + coins[i]</span><br></pre></td></tr></table></figure></p><p>LeetCode 377 Combination Sum IV 题目基本一样，唯一区别是结果元素有序，属于排列<br>LeetCode 518 Coin Change 2 题目基本一样，唯一区别是结果元素无序，属于组合</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>递归5部曲</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>for循环顺序不能错，先coin再dp</strong>，否则会有重复计算，如dp[3] = 2 + 1和1 + 2. 字面上理解也是可以知道重复。但如果coin先的话，就只能用1的硬币，第二轮是只能用2的硬币，如此类推，显然不会重复，dp[3] = dp[2] + 1(只用硬币1), dp[1] + 2(只用硬币2) </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i] = dp[j], i = j + coins[i]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)): <span class="comment"># [0, 0]</span></span><br><span class="line"><span class="keyword">if</span> i + coin &lt;= amount:</span><br><span class="line">dp[i + coin] += dp[i]</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n*amount)</code>，空间复杂度<code>O(amount)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/coin-change-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 259 3Sum Smaller</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-259-3sum-smaller/</id>
    <published>2022-01-30T07:18:03.625Z</published>
    <updated>2022-01-30T07:23:03.623Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/3sum-smaller/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of <code>n</code> integers <code>nums</code> and an integer <code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [-2,0,1,3], target = 2<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Because there are two triplets which sums are less than 2:<br>[-2,0,1]<br>[-2,0,3]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [0], target = 0<br><strong>Output:</strong> 0<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>0 &lt;= n &lt;= 3500</code><br><em>   <code>-100 &lt;= nums[i] &lt;= 100</code></em>   <code>-100 &lt;= target &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找三数和小于target的组合个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于三数和等于target，但当小于target时，直接求个数，类似于LeetCode 315 Count of Smaller Numbers After Self。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>res不是+1而是right - left</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumSmaller</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">nums.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">left, right = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">if</span> nums[i] + nums[left] + nums[right] &lt; target:</span><br><span class="line">res += right - left <span class="comment"># remember</span></span><br><span class="line">left += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-smaller/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Citadel" scheme="https://shineboy2013.github.com/tags/Citadel/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 628 Maximum Product of Three Numbers</title>
    <link href="https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/"/>
    <id>https://shineboy2013.github.com/2022/01/29/leetcode-628-maximum-product-of-three-numbers/</id>
    <published>2022-01-30T03:29:22.897Z</published>
    <updated>2022-01-30T03:34:17.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, <em>find three numbers whose product is maximum and return the maximum product</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,3,4]<br><strong>Output:</strong> 24<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-2,-3]<br><strong>Output:</strong> -6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>3 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-1000 &lt;= nums[i] &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求数组任意三个数的最大乘积</p><h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>数学题，正负数分开，最大只可以是排序后最大的三个数(全正，全负)或最大整数乘以最小两个负数(正负均有)</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">-1</span>] * nums[<span class="number">-2</span>] * nums[<span class="number">-3</span>], nums[<span class="number">-1</span>] * nums[<span class="number">0</span>] * nums[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="Heap算法II解题思路："><a href="#Heap算法II解题思路：" class="headerlink" title="Heap算法II解题思路："></a><strong>Heap算法II解题思路：</strong></h3><p>由上述思路进一步优化，不需要全部排序，只需要知道最大的3个数和最小的两个数即可</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumProduct2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line">smallest = heapq.nsmallest(<span class="number">2</span>, nums)</span><br><span class="line"><span class="keyword">return</span> max(largest[<span class="number">0</span>] * largest[<span class="number">1</span>] * largest[<span class="number">2</span>], largest[<span class="number">0</span>] * smallest[<span class="number">0</span>] * smallest[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-product-of-three-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
</feed>
