<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-01-26T07:38:24.107Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 359 Logger Rate Limiter</title>
    <link href="https://shineboy2013.github.com/2022/01/25/leetcode-359-logger-rate-limiter/"/>
    <id>https://shineboy2013.github.com/2022/01/25/leetcode-359-logger-rate-limiter/</id>
    <published>2022-01-26T07:30:11.442Z</published>
    <updated>2022-01-26T07:38:24.107Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/logger-rate-limiter/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Design a logger system that receives a stream of messages along with their timestamps. Each <strong>unique</strong> message should only be printed <strong>at most every 10 seconds</strong> (i.e. a message printed at timestamp <code>t</code> will prevent other identical messages from being printed until timestamp <code>t + 10</code>).<br><br>All messages will come in chronological order. Several messages may arrive at the same timestamp.<br><br>Implement the <code>Logger</code> class:<br><br><em>   <code>Logger()</code> Initializes the <code>logger</code> object.</em>   <code>bool shouldPrintMessage(int timestamp, string message)</code> Returns <code>true</code> if the <code>message</code> should be printed in the given <code>timestamp</code>, otherwise returns <code>false</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Logger”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”, “shouldPrintMessage”]<br>[[], [1, “foo”], [2, “bar”], [3, “foo”], [8, “bar”], [10, “foo”], [11, “foo”]]<br><strong>Output</strong><br>[null, true, true, false, false, false, true]<br><br><strong>Explanation</strong><br>Logger logger = new Logger();<br>logger.shouldPrintMessage(1, “foo”);  // return true, next allowed timestamp for “foo” is 1 + 10 = 11<br>logger.shouldPrintMessage(2, “bar”);  // return true, next allowed timestamp for “bar” is 2 + 10 = 12<br>logger.shouldPrintMessage(3, “foo”);  // 3 &lt; 11, return false<br>logger.shouldPrintMessage(8, “bar”);  // 8 &lt; 12, return false<br>logger.shouldPrintMessage(10, “foo”); // 10 &lt; 11, return false<br>logger.shouldPrintMessage(11, “foo”); // 11 &gt;= 11, return true, next allowed timestamp for “foo” is 11 + 10 = 21<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>0 &lt;= timestamp &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></em>   Every <code>timestamp</code> will be passed in non-decreasing order (chronological order).<br><em>   <code>1 &lt;= message.length &lt;= 30</code></em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>shouldPrintMessage</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现Logger打印的rate limiter</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>题不难，但有实际意义</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>shouldPrintMessage只有返回True时候才记录时间点。否则不记录</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.throttle_interval = <span class="number">10</span></span><br><span class="line">        self.msg_to_timestamp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldPrintMessage</span><span class="params">(self, timestamp: int, message: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">in</span> self.msg_to_timestamp <span class="keyword">and</span> timestamp - self.msg_to_timestamp[message] &lt; self.throttle_interval:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.msg_to_timestamp[message] = timestamp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/logger-rate-limiter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Google" scheme="https://shineboy2013.github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 337 House Robber III</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-337-house-robber-iii/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-337-house-robber-iii/</id>
    <published>2022-01-24T10:41:16.144Z</published>
    <updated>2022-01-24T10:56:45.195Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.<br><br>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.<br><br>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,2,3,null,3,null,1]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [3,4,5,1,3,null,1]<br><strong>Output:</strong> 9<br><strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.</em>   <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树，相隔一层投，求最大值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>多状态DP。返回值为，第一个是以root为结尾的最大值，第二个为以儿子层的前n最大值。</p><h3 id="DFS解题步骤："><a href="#DFS解题步骤：" class="headerlink" title="DFS解题步骤："></a><strong>DFS解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>以儿子层的前n最大值 = max(left) + max(right)</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">res = self.dfs2(root)</span><br><span class="line"><span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs2</span><span class="params">(self, root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">left = self.dfs2(root.left)</span><br><span class="line">right = self.dfs2(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>], max(left) + max(right)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="记忆法搜索算法II解题思路："><a href="#记忆法搜索算法II解题思路：" class="headerlink" title="记忆法搜索算法II解题思路："></a><strong>记忆法搜索算法II解题思路：</strong></h3><p>递归式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = root.val + g(root.left) + g(root.right)  </span><br><span class="line">g(n) = max(f(root.left), g(root.left)) + max(f(root.right), g(root.right))</span><br></pre></td></tr></table></figure></p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">f, g = &#123;&#125;, &#123;&#125;</span><br><span class="line">res = self.dfs(root, f, g)</span><br><span class="line"><span class="keyword">return</span> max(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, f, g)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.left <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">f[root.left], g[root.left] = self.dfs(root.left, f, g)</span><br><span class="line"><span class="keyword">if</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">or</span> root.right <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">f[root.right], g[root.right] = self.dfs(root.right, f, g)</span><br><span class="line">f[root] = root.val + g[root.left] + g[root.right]</span><br><span class="line">g[root] = max(f[root.left], g[root.left]) + max(f[root.right], g[root.right])</span><br><span class="line"><span class="keyword">return</span> f[root], g[root]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;T
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 340 Longest Substring with At Most K Distinct Characters</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-340-longest-substring-with-at-most-k-distinct-characters/</id>
    <published>2022-01-24T09:25:03.888Z</published>
    <updated>2022-01-24T09:28:05.865Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>that contains at most</em> <code>k</code> <em><strong>distinct</strong> characters</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “eceba”, k = 2<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The substring is “ece” with length 3.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aa”, k = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The substring is “aa” with length 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>0 &lt;= k &lt;= 50`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求最长子串，它含有最多k种字符</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>同向双指针，属于最长串类型</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>while条件中，反计算char_to_count，还要pop key</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">char_to_count, left, max_len = collections.defaultdict(int), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">char_to_count[char] += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> len(char_to_count) &gt; k:</span><br><span class="line">char_to_count[s[left]] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> char_to_count[s[left]] == <span class="number">0</span>:</span><br><span class="line">char_to_count.pop(s[left])</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">max_len = max(max_len, i - left + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(k)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leet
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 346 Moving Average from Data Stream</title>
    <link href="https://shineboy2013.github.com/2022/01/24/leetcode-346-moving-average-from-data-stream/"/>
    <id>https://shineboy2013.github.com/2022/01/24/leetcode-346-moving-average-from-data-stream/</id>
    <published>2022-01-24T08:59:02.505Z</published>
    <updated>2022-01-24T09:01:50.553Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/moving-average-from-data-stream/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.<br><br>Implement the <code>MovingAverage</code> class:<br><br><em>   <code>MovingAverage(int size)</code> Initializes the object with the size of the window <code>size</code>.</em>   <code>double next(int val)</code> Returns the moving average of the last <code>size</code> values of the stream.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“MovingAverage”, “next”, “next”, “next”, “next”]<br>[[3], [1], [10], [3], [5]]<br><strong>Output</strong><br>[null, 1.0, 5.5, 4.66667, 6.0]<br><br><strong>Explanation</strong><br>MovingAverage movingAverage = new MovingAverage(3);<br>movingAverage.next(1); // return 1.0 = 1 / 1<br>movingAverage.next(10); // return 5.5 = (1 + 10) / 2<br>movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3<br>movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= size &lt;= 1000</code></em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>next</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求data stream特定窗口的平均数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>结构上跟LRU cache类似</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用queue</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size: int)</span>:</span></span><br><span class="line">self.queue = collections.deque()</span><br><span class="line">self.size = size</span><br><span class="line">self.sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, val: int)</span> -&gt; float:</span></span><br><span class="line"><span class="keyword">if</span> len(self.queue) &lt; self.size:</span><br><span class="line">self.queue.append(val)</span><br><span class="line">self.sum += val</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n = self.queue.popleft()</span><br><span class="line">self.sum -= n</span><br><span class="line">self.queue.append(val)</span><br><span class="line">self.sum += val</span><br><span class="line"><span class="keyword">return</span> self.sum / len(self.queue)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/moving-average-from-data-stream/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 328 Odd Even Linked List</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-328-odd-even-linked-list/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-328-odd-even-linked-list/</id>
    <published>2022-01-24T04:47:53.344Z</published>
    <updated>2022-01-24T05:04:41.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.<br><br>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.<br><br>Note that the relative order inside both the even and odd groups should remain as it was in the input.<br><br>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [1,2,3,4,5]<br><strong>Output:</strong> [1,3,5,2,4]<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt=""><br><br><pre><strong>Input:</strong> head = [2,1,3,5,6,4,7]<br><strong>Output:</strong> [2,3,6,7,1,5,4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n ==</code>number of nodes in the linked list</em>   <code>0 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>-10&lt;sup&gt;6&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>重排LL， 先偶位再奇位</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>LL四点注意事项： 删除节点.next = None</li><li>空输入特别处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> head: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">odd_head = ListNode(<span class="number">0</span>)</span><br><span class="line">it, it_odd = head, odd_head</span><br><span class="line"><span class="keyword">while</span> it.next:</span><br><span class="line">it_odd.next = it.next</span><br><span class="line">it.next = it.next.next</span><br><span class="line"><span class="keyword">if</span> it.next:</span><br><span class="line">it = it.next</span><br><span class="line">it_odd = it_odd.next</span><br><span class="line">it_odd.next = <span class="keyword">None</span> <span class="comment"># remember</span></span><br><span class="line">it.next = odd_head.next</span><br><span class="line"><span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/odd-even-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 325 Maximum Size Subarray Sum Equals k</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-325-maximum-size-subarray-sum-equals-k/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-325-maximum-size-subarray-sum-equals-k/</id>
    <published>2022-01-24T04:05:47.958Z</published>
    <updated>2022-01-24T04:16:55.336Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the maximum length of a subarray that sums to</em> <code>k</code>. If there is not one, return <code>0</code> instead.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,-1,5,-2,3], k = 3<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> The subarray [1, -1, 5, -2] sums to 3 and is the longest.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-2,-1,2,1], k = 1<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The subarray [-1, 2] sums to 1 and is the longest.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 2 </em> 10<sup>5</sup><code>*</code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup><code>*</code>-10<sup>9</sup> &lt;= k &lt;= 10<sup>9</sup>`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长子数组和等于k，求长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始以为类似于LeetCode 209 Minimum Size Subarray Sum用同向双指针。但这题不是连续，因为此题含负数，不会连续大于等于target。考虑用presum的two sum法。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>加入presum[0] = 0</strong>，因为这样才可以得到以首元素开始的子数组和</li><li>若presum已经在hashmap中了，不要加入，因为要保证最长数组，如 [-1, 1], target = 0, index可以为0, 2</li><li>max_len答案只要初始化为0，不用最小值，因为最大长度必为非负</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># presum[i] - presum[j] = k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArrayLen</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">max_len, presum = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># not float('-inf')</span></span><br><span class="line">sum_to_idx = collections.defaultdict(int)</span><br><span class="line">sum_to_idx[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">presum += nums[i]</span><br><span class="line"><span class="keyword">if</span> presum - k <span class="keyword">in</span> sum_to_idx:</span><br><span class="line">max_len = max(max_len, i - sum_to_idx[presum - k] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> presum <span class="keyword">not</span> <span class="keyword">in</span> sum_to_idx: <span class="comment"># remember</span></span><br><span class="line">sum_to_idx[presum] = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 315 Count of Smaller Numbers After Self</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-315-count-of-smaller-numbers-after-self/</id>
    <published>2022-01-24T03:09:12.360Z</published>
    <updated>2022-01-24T03:14:43.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [5,2,6,1]<br><strong>Output:</strong> [2,1,1,0]<br><strong>Explanation:</strong><br>To the right of 5 there are <strong>2</strong> smaller elements (2 and 1).<br>To the right of 2 there is only <strong>1</strong> smaller element (1).<br>To the right of 6 there is <strong>1</strong> smaller element (1).<br>To the right of 1 there is <strong>0</strong> smaller element.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [-1]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [-1,-1]<br><strong>Output:</strong> [0,0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组中，统计每一位比自己小的数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始考虑用递减栈。但不可行。类似于merge sort，考虑统计逆序数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>由于mergesort会改变数组顺序，所以统计数组count也要对应的数也会变，所以将原数组变成(数值, 下标)对，count就可以统计原数组</li><li>计算逆序对时候，放在nums[i][0] &lt;= nums[j][0]中，核心在count[nums[i][1]] += j - mid - 1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">count = [<span class="number">0</span>] * len(nums)</span><br><span class="line">num_with_idx = [(n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">self.merge_sort(num_with_idx, <span class="number">0</span>, len(nums) - <span class="number">1</span>, count)</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(self, nums, start, end, count)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start &gt;= end:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">self.merge_sort(nums, start, mid, count)</span><br><span class="line">self.merge_sort(nums, mid + <span class="number">1</span>, end, count)</span><br><span class="line">self.merge(nums, start, mid, end, count)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums, start, mid, end, count)</span>:</span></span><br><span class="line">i, j = start, mid + <span class="number">1</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line"><span class="keyword">if</span> nums[i][<span class="number">0</span>] &lt;= nums[j][<span class="number">0</span>]:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">res.append(nums[i])</span><br><span class="line">count[nums[i][<span class="number">1</span>]] += j - mid - <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= end:</span><br><span class="line">res.append(nums[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">nums[start:end + <span class="number">1</span>] = res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-of-smaller-numbers-after-self/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Merge Sort" scheme="https://shineboy2013.github.com/tags/Merge-Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 348 Design Tic-Tac-Toe</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-348-design-tic-tac-toe/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-348-design-tic-tac-toe/</id>
    <published>2022-01-24T00:15:36.677Z</published>
    <updated>2022-01-24T00:22:51.263Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-tic-tac-toe/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Assume the following rules are for the tic-tac-toe game on an <code>n x n</code> board between two players:<br><br>1.  A move is guaranteed to be valid and is placed on an empty block.<br>2.  Once a winning condition is reached, no more moves are allowed.<br>3.  A player who succeeds in placing <code>n</code> of their marks in a horizontal, vertical, or diagonal row wins the game.<br><br>Implement the <code>TicTacToe</code> class:<br><br><em>   <code>TicTacToe(int n)</code> Initializes the object the size of the board <code>n</code>.</em>   <code>int move(int row, int col, int player)</code> Indicates that the player with id <code>player</code> plays at the cell <code>(row, col)</code> of the board. The move is guaranteed to be a valid move.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“TicTacToe”, “move”, “move”, “move”, “move”, “move”, “move”, “move”]<br>[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]<br><strong>Output</strong><br>[null, 0, 0, 0, 0, 0, 0, 1]<br><br><strong>Explanation</strong><br>TicTacToe ticTacToe = new TicTacToe(3);<br>Assume that player 1 is “X” and player 2 is “O” in the board.<br>ticTacToe.move(0, 0, 1); // return 0 (no one wins)<br>|X| | |<br>| | | |    // Player 1 makes a move at (0, 0).<br>| | | |<br><br>ticTacToe.move(0, 2, 2); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 2 makes a move at (0, 2).<br>| | | |<br><br>ticTacToe.move(2, 2, 1); // return 0 (no one wins)<br>|X| |O|<br>| | | |    // Player 1 makes a move at (2, 2).<br>| | |X|<br><br>ticTacToe.move(1, 1, 2); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 2 makes a move at (1, 1).<br>| | |X|<br><br>ticTacToe.move(2, 0, 1); // return 0 (no one wins)<br>|X| |O|<br>| |O| |    // Player 1 makes a move at (2, 0).<br>|X| |X|<br><br>ticTacToe.move(1, 0, 2); // return 0 (no one wins)<br>|X| |O|<br>|O|O| |    // Player 2 makes a move at (1, 0).<br>|X| |X|<br><br>ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)<br>|X| |O|<br>|O|O| |    // Player 1 makes a move at (2, 1).<br>|X|X|X|<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 100</code></em>   player is <code>1</code> or <code>2</code>.<br><em>   <code>0 &lt;= row, col &lt; n</code></em>   <code>(row, col)</code> are <strong>unique</strong> for each different call to <code>move</code>.<br><em>   At most <code>n&lt;sup&gt;2&lt;/sup&gt;</code> calls will be made to <code>move</code>.<br><br><em>*Follow-up:</em></em> Could you do better than <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> per <code>move()</code> operation?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计井字过三关</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>游戏题。最重要是是数据结构，类似于LeetCode 051 N-Queens和LeetCode 037 Sudoku Solver用matrix记录每行，每列，对角线和反对角线的和。这样验证时候只需要O(1). </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>对角线和反对角线只有一条，所以要先判断move的这个点是否在对角线上。</li><li>由于用-1来代表某一个player，所以判断和时候，用abs</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        self.board_len = n</span><br><span class="line">        self.row = [<span class="number">0</span>] * n</span><br><span class="line">        self.col = [<span class="number">0</span>] * n</span><br><span class="line">        self.diag = <span class="number">0</span></span><br><span class="line">        self.anti_diag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, row: int, col: int, player: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> player == <span class="number">2</span>:</span><br><span class="line">            player = <span class="number">-1</span></span><br><span class="line">        self.row[row] += player</span><br><span class="line">        self.col[col] += player</span><br><span class="line">        <span class="keyword">if</span> row == col: <span class="comment"># remember</span></span><br><span class="line">            self.diag += player</span><br><span class="line">        <span class="keyword">if</span> row == self.board_len - <span class="number">1</span> - col:</span><br><span class="line">            self.anti_diag += player</span><br><span class="line">        does_win = abs(self.row[row]) == self.board_len <span class="keyword">or</span> abs(self.col[col]) == self.board_len <span class="keyword">or</span> \</span><br><span class="line">                abs(self.diag) == self.board_len <span class="keyword">or</span> abs(self.anti_diag) == self.board_len <span class="comment"># remember abs</span></span><br><span class="line">        <span class="keyword">if</span> does_win:</span><br><span class="line">            <span class="keyword">if</span> player == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> player</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>move时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-tic-tac-toe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 317 Shortest Distance from All Buildings</title>
    <link href="https://shineboy2013.github.com/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/"/>
    <id>https://shineboy2013.github.com/2022/01/23/leetcode-317-shortest-distance-from-all-buildings/</id>
    <published>2022-01-23T23:33:23.203Z</published>
    <updated>2022-01-23T23:50:32.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> grid <code>grid</code> of values <code>0</code>, <code>1</code>, or <code>2</code>, where:<br><br><em>   each <code>0</code> marks <strong>an empty land</strong> that you can pass by freely,</em>   each <code>1</code> marks <strong>a building</strong> that you cannot pass through, and<br><em>   each <code>2</code> marks <strong>an obstacle</strong> that you cannot pass through.<br><br>You want to build a house on an empty land that reaches all buildings in the <strong>shortest total travel</strong> distance. You can only move up, down, left, and right.<br><br>Return <em>the <strong>shortest travel distance</strong> for such a house</em>. If it is not possible to build such a house according to the above rules, return <code>-1</code>.<br><br>The <strong>total travel distance</strong> is the sum of the distances between the houses of the friends and the meeting point.<br><br>The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Manhattan Distance</a>, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/buildings-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).<br>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.<br>So return 7.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> grid = [[1,0]]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> grid = [[1]]<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == grid.length</code><br><em>   <code>n == grid[i].length</code></em>   <code>1 &lt;= m, n &lt;= 50</code><br><em>   <code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</em>   There will be <strong>at least one</strong> building in the <code>grid</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找到所有大厦最短距离的点，这个点不能是大厦也不能是障碍</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>一开始觉得类似于LeetCode 296 Best Meeting Point，但由于有障碍，所以不能用贪婪法。最值考虑用BFS。属于对所有节点BFS。类似于LeetCode 200 Number of Islands，<br>从每一栋大厦开始做BFS，计算每个点到此大厦距离。然后对累计到这个点的总距离矩阵dis中。最后求距离矩阵的最小值。 </p><p>此题难点在于-1的情况，也就是一个点不能到达其中一个building或者是这个building不能到达的点。所以要再用一个矩阵house_count来记录每一个点能到达的大厦数。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>-1的情况，用一个矩阵house_count来记录每一个点能到达的大厦数。  </li><li>用常数记录矩阵长和宽，不用x &gt;= len(grid) or y &gt;= len(grid[0]), 否则会TLE</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OFFSETS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dis = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">house_count = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">total_houses = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">self.bfs(grid, i, j, dis, house_count)</span><br><span class="line">total_houses += <span class="number">1</span></span><br><span class="line">min_dis = float(<span class="string">'inf'</span>) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dis)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(dis[<span class="number">0</span>])):</span><br><span class="line"><span class="keyword">if</span> dis[i][j] &gt; <span class="number">0</span> <span class="keyword">and</span> house_count[i][j] == total_houses:</span><br><span class="line">min_dis = min(min_dis, dis[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> min_dis == float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_dis <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, start_x, start_y, dis, house_count)</span>:</span></span><br><span class="line">h = len(grid)</span><br><span class="line">w = len(grid[<span class="number">0</span>]) <span class="comment"># remember otherwise TLE</span></span><br><span class="line">queue = collections.deque([(start_x, start_y, <span class="number">0</span>)])</span><br><span class="line">visited = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">visited[start_x][start_y] = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSETS:</span><br><span class="line">x, y = node[<span class="number">0</span>] + _dx, node[<span class="number">1</span>] + _dy</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= h <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= w <span class="keyword">or</span> grid[x][y] != <span class="number">0</span> <span class="keyword">or</span> visited[x][y]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append((x, y, node[<span class="number">2</span>] + <span class="number">1</span>))</span><br><span class="line">visited[x][y] = <span class="keyword">True</span></span><br><span class="line">dis[x][y] += node[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">house_count[x][y] += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm * nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-distance-from-all-buildings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 304 Range Sum Query 2D - Immutable</title>
    <link href="https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/"/>
    <id>https://shineboy2013.github.com/2022/01/21/leetcode-304-range-sum-query-2d-immutable/</id>
    <published>2022-01-21T10:03:16.136Z</published>
    <updated>2022-01-21T10:08:55.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:<br><br><em>   Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br>Implement the NumMatrix class:</em>   <code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.<br><em>   <code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt=""><br><br><pre><strong>Input</strong><br>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<br><strong>Output</strong><br>[null, 8, 11, 12]<br><br><strong>Explanation</strong><br>NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == matrix.length</code><br><em>   <code>n == matrix[i].length</code></em>   <code>1 &lt;= m, n &lt;= 200</code><br><em>   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= matrix[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= row1 &lt;= row2 &lt; m</code><br><em>   <code>0 &lt;= col1 &lt;= col2 &lt; n</code></em>   At most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> calls will be made to <code>sumRegion</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求子矩阵和</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>计算presum公式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j] - dp[i-1][j-1]</span><br></pre></td></tr></table></figure></p><p>计算子矩阵公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = presum[x][y] - left - top + diag</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dp有左上边界，计算子矩阵注意dp和输入差1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(self.dp[<span class="number">0</span>])):</span><br><span class="line">                self.dp[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + self.dp[i - <span class="number">1</span>][j] + self.dp[i][j - <span class="number">1</span>] - self.dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/range-sum-query-2d-immutable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;d
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 721 Accounts Merge</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-721-accounts-mergesolution/</id>
    <published>2022-01-21T03:34:29.553Z</published>
    <updated>2022-01-21T09:32:04.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> accounts = [[“John”,”johnsmith@mail.com”,”john_newyork@mail.com”],[“John”,”johnsmith@mail.com”,”john00@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Output:</strong> [[“John”,”john00@mail.com”,”john_newyork@mail.com”,”johnsmith@mail.com”],[“Mary”,”mary@mail.com”],[“John”,”johnnybravo@mail.com”]]<br><strong>Explanation:</strong><br>The first and second John’s are the same person as they have the common email “johnsmith@mail.com”.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’],<br>[‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> accounts = [[“Gabe”,”Gabe0@m.co”,”Gabe3@m.co”,”Gabe1@m.co”],[“Kevin”,”Kevin3@m.co”,”Kevin5@m.co”,”Kevin0@m.co”],[“Ethan”,”Ethan5@m.co”,”Ethan4@m.co”,”Ethan0@m.co”],[“Hanzo”,”Hanzo3@m.co”,”Hanzo1@m.co”,”Hanzo0@m.co”],[“Fern”,”Fern5@m.co”,”Fern1@m.co”,”Fern0@m.co”]]<br><strong>Output:</strong> [[“Ethan”,”Ethan0@m.co”,”Ethan4@m.co”,”Ethan5@m.co”],[“Gabe”,”Gabe0@m.co”,”Gabe1@m.co”,”Gabe3@m.co”],[“Hanzo”,”Hanzo0@m.co”,”Hanzo1@m.co”,”Hanzo3@m.co”],[“Kevin”,”Kevin0@m.co”,”Kevin3@m.co”,”Kevin5@m.co”],[“Fern”,”Fern0@m.co”,”Fern1@m.co”,”Fern5@m.co”]]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= accounts.length &lt;= 1000</code></em>   <code>2 &lt;= accounts[i].length &lt;= 10</code><br><em>   <code>1 &lt;= accounts[i][j] &lt;= 30</code></em>   <code>accounts[i][0]</code> consists of English letters.<br>*   <code>accounts[i][j] (for j &gt; 0)</code> is a valid email.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>每个人都有一堆邮件，根据邮件是否相同判断是否同一个人，合并同一个人的所有邮件。</p><h3 id="BFS解题思路-推荐-："><a href="#BFS解题思路-推荐-：" class="headerlink" title="BFS解题思路(推荐)："></a><strong>BFS解题思路(推荐)：</strong></h3><p>根据输入建图，然后类似于Num of island从某一个邮件出发用BFS找连通的所有邮件，迭代所有邮件，全局visited来记录访问过的，这点跟Num of island一样。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>图的初始化，要记得没有边的图要加入到邻接表中，注意不存在的时候才加入，否则会覆盖现有的邻接表Line 8 - 9</li><li>处理名字(第一个元素)，名字对确定是否连通没有任何作用，只需要加入到最后结果即可</li><li>有重复邮件，所以一开始去重。结果按同一账号内按字母排序</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">graph = collections.defaultdict(list)</span><br><span class="line">name_dict = collections.defaultdict(str)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">name_dict[li[<span class="number">1</span>]] = li[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> li[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">graph[li[<span class="number">1</span>]] = [] <span class="comment"># remember single email</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">graph[li[<span class="number">1</span>]].append(li[i])</span><br><span class="line">graph[li[i]].append(li[<span class="number">1</span>])</span><br><span class="line">res, visited = [], set()</span><br><span class="line"><span class="keyword">for</span> email <span class="keyword">in</span> graph.keys():</span><br><span class="line">sub_res = self.bfs(graph, email, visited, name_dict)</span><br><span class="line"><span class="keyword">if</span> sub_res:</span><br><span class="line">res.append(sub_res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, start, visited, name_dict)</span>:</span></span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">res, name = [], <span class="string">''</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line">res.append(node)</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> name_dict:</span><br><span class="line">name = name_dict[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">res.sort()</span><br><span class="line">res.insert(<span class="number">0</span>, name)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数, 因为结果需要按字母排序</p><hr><h3 id="UnionFind算法II解题思路-不推荐-："><a href="#UnionFind算法II解题思路-不推荐-：" class="headerlink" title="UnionFind算法II解题思路(不推荐)："></a><strong>UnionFind算法II解题思路(不推荐)：</strong></h3><p>这题很容易想到用连通集做，但其实连通集应用条件为动态求连通集个数。这题是静态求连通数，所以类似于L200 Num of island可以用DFS或者BFS。</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>union只做每个list里面的，而list之间相同的邮件不用做union，因为既然相同自动做了</li><li>模板的问题，见UnionFind里的注意事项： if self.parent[email] != email, self.parent[parent] = parent2</li><li>处理名字</li><li>有重复邮件</li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge2</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            li[::] = [li[<span class="number">0</span>]] + list(set(li[<span class="number">1</span>:]))</span><br><span class="line">        uf = UnionFind(accounts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(li)):</span><br><span class="line">                uf.union(li[i - <span class="number">1</span>], li[i])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        name_dict = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> accounts:</span><br><span class="line">            name_dict[uf.find(li[<span class="number">1</span>])] = li[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">in</span> visited:  <span class="comment"># remember</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res[uf.find(email)].append(email)</span><br><span class="line">                visited.add(email)</span><br><span class="line">        <span class="keyword">for</span> _id, li <span class="keyword">in</span> res.items():</span><br><span class="line">            li.sort()</span><br><span class="line">            li.insert(<span class="number">0</span>, name_dict[_id])</span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_list)</span>:</span></span><br><span class="line">        self.parent = collections.defaultdict(str)</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> enumerate(email_list):</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">                self.parent[email] = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, email)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[email] != email:  <span class="comment"># if statement</span></span><br><span class="line">            self.parent[email] = self.find(self.parent[email])</span><br><span class="line">        <span class="keyword">return</span> self.parent[email]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, email, email2)</span>:</span></span><br><span class="line">        parent = self.find(email)</span><br><span class="line">        parent2 = self.find(email2)</span><br><span class="line">        <span class="keyword">if</span> parent != parent2:</span><br><span class="line">            self.parent[parent] = parent2 <span class="comment"># remember not self.parent[email] = email2</span></span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nklognk)</code>，空间复杂度<code>O(nk)</code>, n, k分别账号数，每个账号的邮件数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/accounts-merge/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Giv
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-287-find-the-duplicate-number/</id>
    <published>2022-01-20T10:10:33.912Z</published>
    <updated>2022-01-20T10:23:45.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.<br><br>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.<br><br>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,3,4,2,2]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,1,3,4,2]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>nums.length == n + 1</code><br><em>   <code>1 &lt;= nums[i] &lt;= n</code></em>   All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.<br><br><strong>Follow up:</strong><br><br><em>   How can we prove that at least one duplicate number must exist in <code>nums</code>?</em>   Can you solve the problem in linear runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定数值范围[1, n]找重复的数，只有一个重复数，但可能重复多次。题目要求不能用额外空间，不能修改数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数值二分法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>比较mid和count的关系，用例子来写程序，如[1, 2, 2, 3, 4]</li><li><strong>重复的数可能重复多次</strong>，所以不能用异或法</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">start, end, epsilon = min(nums), max(nums), <span class="number">0.5</span></span><br><span class="line"><span class="keyword">while</span> end - start &gt; epsilon:</span><br><span class="line">mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">count = len([n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt;= mid])</span><br><span class="line"><span class="keyword">if</span> count &lt;= mid:</span><br><span class="line">start = mid</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">end = mid</span><br><span class="line"><span class="keyword">return</span> int(end)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-duplicate-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 286 Walls and Gates</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-286-walls-and-gates/</id>
    <published>2022-01-20T09:36:10.895Z</published>
    <updated>2022-01-20T09:43:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values.<br><br><em>   <code>-1</code> A wall or an obstacle.</em>   <code>0</code> A gate.<br><em>   <code>INF</code> Infinity means an empty room. We use the value <code>2&lt;sup&gt;31&lt;/sup&gt; - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.<br><br>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt=""><br><br><pre><strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br><strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> rooms = [[-1]]<br><strong>Output:</strong> [[-1]]<br></pre><br><br><strong>Constraints:</strong></em>   <code>m == rooms.length</code><br><em>   <code>n == rooms[i].length</code></em>   <code>1 &lt;= m, n &lt;= 250</code><br>*   <code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2&lt;sup&gt;31&lt;/sup&gt; - 1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求所有房间到门的最短距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>属于多始点BFS类型</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>门的距离不更新，所以出列后要判断该点是否为门，不是用距离来判断</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OFFSET = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        gates = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rooms)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(rooms[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> rooms[i][j] == <span class="number">0</span>:</span><br><span class="line">                    gates.append((i, j, <span class="number">0</span>))</span><br><span class="line">        queue = collections.deque(gates)</span><br><span class="line">        visited = set(gates)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y, distance = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> rooms[x][y] != <span class="number">0</span>: <span class="comment"># not distance != 0</span></span><br><span class="line">                rooms[x][y] = distance</span><br><span class="line">            <span class="keyword">for</span> _dx, _dy <span class="keyword">in</span> OFFSET:</span><br><span class="line">                _x, _y = x + _dx, y + _dy</span><br><span class="line">                <span class="keyword">if</span> _x &lt; <span class="number">0</span> <span class="keyword">or</span> _x &gt;= len(rooms) <span class="keyword">or</span> _y &lt; <span class="number">0</span> <span class="keyword">or</span> _y &gt;= len(rooms[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        rooms[_x][_y] == <span class="number">-1</span> <span class="keyword">or</span> (_x, _y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                queue.append((_x, _y, distance + <span class="number">1</span>))</span><br><span class="line">                visited.add((_x, _y))</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(mn)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/walls-and-gates/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Yo
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 283 Move Zeroes</title>
    <link href="https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/"/>
    <id>https://shineboy2013.github.com/2022/01/20/leetcode-283-move-zeroes/</id>
    <published>2022-01-20T08:58:11.187Z</published>
    <updated>2022-01-20T09:00:49.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.<br><br><strong>Note</strong> that you must do this in-place without making a copy of the array.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [0,1,0,3,12]<br><strong>Output:</strong> [1,3,12,0,0]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0]<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br><strong>Follow up:</strong> Could you minimize the total number of operations done?</div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>将数组的0全部移到数组末</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>简单题。Quicksort的partition的应用</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">non_zero_idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">nums[i], nums[non_zero_idx] = nums[non_zero_idx], nums[i]</span><br><span class="line">non_zero_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 282 Expression Add Operators</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-282-expression-add-operators/</id>
    <published>2022-01-20T07:00:41.425Z</published>
    <updated>2022-01-20T08:59:51.182Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/expression-add-operators" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators</em> <code>&#39;+&#39;</code><em>,</em> <code>&#39;-&#39;</code><em>, and/or</em> <code>&#39;*&#39;</code> <em>between the digits of</em> <code>num</code> <em>so that the resultant expression evaluates to the</em> <code>target</code> <em>value</em>.<br><br>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> num = “123”, target = 6<br><strong>Output:</strong> [“1<em>2</em>3”,”1+2+3”]<br><strong>Explanation:</strong> Both “1<em>2</em>3” and “1+2+3” evaluate to 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> num = “232”, target = 8<br><strong>Output:</strong> [“2<em>3+2”,”2+3</em>2”]<br><strong>Explanation:</strong> Both “2<em>3+2” and “2+3</em>2” evaluate to 8.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> num = “3456237490”, target = 9191<br><strong>Output:</strong> []<br><strong>Explanation:</strong> There are no expressions that can be created from “3456237490” to evaluate to 9191.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= num.length &lt;= 10</code></em>   <code>num</code> consists of only digits.<br>*   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= target &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求一串数字加入加减乘能得到target的所有可能性</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求所有可能用DFS。属于分割型DFS，在数位之间加符号，数位可以是1个到多个。<br>一轮递归分割出符号 + 数字<br>另一种选择是数字 + 符号，但需要额外变量sign，因为不能立刻计算到结果。也不符合正常逻辑。所以选择前者。</p><p>由于运算都是二元，也就是用上述分割法，第一个数要特别处理。所以DFS中要特别处理第一个数。这样可以开始写加减。引入prev_res作为DFS参数，这样只要prev_res 加减 该轮数字即可得到该轮结果。用DFS模板5个标准参数外加prev_res：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_res, path, res):</span><br></pre></td></tr></table></figure></p><p>这样只处理加减的DFS比较容易实现  </p><p>最大难点在于乘法，参考LeetCode 227 Basic Calculator II，加减和乘除属于两层计算需要分别处理，所以引入<strong>新参数prev_multi_res，用于保存乘法结果，而刚才的命名为prev_add_res保存加减乘的全部结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def dfs(self, num, st, target, prev_add_res, prev_multi_res, path, res):</span><br></pre></td></tr></table></figure></p><p>举例2+3*4，按照原来的逻辑会计算到2+3=5，但此时如果遇到乘号，就要重新计算加法结果，先减去乘法结果，退回到2，再计算3*4=12这是乘法结果，再加回2得到新加法结果。进一步理解prev_multi_res，如果该轮是加减法，仍要将该轮的数作为prev_multi_res传到下轮DFS，因为如果下一轮是乘法，它就是第一个乘法的数。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>先实现加减法</li><li>再实现乘法</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>分割型DFS，选择每轮递归分割符号 + 数字。由于运算都是二元，<strong>特别处理第一个数</strong></li><li>引入参数prev_add_res, prev_multi_res. <strong>prev_multi_res若是加减，用(+/-)cur_num, 否则用乘法结果prev_multi_res * cur_num</strong>。注意若是减法cur_num用负号</li><li>分割时数字不能有前缀0</li><li>prev_res不用恢复状态因为是标量</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span><span class="params">(self, num: str, target: int)</span> -&gt; List[str]:</span></span><br><span class="line">res = []</span><br><span class="line">self.dfs(num, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, st, target, prev_add_res, prev_multi_res, path, res)</span>:</span></span><br><span class="line"><span class="keyword">if</span> st == len(num):</span><br><span class="line"><span class="keyword">if</span> target == prev_add_res:</span><br><span class="line">res.append(path)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(st, len(num)):</span><br><span class="line"><span class="keyword">if</span> i &gt; st <span class="keyword">and</span> num[st] == <span class="string">'0'</span>: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">cur_num = int(num[st:i + <span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> path: <span class="comment"># remember</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, str(cur_num), res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res + cur_num, cur_num, path + <span class="string">'+'</span> + str(cur_num), res) <span class="comment"># use cur_num rather than cur</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, prev_add_res - cur_num, -cur_num, path + <span class="string">'-'</span> + str(cur_num), res) <span class="comment"># -cur_num rather than cur_num</span></span><br><span class="line">self.dfs(num, i + <span class="number">1</span>, target, (prev_add_res - prev_multi_res) + prev_multi_res * cur_num, prev_multi_res * cur_num, path + <span class="string">'*'</span> + str(cur_num), res) <span class="comment"># prev_multi_res * cur_num not cur_num</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(4<sup>n</sup>)</code>，空间复杂度<code>O(n)</code>, 因为每个字符之间都有不加操作符，加3个操作符，所以是4，有n-1个间隔  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/expression-add-operators&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 277 Find the Celebrity</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-277-find-the-celebrity/</id>
    <published>2022-01-20T04:06:37.308Z</published>
    <updated>2022-01-20T04:20:05.576Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.<br><br>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is ask questions like: “Hi, A. Do you know B?” to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).<br><br>You are given a helper function <code>bool knows(a, b)</code> that tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.<br><br>Return <em>the celebrity’s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g1.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/19/g2.jpg" alt=""><br><br><pre><strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There is no celebrity.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == graph.length</code></em>   <code>n == graph[i].length</code><br><em>   <code>2 &lt;= n &lt;= 100</code></em>   <code>graph[i][j]</code> is <code>0</code> or <code>1</code>.<br><em>   <code>graph[i][i] == 1</code><br><br><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is `3 </em> n`, could you find a solution without exceeding the maximum number of calls?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过调用a是否认识b函数，找出名人。名人是除自己的所有人都认识他，他不认识其他所有人</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 169 Majority Element，用水王法</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>找出可能名人，通过查看是否i后面的每一个人都认识i，若不是将candidate换成当前下标</li><li>按定义验证第一步的结果是否名人，两步验证</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>按照定义，若i不认识candiate才换candidate，用not。因为edge case是没有边或者图存在循环</li><li>验证时候，第二步验证candidate若认识任意人就不是名人，排除candidate认识自己。题目条件candidate认识自己。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment"># find potential candidate</span></span><br><span class="line">candidate = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">candidate = i</span><br><span class="line"><span class="comment"># validate</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">if</span> candidate != i <span class="keyword">and</span> knows(candidate, i):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-celebrity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 270 Closest Binary Search Tree Value</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-270-closest-binary-search-tree-value/</id>
    <published>2022-01-19T10:20:20.197Z</published>
    <updated>2022-01-19T10:28:34.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">LeetCode</a></strong></p><div>Given the <code>root</code> of a binary search tree and a <code>target</code> value, return <em>the value in the BST that is closest to the</em> <code>target</code>. <strong>Example 1:</strong> <img src="https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg" alt=""><br><br><pre><strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> root = [1], target = 4.428571<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong> <em> The number of nodes in the tree is in the range <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>. </em> <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code> * <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求BST中最接近target的值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>接近target的值在BST搜索路径上，越后搜索到的(越后入栈的)越接近，但最接近的可能大于或小于target(predecessors or successors)，只能逐一比较.<br>类似于LeetCode 272 Closest Binary Search Tree Value II</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>循环中用it，不能用root，注意检查</li><li>接近target的值在BST搜索路径上，逐一比较</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root: TreeNode, target: float)</span> -&gt; int:</span></span><br><span class="line">closest_vals = []</span><br><span class="line">it = root</span><br><span class="line"><span class="keyword">while</span> it:</span><br><span class="line">closest_vals.append(it.val)</span><br><span class="line"><span class="keyword">if</span> target &lt; it.val:</span><br><span class="line">it = it.left</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">it = it.right</span><br><span class="line">min_val, res = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> closest_vals:</span><br><span class="line"><span class="keyword">if</span> abs(target - n) &lt; min_val:</span><br><span class="line">min_val = abs(target - n)</span><br><span class="line">res = n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(h)</code>，空间复杂度<code>O(h)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/closest-binary-search-tree-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 268 Missing Number</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-268-missing-number/</id>
    <published>2022-01-19T09:14:29.294Z</published>
    <updated>2022-01-19T09:23:13.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [3,0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [0,1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums.length</code></em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>0 &lt;= nums[i] &lt;= n</code></em>   All the numbers of <code>nums</code> are <strong>unique</strong>.<br><br><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>数组缺失一个数，所有数应该在[0, n]内，求缺失数</p><h3 id="排序法解题思路："><a href="#排序法解题思路：" class="headerlink" title="排序法解题思路："></a><strong>排序法解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="异或法解题思路II："><a href="#异或法解题思路II：" class="headerlink" title="异或法解题思路II："></a><strong>异或法解题思路II：</strong></h3><p>高斯原理</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">res = len(nums) <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">res ^= i ^ n</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code> </p><hr><h3 id="数学法解题思路III："><a href="#数学法解题思路III：" class="headerlink" title="数学法解题思路III："></a><strong>数学法解题思路III：</strong></h3><p>高斯原理</p><h3 id="Python代码：-2"><a href="#Python代码：-2" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber3</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">n = len(nums)</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> + n) * (n + <span class="number">1</span>) // <span class="number">2</span> - sum(nums)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Giv
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 266 Palindrome Permutation</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-266-palindrome-permutation/</id>
    <published>2022-01-19T09:04:18.224Z</published>
    <updated>2022-01-19T09:07:29.265Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/palindrome-permutation/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <code>true</code> if a permutation of the string could form a palindrome.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “code”<br><strong>Output:</strong> false<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “carerac”<br><strong>Output:</strong> true<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 5000</code></em>   <code>s</code> consists of only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>字符串的任一全排列是否存在回文字符串</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，也就是统计字符频率，奇数频率的字符最多有1个</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>统计字符频率，奇数频率的字符最多有1个</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> len([count <span class="keyword">for</span> count <span class="keyword">in</span> char_to_count.values() <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 256 Paint House</title>
    <link href="https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/"/>
    <id>https://shineboy2013.github.com/2022/01/19/leetcode-256-paint-house/</id>
    <published>2022-01-19T08:43:00.412Z</published>
    <updated>2022-01-19T08:51:13.879Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is a row of <code>n</code> houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br><br>The cost of painting each house with a certain color is represented by an <code>n x 3</code> cost matrix <code>costs</code>.<br><br><em>   For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with the color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on…<br><br>Return <em>the minimum cost to paint all houses</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> costs = [[17,2,17],[16,16,5],[14,3,19]]<br><strong>Output:</strong> 10<br><strong>Explanation:</strong> Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>Minimum cost: 2 + 5 + 3 = 10.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> costs = [[7,6,2]]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong></em>   <code>costs.length == n</code><br><em>   <code>costs[i].length == 3</code></em>   <code>1 &lt;= n &lt;= 100</code><br>*   <code>1 &lt;= costs[i][j] &lt;= 20</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>排屋相邻不同色地涂色(3色)的最低成本</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>低频题。最值且涉及数值考虑用DP。由于相邻不能同色，所以是多状态DP，有3个状态，不妨多用一维表示，第二维只有3值。<br>dp[i][j]定义为第i间屋涂上第j色的最低总费用，递归式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归5步曲，多1，初始，多1，少1，答案。记得第一步初始化数组多1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] = min(dp[i-1][(j+1)%3] + costs[i-1][j], dp[i-1][(j+2)%3] + costs[i-1][j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dp = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(costs) + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dp)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>] + costs[i - <span class="number">1</span>][j])</span><br><span class="line"><span class="keyword">return</span> min(dp[<span class="number">-1</span>][<span class="number">0</span>], dp[<span class="number">-1</span>][<span class="number">1</span>], dp[<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/paint-house/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;There 
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
