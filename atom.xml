<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2022-02-15T18:21:19.212Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1166 Design File System</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1166-design-file-system/</id>
    <published>2022-02-15T18:13:22.294Z</published>
    <updated>2022-02-15T18:21:19.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are asked to design a file system that allows you to create new paths and associate them with different values.<br><br>The format of a path is one or more concatenated strings of the form: <code>/</code> followed by one or more lowercase English letters. For example, “<code>/leetcode&quot;</code> and “<code>/leetcode/problems&quot;</code> are valid paths while an empty string <code>&quot;&quot;</code> and <code>&quot;/&quot;</code> are not.<br><br>Implement the <code>FileSystem</code> class:<br><br><em>   <code>bool createPath(string path, int value)</code> Creates a new <code>path</code> and associates a <code>value</code> to it if possible and returns <code>true</code>. Returns <code>false</code> if the path <strong>already exists</strong> or its parent path <strong>doesn’t exist</strong>.</em>   <code>int get(string path)</code> Returns the value associated with <code>path</code> or returns <code>-1</code> if the path doesn’t exist.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”get”]<br>[[],[“/a”,1],[“/a”]]<br><strong>Output:</strong><br>[null,true,1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/a”, 1); // return true<br>fileSystem.get(“/a”); // return 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>[“FileSystem”,”createPath”,”createPath”,”get”,”createPath”,”get”]<br>[[],[“/leet”,1],[“/leet/code”,2],[“/leet/code”],[“/c/d”,1],[“/c”]]<br><strong>Output:</strong><br>[null,true,true,2,false,-1]<br><strong>Explanation:</strong><br>FileSystem fileSystem = new FileSystem();<br><br>fileSystem.createPath(“/leet”, 1); // return true<br>fileSystem.createPath(“/leet/code”, 2); // return true<br>fileSystem.get(“/leet/code”); // return 2<br>fileSystem.createPath(“/c/d”, 1); // return false because the parent path “/c” doesn’t exist.<br>fileSystem.get(“/c”); // return -1 because this path doesn’t exist.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of calls to the two functions is less than or equal to <code>10&lt;sup&gt;4&lt;/sup&gt;</code> in total.</em>   <code>2 &lt;= path.length &lt;= 100</code><br>*   <code>1 &lt;= value &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统，支持创建路径，路径含key, value</p><h3 id="Trie解题思路："><a href="#Trie解题思路：" class="headerlink" title="Trie解题思路："></a><strong>Trie解题思路：</strong></h3><p>用Trie, is_end变成key, value</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>遍历用1开始，因为首个/前面是空字符串</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = TrieNode(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">if</span> i == len(segments) - <span class="number">1</span>: <span class="comment"># match all the previous segments</span></span><br><span class="line">                    it.children[segment] = TrieNode(segment)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">if</span> it.value != <span class="number">-1</span>: <span class="comment"># exists</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        it.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        segments = path.split(<span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line">        it = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segments)):</span><br><span class="line">            segment = segments[i]</span><br><span class="line">            <span class="keyword">if</span> segment <span class="keyword">not</span> <span class="keyword">in</span> it.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            it = it.children[segment]</span><br><span class="line">        <span class="keyword">return</span> it.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)  <span class="comment"># &#123;&#125;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.value = <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p><hr><h3 id="算法II-HashMap解题思路："><a href="#算法II-HashMap解题思路：" class="headerlink" title="算法II HashMap解题思路："></a><strong>算法II HashMap解题思路：</strong></h3><p>用前缀法</p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem2</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.path_to_val = defaultdict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createPath</span><span class="params">(self, path: str, value: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">"/"</span> <span class="keyword">or</span> len(path) == <span class="number">0</span> <span class="keyword">or</span> path <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># search from the right</span></span><br><span class="line">        parent = path[:path.rfind(<span class="string">'/'</span>)]</span><br><span class="line">        <span class="keyword">if</span> len(parent) &gt; <span class="number">1</span> <span class="keyword">and</span> parent <span class="keyword">not</span> <span class="keyword">in</span> self.path_to_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        self.path_to_val[path] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, path: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.path_to_val.get(path, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-file-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 839 Similar String Groups</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-839-similar-string-groups/</id>
    <published>2022-02-15T17:23:01.070Z</published>
    <updated>2022-02-15T17:28:06.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/similar-string-groups/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>. Also two strings <code>X</code> and <code>Y</code> are similar if they are equal.<br><br>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.<br><br>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.<br><br>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> strs = [“tars”,”rats”,”arts”,”star”]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> strs = [“omv”,”ovm”]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= strs.length &lt;= 300</code></em>   <code>1 &lt;= strs[i].length &lt;= 300</code><br><em>   <code>strs[i]</code> consists of lowercase letters only.</em>   All words in <code>strs</code> have the same length and are anagrams of each other.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>单词列表中，可以分成多少组，每组里面的单词互相之间至少有一对可以通过交换一个位置变成另一个单词</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>典型求连通集个数，类似于Num of island，用BFS。难点在于怎么找到neighbor，用遍历每一个单词的方式</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>难点在于怎么找到neighbor，用遍历每一个单词的方式，判断是否buddyStrings Leetcode 0859</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, strs: List[str])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">visited, groups, word_set = set(), <span class="number">0</span>, set(strs)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">self.bfs(word_set, s, visited)</span><br><span class="line">groups += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> groups</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, word_set, start, visited)</span>:</span></span><br><span class="line">queue = collections.deque([start])</span><br><span class="line">visited.add(start)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> word_set:</span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node == s <span class="keyword">or</span> <span class="keyword">not</span> self.buddyStrings(node, s):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(s)</span><br><span class="line">visited.add(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal):  <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nL)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/similar-string-groups/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1347 Minimum Number of Steps to Make Two Strings Anagram</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-1347-minimum-number-of-steps-to-make-two-strings-anagram/</id>
    <published>2022-02-15T16:48:02.381Z</published>
    <updated>2022-02-15T16:51:30.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.<br><br>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.<br><br>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “bab”, t = “aba”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Replace the first ‘a’ in t with b, t = “bba” which is anagram of s.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “leetcode”, t = “practice”<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> Replace ‘p’, ‘r’, ‘a’, ‘i’ and ‘c’ from t with proper characters to make t anagram of s.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “anagram”, t = “mangaar”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> “anagram” and “mangaar” are anagrams.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= s.length &lt;= 5 </em> 10<sup>4</sup><code>*</code>s.length == t.length<code>*</code>s<code>and</code>t` consist of lowercase English letters only.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>通过替换字母使得两字符为同位词Anagram</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计某一个词的词频，遍历另一个单词，减去词频，若不够减(小于0)，就加步数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSteps</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count_t = collections.Counter(t)</span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">if</span> char <span class="keyword">in</span> char_to_count_t <span class="keyword">and</span> char_to_count_t[char] &gt; <span class="number">0</span>:</span><br><span class="line">char_to_count_t[char] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">steps += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetC
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 854 K-Similar Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-854-k-similar-strings/</id>
    <published>2022-02-15T10:00:31.027Z</published>
    <updated>2022-02-15T10:07:52.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/k-similar-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Strings <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong> (for some non-negative integer <code>k</code>) if we can swap the positions of two letters in <code>s1</code> exactly <code>k</code> times so that the resulting string equals <code>s2</code>.<br><br>Given two anagrams <code>s1</code> and <code>s2</code>, return the smallest <code>k</code> for which <code>s1</code> and <code>s2</code> are <code>k</code><strong>-similar</strong>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s1 = “ab”, s2 = “ba”<br><strong>Output:</strong> 1<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s1 = “abc”, s2 = “bca”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s1.length &lt;= 20</code></em>   <code>s2.length == s1.length</code><br><em>   <code>s1</code> and <code>s2</code> contain only lowercase letters from the set <code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>.</em>   <code>s2</code> is an anagram of <code>s1</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>两字符，交换两个位置，使得他们相等，求最小交换次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值考虑用BFS，难点在于生成neighbor，见注意事项</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用例子写程序node = abc s2 = cba, 先找到第一个不同位i，然后找下一个不同位j，这个不同位node[j]需要与目标s2[i]相同，贪心法</li><li>倒数第二行要break，否则TLE，因为只要找到一位可以交换这一层的BFS算是结束</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, s1: str, s2: str)</span> -&gt; int:</span></span><br><span class="line">queue = collections.deque([s1])</span><br><span class="line">visited = set([s1])</span><br><span class="line">distance = &#123;s1: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == s2:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(node)): <span class="comment"># abc, cba</span></span><br><span class="line"><span class="keyword">if</span> node[i] == s2[i]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(node)):</span><br><span class="line"><span class="keyword">if</span> node[j] == s2[j]:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> node[j] == s2[i]:</span><br><span class="line">ss = node[:i] + node[j] + node[i + <span class="number">1</span>:j] + node[i] + node[j + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> ss <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(ss)</span><br><span class="line">visited.add(ss)</span><br><span class="line">distance[ss] = distance[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(解大小)</code>，空间复杂度<code>O(解大小)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/k-similar-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Buddy Strings</title>
    <link href="https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/"/>
    <id>https://shineboy2013.github.com/2022/02/15/leetcode-859-buddy-strings/</id>
    <published>2022-02-15T09:35:36.737Z</published>
    <updated>2022-02-15T09:38:45.215Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/buddy-strings/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> <em>if you can swap two letters in</em> <code>s</code> <em>so the result is equal to</em> <code>goal</code><em>, otherwise, return</em> <code>false</code><em>.</em><br><br>Swapping letters is defined as taking two indices <code>i</code> and <code>j</code> (0-indexed) such that <code>i != j</code> and swapping the characters at <code>s[i]</code> and <code>s[j]</code>.<br><br><em>   For example, swapping at indices <code>0</code> and <code>2</code> in <code>&quot;abcd&quot;</code> results in <code>&quot;cbad&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ba”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘b’ to get “ba”, which is equal to goal.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “ab”, goal = “ab”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The only letters you can swap are s[0] = ‘a’ and s[1] = ‘b’, which results in “ba” != goal.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “aa”, goal = “aa”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You can swap s[0] = ‘a’ and s[1] = ‘a’ to get “aa”, which is equal to goal.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length, goal.length &lt;= 2 * 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>s</code> and <code>goal</code> consist of lowercase letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两字符串，交换一次使得他们相等</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>三种情况： 长度不等，完全相等（若至少有一个重复，即满足题意），两次不同</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>三种情况： 长度不等，完全相等，两次不同</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, s: str, goal: str)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> len(s) != len(goal):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> s == goal <span class="keyword">and</span> len(set(s)) &lt; len(goal): <span class="comment"># any dups</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">diff = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(diff) == <span class="number">2</span> <span class="keyword">and</span> diff[<span class="number">0</span>] == diff[<span class="number">1</span>][::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/buddy-strings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Give
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 351 Android Unlock Patterns</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-351-android-unlock-patterns/</id>
    <published>2022-02-14T03:49:42.062Z</published>
    <updated>2022-02-14T04:07:52.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/android-unlock-patterns" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Android devices have a special lock screen with a <code>3 x 3</code> grid of dots. Users can set an “unlock pattern” by connecting the dots in a specific sequence, forming a series of joined line segments where each segment’s endpoints are two consecutive dots in the sequence. A sequence of <code>k</code> dots is a <strong>valid</strong> unlock pattern if both of the following are true:<br><br><em>   All the dots in the sequence are <strong>distinct</strong>.</em>   If the line segment connecting two consecutive dots in the sequence passes through the <strong>center</strong> of any other dot, the other dot <strong>must have previously appeared</strong> in the sequence. No jumps through the center non-selected dots are allowed.<br>    <em>   For example, connecting dots <code>2</code> and <code>9</code> without dots <code>5</code> or <code>6</code> appearing beforehand is valid because the line from dot <code>2</code> to dot <code>9</code> does not pass through the center of either dot <code>5</code> or <code>6</code>.    </em>   However, connecting dots <code>1</code> and <code>3</code> without dot <code>2</code> appearing beforehand is invalid because the line from dot <code>1</code> to dot <code>3</code> passes through the center of dot <code>2</code>.<br><br>Here are some example valid and invalid unlock patterns:<br><br><img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png" alt=""><br><br><em>   The 1st pattern <code>[4,1,3,6]</code> is invalid because the line connecting dots <code>1</code> and <code>3</code> pass through dot <code>2</code>, but dot <code>2</code> did not previously appear in the sequence.</em>   The 2nd pattern <code>[4,1,9,2]</code> is invalid because the line connecting dots <code>1</code> and <code>9</code> pass through dot <code>5</code>, but dot <code>5</code> did not previously appear in the sequence.<br><em>   The 3rd pattern <code>[2,4,1,3,6]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>3</code> meets the condition because dot <code>2</code> previously appeared in the sequence.</em>   The 4th pattern <code>[6,5,4,1,9,2]</code> is valid because it follows the conditions. The line connecting dots <code>1</code> and <code>9</code> meets the condition because dot <code>5</code> previously appeared in the sequence.<br><br>Given two integers <code>m</code> and <code>n</code>, return <em>the <strong>number of unique and valid unlock patterns</strong> of the Android grid lock screen that consist of <strong>at least</strong></em> <code>m</code> <em>keys and <strong>at most</strong></em> <code>n</code> <em>keys.</em><br><br>Two unlock patterns are considered <strong>unique</strong> if there is a dot in one sequence that is not in the other, or the order of the dots is different.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 1<br><strong>Output:</strong> 9<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> m = 1, n = 2<br><strong>Output:</strong> 65<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= m, n &lt;= 9</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>安卓开屏密码解锁种数。给定m, n是安卓的密码长度范围，求这个范围内的解码种数。1可以跳到2和4, 5, 6, 8(斜线没有通过其他数字)，但不能跳到3, 7, 9因为前提条件是这条线通过的数如2, 4, 5必须已经用过了。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题属于填位法，带条件的，条件在于map中，类似于LeetCode 248 Strobogrammatic Number III<br>难点是理解jump keys，有16种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skip[1][3] = skip[3][1] = 2;</span><br><span class="line">skip[1][7] = skip[7][1] = 4;</span><br><span class="line">skip[3][9] = skip[9][3] = 6;</span><br><span class="line">skip[7][9] = skip[9][7] = 8;</span><br><span class="line">skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;</span><br></pre></td></tr></table></figure></p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>用DFS模板: def dfs(self, graph, start, visited, res), start = num</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 9有return，所以要去掉刚加入的visited的num</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JUMP_KEYS = &#123;(<span class="number">1</span>,<span class="number">3</span>):<span class="number">2</span>, (<span class="number">1</span>,<span class="number">7</span>):<span class="number">4</span>, (<span class="number">1</span>,<span class="number">9</span>):<span class="number">5</span>, (<span class="number">2</span>,<span class="number">8</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">7</span>):<span class="number">5</span>, (<span class="number">3</span>,<span class="number">1</span>):<span class="number">2</span>, (<span class="number">3</span>,<span class="number">9</span>):<span class="number">6</span>, (<span class="number">4</span>,<span class="number">6</span>):<span class="number">5</span>, (<span class="number">6</span>,<span class="number">4</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">1</span>):<span class="number">4</span>, (<span class="number">7</span>,<span class="number">3</span>):<span class="number">5</span>, (<span class="number">7</span>,<span class="number">9</span>):<span class="number">8</span>, (<span class="number">8</span>,<span class="number">2</span>):<span class="number">5</span>, (<span class="number">9</span>,<span class="number">7</span>):<span class="number">8</span>, (<span class="number">9</span>,<span class="number">3</span>):<span class="number">6</span>, (<span class="number">9</span>,<span class="number">1</span>):<span class="number">5</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, num, m, n, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited.add(num)</span><br><span class="line">        <span class="keyword">if</span> len(visited) == n:</span><br><span class="line">            visited.remove(num) <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) &gt;= m:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> next_num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> (num, next_num) <span class="keyword">in</span> JUMP_KEYS <span class="keyword">and</span> JUMP_KEYS[(num, next_num)] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += self.dfs(next_num, m, n, visited)</span><br><span class="line">        visited.remove(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>, 因为最多是9乘以8乘以7…  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/android-unlock-patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Backtracking" scheme="https://shineboy2013.github.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 158 Read N Characters Given read4 II - Call Multiple Times</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-158-read-n-characters-given-read4/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-158-read-n-characters-given-read4/</id>
    <published>2022-02-13T10:32:10.048Z</published>
    <updated>2022-02-13T10:55:34.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method <code>read</code> to read <code>n</code> characters. Your method <code>read</code> may be <strong>called multiple times</strong>.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;char[] buf4 = new char[4]; // Create buffer with enough space to store charactersread4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of fileread4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.</em>   The read function may be <strong>called multiple times</strong>.<br><em>   Please remember to <strong>RESET</strong> your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/" target="_blank" rel="noopener">here</a> for more details.</em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><em>   It is guaranteed that in a given test case the same buffer <code>buf</code> is called by <code>read</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [1,2,1]<br><strong>Output:</strong> [1,2,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 1); // After calling your read method, buf should contain “a”. We read a total of 1 character from the file, so return 1.<br>sol.read(buf, 2); // Now buf should contain “bc”. We read a total of 2 characters from the file, so return 2.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br>Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abc”, queries = [4,1]<br><strong>Output:</strong> [3,0]<br><strong>Explanation:</strong> The test case represents the following scenario:<br>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 4); // After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.</em>   <code>1 &lt;= queries.length &lt;= 10</code><br>*   <code>1 &lt;= queries[i] &lt;= 500</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>题意类似于LeetCode 157 Read N Characters Given Read4，但此题唯一的区别是这个新的API: def read(self, buf, n)会被调用多次</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为read调用多次，所以调用read4多读了几个字符在n以外的，需要保留下来让下一次read返回到结果中，所以用queue来保存中间结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先将read4的结果保存在self.queue中，然后再填充到buf中，这里用到了quicksort里面partition的方法，while中只有当填充buf时i才移动，而read4时候不移动</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.queue = collections.deque()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line"><span class="keyword">if</span> self.queue:</span><br><span class="line">buf[i] = self.queue.popleft()</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">count = read4(buf4)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">self.queue.extend(buf4[:count])</span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leet
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 157 Read N Characters Given Read4</title>
    <link href="https://shineboy2013.github.com/2022/02/13/leetcode-157-read-n-characters-given-read4/"/>
    <id>https://shineboy2013.github.com/2022/02/13/leetcode-157-read-n-characters-given-read4/</id>
    <published>2022-02-13T09:46:16.876Z</published>
    <updated>2022-02-13T10:46:58.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method to read <code>n</code> characters.<br><br><strong>Method read4:</strong><br><br>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.<br><br>The return value is the number of actual characters read.<br><br>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.<br><br><strong>Definition of read4:</strong><br><br><pre>    Parameter:  char[] buf4<br>    Returns:    int<br><br>buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].<br></pre><br><br>Below is a high-level example of how <code>read4</code> works:<br><br><img src="https://assets.leetcode.com/uploads/2020/07/01/157_example.png" alt=""><br><br><pre>File file(“abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;char[] buf4 = new char[4]; // Create buffer with enough space to store charactersread4(buf4); // read4 returns 4\. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;read4(buf4); // read4 returns 1\. Now buf4 = &quot;e&quot;, fp points to end of fileread4(buf4); // read4 returns 0\. Now buf4 = &quot;&quot;, fp points to end of file</code><br></pre><br><br><strong>Method read:</strong><br><br>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.<br><br>The return value is the number of actual characters read.<br><br><strong>Definition of read:</strong><br><br><pre>    Parameters:    char[] buf, int n<br>    Returns:    int<br><br>buf[] is a destination, not a source. You will need to write the results to buf[].<br></pre><br><br><strong>Note:</strong><br><br><em>   Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.</em>   The <code>read</code> function will only be called once for each test case.<br><em>   You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> file = “abc”, n = 4<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>Note that “abc” is the file’s content, not buf. buf is the destination buffer that you will have to write the results to.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> file = “abcde”, n = 5<br><strong>Output:</strong> 5<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcde”. We read a total of 5 characters from the file, so return 5.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> file = “abcdABCD1234”, n = 12<br><strong>Output:</strong> 12<br><strong>Explanation:</strong> After calling your read method, buf should contain “abcdABCD1234”. We read a total of 12 characters from the file, so return 12.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= file.length &lt;= 500</code><br><em>   <code>file</code> consist of English letters and digits.</em>   <code>1 &lt;= n &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Karat题，有一个函数read4,如此调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf4 = [&apos; &apos;] * 4</span><br><span class="line">count = read4(buf4)</span><br></pre></td></tr></table></figure><p>buf4是填充后的结果，是一个大小为4的char list<br>count是buf4的有数据的实际大小(4或更小，取决于是否文件最后一段是否不够4)</p><p>现在要实现这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def read(self, buf, n)</span><br></pre></td></tr></table></figure></p><p>buf是字符列表，n是想要读取文件的大小，返回值为n或者更小，取决于是否文件大小是否小于n</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>若count为0，跳出循环</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, buf, n)</span>:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">buf4 = [<span class="string">' '</span>] * <span class="number">4</span></span><br><span class="line">count = read4(buf4)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> count: <span class="comment"># avoid dead loop</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">count = min(count, n - i)</span><br><span class="line">buf[i:] = buf4</span><br><span class="line">i += count</span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/read-n-characters-given-read4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>Karat 004 Ads Conversion</title>
    <link href="https://shineboy2013.github.com/2022/02/12/karat-004/"/>
    <id>https://shineboy2013.github.com/2022/02/12/karat-004/</id>
    <published>2022-02-13T03:47:43.099Z</published>
    <updated>2022-02-13T10:58:18.098Z</updated>
    
    <content type="html"><![CDATA[<p>A list of user ids + IPs, a list of user ids who have made purchases, a list of advertisement<br>clicks with user IPs.<br>Each user id has at most 1 IP.</p><p>Output: for each ad, output the number of clicks and the number of purchases.</p><pre>completed_purchase_user_ids = ["123"]ad_clicks = [    #"IP_Address,Time,Ad_Text",    "127.0.0.1,2011-01-03 09:21:22,black pen"]all_user_ips = [    #"User_ID,IP_Address",        "123,127.0.0.1"]</pre><p>输出:<br>black pen, 1 click, 1 purchase</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定购买记录，click记录，ip地址。求每个产品点击数和购买次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题比较直观，点击数直接可以从click记录中获得，购买次数就是将三个表格join一起获得</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n + m + p)</code>，空间复杂度<code>O(n + m + p)</code>, n, m, p分别每个表的大小  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A list of user ids + IPs, a list of user ids who have made purchases, a list of advertisement&lt;br&gt;clicks with user IPs.&lt;br&gt;Each user id ha
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 498 Diagonal Traverse</title>
    <link href="https://shineboy2013.github.com/2022/02/12/leetcode-498-diagonal-traverse/"/>
    <id>https://shineboy2013.github.com/2022/02/12/leetcode-498-diagonal-traverse/</id>
    <published>2022-02-13T00:56:43.553Z</published>
    <updated>2022-02-13T01:08:27.461Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt=""><br><br><pre><strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]<br><strong>Output:</strong> [1,2,4,7,5,3,6,8,9]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> mat = [[1,2],[3,4]]<br><strong>Output:</strong> [1,2,3,4]<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == mat.length</code></em>   <code>n == mat[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>1 &lt;= m * n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br>*   <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= mat[i][j] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>按类对角线梅花间竹地遍历每个元素，输出最后结果</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>边界条件很难找，而且每一层的结束点也和矩阵的长度或宽度有关。先找规律，可以看出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每层的所有元素下标和相等</span><br></pre></td></tr></table></figure></p><p>正常从左到右从上到下遍历矩阵，用一个dict来每层的每一个数，可以看出这些数的顺序都是按题目要求的，只不过是正序或逆序，所以最后按照奇偶决定是否正序或逆序加入到结果</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>从左到右从上到下遍历矩阵，dict[i + j]来加入每层的每一个数</li><li>dict的key的范围容易得知，按照奇偶决定是否正序或逆序加入到结果</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>dict[i + j]来加入每层的每一个数</li><li>dict的key的最大值为len(mat) + len(mat[0]) - 1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, mat: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">groups = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(mat[<span class="number">0</span>])):</span><br><span class="line">groups[i + j].append(mat[i][j])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mat) + len(mat[<span class="number">0</span>]) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.extend(groups[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res.extend(groups[i][::<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(nm)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diagonal-traverse/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Matrix" scheme="https://shineboy2013.github.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1779 Find Nearest Point That Has the Same X or Y Coordinate</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-1779-find-nearest-point-that-has-the-same-x-or-y-coordinate/</id>
    <published>2022-02-08T10:22:03.551Z</published>
    <updated>2022-02-08T10:26:14.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given two integers, <code>x</code> and <code>y</code>, which represent your current location on a Cartesian grid: <code>(x, y)</code>. You are also given an array <code>points</code> where each <code>points[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> represents that a point exists at <code>(a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;)</code>. A point is <strong>valid</strong> if it shares the same x-coordinate or the same y-coordinate as your location.<br><br>Return <em>the index <strong>(0-indexed)</strong> of the <strong>valid</strong> point with the smallest <strong>Manhattan distance</strong> from your current location</em>. If there are multiple, return <em>the valid point with the <strong>smallest</strong> index</em>. If there are no valid points, return <code>-1</code>.<br><br>The <strong>Manhattan distance</strong> between two points <code>(x&lt;sub&gt;1&lt;/sub&gt;, y&lt;sub&gt;1&lt;/sub&gt;)</code> and <code>(x&lt;sub&gt;2&lt;/sub&gt;, y&lt;sub&gt;2&lt;/sub&gt;)</code> is <code>abs(x&lt;sub&gt;1&lt;/sub&gt; - x&lt;sub&gt;2&lt;/sub&gt;) + abs(y&lt;sub&gt;1&lt;/sub&gt; - y&lt;sub&gt;2&lt;/sub&gt;)</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[3,4]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> The answer is allowed to be on the same location as your current location.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 3, y = 4, points = [[2,3]]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> There are no valid points.</pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= points.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>points[i].length == 2</code><br>*   <code>1 &lt;= x, y, a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个坐标和一堆坐标，这个坐标与某个点在同一条y轴或x轴上叫合法点，求它到这些点的最小曼哈顿距离对应的点的下标，若有多个结果，返回最小的数组下标。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，根据题意求</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearestValidPoint</span><span class="params">(self, x: int, y: int, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">min_dis = float(<span class="string">'inf'</span>)</span><br><span class="line">res = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i, (_x, _y) <span class="keyword">in</span> enumerate(points):</span><br><span class="line"><span class="keyword">if</span> x == _x <span class="keyword">or</span> y == _y:</span><br><span class="line"><span class="keyword">if</span> abs(x - _x) + abs(y - _y) &lt; min_dis:</span><br><span class="line">min_dis = abs(x - _x) + abs(y - _y)</span><br><span class="line">res = i</span><br><span class="line"><span class="keyword">elif</span> abs(x - _x) + abs(y - _y) == min_dis <span class="keyword">and</span> i &lt; res:</span><br><span class="line">res = i</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1761 Minimum Degree of a Connected Trio in a Graph</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-1761-minimum-degree-of-a-connected-trio-in-a-graph/</id>
    <published>2022-02-08T09:49:32.723Z</published>
    <updated>2022-02-08T10:03:40.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an undirected graph. You are given an integer <code>n</code> which is the number of nodes in the graph and an array <code>edges</code>, where each <code>edges[i] = [u&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;i&lt;/sub&gt;]</code> indicates that there is an undirected edge between <code>u&lt;sub&gt;i&lt;/sub&gt;</code> and <code>v&lt;sub&gt;i&lt;/sub&gt;</code>.<br><br>A <strong>connected trio</strong> is a set of <strong>three</strong> nodes where there is an edge between <strong>every</strong> pair of them.<br><br>The <strong>degree of a connected trio</strong> is the number of edges where one endpoint is in the trio, and the other is not.<br><br>Return <em>the <strong>minimum</strong> degree of a connected trio in the graph, or</em> <code>-1</code> <em>if the graph has no connected trios.</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios1.png" alt=""><br><br><pre><strong>Input:</strong> n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/01/26/trios2.png" alt=""><br><br><pre><strong>Input:</strong> n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> There are exactly three trios:<br>1) [1,4,3] with degree 0.<br>2) [2,5,6] with degree 2.<br>3) [5,6,7] with degree 2.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>2 &lt;= n &lt;= 400</code></em>   <code>edges[i].length == 2</code><br><em>   `1 &lt;= edges.length &lt;= n </em> (n-1) / 2<code>*</code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n<code>*</code>u<sub>i</sub> != v<sub>i</sub>`<br>*   There are no repeated edges.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个图，trio是三个节点直接互相相连，而度数表示连着trio的边的个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>根据定义，找出所有三个节点的组合，判断是否trio，然后根据trio的每个节点的度数总和 - 6即为所求<br>遍历所有三个节点组合时，会重复了两次。所以一个优化是，先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环。因为这个最小度数的节点已经大于等于3，trio里其他两个度数比它大的节点的度数更加会大于最小度数除以3，这样总度数肯定大于此时的最小度数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>根据定义，找出所有三个节点的组合u -&gt; v, v -&gt; w, w是否在u中，判断是否trio。先按度数排序节点，若节点度数大于等于最小度数除以3，跳出循环</li><li>邻接图用set，因为Line 13查找w是否在u中可以提高效率</li><li>min_degree / 3不是// 3</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTrioDegree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">graph = collections.defaultdict(set) <span class="comment"># use set coz if w in graph[u]</span></span><br><span class="line"><span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">graph[u].add(v)</span><br><span class="line">graph[v].add(u)</span><br><span class="line"></span><br><span class="line">min_degree = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> sorted(range(<span class="number">1</span>, n + <span class="number">1</span>), key=<span class="keyword">lambda</span> x: len(graph[x])):</span><br><span class="line"><span class="keyword">if</span> len(graph[u]) &gt;= min_degree / <span class="number">3</span>: <span class="comment"># remember / 3 not // 3</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> graph[v]:</span><br><span class="line"><span class="keyword">if</span> w <span class="keyword">in</span> graph[u]:</span><br><span class="line">min_degree = min(min_degree, len(graph[u]) + len(graph[v]) + len(graph[w]))</span><br><span class="line"><span class="keyword">return</span> min_degree - <span class="number">6</span> <span class="keyword">if</span> min_degree != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a
      
    
    </summary>
    
    
      <category term="DoorDash" scheme="https://shineboy2013.github.com/tags/DoorDash/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 979 Distribute Coins in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/08/leetcode-979-distribute-coins-in-binary-tree/</id>
    <published>2022-02-08T08:30:55.871Z</published>
    <updated>2022-02-08T08:53:25.280Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given the <code>root</code> of a binary tree with <code>n</code> nodes where each <code>node</code> in the tree has <code>node.val</code> coins. There are <code>n</code> coins in total throughout the whole tree.<br><br>In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.<br><br>Return <em>the <strong>minimum</strong> number of moves required to make every node have <strong>exactly</strong> one coin</em>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" alt=""><br><br><pre><strong>Input:</strong> root = [3,0,0]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> From the root of the tree, we move one coin to its left child, and one coin to its right child.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" alt=""><br><br><pre><strong>Input:</strong> root = [0,3,0]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the tree is <code>n</code>.</em>   <code>1 &lt;= n &lt;= 100</code><br><em>   <code>0 &lt;= Node.val &lt;= n</code></em>   The sum of all <code>Node.val</code> is <code>n</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>二叉树某些节点含有硬币，求将这些硬币推向其他节点，使得所有节点都有一个硬币，求总移动次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>先思考，若硬币都在root，也就是求所有节点的路径和。可以用每个节点的路径和求和，也可以定义dfs返回节点数，用全局变量加左右数，每轮递归都加一次，所以每个节点被加了其路径长度的次数。本算法采用后者<br>下面思考若硬币不在root，由于硬币可以从儿子给父亲，这是双向的，所以<strong>dfs定义为儿子给父亲的硬币数</strong>，若节点没有硬币，返回值会是负数，也就是父亲给儿子硬币，此时这个负数正是以此节点为root的数的总的节点数，所以与上述定义一致。<br>所以返回root.val + left + right - 1，left和right都是负数，left + right - 1是树的大小的负数，此结果为剩余硬币推给父亲的硬币数<br>res += abs(left) + abs(right)左子树和右子树所有节点一起走一条边的路径和</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>dfs定义为儿子给父亲的硬币数(若有硬币)，同时是子树的节点数的负数(若无硬币)</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> res</span><br><span class="line">left = dfs(root.left)</span><br><span class="line">right = dfs(root.right)</span><br><span class="line">res += abs(left) + abs(right)</span><br><span class="line"><span class="keyword">return</span> root.val + left + right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/distribute-coins-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1448 Count Good Nodes in Binary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1448-count-good-nodes-in-binary-tree/</id>
    <published>2022-02-08T07:07:29.316Z</published>
    <updated>2022-02-08T07:26:22.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named <strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.<br><br>Return the number of <strong>good</strong> nodes in the binary tree.<br><br><strong>Example 1:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.<br>Root Node (3) is always a good node.<br>Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.<br>Node 5 -&gt; (3,4,5) is the maximum value in the path<br>Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [3,3,null,4,2]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because “3” is higher than it.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> root = [1]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre><br><br><strong>Constraints:</strong><br><br><em>   The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.</em>   Each node’s value is between <code>[-10^4, 10^4]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个节点是good表示该节点从root到自己的路径上，所有节点都小于等于自己。求二叉树的good节点个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计左右子树的good节点个数，最重要是引入类似于min, max验证BST，<strong>引入path_max来记录路径上的最大值</strong>，只要该节点值大于path_max就是good节点。DFS返回good节点个数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>引入path_max来记录路径上的最大值</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> self.dfs(root, float(<span class="string">'-inf'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path_max)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">left = self.dfs(root.left, max(root.val, path_max))</span><br><span class="line">right = self.dfs(root.right, max(root.val, path_max))</span><br><span class="line">res = left + right</span><br><span class="line"><span class="keyword">if</span> path_max &lt;= root.val:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/count-good-nodes-in-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1304 Find N Unique Integers Sum up to Zero</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1304-find-n-unique-integers-sum-up-to-zero/</id>
    <published>2022-02-08T07:03:16.849Z</published>
    <updated>2022-02-08T07:05:51.085Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong> integers such that they add up to <code>0</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> [-7,-1,1,3,4]<br><strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3<br><strong>Output:</strong> [-1,0,1]<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 1<br><strong>Output:</strong> [0]<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n，求n个数的数组使得数组和为0</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>Easy题，只要将相反数放入数组即可</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">res.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span>):</span><br><span class="line">res.append(i + <span class="number">1</span>)</span><br><span class="line">res.append(-i - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 984 String Without AAA or BBB</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-984-string-without-aaa-or-bbb/</id>
    <published>2022-02-08T06:42:39.348Z</published>
    <updated>2022-02-08T06:45:10.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two integers <code>a</code> and <code>b</code>, return <strong>any</strong> string <code>s</code> such that:<br><br><em>   <code>s</code> has length <code>a + b</code> and contains exactly <code>a</code> <code>&#39;a&#39;</code> letters, and exactly <code>b</code> <code>&#39;b&#39;</code> letters,</em>   The substring <code>&#39;aaa&#39;</code> does not occur in <code>s</code>, and<br><em>   The substring <code>&#39;bbb&#39;</code> does not occur in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 2<br><strong>Output:</strong> “abb”<br><strong>Explanation:</strong> “abb”, “bab” and “bba” are all correct answers.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 4, b = 1<br><strong>Output:</strong> “aabaa”<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b &lt;= 100</code><br>*   It is guaranteed such an <code>s</code> exists for the given <code>a</code> and <code>b</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个整数代表ab的个数，生成一个字符串，字符串ab频数不能超过这2个数，不能有连续的aaa, bbb, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>参考LeetCode 1405 Longest Happy String, 此题不用heap因为只有两种字符</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>不能连续的处理</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span><span class="params">(self, a: int, b: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">0</span> <span class="keyword">or</span> b &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'a'</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">res += <span class="string">'a'</span></span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += <span class="string">'b'</span></span><br><span class="line">b -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-without-aaa-or-bbb/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1405 Longest Happy String</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1405-longest-happy-string/</id>
    <published>2022-02-08T06:20:09.075Z</published>
    <updated>2022-02-08T06:32:41.593Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-happy-string/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>happy</strong> if it satisfies the following conditions:<br><br><em>   <code>s</code> only contains the letters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</em>   <code>s</code> does not contain any of <code>&quot;aaa&quot;</code>, <code>&quot;bbb&quot;</code>, or <code>&quot;ccc&quot;</code> as a substring.<br><em>   <code>s</code> contains <strong>at most</strong> <code>a</code> occurrences of the letter <code>&#39;a&#39;</code>.</em>   <code>s</code> contains <strong>at most</strong> <code>b</code> occurrences of the letter <code>&#39;b&#39;</code>.<br><em>   <code>s</code> contains <strong>at most</strong> <code>c</code> occurrences of the letter <code>&#39;c&#39;</code>.<br><br>Given three integers <code>a</code>, <code>b</code>, and <code>c</code>, return <em>the <strong>longest possible happy</strong> string</em>. If there are multiple longest happy strings, return <em>any of them</em>. If there is no such string, return <em>the empty string</em> <code>&quot;&quot;</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters within a string.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> a = 1, b = 1, c = 7<br><strong>Output:</strong> “ccaccbcc”<br><strong>Explanation:</strong> “ccbccacc” would also be a correct answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> a = 7, b = 1, c = 0<br><strong>Output:</strong> “aabaa”<br><strong>Explanation:</strong> It is the only correct answer in this case.<br></pre><br><br><strong>Constraints:</strong></em>   <code>0 &lt;= a, b, c &lt;= 100</code><br>*   <code>a + b + c &gt; 0</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定三个整数代表abc的个数，生成一个字符串，字符串abc频数不能超过这3个数，不能有连续的aaa, bbb, ccc, 求此种字符串的最大长度</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由第一个例子看出，先尽量用频数最多的字符，直到连续3个为止，然后再用次多的，如此反复做。这里用到最多和次多，所以考虑用Heap</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>每次选频数最高的字符，但若此字符已连续3次，选次高的，用heap。 </li><li>大于0的频数才加入到heap Line 4和Line 17</li><li>heapreplace等于heappop次高的和heappush最高的。<strong>既然要有次高，heap就不能为空</strong></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">heapq.heappush(heap, (-a, <span class="string">'a'</span>))</span><br><span class="line"><span class="keyword">if</span> b &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-b, <span class="string">'b'</span>))</span><br><span class="line"><span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">heapq.heappush(heap, (-c, <span class="string">'c'</span>))</span><br><span class="line"><span class="keyword">while</span> heap:</span><br><span class="line">count, char = heapq.heappop(heap)</span><br><span class="line"><span class="keyword">if</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-2</span>] == res[<span class="number">-1</span>] == char:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">count, char = heapq.heapreplace(heap, (count, char))</span><br><span class="line">res += char</span><br><span class="line"><span class="keyword">if</span> count + <span class="number">1</span>:</span><br><span class="line">heapq.heappush(heap, (count + <span class="number">1</span>, char))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-happy-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1647 Minimum Deletions to Make Character Frequencies Unique</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1647-minimum-deletions-to-make-character-frequencies-unique/</id>
    <published>2022-02-08T02:42:06.875Z</published>
    <updated>2022-02-08T02:47:59.204Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.<br><br>Given a string <code>s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>s</code> <em><strong>good</strong>.</em><br><br>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>&quot;aab&quot;</code>, the <strong>frequency</strong> of <code>&#39;a&#39;</code> is <code>2</code>, while the <strong>frequency</strong> of <code>&#39;b&#39;</code> is <code>1</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aab”<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> <code>s</code> is already good.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “aaabbbcc”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete two ‘b’s resulting in the good string “aaabcc”.<br>Another way it to delete one ‘b’ and one ‘c’ resulting in the good string “aaabbc”.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “ceabaacb”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> You can delete both ‘c’s resulting in the good string “eabaab”.<br>Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> contains only lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字符串，求最小删除次数使得字符串的每一种字符频率不同</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解，若遇到频率相同的字符，就将其减一，也就是删除一个字符，使得它不再与其他字符频率相同直到0. 关键在用一个unique_count的set来记录频数</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用一个unique_count的set来记录频数</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDeletions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">char_to_count = collections.Counter(s)</span><br><span class="line">unique_count = set()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char, count <span class="keyword">in</span> char_to_count.items():</span><br><span class="line">cur_count = count</span><br><span class="line"><span class="keyword">while</span> cur_count <span class="keyword">in</span> unique_count:</span><br><span class="line">cur_count -= <span class="number">1</span></span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cur_count &gt; <span class="number">0</span>:</span><br><span class="line">unique_count.add(cur_count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Le
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Microsoft" scheme="https://shineboy2013.github.com/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>Karat 003 Nonogram</title>
    <link href="https://shineboy2013.github.com/2022/02/07/karat-003/"/>
    <id>https://shineboy2013.github.com/2022/02/07/karat-003/</id>
    <published>2022-02-07T10:16:22.375Z</published>
    <updated>2022-02-07T10:23:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>A nonogram is a logic puzzle, similar to a crossword, in which the player is given<br>a blank grid and has to color it according to some instructions. Specifically,<br>each cell can be either black or white, which we will represent as 0 for black and<br>1 for white.<br>+————+<br>| 1 1 1 1 |<br>| 0 1 1 1 |<br>| 0 1 0 0 |<br>| 1 1 0 1 |<br>| 0 0 1 1 |<br>+————+<br>For each row and column, the instructions give the lengths of contiguous runs of<br>black (0) cells. For example, the instructions for one row of [ 2, 1 ] indicate<br>that there must be a run of two black cells, followed later by another run of one<br>black cell, and the rest of the row filled with white cells.<br>These are valid solutions: [ 1, 0, 0, 1, 0 ] and [ 0, 0, 1, 1, 0 ] and also [ 0,<br>0, 1, 0, 1 ]<br>This is not valid: [ 1, 0, 1, 0, 0 ] since the runs are not in the correct order.<br>This is not valid: [ 1, 0, 0, 0, 1 ] since the two runs of 0s are not separated by<br>1s.<br>Your job is to write a function to validate a possible solution against a set of<br>instructions. Given a 2D matrix representing a player’s solution; and instructions<br>for each row along with additional instructions for each column; return True or<br>False according to whether both sets of instructions match.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Nonogram日本游戏，0表示黑子，[2, 1]表示黑子的连续数目，如棋盘状态[ 1, 0, 0, 1, 0 ]，表示连续黑子数为[2, 1]<br>[ 1, 0, 0, 0, 1 ]连续黑子数为[3]. 验证棋盘的每一行和每一列是否满足rows和cols所指定的连续黑子数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按题意求解</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>递归只有一种情况</li><li>答案需求全局</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_nonogram</span><span class="params">(self, matrix, rows, cols)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(matrix[i]) != rows[i]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">col_vals = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">col_vals.append(matrix[i][j])</span><br><span class="line"><span class="keyword">if</span> self.get_consecutive_zeros(col_vals) != cols[j]:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 1, 0, 0, 1, 0 ] -&gt; [2, 1], # of 0s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_consecutive_zeros</span><span class="params">(self, matrix_row)</span>:</span></span><br><span class="line">count, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> matrix_row:</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">res.append(count)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A nonogram is a logic puzzle, similar to a crossword, in which the player is given&lt;br&gt;a blank grid and has to color it according to some 
      
    
    </summary>
    
    
      <category term="Karat" scheme="https://shineboy2013.github.com/tags/Karat/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1522 Diameter of N-Ary Tree</title>
    <link href="https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/"/>
    <id>https://shineboy2013.github.com/2022/02/07/leetcode-1522-diameter-of-n-ary-tree/</id>
    <published>2022-02-07T09:33:44.019Z</published>
    <updated>2022-02-07T09:38:33.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/diameter-of-n-ary-tree/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a <code>root</code> of an <a href="https://leetcode.com/articles/introduction-to-n-ary-trees/" target="_blank" rel="noopener">N-ary tree</a>, you need to compute the length of the diameter of the tree.<br><br>The diameter of an N-ary tree is the length of the <strong>longest</strong> path between any two nodes in the tree. This path may or may not pass through the root.<br><br>(<em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)</em><br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> Diameter is shown in red color.</pre><br><br><strong>Example 2:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png" alt=""></strong><br><br><pre><strong>Input:</strong> root = [1,null,2,null,3,4,null,5,null,6]<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png" alt=""><br><br><pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br><strong>Output:</strong> 7<br></pre><br><br><strong>Constraints:</strong><br><br><em>   The depth of the n-ary tree is less than or equal to <code>1000</code>.</em>   The total number of nodes is between <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求树的直径：任何两个节点的最大距离</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于LeetCode 543 Diameter of Binary Tree，但此题为N叉树</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>DFS</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>求数组中最大的两数和，用去掉最大值的方法得到次大值。还要注意初始值加入[1, 1]，避免没有儿子节点或只有一个的情况</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; int:</span></span><br><span class="line">max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nonlocal</span> max_len</span><br><span class="line">path_len = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">path_len.append(dfs(child) + <span class="number">1</span>)</span><br><span class="line">largest = max(path_len)</span><br><span class="line">path_len.remove(largest)</span><br><span class="line">second_largest = max(path_len)</span><br><span class="line">total = largest + second_largest - <span class="number">1</span></span><br><span class="line">max_len = max(total, max_len)</span><br><span class="line"><span class="keyword">return</span> largest</span><br><span class="line"></span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/diameter-of-n-ary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
</feed>
