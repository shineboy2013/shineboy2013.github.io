<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2021-12-21T09:46:06.975Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 013 Roman to Integer</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-013/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-013/</id>
    <published>2021-12-21T09:34:21.623Z</published>
    <updated>2021-12-21T09:46:06.975Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.<br><br><pre><strong>Symbol</strong>       <strong>Value</strong><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</pre><br><br>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:<br><br><em>   <code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </em>   <code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.<br><em>   <code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.<br><br>Given a roman numeral, convert it to an integer.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “III”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> III = 3.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “LVIII”<br><strong>Output:</strong> 58<br><strong>Explanation:</strong> L = 50, V= 5, III = 3.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “MCMXCIV”<br><strong>Output:</strong> 1994<br><strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length &lt;= 15</code><br><em>   <code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</em>   It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>罗马数组转阿拉伯数字</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>按照规则累加。有一个特别规则是需要做减法如IV。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>先加再减的方法。  </li><li>SYMBOL_TO_VAL的值可以哟用于判断先后顺序。     </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">SYMBOL_TO_VAL = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">res, num, prev = <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> s:</span><br><span class="line">num = SYMBOL_TO_VAL[symbol]</span><br><span class="line"><span class="keyword">if</span> prev <span class="keyword">and</span> SYMBOL_TO_VAL[prev] &lt; SYMBOL_TO_VAL[symbol]:</span><br><span class="line">res -= SYMBOL_TO_VAL[prev] * <span class="number">2</span></span><br><span class="line">res += num</span><br><span class="line">prev = symbol</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;R
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1570 Dot Product of Two Sparse Vectors</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-1570/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-1570/</id>
    <published>2021-12-21T08:49:53.594Z</published>
    <updated>2021-12-21T08:58:36.300Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given two sparse vectors, compute their dot product.<br><br>Implement class <code>SparseVector</code>:<br><br><em>   <code>SparseVector(nums)</code> Initializes the object with the vector <code>nums</code></em>   <code>dotProduct(vec)</code> Compute the dot product between the instance of <em>SparseVector</em> and <code>vec</code><br><br>A <strong>sparse vector</strong> is a vector that has mostly zero values, you should store the sparse vector <strong>efficiently</strong> and compute the dot product between two <em>SparseVector</em>.<br><br><strong>Follow up: </strong>What if only one of the vectors is sparse?<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]<br><strong>Output:</strong> 8<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 1<em>0 + 0</em>3 + 0<em>0 + 2</em>4 + 3<em>0 = 8<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> v1 = SparseVector(nums1) , v2 = SparseVector(nums2)<br>v1.dotProduct(v2) = 00 + 1<em>0 + 0</em>0 + 0<em>0 + 0</em>2 = 0<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]<br><strong>Output:</strong> 6<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == nums1.length == nums2.length</code></em>   <code>1 &lt;= n &lt;= 10^5</code><br>*   <code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>稀疏数组乘法，设计类来存储且计算乘积</p><h3 id="HashMap解题思路："><a href="#HashMap解题思路：" class="headerlink" title="HashMap解题思路："></a><strong>HashMap解题思路：</strong></h3><p>类似于Two sum，也是两种方法。HashMap的方法由于hash函数计算容易冲突，所以算法复杂度不够稳定。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.idx_to_num = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.idx_to_num[i] = n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> vec.idx_to_num.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> self.idx_to_num:</span><br><span class="line">                res += self.idx_to_num[i] * n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p><hr><h3 id="Mergesort算法II解题思路："><a href="#Mergesort算法II解题思路：" class="headerlink" title="Mergesort算法II解题思路："></a><strong>Mergesort算法II解题思路：</strong></h3><p>初始化复杂度比较稳定  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.non_zero_list = []</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                self.non_zero_list.append((i,n))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(self.non_zero_list) - <span class="number">1</span> <span class="keyword">and</span> j &lt;= len(vec.non_zero_list) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> self.non_zero_list[i][<span class="number">0</span>] == vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                res += self.non_zero_list[i][<span class="number">1</span>] * vec.non_zero_list[j][<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> self.non_zero_list[i][<span class="number">0</span>] &lt; vec.non_zero_list[j][<span class="number">0</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>创建时间复杂度为<code>O(n)</code>，计算时间复杂度为<code>O(L1 + L2)</code>，空间复杂度<code>O(L)</code>，L为非0元素个数  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/dot-product-of-two-sparse-vectors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 050 Pow(x, n)</title>
    <link href="https://shineboy2013.github.com/2021/12/21/lee-050/"/>
    <id>https://shineboy2013.github.com/2021/12/21/lee-050/</id>
    <published>2021-12-21T08:03:42.776Z</published>
    <updated>2021-12-21T08:06:48.730Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x&lt;sup&gt;n&lt;/sup&gt;</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = 10<br><strong>Output:</strong> 1024.00000<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> x = 2.10000, n = 3<br><strong>Output:</strong> 9.26100<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> x = 2.00000, n = -2<br><strong>Output:</strong> 0.25000<br><strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>-100.0 &lt; x &lt; 100.0</code></em>   <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= n &lt;= 2&lt;sup&gt;31&lt;/sup&gt;-1</code><br>*   <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= x&lt;sup&gt;n&lt;/sup&gt; &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求幂</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>保存dfs(x, n/2)的临时结果，避免重复计算   </li><li>n可以是0，负数 </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs(x, n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> self.dfs(<span class="number">1</span> / x, -n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">tmp = self.dfs(x, n / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> tmp * tmp</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp = self.dfs(x, (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> tmp * tmp * x</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/powx-n/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Implement &lt;
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
      <category term="Recursion" scheme="https://shineboy2013.github.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 443 String Compression</title>
    <link href="https://shineboy2013.github.com/2021/12/20/lee-443/"/>
    <id>https://shineboy2013.github.com/2021/12/20/lee-443/</id>
    <published>2021-12-21T07:37:40.086Z</published>
    <updated>2021-12-21T07:43:38.054Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/string-compression/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of characters <code>chars</code>, compress it using the following algorithm:<br><br>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:<br><br><em>   If the group’s length is <code>1</code>, append the character to <code>s</code>.</em>   Otherwise, append the character followed by the group’s length.<br><br>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.<br><br>After you are done <strong>modifying the input array</strong>, return <em>the new length of the array</em>.<br><br>You must write an algorithm that uses only constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>Explanation:</strong> The groups are “aa”, “bb”, and “ccc”. This compresses to “a2b2c3”.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> chars = [“a”]<br><strong>Output:</strong> Return 1, and the first character of the input array should be: [“a”]<br><strong>Explanation:</strong> The only group is “a”, which remains uncompressed since it’s a single character.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br><strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”].<br><strong>Explanation:</strong> The groups are “a” and “bbbbbbbbbbbb”. This compresses to “ab12”.</pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> chars = [“a”,”a”,”a”,”b”,”b”,”a”,”a”]<br><strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [“a”,”3”,”b”,”2”,”a”,”2”].<br><strong>Explanation:</strong> The groups are “aaa”, “bb”, and “aa”. This compresses to “a3b2a2”. Note that each group is independent even if two groups have the same character.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= chars.length &lt;= 2000</code></em>   <code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>相邻相同字母用数字压缩</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>题目要求，如果是超过10，也要将这个数按多个字符populate到原数组，见populate_count的实现，用字符串处理  </li><li>在循环外处理最后一部分    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class="line">res, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(chars)):</span><br><span class="line"><span class="keyword">if</span> chars[i - <span class="number">1</span>] == chars[i]:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">res = self.populate_count(chars, res, count)</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">chars[res] = chars[i]</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">res = self.populate_count(chars, res, count)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">populate_count</span><span class="params">(self, chars, res, count)</span>:</span></span><br><span class="line">num_str = str(count)</span><br><span class="line">chars[res:res + len(num_str)] = [c <span class="keyword">for</span> c <span class="keyword">in</span> num_str]</span><br><span class="line">res += len(num_str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/string-compression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 011 Container With Most Water</title>
    <link href="https://shineboy2013.github.com/2021/12/20/lee-011/"/>
    <id>https://shineboy2013.github.com/2021/12/20/lee-011/</id>
    <published>2021-12-21T03:41:35.494Z</published>
    <updated>2021-12-21T03:44:13.071Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.<br><br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br><br>Return <em>the maximum amount of water a container can store</em>.<br><br><strong>Notice</strong> that you may not slant the container.<br><br><strong>Example 1:</strong><br><br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""><br><br><pre><strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49<br><strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> height = [1,1]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>n == height.length</code></em>   <code>2 &lt;= n &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= height[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两板之间的最大水量</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>贪婪法，求面积，然后移动矮的那条边</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>贪婪法，求面积，然后移动矮的那条边    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">i, j = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; j:</span><br><span class="line">res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class="line"><span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1762 Buildings With an Ocean View</title>
    <link href="https://shineboy2013.github.com/2021/12/20/lee-1762/"/>
    <id>https://shineboy2013.github.com/2021/12/20/lee-1762/</id>
    <published>2021-12-20T10:16:19.976Z</published>
    <updated>2021-12-20T10:28:26.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>大海在右边，求看到大海的大厦的下标  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数组元素之间大小关系且保持顺序，用stack</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span><span class="params">(self, heights: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &gt;= heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">stack.pop()</span><br><span class="line">stack.append(i) <span class="comment"># 4 3 1</span></span><br><span class="line"><span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p><hr><h3 id="算法II解题思路-推荐-："><a href="#算法II解题思路-推荐-：" class="headerlink" title="算法II解题思路(推荐)："></a><strong>算法II解题思路(推荐)：</strong></h3><p>数组元素之间大小关系且保持顺序，用stack</p><h3 id="解题步骤：-1"><a href="#解题步骤：-1" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>类似于Leetcode 42的trapping rain water，看不到大海表示在低位。此题只求单边，从右往左扫描一次。  </p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings2</span><span class="params">(self, heights: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">right_max, res = <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(heights))):</span><br><span class="line"><span class="keyword">if</span> heights[i] &gt; right_max:</span><br><span class="line">res.append(i)</span><br><span class="line">right_max = max(right_max, heights[i])</span><br><span class="line"><span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/buildings-with-an-ocean-view/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 068 Text Justification</title>
    <link href="https://shineboy2013.github.com/2021/12/19/lee-068/"/>
    <id>https://shineboy2013.github.com/2021/12/19/lee-068/</id>
    <published>2021-12-20T01:20:31.504Z</published>
    <updated>2021-12-20T05:09:40.077Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.<br><br>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.<br><br>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.<br><br>For the last line of text, it should be left-justified and no extra space is inserted between words.<br><br><strong>Note:</strong><br><br><em>   A word is defined as a character sequence consisting of non-space characters only.</em>   Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.<br><em>   The input array <code>words</code> contains at least one word.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> words = [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”], maxWidth = 16<br><strong>Output:</strong><br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> words = [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”], maxWidth = 16<br><strong>Output:</strong><br>[<br>  “What   must   be”,<br>  “acknowledgment  “,<br>  “shall be        “<br>]<br><strong>Explanation:</strong> Note that the last line is “shall be    “ instead of “shall     be”, because the last line must be left-justified instead of fully-justified.<br>Note that the second line is also left-justified becase it contains only one word.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> words = [“Science”,”is”,”what”,”we”,”understand”,”well”,”enough”,”to”,”explain”,”to”,”a”,”computer.”,”Art”,”is”,”everything”,”else”,”we”,”do”], maxWidth = 20<br><strong>Output:</strong><br>[<br>  “Science  is  what we”,<br>  “understand      well”,<br>  “enough to explain to”,<br>  “a  computer.  Art is”,<br>  “everything  else  we”,<br>  “do                  “<br>]</pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= words.length &lt;= 300</code><br><em>   <code>1 &lt;= words[i].length &lt;= 20</code></em>   <code>words[i]</code> consists of only English letters and symbols.<br><em>   <code>1 &lt;= maxWidth &lt;= 100</code></em>   <code>words[i].length &lt;= maxWidth</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>加入尽量均等的空格使得单词组成的每行左右对齐  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>0.1 题目要求： 若空格有多余，尽量分到前面；若某一行只有一个单词，左对齐右补空格；最后一行无论多少个单词都是左对齐右补空格<br>0.2 用buffer记录这一行的单词，count记录单词和空格的长度，若count + 当前单词长度大于maxWidth就处理   </p><ol><li>公式：extra_space_num, idx = math.ceil(num_space_left / (len(buffer) - 1)), num_space_left % (len(buffer) - 1)<br>有多余空格就分配到单词间隔个数中len(buffer) - 1，而不是单词个数. 商为多余的空格个数，余数为从第几位开始，减一个空格。如x x x x，idx = 1，表示平分后仍多出一个空格，所以分配到第0个到第1个单词之间，也就是[:idx + 1]中，而剩余的buffer[idx + 1:]比上述少一个空格。它们之间的连接用较少空格数  </li><li>公式中<strong>若余数为0</strong>， 表示全部平均分配，这时要取extra_space_num + 1，所以令idx = len(buffer) - 1  </li><li>公式中len(buffer) - 1可能为0，所以要特别处理，对应到题目要求的第二点  </li><li>最后一行是buffer的内容，出来for循环后，向右加空格，对应到题目要求的第三点，代码与第二点要求类似   </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line"><span class="comment"># words.append(' ' * maxWidth)</span></span><br><span class="line">buffer, count, res = [], <span class="number">0</span>, []</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">new_length = len(word) <span class="keyword">if</span> len(buffer) == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> + len(word)</span><br><span class="line"><span class="keyword">if</span> count + new_length &lt;= maxWidth:</span><br><span class="line">buffer.append(word)</span><br><span class="line">count += new_length</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">num_space_left = maxWidth - count <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">if</span> len(buffer) &gt; <span class="number">1</span>:</span><br><span class="line">extra_space_num, idx = math.ceil(num_space_left / (len(buffer) - <span class="number">1</span>)), num_space_left % (len(buffer) - <span class="number">1</span>) <span class="comment"># 3, 0</span></span><br><span class="line"><span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">idx = len(buffer) - <span class="number">1</span></span><br><span class="line">tmp = (<span class="string">' '</span> * (extra_space_num + <span class="number">1</span>)).join(buffer[:idx + <span class="number">1</span>]) + (<span class="string">' '</span> * extra_space_num) <span class="comment">#</span></span><br><span class="line">tmp += (<span class="string">' '</span> * extra_space_num).join(buffer[idx + <span class="number">1</span>:])</span><br><span class="line">res.append(tmp.strip())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp = buffer[<span class="number">0</span>] + (<span class="string">' '</span> * (maxWidth - len(buffer[<span class="number">0</span>])))</span><br><span class="line">res.append(tmp)</span><br><span class="line">buffer = [word]</span><br><span class="line">count = len(word)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buffer:</span><br><span class="line">res.append(<span class="string">' '</span>.join(buffer))</span><br><span class="line">res[<span class="number">-1</span>] += (<span class="string">' '</span> * (maxWidth - len(res[<span class="number">-1</span>])))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/text-justification/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="LinkedIn" scheme="https://shineboy2013.github.com/tags/LinkedIn/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 005 Longest Palindromic Substring</title>
    <link href="https://shineboy2013.github.com/2021/12/19/lee-005/"/>
    <id>https://shineboy2013.github.com/2021/12/19/lee-005/</id>
    <published>2021-12-20T01:13:51.149Z</published>
    <updated>2021-12-20T01:23:20.633Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “babad”<br><strong>Output:</strong> “bab”<br><strong>Explanation:</strong> “aba” is also a valid answer.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “cbbd”<br><strong>Output:</strong> “bb”<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 1000</code></em>   <code>s</code> consist of only digits and English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>最长回文</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>遍历每个字符，以该字符为中心，往前后比较是否回文，求最长回文  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>回文字符串的中心位可以为1个或2个      </li><li>此题求最长回文字符串，而不是其长度  </li><li>避免死循环，记得i -= 1, j += 1  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">tmp = self.longestPalindromeFromCenter(s, i, i)</span><br><span class="line"><span class="keyword">if</span> len(tmp) &gt; len(res):</span><br><span class="line">res = tmp</span><br><span class="line"><span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s):</span><br><span class="line">tmp = self.longestPalindromeFromCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> len(tmp) &gt; len(res):</span><br><span class="line">res = tmp</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeFromCenter</span><span class="params">(self, s, i, j)</span>:</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt;= len(s) - <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">i -= <span class="number">1</span></span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> s[i + <span class="number">1</span>:j]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 815 Bus Routes</title>
    <link href="https://shineboy2013.github.com/2021/12/19/lee-815/"/>
    <id>https://shineboy2013.github.com/2021/12/19/lee-815/</id>
    <published>2021-12-19T19:00:18.183Z</published>
    <updated>2021-12-19T19:34:22.524Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/bus-routes/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an array <code>routes</code> representing bus routes where <code>routes[i]</code> is a bus route that the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> bus repeats forever.<br><br><em>   For example, if <code>routes[0] = [1, 5, 7]</code>, this means that the <code>0&lt;sup&gt;th&lt;/sup&gt;</code> bus travels in the sequence <code>1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; ...</code> forever.<br><br>You will start at the bus stop <code>source</code> (You are not on any bus initially), and you want to go to the bus stop <code>target</code>. You can travel between bus stops by buses only.<br><br>Return <em>the least number of buses you must take to travel from</em> <code>source</code> <em>to</em> <code>target</code>. Return <code>-1</code> if it is not possible.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> routes = [[1,2,7],[3,6,7]], source = 1, target = 6<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12<br><strong>Output:</strong> -1<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= routes.length &lt;= 500</code>.<br><em>   <code>1 &lt;= routes[i].length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   All the values of <code>routes[i]</code> are <strong>unique</strong>.<br><em>   <code>sum(routes[i].length) &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>0 &lt;= routes[i][j] &lt; 10&lt;sup&gt;6&lt;/sup&gt;</code><br>*   <code>0 &lt;= source, target &lt; 10&lt;sup&gt;6&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求公交路线中最小换站次数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最值题且涉及到图，容易想到BFS。但此题难点在于不能将每个站作为一个节点，这样代码复杂且TLE。优化的做法是将路线作为节点，因为同一路线换站次数是一样的。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>将整条路线作为图的节点</strong>。这些节点都位于同一层，换乘不同路线才会换到下一层，路径+1    </li><li>source和target所在的路线可能是多个，所以要将target所在的所有路线放在set中  </li><li><strong>邻接表计算是用两条路线是否有交集</strong>，有交集才能换乘，才能进入下一层访问，Python用set(a) &amp; set(b)  </li><li>如果target和source相等，返回0 (<strong>相等test case</strong>)  </li><li>站点不存在或者不存在任何路线，就返回-1</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination</span><span class="params">(self, routes: List[List[int]], source: int, target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> target == source: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">queue, targets, visited, distance = collections.deque(), set(), set(), collections.defaultdict(int)</span><br><span class="line">    route_dict = collections.defaultdict(list) <span class="comment"># both set or list are fine</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(routes)):</span><br><span class="line"><span class="keyword">if</span> source <span class="keyword">in</span> set(routes[i]):</span><br><span class="line">queue.append(i)</span><br><span class="line">visited.add(i)</span><br><span class="line">distance[i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> target <span class="keyword">in</span> set(routes[i]):</span><br><span class="line">targets.add(i)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(routes)):</span><br><span class="line"><span class="keyword">if</span> set(routes[i]) &amp; set(routes[j]):</span><br><span class="line">route_dict[i].add(j)</span><br><span class="line">route_dict[j].add(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> targets:</span><br><span class="line"><span class="keyword">return</span> distance[node]</span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> route_dict[node]:</span><br><span class="line"><span class="keyword">if</span> neighbor <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(neighbor)</span><br><span class="line">visited.add(neighbor)</span><br><span class="line">distance[neighbor] = distance[node] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure><p>TLE版本用station作为节点  </p><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination2</span><span class="params">(self, routes: List[List[int]], source: int, target: int)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> target == source: <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">graph, station_to_route = collections.defaultdict(list), collections.defaultdict(set)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">r = routes[j] + [routes[j][<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(r)):</span><br><span class="line"><span class="comment"># graph[r[i - 1]].append(r[i])</span></span><br><span class="line">station_to_route[r[i]].add(j)</span><br><span class="line"></span><br><span class="line">queue = collections.deque()</span><br><span class="line">visited = set()</span><br><span class="line">bus_num = collections.defaultdict(int)  <span class="comment"># remember collections.defaultdict(lambda: 1)</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> station_to_route[source]:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> routes[j]:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(i)</span><br><span class="line">visited.add(i)</span><br><span class="line">bus_num[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">node = queue.popleft()</span><br><span class="line"><span class="keyword">if</span> node == target:</span><br><span class="line"><span class="keyword">return</span> bus_num[node]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> station_to_route[node]:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> routes[j]:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">queue.append(i)</span><br><span class="line">visited.add(i)</span><br><span class="line">bus_num[i] = bus_num[node] + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># remember</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>&lt;code&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/code&gt;</code>, n = num of routes </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/bus-routes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You are
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Uber" scheme="https://shineboy2013.github.com/tags/Uber/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 809 Expressive Words</title>
    <link href="https://shineboy2013.github.com/2021/12/18/lee-809/"/>
    <id>https://shineboy2013.github.com/2021/12/18/lee-809/</id>
    <published>2021-12-18T08:25:24.764Z</published>
    <updated>2021-12-18T08:40:38.803Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/expressive-words/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Sometimes people repeat letters to represent extra feeling. For example:<br><br><em>   <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code></em>   <code>&quot;hi&quot; -&gt; &quot;hiiii&quot;</code><br><br>In these strings like <code>&quot;heeellooo&quot;</code>, we have groups of adjacent letters that are all the same: <code>&quot;h&quot;</code>, <code>&quot;eee&quot;</code>, <code>&quot;ll&quot;</code>, <code>&quot;ooo&quot;</code>.<br><br>You are given a string <code>s</code> and an array of query strings <code>words</code>. A query word is <strong>stretchy</strong> if it can be made to be equal to <code>s</code> by any number of applications of the following extension operation: choose a group consisting of characters <code>c</code>, and add some number of characters <code>c</code> to the group so that the size of the group is <strong>three or more</strong>.<br><br><em>   For example, starting with <code>&quot;hello&quot;</code>, we could do an extension on the group <code>&quot;o&quot;</code> to get <code>&quot;hellooo&quot;</code>, but we cannot get <code>&quot;helloo&quot;</code> since the group <code>&quot;oo&quot;</code> has a size less than three. Also, we could do another extension like <code>&quot;ll&quot; -&gt; &quot;lllll&quot;</code> to get <code>&quot;helllllooo&quot;</code>. If <code>s = &quot;helllllooo&quot;</code>, then the query word <code>&quot;hello&quot;</code> would be <strong>stretchy</strong> because of these two extension operations: <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>.<br><br>Return <em>the number of query strings that are <strong>stretchy</strong></em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “heeellooo”, words = [“hello”, “hi”, “helo”]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>We can extend “e” and “o” in the word “hello” to get “heeellooo”.<br>We can’t extend “helo” to get “heeellooo” because the group “ll” is not size 3 or more.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “zzzzzyyyyy”, words = [“zzyy”,”zy”,”zyy”]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= s.length, words.length &lt;= 100</code><br><em>   <code>1 &lt;= words[i].length &lt;= 100</code></em>   <code>s</code> and <code>words[i]</code> consist of lowercase letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Cisco常考题<br>定义了一种富于表现力的单词，就是说某个字母可以重复三次或以上，叫stretchy<br>找给定的单词列表中的单词可以成为stretchy单词的个数  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>统计每个字符的个数，然后比较对应每个字符个数 </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Line 13的条件，若个数不等，word的字符个数大于stretchy的字符个数(word不能删除字符)，或者stretchy的个数小于3，就不满足    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, s: str, words: List[str])</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">s_count = self.get_count(s)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">char_count = self.get_count(word)</span><br><span class="line"><span class="keyword">if</span> len(char_count) != len(s_count):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s_count)):</span><br><span class="line">char_s, count_s = s_count[i]</span><br><span class="line">char_w, count_w = char_count[i]</span><br><span class="line"><span class="keyword">if</span> char_w != char_s:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> count_s != count_w <span class="keyword">and</span> (count_w &gt; count_s <span class="keyword">or</span> count_s &lt; <span class="number">3</span>): <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == len(s_count) - <span class="number">1</span>:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_count</span><span class="params">(self, s)</span>:</span></span><br><span class="line">s += <span class="string">' '</span></span><br><span class="line">s_count, count = [], <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line"><span class="keyword">if</span> s[i] != s[i - <span class="number">1</span>]:</span><br><span class="line">s_count.append((s[i - <span class="number">1</span>], count))</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> s_count</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/expressive-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;S
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 829 Consecutive Numbers Sum</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-829/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-829/</id>
    <published>2021-12-17T03:46:42.282Z</published>
    <updated>2021-12-17T04:46:22.326Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/consecutive-numbers-sum/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an integer <code>n</code>, return <em>the number of ways you can write</em> <code>n</code> <em>as the sum of consecutive positive integers.</em><br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> n = 5<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> 5 = 2 + 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 9<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> 9 = 4 + 5 = 2 + 3 + 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 15<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5<br></pre><br><br><strong>Constraints:</strong><br><br>*   <code>1 &lt;= n &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求连续整数的和等于N的个数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>只有Fintech考，数学题。思路见注释  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x, x+1, ... , x+k-1</span></span><br><span class="line"><span class="comment"># (x + x+k-1) * k / 2 = 2x+k-1) = n, x = [n - k(k-1)/2]/k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(<span class="number">2</span> * n) + <span class="number">1</span>)):</span><br><span class="line"><span class="keyword">if</span> (n - i * (i - <span class="number">1</span>) / <span class="number">2</span>) % i == <span class="number">0</span>:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/consecutive-numbers-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 041 First Missing Positive</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-041/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-041/</id>
    <published>2021-12-17T03:38:45.498Z</published>
    <updated>2021-12-17T03:47:45.279Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.<br><br>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [1,2,0]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,4,-1,1]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> nums = [7,8,9,11,12]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   `1 &lt;= nums.length &lt;= 5 </em> 10<sup>5</sup><code>*</code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1`<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找第一个缺失的正整数</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于quick sort里面的partition，满足某些条件才移动指针  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>第一个正确元素为1，所以预期数组为[1, 2, 3…]，从1开始并不是从0开始。  </li><li>交换元素的条件：需要交换nums[i] != i + 1, 可以交换[1 &lt;= nums[i] &lt;= len(nums)], 不会死循环(nums[nums[i] - 1] != nums[i])    </li><li>若满足条件，无限交换，直到不满足条件。不满足条件才移动遍历指针i</li><li>交换两元素涉及内嵌数组，所以不能用comment上的。  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line"><span class="keyword">if</span> nums[i] != i + <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line"><span class="comment"># nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]</span></span><br><span class="line">self.swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt;= len(nums):</span><br><span class="line"><span class="keyword">if</span> j != nums[j - <span class="number">1</span>]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 588 Design In-Memory File System</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-588/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-588/</id>
    <published>2021-12-16T22:55:02.876Z</published>
    <updated>2021-12-16T23:59:42.644Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/design-in-memory-file-system/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计文件系统 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>如数据库系统的B+树一样，用Trie</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>TrieNode含children和files，都是dict，<strong>只能是目录节点</strong>。因为不知道最后一个路劲部分是文件还是目录，所以ls里面需要遍历直到倒数第二个节点，再判断是哪种情况。另一个种设计是采取is_file, content，既可以是目录节点也可以是文件节点，本文采取前者     </li><li>ls:题目要求目录可以含目录和文件。两种情况：若是文件，返回[文件]含在一个list中；若是目录，返回它下面的目录+文件  </li><li>ls:返回结果要排序  </li><li>ls:输入path可以是/或/a/b，所以/要特殊化处理，只能是目录，所以只有一种情况：目录和文件    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ls</span><span class="params">(self, path: str)</span> -&gt; List[str]:</span>  <span class="comment"># req remember /a not /a/</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted(list(self.root.children.keys()) + list(self.root.files.keys())) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">        dirs = path[<span class="number">1</span>:].split(<span class="string">'/'</span>)</span><br><span class="line">        it = self.ls_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dirs[<span class="number">-1</span>] <span class="keyword">in</span> it.files:</span><br><span class="line">            <span class="keyword">return</span> [dirs[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># return files if no dir, no mixed types in same dir</span></span><br><span class="line">            <span class="keyword">return</span> sorted(list(it.children[dirs[<span class="number">-1</span>]].children.keys()) + list(it.children[dirs[<span class="number">-1</span>]].files.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(self, path: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        path = path[<span class="number">1</span>:]</span><br><span class="line">        dirs = path.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        self.mkdir_internal(dirs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addContentToFile</span><span class="params">(self, filePath: str, content: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>) <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self.mkdir_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        filename = dirs[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">not</span> <span class="keyword">in</span> it.files:</span><br><span class="line">            it.files[filename] = <span class="string">''</span></span><br><span class="line">        it.files[filename] += content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readContentFromFile</span><span class="params">(self, filePath: str)</span> -&gt; str:</span></span><br><span class="line">        filePath = filePath[<span class="number">1</span>:]</span><br><span class="line">        dirs = filePath.split(<span class="string">'/'</span>)  <span class="comment"># [a,b,c]</span></span><br><span class="line">        it = self.ls_internal(dirs[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> it.files[dirs[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ls_internal</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">            it = it.children[dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mkdir_internal</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        it = self.root</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">            <span class="keyword">if</span> dir <span class="keyword">not</span> <span class="keyword">in</span> it.children: <span class="comment"># a</span></span><br><span class="line">                it.children[dir] = TrieNode() <span class="comment">#</span></span><br><span class="line">            it = it.children[dir]</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.files = collections.defaultdict(str) <span class="comment"># use dict coz filename can't be duplicate and faster for lookup</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>, n为路径长度  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/design-in-memory-file-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Trie" scheme="https://shineboy2013.github.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1041 Robot Bounded In Circle</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-1041/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-1041/</id>
    <published>2021-12-16T20:37:05.135Z</published>
    <updated>2021-12-16T20:41:07.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/robot-bounded-in-circle/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>On an infinite plane, a robot initially stands at <code>(0, 0)</code> and faces north. The robot can receive one of three instructions:<br><br><em>   <code>&quot;G&quot;</code>: go straight 1 unit;</em>   <code>&quot;L&quot;</code>: turn 90 degrees to the left;<br><em>   <code>&quot;R&quot;</code>: turn 90 degrees to the right.<br><br>The robot performs the <code>instructions</code> given in order, and repeats them forever.<br><br>Return <code>true</code> if and only if there exists a circle in the plane such that the robot never leaves the circle.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> instructions = “GGLLGG”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).<br>When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.</pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> instructions = “GG”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The robot moves north indefinitely.</pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> instructions = “GL”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; …</pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= instructions.length &lt;= 100</code><br>*   <code>instructions[i]</code> is <code>&#39;G&#39;</code>, <code>&#39;L&#39;</code> or, <code>&#39;R&#39;</code>.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>循环按模式走是否回到原点  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>数学题，很难证明。定理是，只要按照给定模式走完，若回到原点或最后方向不是向北，都能回到原点  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li></li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isRobotBounded</span><span class="params">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class="line">DIRECTION_CONVERT_LEFT = &#123;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">DIRECTION_CONVERT_RIGHT = &#123;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>): (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">(<span class="number">0</span>, <span class="number">-1</span>): (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="number">-1</span>, <span class="number">0</span>): (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">path, direction, position = instructions, (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> path:</span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'L'</span>:</span><br><span class="line">direction = DIRECTION_CONVERT_LEFT[direction]</span><br><span class="line"><span class="keyword">elif</span> char == <span class="string">'R'</span>:</span><br><span class="line">direction = DIRECTION_CONVERT_RIGHT[direction]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">position = (position[<span class="number">0</span>] + direction[<span class="number">0</span>], position[<span class="number">1</span>] + direction[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> position == (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">or</span> direction != (<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/robot-bounded-in-circle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Math" scheme="https://shineboy2013.github.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 680 Valid Palindrome II</title>
    <link href="https://shineboy2013.github.com/2021/12/16/lee-680/"/>
    <id>https://shineboy2013.github.com/2021/12/16/lee-680/</id>
    <published>2021-12-16T08:58:10.905Z</published>
    <updated>2021-12-20T01:22:09.738Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given a string <code>s</code>, return <code>true</code> <em>if the</em> <code>s</code> <em>can be palindrome after deleting <strong>at most one</strong> character from it</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “aba”<br><strong>Output:</strong> true<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “abca”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> You could delete the character ‘c’.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “abc”<br><strong>Output:</strong> false<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>s</code> consists of lowercase English letters.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>删除一个字符变成回文字符串 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>暴力法是O(n^2)，要优化到O(n)且这是关于元素之间的关系，考虑用Two pointers</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>当发现不相等的字符，不能简单认为s[i + 1] == s[j]就觉得应该删除左边字符，因为可能是刚好相等，如bddbd，第一个b和倒数第二个b相等，如果删除第一个b，就会得到False，所以应该<strong>删除左边字符和删除右边字符同时都要试</strong>    </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; j:</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line"><span class="keyword">if</span> self.is_palindrome(s[i + <span class="number">1</span>:j + <span class="number">1</span>]) <span class="keyword">or</span> self.is_palindrome(s[i:j]):</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-palindrome-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Facebook" scheme="https://shineboy2013.github.com/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 811 Subdomain Visit Count</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-811/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-811/</id>
    <published>2021-12-16T07:29:39.870Z</published>
    <updated>2021-12-16T07:34:12.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subdomain-visit-count/" target="_blank" rel="noopener">LeetCode</a></strong></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>统计domain个数  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>N/A    </p><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">domain_to_count = collections.defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> pair_str <span class="keyword">in</span> cpdomains:</span><br><span class="line">pair = pair_str.split(<span class="string">' '</span>)</span><br><span class="line">count = int(pair[<span class="number">0</span>])</span><br><span class="line">domain = pair[<span class="number">1</span>]</span><br><span class="line">domain_to_count[domain] += count</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> domain.find(<span class="string">'.'</span>, pos) &gt;= <span class="number">0</span>:</span><br><span class="line">domain = domain[domain.index(<span class="string">'.'</span>, pos) + <span class="number">1</span>:]</span><br><span class="line">domain_to_count[domain] += count</span><br><span class="line"><span class="keyword">return</span> [<span class="string">'&#123;&#125; &#123;&#125;'</span>.format(_count, _domain) <span class="keyword">for</span> _domain, _count <span class="keyword">in</span> domain_to_count.items()]</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subdomain-visit-count/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;题
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1326 Minimum Number of Taps to Open to Water a Garden</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-1326/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-1326/</id>
    <published>2021-12-16T05:18:45.763Z</published>
    <updated>2021-12-16T07:00:25.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>There is a one-dimensional garden on the x-axis. The garden starts at the point <code>0</code> and ends at the point <code>n</code>. (i.e The length of the garden is <code>n</code>).<br><br>There are <code>n + 1</code> taps located at points <code>[0, 1, ..., n]</code> in the garden.<br><br>Given an integer <code>n</code> and an integer array <code>ranges</code> of length <code>n + 1</code> where <code>ranges[i]</code> (0-indexed) means the <code>i-th</code> tap can water the area <code>[i - ranges[i], i + ranges[i]]</code> if it was open.<br><br>Return <em>the minimum number of taps</em> that should be open to water the whole garden, If the garden cannot be watered return <strong>-1</strong>.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png" alt=""><br><br><pre><strong>Input:</strong> n = 5, ranges = [3,4,1,1,0,0]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong> The tap at point 0 can cover the interval [-3,3]<br>The tap at point 1 can cover the interval [-3,5]<br>The tap at point 2 can cover the interval [1,3]<br>The tap at point 3 can cover the interval [2,4]<br>The tap at point 4 can cover the interval [4,4]<br>The tap at point 5 can cover the interval [5,5]<br>Opening Only the second tap will water the whole garden [0,5]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> n = 3, ranges = [0,0,0,0]<br><strong>Output:</strong> -1<br><strong>Explanation:</strong> Even if you activate all the four taps you cannot water the whole garden.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> n = 7, ranges = [1,2,1,0,2,1,0,1]<br><strong>Output:</strong> 3<br></pre><br><br><strong>Example 4:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 5:</strong><br><br><pre><strong>Input:</strong> n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br><strong>Output:</strong> 1<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>ranges.length == n + 1</code><br>*   <code>0 &lt;= ranges[i] &lt;= 100</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>用多少个水龙头覆盖整个花园</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>两个难点，此题类似于jump game，这一层某个水龙头浇到最远点的水龙头也就是这一层的水龙头，这是难点一。<br>难点二是跟jump game不同，这题可以往前跳，也就是如例子中，点2表示从1跳到3，因为它的范围是1. 所以要重新计算每个水龙头的起点=它的左半范围起点  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>第一步转化成jump game，jump game每个数值都是长度。若左半范围起点小于等于0，所有这些水龙头归结到起点0，长度为i + ranges[i], 其余情况是ranges[i] * 2    </li><li>完全用jump game的程序</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTaps</span><span class="params">(self, n: int, ranges: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">nums = [<span class="number">0</span>] * len(ranges)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ranges)):</span><br><span class="line"><span class="keyword">if</span> i - ranges[i] &lt;= <span class="number">0</span>:</span><br><span class="line">nums[<span class="number">0</span>] = max(nums[<span class="number">0</span>], ranges[i] + i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums[i - ranges[i]] = max(nums[i - ranges[i]], ranges[i] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>): <span class="comment"># remember</span></span><br><span class="line"><span class="keyword">if</span> i &lt;= end:  <span class="comment"># -3 &lt;= 0</span></span><br><span class="line">next_end = max(next_end, i + nums[i])  <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">if</span> i == end:</span><br><span class="line">end = next_end</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">if</span> next_end &gt;= len(nums) - <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 055 Jump Game</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-055/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-055/</id>
    <published>2021-12-16T03:20:34.603Z</published>
    <updated>2021-12-16T03:24:50.078Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.<br><br>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [3,2,1,0,4]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>0 &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>参考Jump game II，区别在于如果i &lt;= end才更新，</li><li>返回next_end要大于等于(可以cover)最后一个元素下标  </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">end, next_end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line"><span class="keyword">return</span> next_end &gt;= len(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;You are 
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 045 Jump Game II</title>
    <link href="https://shineboy2013.github.com/2021/12/15/lee-045/"/>
    <id>https://shineboy2013.github.com/2021/12/15/lee-045/</id>
    <published>2021-12-16T02:50:08.907Z</published>
    <updated>2021-12-16T03:21:49.294Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>Given an array of non-negative integers <code>nums</code>, you are initially positioned at the first index of the array.<br><br>Each element in the array represents your maximum jump length at that position.<br><br>Your goal is to reach the last index in the minimum number of jumps.<br><br>You can assume that you can always reach the last index.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,1,1,4]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> nums = [2,3,0,1,4]<br><strong>Output:</strong> 2<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></em>   <code>0 &lt;= nums[i] &lt;= 1000</code><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>N/A</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS，但不需要用queue</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>end, next_end分别表示该层和下一层的边界，end从0开始，表示第0个数是第一层，遍历每个数，从0开始。   </li><li>这个<strong>边界是inclusive的</strong>，所以当i==end时候，不应该res加1，是下一轮循环才是下一层的开始。有两种实现，我的实现是第一种，标准答案是遍历到最后一个数的前一个，因为最后一个数已经是目标，所以不需要计算next_end，更不需要层数+1。</li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump2</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">update_end = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">if</span> update_end:</span><br><span class="line">res += <span class="number">1</span></span><br><span class="line">update_end = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line">update_end = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">end, next_end, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i &lt;= end:</span><br><span class="line">next_end = max(next_end, i + nums[i]) <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">if</span> i == end: <span class="comment">#</span></span><br><span class="line">end = next_end <span class="comment"># 8</span></span><br><span class="line">res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;br&gt;&lt;br&gt;Given
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 528 Random Pick with Weight</title>
    <link href="https://shineboy2013.github.com/2021/12/14/lee-528/"/>
    <id>https://shineboy2013.github.com/2021/12/14/lee-528/</id>
    <published>2021-12-15T06:22:38.057Z</published>
    <updated>2021-12-15T06:32:42.680Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">LeetCode</a></strong></p><div><br><br>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> index.<br><br>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.<br><br><em>   For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”]<br>[[[1]],[]]<br><strong>Output</strong><br>[null,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1]);<br>solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input</strong><br>[“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”]<br>[[[1,3]],[],[],[],[],[]]<br><strong>Output</strong><br>[null,1,1,1,1,0]<br><br><strong>Explanation</strong><br>Solution solution = new Solution([1, 3]);<br>solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 1<br>solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.<br><br>Since this is a randomization problem, multiple answers are allowed.<br>All of the following outputs can be considered correct:<br>[null,1,1,1,1,0]<br>[null,1,1,1,1,1]<br>[null,1,1,1,0,0]<br>[null,1,1,1,0,1]<br>[null,1,0,1,0,0]<br>……<br>and so on.<br></pre><br><br><strong>Constraints:</strong></em>   <code>1 &lt;= w.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code><br><em>   <code>1 &lt;= w[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></em>   <code>pickIndex</code> will be called at most <code>10&lt;sup&gt;4&lt;/sup&gt;</code> times.<br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>根据数组每个元素的weight来决定其出现的概率： weight/sum of weight  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>模拟运算过程，先求和，然后根据上述公式分配概率： 如[1, 3], 小于0.25属于第一个元素，大于属于后一个元素，我们不用小数，还原回整数<br>所以数值小于1属于第一个元素，大于1小于4属于后一个，想到用presum，然后在presum搜索某个value，就想到二分法。  </p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>random.randint前闭后闭      </li></ol><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, w: List[int])</span>:</span></span><br><span class="line">        self.presum = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> w:</span><br><span class="line">            sum += n</span><br><span class="line">            self.presum.append(sum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        rand_value = random.randint(<span class="number">0</span>, self.presum[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect(self.presum, rand_value)</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1ogn)</code>，空间复杂度<code>O(n)</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/random-pick-with-weight/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Randomized" scheme="https://shineboy2013.github.com/tags/Randomized/"/>
    
  </entry>
  
</feed>
