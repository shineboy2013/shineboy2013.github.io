<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-2034-stock-price-fluctuation/">LeetCode 2034 Stock Price Fluctuation</a></h1>
  

      
        <time datetime="2022-02-17T04:00:04.962Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/stock-price-fluctuation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a stream of <strong>records</strong> about a particular stock. Each record contains a <strong>timestamp</strong> and the corresponding <strong>price</strong> of the stock at that timestamp.<br><br>Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream <strong>correcting</strong> the price of the previous wrong record.<br><br>Design an algorithm that:<br><br><em>   <strong>Updates</strong> the price of the stock at a particular timestamp, <strong>correcting</strong> the price from any previous records at the timestamp.
</em>   Finds the <strong>latest price</strong> of the stock based on the current records. The <strong>latest price</strong> is the price at the latest timestamp recorded.<br><em>   Finds the <strong>maximum price</strong> the stock has been based on the current records.
</em>   Finds the <strong>minimum price</strong> the stock has been based on the current records.<br><br>Implement the <code>StockPrice</code> class:<br><br><em>   <code>StockPrice()</code> Initializes the object with no price records.
</em>   <code>void update(int timestamp, int price)</code> Updates the <code>price</code> of the stock at the given <code>timestamp</code>.<br><em>   <code>int current()</code> Returns the <strong>latest price</strong> of the stock.
</em>   <code>int maximum()</code> Returns the <strong>maximum price</strong> of the stock.<br><em>   <code>int minimum()</code> Returns the <strong>minimum price</strong> of the stock.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“StockPrice”, “update”, “update”, “current”, “maximum”, “update”, “maximum”, “update”, “minimum”]<br>[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]<br><strong>Output</strong><br>[null, null, null, 5, 10, null, 5, null, 2]<br><br><strong>Explanation</strong><br>StockPrice stockPrice = new StockPrice();<br>stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].<br>stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].<br>stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.<br>stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.<br>stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.<br>                          // Timestamps are [1,2] with corresponding prices [3,5].<br>stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.<br>stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].<br>stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= timestamp, price &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made <strong>in total</strong> to <code>update</code>, <code>current</code>, <code>maximum</code>, and <code>minimum</code>.
</em>   <code>current</code>, <code>maximum</code>, and <code>minimum</code> will be called <strong>only after</strong> <code>update</code> has been called <strong>at least once</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现一个关于股票的数据结构，可以更新时间点对应的股价，最大最小值，最新价格</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最大最小值容易想到用heap，但heap不支持更新，难点是怎么支持更新股价。<br>仍然(price, timestamp)加入到heap中，在出堆时验证</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>验证堆顶： 若股价和时间不匹配(用time_to_price验证)，表示这是stale股价，不断去掉，直到验证成功为止，最后加入到堆中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.time_to_price = &#123;&#125;</span><br><span class="line">        self.cur_time = <span class="number">0</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, timestamp: int, price: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.time_to_price[timestamp] = price</span><br><span class="line">        self.cur_time = max(self.cur_time, timestamp)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        heapq.heappush(self.max_heap, (-price, timestamp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.time_to_price[self.cur_time]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        <span class="keyword">while</span> -price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.max_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> -price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        <span class="keyword">while</span> price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> price</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>update时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/">LeetCode 2128 Remove All Ones With Row and Column Flips</a></h1>
  

      
        <time datetime="2022-02-17T03:23:00.458Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> binary matrix <code>grid</code>.<br><br>In one operation, you can choose <strong>any</strong> row or column and flip each value in that row or column (i.e., changing all <code>0</code>‘s to <code>1</code>‘s, and all <code>1</code>‘s to <code>0</code>‘s).<br><br>Return <code>true</code> <em>if it is possible to remove all</em> <code>1</code><em>‘s from</em> <code>grid</code> using <strong>any</strong> number of operations or <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103191300-1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way to remove all 1’s from grid is to:<br>- Flip the middle row<br>- Flip the middle column<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181204-7.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,0],[0,0,0],[0,0,0]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> It is impossible to remove all 1’s from grid.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181224-8.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are no 1’s in grid.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code>
</em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个矩阵，每次可以flip一行或一列，求是否可以令矩阵变成全0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从例子找规律，<br>010和010属于一种类型<br>010和101也是同一种，每一行必须符合任何一种类型才是解</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	row_patten, row_pattern_invert = grid[<span class="number">0</span>], [<span class="number">1</span> - n <span class="keyword">for</span> n <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line">		<span class="keyword">if</span> grid[i] != row_patten <span class="keyword">and</span> grid[i] != row_pattern_invert:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-843-guess-the-word/">LeetCode 843 Guess the Word</a></h1>
  

      
        <time datetime="2022-02-17T02:54:15.165Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>This is an <strong><em>interactive problem</em></strong>.<br><br>You are given an array of <strong>unique</strong> strings <code>wordlist</code> where <code>wordlist[i]</code> is <code>6</code> letters long, and one word in this list is chosen as <code>secret</code>.<br><br>You may call <code>Master.guess(word)</code> to guess a word. The guessed word should have type <code>string</code> and must be from the original list with <code>6</code> lowercase letters.<br><br>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <code>secret</code> word. Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.<br><br>For each test case, you have exactly <code>10</code> guesses to guess the word. At the end of any number of calls, if you have made <code>10</code> or fewer calls to <code>Master.guess</code> and at least one of these guesses was <code>secret</code>, then you pass the test case.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br><strong>Explanation:</strong><br>master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>We made 5 calls to master.guess and one of them was the secret, so we pass the test case.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> secret = “hamada”, wordlist = [“hamada”,”khaled”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= wordlist.length &lt;= 100</code>
</em>   <code>wordlist[i].length == 6</code><br><em>   <code>wordlist[i]</code> consist of lowercase English letters.
</em>   All the strings of <code>wordlist</code> are <strong>unique</strong>.<br><em>   <code>secret</code> exists in <code>wordlist</code>.
</em>   <code>numguesses == 10</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定单词列表，每个单词长度为6， 其中一个为答案，每次猜一个单词。给一个API会告诉你猜的单词有多少位命中(位置,数值), 求是否可以10次内猜对</p>
<h3 id="暴力法解题思路："><a href="#暴力法解题思路：" class="headerlink" title="暴力法解题思路："></a><strong>暴力法解题思路：</strong></h3><p>较直观的解法是抽第一个单词出来，然后call API, 然后再filter wordlist使得新的单词列表里的单词的命中位数也是一样的。每轮缩少范围。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord2</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		guess = wordlist[<span class="number">0</span>]</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="统计频率算法II解题思路-推荐-："><a href="#统计频率算法II解题思路-推荐-：" class="headerlink" title="统计频率算法II解题思路(推荐)："></a><strong>统计频率算法II解题思路(推荐)：</strong></h3><p>上述方法跟单词个数有关，如果很多的话，就会超过10次。考虑单词长度为6，而可以猜10次。考虑用26字母存储法，也就是统计频率。统计每位的频率，然后将频率作为这一位的分数，求每个单词的总分。<br>一定要选择单词列表中的某个单词去猜，如果不在列表中返回为-1，这个信息没有任何作用。<br>选择总分最高的去猜，原理是它最具代表性，这样可以快速排除很多单词，有点类似于二分法。反之，若用频率低的单词，也就只能排除一个单词。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		char_to_count = [collections.Counter(w[i] <span class="keyword">for</span> w <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">		guess = max(wordlist, key=<span class="keyword">lambda</span> w: sum(char_to_count[i][char] <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(w)))</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-833-find-and-replace-in-string/">LeetCode 833 Find And Replace in String</a></h1>
  

      
        <time datetime="2022-02-16T23:28:45.137Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/find-and-replace-in-string/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a <strong>0-indexed</strong> string <code>s</code> that you must perform <code>k</code> replacement operations on. The replacement operations are given as three <strong>0-indexed</strong> parallel arrays, <code>indices</code>, <code>sources</code>, and <code>targets</code>, all of length <code>k</code>.<br><br>To complete the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> replacement operation:<br><br>1.  Check if the <strong>substring</strong> <code>sources[i]</code> occurs at index <code>indices[i]</code> in the <strong>original string</strong> <code>s</code>.<br>2.  If it does not occur, <strong>do nothing</strong>.<br>3.  Otherwise if it does occur, <strong>replace</strong> that substring with <code>targets[i]</code>.<br><br>For example, if <code>s = &quot;&lt;u&gt;ab&lt;/u&gt;cd&quot;</code>, <code>indices[i] = 0</code>, <code>sources[i] = &quot;ab&quot;</code>, and <code>targets[i] = &quot;eee&quot;</code>, then the result of this replacement will be <code>&quot;&lt;u&gt;eee&lt;/u&gt;cd&quot;</code>.<br><br>All replacement operations must occur <strong>simultaneously</strong>, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will <strong>not overlap</strong>.<br><br><em>   For example, a testcase with <code>s = &quot;abc&quot;</code>, <code>indices = [0, 1]</code>, and <code>sources = [&quot;ab&quot;,&quot;bc&quot;]</code> will not be generated because the <code>&quot;ab&quot;</code> and <code>&quot;bc&quot;</code> replacements overlap.<br><br>Return <em>the <strong>resulting string</strong> after performing all replacement operations on</em> <code>s</code>.<br><br>A <strong>substring</strong> is a contiguous sequence of characters in a string.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“a”, “cd”], targets = [“eee”, “ffff”]<br><strong>Output:</strong> “eeebffff”<br><strong>Explanation:</strong><br>“a” occurs at index 0 in s, so we replace it with “eee”.<br>“cd” occurs at index 2 in s, so we replace it with “ffff”.<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png" alt=""><br><br><pre><strong>Input:</strong> s = “abcd”, indices = [0, 2], sources = [“ab”,”ec”], targets = [“eee”,”ffff”]<br><strong>Output:</strong> “eeecd”<br><strong>Explanation:</strong><br>“ab” occurs at index 0 in s, so we replace it with “eee”.<br>“ec” does not occur at index 2 in s, so we do nothing.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= s.length &lt;= 1000</code><br><em>   <code>k == indices.length == sources.length == targets.length</code>
</em>   <code>1 &lt;= k &lt;= 100</code><br><em>   <code>0 &lt;= indexes[i] &lt; s.length</code>
</em>   <code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code><br><em>   <code>s</code> consists of only lowercase English letters.
</em>   <code>sources[i]</code> and <code>targets[i]</code> consist of only lowercase English letters.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>整洁题。找到位置，然后验证，最后替换</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>N/A</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>i是循环外的变量，所以poplate index_dict注意不能重名</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, s: str, indices: List[int], sources: List[str], targets: List[str])</span> -&gt; str:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">	index_dict = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _i, _n <span class="keyword">in</span> enumerate(indices):</span><br><span class="line">		index_dict[_n] = _i <span class="comment"># 0 -&gt; 0, 2 -&gt; 1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">		<span class="keyword">if</span> i <span class="keyword">in</span> index_dict <span class="keyword">and</span> s[i:i + len(sources[index_dict[i]])] == sources[index_dict[i]]:</span><br><span class="line">			res += targets[index_dict[i]]</span><br><span class="line">			i += len(sources[index_dict[i]])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res += s[i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/">LeetCode 2007 Find Original Array From Doubled Array</a></h1>
  

      
        <time datetime="2022-02-16T20:54:39.600Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/find-original-array-from-doubled-array/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>An integer array <code>original</code> is transformed into a <strong>doubled</strong> array <code>changed</code> by appending <strong>twice the value</strong> of every element in <code>original</code>, and then randomly <strong>shuffling</strong> the resulting array.<br><br>Given an array <code>changed</code>, return <code>original</code> <em>if</em> <code>changed</code> <em>is a <strong>doubled</strong> array. If</em> <code>changed</code> <em>is not a <strong>doubled</strong> array, return an empty array. The elements in</em> <code>original</code> <em>may be returned in <strong>any</strong> order</em>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> changed = [1,3,4,2,6,8]<br><strong>Output:</strong> [1,3,4]<br><strong>Explanation:</strong> One possible original array could be [1,3,4]:<br>- Twice the value of 1 is 1 <em> 2 = 2.<br>- Twice the value of 3 is 3 </em> 2 = 6.<br>- Twice the value of 4 is 4 <em> 2 = 8.<br>Other original arrays could be [4,3,1] or [3,1,4].<br></em></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> changed = [6,3,0,1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> changed = [1]<br><strong>Output:</strong> []<br><strong>Explanation:</strong> changed is not a doubled array.<br></pre><br><br><strong>Constraints:</strong>

   <code>1 &lt;= changed.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br>*   <code>0 &lt;= changed[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，求这个数组是否可以分成两部分，后一部分的每个元素是否前一部分某元素的两倍</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>由最大值容易确定它的一半是否在数组中。所以排序后由大到小遍历。注意数组元素可能相等，所以不能用visited set来记录已用过的数，val_to_index也不支持重复，只有val_to_count支持</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>用val_to_count，注意遍历时候就要减去，不要进入if才减去</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOriginalArray</span><span class="params">(self, changed: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">	<span class="keyword">if</span> len(changed) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	changed.sort()</span><br><span class="line">	res = []</span><br><span class="line">	val_to_count = collections.Counter(changed)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(changed))):</span><br><span class="line">		<span class="keyword">if</span> val_to_count[changed[i]] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		val_to_count[changed[i]] -= <span class="number">1</span> <span class="comment"># not in  if statement</span></span><br><span class="line">		<span class="keyword">if</span> changed[i] / <span class="number">2</span> <span class="keyword">in</span> val_to_count <span class="keyword">and</span> val_to_count[changed[i] / <span class="number">2</span>] &gt; <span class="number">0</span>:</span><br><span class="line">			val_to_count[changed[i] / <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">			res.append(int(changed[i] / <span class="number">2</span>))</span><br><span class="line">	<span class="keyword">return</span> [] <span class="keyword">if</span> len(res) * <span class="number">2</span> != len(changed) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/02/16/leetcode-2034-stock-price-fluctuation/">LeetCode 2034 Stock Price Fluctuation</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/">LeetCode 2128 Remove All Ones With Row and Column Flips</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-843-guess-the-word/">LeetCode 843 Guess the Word</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-833-find-and-replace-in-string/">LeetCode 833 Find And Replace in String</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-2007-find-original-array-from-doubled-array/">LeetCode 2007 Find Original Array From Doubled Array</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.17px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 14.17px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.08px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.75px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.42px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.42px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.92px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.83px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.33px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.25px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.25px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 14.17px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.58px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.17px;">Facebook</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 13.33px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.08px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 14.17px;">Heap</a> <a href="/tags/Interactive/" style="font-size: 10px;">Interactive</a> <a href="/tags/Interviewer/" style="font-size: 13.33px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.25px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 12.5px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 16.67px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.42px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.5px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.33px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.83px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.25px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.83px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 12.08px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 15.83px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.83px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.42px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 11.67px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.42px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.5px;">Stack</a> <a href="/tags/String/" style="font-size: 18.75px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.25px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.25px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.67px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.58px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.42px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.42px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

