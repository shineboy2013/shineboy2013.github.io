<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>KK&#39;s blog</title>
  <meta name="author" content="KK Shum">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="KK&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="KK&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header"><div class="meta inner">
  <h1><a href="/">KK&#39;s blog</a></h1>
  <h2><a href="/">每天积累多一些</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>

	<script data-ad-client="ca-pub-3350210696528821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/03/01/leetcode-772-basic-calculator-iii/">LeetCode 772 Basic Calculator III</a></h1>
  

      
        <time datetime="2022-03-02T06:31:18.494Z">2022-03-01</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/basic-calculator-iii/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Implement a basic calculator to evaluate a simple expression string.<br><br>The expression string contains only non-negative integers, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code> operators, and open <code>&#39;(&#39;</code> and closing parentheses <code>&#39;)&#39;</code>. The integer division should <strong>truncate toward zero</strong>.<br><br>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt; - 1]</code>.<br><br><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> s = “1+1”<br><strong>Output:</strong> 2<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> s = “6-4/2”<br><strong>Output:</strong> 4<br></pre><br><br><strong>Example 3:</strong><br><br><pre><strong>Input:</strong> s = “2<em>(5+5</em>2)/3+(6/2+8)”<br><strong>Output:</strong> 21<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= s &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code>
</em>   <code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.<br><em>   <code>s</code> is a <em>*valid</em></em> expression.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现字符串加减乘除且有括号。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于Leetcode 227求加减乘除，这里多了括号，括号内含加减乘除，所以每对括号是一轮DFS。遇到左括号，就进入递归，遇到右括号就返回递归值</p>
<p><a href="https://shineboy2013.github.io/2021/12/08/lee-224/" target="_blank" rel="noopener">LeetCode 224 Basic Calculator</a> 括号加减法, 同一层括号内求和遇括号入栈<br><a href="https://shineboy2013.github.io/2021/12/06/lee-227/" target="_blank" rel="noopener">LeetCode 227 Basic Calculator II</a> 加减乘除, 和的每一项入栈，方便出栈计乘除<br><a href="https://shineboy2013.github.io/2022/03/01/leetcode-772-basic-calculator-iii/" target="_blank" rel="noopener">LeetCode 772 Basic Calculator III</a> 加减乘除括号, L227的递归版</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>不同于L227, 类似于填位法将i作为DFS参数传入，返回括号内的值以及i。i放入while循环， i += 1要加入到空格情况和循环最后</li>
<li>最后位加入加号要移除DFS中，放入主函数</li>
<li><strong>注意处理括号情况的顺序，左括号在空格后，右括号在最后</strong></li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">	s += <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">return</span> self.dfs(s, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, i)</span>:</span></span><br><span class="line">	res, num, stack, op = <span class="number">0</span>, <span class="number">0</span>, [], <span class="string">'+'</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">		char = s[i]</span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">			num, i = self.dfs(s, i + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">elif</span> char.isdigit():</span><br><span class="line">			num = num * <span class="number">10</span> + int(char)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">			stack.append(-num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'+'</span>:</span><br><span class="line">			stack.append(num) <span class="comment"># [4+2*1]</span></span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(prev * num)</span><br><span class="line">		<span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">			prev = stack.pop()</span><br><span class="line">			stack.append(int(prev / num))  <span class="comment"># remember</span></span><br><span class="line">		<span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">			num = <span class="number">0</span></span><br><span class="line">			op = char</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> char == <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">return</span> sum(stack), i</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/24/leetcode-432-all-oone-data-structure/">LeetCode 432 All O one Data Structure</a></h1>
  

      
        <time datetime="2022-02-24T09:36:23.632Z">2022-02-24</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>Design a data structure to store the strings’ count with the ability to return the strings with minimum and maximum counts.<br><br>Implement the <code>AllOne</code> class:<br><br><em>   <code>AllOne()</code> Initializes the object of the data structure.
</em>   <code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.<br><em>   <code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.
</em>   <code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><em>   <code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“AllOne”, “inc”, “inc”, “getMaxKey”, “getMinKey”, “inc”, “getMaxKey”, “getMinKey”]<br>[[], [“hello”], [“hello”], [], [], [“leet”], [], []]<br><strong>Output</strong><br>[null, null, null, “hello”, “hello”, null, “hello”, “leet”]<br><br><strong>Explanation</strong><br>AllOne allOne = new AllOne();<br>allOne.inc(“hello”);<br>allOne.inc(“hello”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “hello”<br>allOne.inc(“leet”);<br>allOne.getMaxKey(); // return “hello”<br>allOne.getMinKey(); // return “leet”<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= key.length &lt;= 10</code><br><em>   <code>key</code> consists of lowercase English letters.
</em>   It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.<br><em>   At most `5 </em> 10<sup>4</sup><code>calls will be made to</code>inc<code>,</code>dec<code>,</code>getMaxKey<code>, and</code>getMinKey`.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计数据结构，使其支持增加或减少一个单词的频数，最大或最小单词的频数。注意最小频数不能为0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这个频数有点似LRU的分层思路，加入self.max_freq, 其他操作都可以实现，但是dec操作不能达到O(1), 因为若某个最小频数单词从1变成0，需要检索频率到下一个有节点的层。<br>改进就是要将频率的的值连起来，所以参考LRU，map的key是频率，value是node，node中含有freq，形成一个环。而node含有该频率对应的单词set，inc/dec就是将单词移动另一个node中</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>与LRU区别: map的key是频率，node含有频率和单词set，数据结构加入key_to_count。LL是从最大频率到最小频率</li>
<li>inc操作将节点从原频率node移到下一个频率node，若新node不存在，调用append_before. 然后从原频率node的单词set中删除该单词，若set为空，删除此node以及map中的entry</li>
<li>dec与inc类似，但要注意频率变成0的情况：不移到新的node，且从key_to_count中删除该单词</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.freq_to_node = &#123;&#125;</span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line">        self.key_to_count = collections.defaultdict(int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.tail</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">            self.freq_to_node[count] = self.append_before(old_node)</span><br><span class="line">        new_node = self.freq_to_node[count]</span><br><span class="line">        new_node.key_set.add(key)</span><br><span class="line">        self.key_to_count[key] = count</span><br><span class="line"></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count) <span class="comment"># remember</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(self, key: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        count = self.key_to_count[key]</span><br><span class="line">        old_node = self.freq_to_node[count] <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">else</span> self.head</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>: <span class="comment"># remember</span></span><br><span class="line">            <span class="keyword">if</span> count <span class="keyword">not</span> <span class="keyword">in</span> self.freq_to_node:</span><br><span class="line">                self.freq_to_node[count] = self.append_after(old_node)</span><br><span class="line">            new_node = self.freq_to_node[count]</span><br><span class="line">            new_node.key_set.add(key)</span><br><span class="line">            self.key_to_count[key] = count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.key_to_count.pop(key)</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">in</span> self.freq_to_node <span class="keyword">and</span> key <span class="keyword">in</span> self.freq_to_node[count].key_set:</span><br><span class="line">            self.freq_to_node[count].key_set.remove(key)</span><br><span class="line">            <span class="keyword">if</span> len(self.freq_to_node[count].key_set) == <span class="number">0</span>:</span><br><span class="line">                self.remove_node(self.freq_to_node[count])</span><br><span class="line">                self.freq_to_node.pop(count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.tail <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinKey</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">if</span> node == self.head <span class="keyword">else</span> next(iter(node.key_set))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_before</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq + <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node.prev, node</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_after</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        new_node = ListNode(node.freq - <span class="number">1</span>)</span><br><span class="line">        predecessor, successor = node, node.next</span><br><span class="line">        predecessor.next, new_node.prev = new_node, predecessor</span><br><span class="line">        new_node.next, successor.prev = successor, new_node</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        predecessor, successor = node.prev, node.next</span><br><span class="line">        predecessor.next, successor.prev = successor, predecessor</span><br><span class="line">        node.prev, node.next = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, freq=<span class="number">0</span>, next=None, prev=None)</span>:</span></span><br><span class="line">        self.key_set = set()</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.next = next</span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-2034-stock-price-fluctuation/">LeetCode 2034 Stock Price Fluctuation</a></h1>
  

      
        <time datetime="2022-02-17T04:00:04.962Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/stock-price-fluctuation/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given a stream of <strong>records</strong> about a particular stock. Each record contains a <strong>timestamp</strong> and the corresponding <strong>price</strong> of the stock at that timestamp.<br><br>Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream <strong>correcting</strong> the price of the previous wrong record.<br><br>Design an algorithm that:<br><br><em>   <strong>Updates</strong> the price of the stock at a particular timestamp, <strong>correcting</strong> the price from any previous records at the timestamp.
</em>   Finds the <strong>latest price</strong> of the stock based on the current records. The <strong>latest price</strong> is the price at the latest timestamp recorded.<br><em>   Finds the <strong>maximum price</strong> the stock has been based on the current records.
</em>   Finds the <strong>minimum price</strong> the stock has been based on the current records.<br><br>Implement the <code>StockPrice</code> class:<br><br><em>   <code>StockPrice()</code> Initializes the object with no price records.
</em>   <code>void update(int timestamp, int price)</code> Updates the <code>price</code> of the stock at the given <code>timestamp</code>.<br><em>   <code>int current()</code> Returns the <strong>latest price</strong> of the stock.
</em>   <code>int maximum()</code> Returns the <strong>maximum price</strong> of the stock.<br><em>   <code>int minimum()</code> Returns the <strong>minimum price</strong> of the stock.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input</strong><br>[“StockPrice”, “update”, “update”, “current”, “maximum”, “update”, “maximum”, “update”, “minimum”]<br>[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]<br><strong>Output</strong><br>[null, null, null, 5, 10, null, 5, null, 2]<br><br><strong>Explanation</strong><br>StockPrice stockPrice = new StockPrice();<br>stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].<br>stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].<br>stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.<br>stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.<br>stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.<br>                          // Timestamps are [1,2] with corresponding prices [3,5].<br>stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.<br>stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].<br>stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.<br></pre><br><br><strong>Constraints:</strong>

</em>   <code>1 &lt;= timestamp, price &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code><br><em>   At most <code>10&lt;sup&gt;5&lt;/sup&gt;</code> calls will be made <strong>in total</strong> to <code>update</code>, <code>current</code>, <code>maximum</code>, and <code>minimum</code>.
</em>   <code>current</code>, <code>maximum</code>, and <code>minimum</code> will be called <strong>only after</strong> <code>update</code> has been called <strong>at least once</strong>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>实现一个关于股票的数据结构，可以更新时间点对应的股价，最大最小值，最新价格</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>求最大最小值容易想到用heap，但heap不支持更新，难点是怎么支持更新股价。<br>仍然(price, timestamp)加入到heap中，在出堆时验证</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li>验证堆顶： 若股价和时间不匹配(用time_to_price验证)，表示这是stale股价，不断去掉，直到验证成功为止，最后加入到堆中</li>
</ol>
<h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span><span class="params">(TestCases)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.time_to_price = &#123;&#125;</span><br><span class="line">        self.cur_time = <span class="number">0</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, timestamp: int, price: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.time_to_price[timestamp] = price</span><br><span class="line">        self.cur_time = max(self.cur_time, timestamp)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        heapq.heappush(self.max_heap, (-price, timestamp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.time_to_price[self.cur_time]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        <span class="keyword">while</span> -price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.max_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> -price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        <span class="keyword">while</span> price != self.time_to_price[timestamp]:</span><br><span class="line">            price, timestamp = heapq.heappop(self.min_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, (price, timestamp))</span><br><span class="line">        <span class="keyword">return</span> price</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>update时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/">LeetCode 2128 Remove All Ones With Row and Column Flips</a></h1>
  

      
        <time datetime="2022-02-17T03:23:00.458Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>You are given an <code>m x n</code> binary matrix <code>grid</code>.<br><br>In one operation, you can choose <strong>any</strong> row or column and flip each value in that row or column (i.e., changing all <code>0</code>‘s to <code>1</code>‘s, and all <code>1</code>‘s to <code>0</code>‘s).<br><br>Return <code>true</code> <em>if it is possible to remove all</em> <code>1</code><em>‘s from</em> <code>grid</code> using <strong>any</strong> number of operations or <code>false</code> otherwise.<br><br><strong>Example 1:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103191300-1.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0,1,0],[1,0,1],[0,1,0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> One possible way to remove all 1’s from grid is to:<br>- Flip the middle row<br>- Flip the middle column<br></pre><br><br><strong>Example 2:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181204-7.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[1,1,0],[0,0,0],[0,0,0]]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> It is impossible to remove all 1’s from grid.<br></pre><br><br><strong>Example 3:</strong><br><br><img src="https://assets.leetcode.com/uploads/2022/01/03/image-20220103181224-8.png" alt=""><br><br><pre><strong>Input:</strong> grid = [[0]]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> There are no 1’s in grid.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>m == grid.length</code>
</em>   <code>n == grid[i].length</code><br><em>   <code>1 &lt;= m, n &lt;= 300</code>
</em>   <code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.<br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个矩阵，每次可以flip一行或一列，求是否可以令矩阵变成全0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>从例子找规律，<br>010和010属于一种类型<br>010和101也是同一种，每一行必须符合任何一种类型才是解</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span><span class="params">(self, grid: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">	row_patten, row_pattern_invert = grid[<span class="number">0</span>], [<span class="number">1</span> - n <span class="keyword">for</span> n <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(grid)):</span><br><span class="line">		<span class="keyword">if</span> grid[i] != row_patten <span class="keyword">and</span> grid[i] != row_pattern_invert:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n<sup>2</sup>)</code>，空间复杂度<code>O(n)</code>  </p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2022/02/16/leetcode-843-guess-the-word/">LeetCode 843 Guess the Word</a></h1>
  

      
        <time datetime="2022-02-17T02:54:15.165Z">2022-02-16</time>
      
    </header>
    <div class="entry">
      
        <p><strong><a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">LeetCode</a></strong></p>
<div><br><br>This is an <strong><em>interactive problem</em></strong>.<br><br>You are given an array of <strong>unique</strong> strings <code>wordlist</code> where <code>wordlist[i]</code> is <code>6</code> letters long, and one word in this list is chosen as <code>secret</code>.<br><br>You may call <code>Master.guess(word)</code> to guess a word. The guessed word should have type <code>string</code> and must be from the original list with <code>6</code> lowercase letters.<br><br>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <code>secret</code> word. Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.<br><br>For each test case, you have exactly <code>10</code> guesses to guess the word. At the end of any number of calls, if you have made <code>10</code> or fewer calls to <code>Master.guess</code> and at least one of these guesses was <code>secret</code>, then you pass the test case.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong> secret = “acckzz”, wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br><strong>Explanation:</strong><br>master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>We made 5 calls to master.guess and one of them was the secret, so we pass the test case.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong> secret = “hamada”, wordlist = [“hamada”,”khaled”], numguesses = 10<br><strong>Output:</strong> You guessed the secret word correctly.<br></pre><br><br><strong>Constraints:</strong><br><br><em>   <code>1 &lt;= wordlist.length &lt;= 100</code>
</em>   <code>wordlist[i].length == 6</code><br><em>   <code>wordlist[i]</code> consist of lowercase English letters.
</em>   All the strings of <code>wordlist</code> are <strong>unique</strong>.<br><em>   <code>secret</code> exists in <code>wordlist</code>.
</em>   <code>numguesses == 10</code><br><br></div>

<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定单词列表，每个单词长度为6， 其中一个为答案，每次猜一个单词。给一个API会告诉你猜的单词有多少位命中(位置,数值), 求是否可以10次内猜对</p>
<h3 id="暴力法解题思路："><a href="#暴力法解题思路：" class="headerlink" title="暴力法解题思路："></a><strong>暴力法解题思路：</strong></h3><p>较直观的解法是抽第一个单词出来，然后call API, 然后再filter wordlist使得新的单词列表里的单词的命中位数也是一样的。每轮缩少范围。</p>
<h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>N/A</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol>
<li><h3 id="Python代码："><a href="#Python代码：" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord2</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		guess = wordlist[<span class="number">0</span>]</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>  </p>
<hr>
<h3 id="统计频率算法II解题思路-推荐-："><a href="#统计频率算法II解题思路-推荐-：" class="headerlink" title="统计频率算法II解题思路(推荐)："></a><strong>统计频率算法II解题思路(推荐)：</strong></h3><p>上述方法跟单词个数有关，如果很多的话，就会超过10次。考虑单词长度为6，而可以猜10次。考虑用26字母存储法，也就是统计频率。统计每位的频率，然后将频率作为这一位的分数，求每个单词的总分。<br>一定要选择单词列表中的某个单词去猜，如果不在列表中返回为-1，这个信息没有任何作用。<br>选择总分最高的去猜，原理是它最具代表性，这样可以快速排除很多单词，有点类似于二分法。反之，若用频率低的单词，也就只能排除一个单词。</p>
<h3 id="Python代码：-1"><a href="#Python代码：-1" class="headerlink" title="Python代码："></a><strong>Python代码：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		char_to_count = [collections.Counter(w[i] <span class="keyword">for</span> w <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">		guess = max(wordlist, key=<span class="keyword">lambda</span> w: sum(char_to_count[i][char] <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(w)))</span><br><span class="line">		res = master.guess(guess)</span><br><span class="line">		wordlist = [w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> self.match(w, guess) == res]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> sum(i == j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(w1, w2))</span><br></pre></td></tr></table></figure>
<h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:shineboy2013.github.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/03/01/leetcode-772-basic-calculator-iii/">LeetCode 772 Basic Calculator III</a>
      </li>
    
      <li>
        <a href="/2022/02/24/leetcode-432-all-oone-data-structure/">LeetCode 432 All O one Data Structure</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-2034-stock-price-fluctuation/">LeetCode 2034 Stock Price Fluctuation</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-2128-remove-all-ones-with-row-and-column-flips/">LeetCode 2128 Remove All Ones With Row and Column Flips</a>
      </li>
    
      <li>
        <a href="/2022/02/16/leetcode-843-guess-the-word/">LeetCode 843 Guess the Word</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Airbnb/" style="font-size: 10px;">Airbnb</a> <a href="/tags/Amazon/" style="font-size: 14.17px;">Amazon</a> <a href="/tags/Array/" style="font-size: 20px;">Array</a> <a href="/tags/Backtracking/" style="font-size: 14.17px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 17.08px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 13.75px;">Binary Tree</a> <a href="/tags/Bit-Manipulation/" style="font-size: 10.42px;">Bit Manipulation</a> <a href="/tags/Bloomberg/" style="font-size: 10.42px;">Bloomberg</a> <a href="/tags/Breadth-first-Search/" style="font-size: 17.92px;">Breadth-first Search</a> <a href="/tags/Citadel/" style="font-size: 10.83px;">Citadel</a> <a href="/tags/Classic/" style="font-size: 18.33px;">Classic</a> <a href="/tags/Depth-first-Search/" style="font-size: 15px;">Depth-first Search</a> <a href="/tags/Design/" style="font-size: 11.25px;">Design</a> <a href="/tags/Divide-and-Conquer/" style="font-size: 11.25px;">Divide and Conquer</a> <a href="/tags/DoorDash/" style="font-size: 14.17px;">DoorDash</a> <a href="/tags/Dynamic-Programming/" style="font-size: 19.58px;">Dynamic Programming</a> <a href="/tags/Facebook/" style="font-size: 19.17px;">Facebook</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/Graph/" style="font-size: 12.92px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 13.33px;">Greedy</a> <a href="/tags/Hash-Table/" style="font-size: 17.08px;">Hash Table</a> <a href="/tags/Heap/" style="font-size: 14.17px;">Heap</a> <a href="/tags/Interactive/" style="font-size: 10px;">Interactive</a> <a href="/tags/Interviewer/" style="font-size: 13.33px;">Interviewer</a> <a href="/tags/Iterator/" style="font-size: 11.25px;">Iterator</a> <a href="/tags/Karat/" style="font-size: 12.5px;">Karat</a> <a href="/tags/Knowledge-Base/" style="font-size: 16.67px;">Knowledge Base</a> <a href="/tags/Linked-List/" style="font-size: 15.42px;">Linked List</a> <a href="/tags/LinkedIn/" style="font-size: 12.92px;">LinkedIn</a> <a href="/tags/Math/" style="font-size: 18.33px;">Math</a> <a href="/tags/Matrix/" style="font-size: 15.83px;">Matrix</a> <a href="/tags/Memoization/" style="font-size: 11.25px;">Memoization</a> <a href="/tags/Merge-Sort/" style="font-size: 10.83px;">Merge Sort</a> <a href="/tags/Microsoft/" style="font-size: 12.08px;">Microsoft</a> <a href="/tags/Mtrix/" style="font-size: 10px;">Mtrix</a> <a href="/tags/Object-Oriented-Design/" style="font-size: 10px;">Object Oriented Design</a> <a href="/tags/Prefix-Sum/" style="font-size: 10px;">Prefix Sum</a> <a href="/tags/Python-KB/" style="font-size: 15.83px;">Python KB</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Quickselect/" style="font-size: 10px;">Quickselect</a> <a href="/tags/Randomized/" style="font-size: 10px;">Randomized</a> <a href="/tags/Recursion/" style="font-size: 10.83px;">Recursion</a> <a href="/tags/Segment-Tree/" style="font-size: 10.42px;">Segment Tree</a> <a href="/tags/Sliding-Window/" style="font-size: 11.67px;">Sliding Window</a> <a href="/tags/Sliding-window/" style="font-size: 10px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/Sorting/" style="font-size: 10.42px;">Sorting</a> <a href="/tags/Stack/" style="font-size: 17.5px;">Stack</a> <a href="/tags/String/" style="font-size: 18.75px;">String</a> <a href="/tags/Topological-Sort/" style="font-size: 11.25px;">Topological Sort</a> <a href="/tags/Tree/" style="font-size: 16.25px;">Tree</a> <a href="/tags/Trie/" style="font-size: 11.67px;">Trie</a> <a href="/tags/Two-Pointers/" style="font-size: 14.58px;">Two Pointers</a> <a href="/tags/Uber/" style="font-size: 10.42px;">Uber</a> <a href="/tags/Union-Find/" style="font-size: 10.42px;">Union Find</a> <a href="/tags/tiktok/" style="font-size: 10px;">tiktok</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 KK Shum
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>

